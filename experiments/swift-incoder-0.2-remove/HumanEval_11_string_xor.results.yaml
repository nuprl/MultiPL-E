language: swift
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzeegldco.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzeegldco.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' {\n            result.append(b[index])\n\
    \        } else {\n            result.append(a[index])\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4xfaju4z.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' {\n                       ^~~\n       \
    \                \"0\"\n/tmp/tmp4xfaju4z.swift:7:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:8:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:10:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result.append(a[index])\n         \
    \                 ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(format: \"%02.2X\", a[index])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcsqr5un5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:8:23:\
    \ error: no exact matches in call to initializer \n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:4:23: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\n/tmp/tmpcsqr5un5.swift:8:23: note: candidate has partially matching\
    \ parameter list (repeating: String, count: Int)\n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:3:12: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    public init<S>(_\
    \ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character\n\
    \           ^\nSwift.String:4:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate '(String) -> String' requires 1 argument, but 2 were provided\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] != b[index] {\n            res += \"0\"\
    \n        } else {\n            res += \"1\"\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhxbhp8b.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdhxbhp8b.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] != b[index] {\n            res += \"0\"\
    \n        } else {\n            res += \"1\"\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhxbhp8b.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdhxbhp8b.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += '0'\n        } else {\n            result += '1'\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5mu41wui.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmp5mu41wui.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmp5mu41wui.swift:8:23: error: single-quoted\
    \ string literal found, use '\"'\n            result += '0'\n                \
    \      ^~~\n                      \"0\"\n/tmp/tmp5mu41wui.swift:10:23: error:\
    \ single-quoted string literal found, use '\"'\n            result += '1'\n  \
    \                    ^~~\n                      \"1\"\n/tmp/tmp5mu41wui.swift:7:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp5mu41wui.swift:7:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[index] == '0' && b[index] == '0' {\n                              ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpn5o0sink.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpn5o0sink.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += a[i]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu_33clrw.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpu_33clrw.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu_33clrw.swift:8:24: error: no exact\
    \ matches in call to subscript \n            result += a[i]\n                \
    \       ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwln6csh5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwln6csh5.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwln6csh5.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" && b[i] != \"1\" {\n          \
    \  result += a[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmphdwimter.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" && b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmphdwimter.swift:7:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[i] != \"1\" && b[i] != \"1\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphdwimter.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[i]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] != b[index] {\n            res += \"0\"\
    \n        } else {\n            res += \"1\"\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhxbhp8b.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdhxbhp8b.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a.index(of: \"1\") != b.index(of: \"1\") {\n\
    \            result += \"0\"\n        } else {\n            result += \"1\"\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmpp9gqy18a/tmpp9gqy18a.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b464835fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4648056b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4648056988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46480557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp9gqy18a                        0x000055d53e6e971b <unavailable> + 5915

    5    libc.so.6                          0x00002b464854b460 __libc_start_main +
    245

    6    tmpp9gqy18a                        0x000055d53e6e9329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b)))])\
    \ == nil {\n            result += a\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdn3r5q16.swift:7:30: error: cannot find 'arc4random_uniform' in\
    \ scope\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b)))]) == nil\
    \ {\n                             ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] == b[index] {\n            res += \"1\"\
    \n        } else {\n            res += \"0\"\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpg3qpjk0t.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpg3qpjk0t.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for x\
    \ in a { res += String(x) }\n    for x in b { res += String(x) }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpa19ds54b/tmpa19ds54b.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b662439ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6624095b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6624095988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66240947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa19ds54b                        0x00005575dd0ac49b <unavailable> + 5275

    5    libc.so.6                          0x00002b662458a460 __libc_start_main +
    245

    6    tmpa19ds54b                        0x00005575dd0ac0a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwln6csh5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwln6csh5.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwln6csh5.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a[0..<a.count-1] == b[0..<b.count-1] {\n    \
    \        result += \"1\"\n        } else {\n            result += \"0\"\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuyr5eok2.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        if a[0..<a.count-1] == b[0..<b.count-1] {\n           ^~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpuyr5eok2.swift:7:32: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        if a[0..<a.count-1] == b[0..<b.count-1] {\n        \
    \                       ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += a[i]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu_33clrw.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpu_33clrw.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu_33clrw.swift:8:24: error: no exact\
    \ matches in call to subscript \n            result += a[i]\n                \
    \       ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\
    \ + \"0\"\n        } else {\n            result += String(a[i])\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwi2482eg.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwi2482eg.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwi2482eg.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i]) + \"0\"\n                             ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwi2482eg.swift:10:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" && b[i] != \"1\" {\n          \
    \  result += \"0\"\n        } else {\n            result += \"1\"\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz6s6kgcl.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" && b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpz6s6kgcl.swift:7:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[i] != \"1\" && b[i] != \"1\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] != b[index] {\n            res += \"1\"\
    \n        } else {\n            res += \"0\"\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp73etjnyj.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp73etjnyj.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for x\
    \ in 0..<a.count {\n        if a[x] != b[x] {\n            res += \"0\"\n    \
    \    } else {\n            res += \"1\"\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpccg5zuqc.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[x] !=\
    \ b[x] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpccg5zuqc.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[x] != b[x] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"0\" {\n            result += a[i]\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"0\" {\n  \
    \          result += b[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp07v86bsy.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"0\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp07v86bsy.swift:8:24: error: no exact matches\
    \ in call to subscript \n            result += a[i]\n                       ^\n\
    Swift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp07v86bsy.swift:12:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if b[i] != \"0\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp07v86bsy.swift:13:24: error: no exact\
    \ matches in call to subscript \n            result += b[i]\n                \
    \       ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        res += String(a[i]) ^ String(b[i])\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpyy82pwfb.swift:7:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        res += String(a[i]) ^ String(b[i])\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978773
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" && b[i] != \"1\" {\n          \
    \  result += String(a[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp662eyjvp.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" && b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp662eyjvp.swift:7:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[i] != \"1\" && b[i] != \"1\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp662eyjvp.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += \"0\"\n        } else {\n            result += \"1\"\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4vwjt4t.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmpx4vwjt4t.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmpx4vwjt4t.swift:7:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' && b[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx4vwjt4t.swift:7:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' {\n            result.append(b[index])\n\
    \        } else {\n            result.append(a[index])\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4xfaju4z.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' {\n                       ^~~\n       \
    \                \"0\"\n/tmp/tmp4xfaju4z.swift:7:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:8:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:10:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result.append(a[index])\n         \
    \                 ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += \"0\"\n        } else {\n            result += \"1\"\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4vwjt4t.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmpx4vwjt4t.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmpx4vwjt4t.swift:7:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' && b[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx4vwjt4t.swift:7:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\
    \ + \"0\"\n        } else {\n            result += String(a[i])\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwi2482eg.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwi2482eg.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwi2482eg.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i]) + \"0\"\n                             ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwi2482eg.swift:10:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for _\
    \ in 0..<a.count {\n        res += String(a[Int(arc4random_uniform(UInt32(a.count)))]\
    \ ^ b[Int(arc4random_uniform(UInt32(b\n            .count)))])\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ytde3rc.swift:7:29: error: cannot find 'arc4random_uniform' in\
    \ scope\n        res += String(a[Int(arc4random_uniform(UInt32(a.count)))] ^ b[Int(arc4random_uniform(UInt32(b\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7ytde3rc.swift:7:75:\
    \ error: cannot find 'arc4random_uniform' in scope\n        res += String(a[Int(arc4random_uniform(UInt32(a.count)))]\
    \ ^ b[Int(arc4random_uniform(UInt32(b\n                                      \
    \                                    ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7ytde3rc.swift:7:67:\
    \ error: binary operator '^' cannot be applied to two 'Character' operands\n \
    \       res += String(a[Int(arc4random_uniform(UInt32(a.count)))] ^ b[Int(arc4random_uniform(UInt32(b\n\
    \                                                                  ^\nSwift.BinaryInteger:1:17:\
    \ note: candidate requires that 'Character' conform to 'BinaryInteger' (requirement\
    \ specified as 'Self' : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(format: \"%02.2X\", a[index])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcsqr5un5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:8:23:\
    \ error: no exact matches in call to initializer \n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:4:23: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\n/tmp/tmpcsqr5un5.swift:8:23: note: candidate has partially matching\
    \ parameter list (repeating: String, count: Int)\n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:3:12: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    public init<S>(_\
    \ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character\n\
    \           ^\nSwift.String:4:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate '(String) -> String' requires 1 argument, but 2 were provided\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpn5o0sink.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpn5o0sink.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' {\n            result.append(b[index])\n\
    \        } else {\n            result.append(a[index])\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4xfaju4z.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' {\n                       ^~~\n       \
    \                \"0\"\n/tmp/tmp4xfaju4z.swift:7:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:8:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:10:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result.append(a[index])\n         \
    \                 ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwln6csh5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwln6csh5.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwln6csh5.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += '0'\n        } else {\n            result += '1'\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5mu41wui.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmp5mu41wui.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmp5mu41wui.swift:8:23: error: single-quoted\
    \ string literal found, use '\"'\n            result += '0'\n                \
    \      ^~~\n                      \"0\"\n/tmp/tmp5mu41wui.swift:10:23: error:\
    \ single-quoted string literal found, use '\"'\n            result += '1'\n  \
    \                    ^~~\n                      \"1\"\n/tmp/tmp5mu41wui.swift:7:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp5mu41wui.swift:7:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[index] == '0' && b[index] == '0' {\n                              ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a.index(of: b[a.index(of: b[0])!]) != nil {\n\
    \            result += a\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpb6hxbo3i.swift:7:14: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if a.index(of: b[a.index(of: b[0])!]) != nil {\n\
    \             ^\n/tmp/tmpb6hxbo3i.swift:7:14: note: use 'firstIndex(of:)' instead\n\
    \        if a.index(of: b[a.index(of: b[0])!]) != nil {\n             ^~~~~\n\
    \             firstIndex\n/tmp/tmpb6hxbo3i.swift:7:28: warning: 'index(of:)' is\
    \ deprecated: renamed to 'firstIndex(of:)'\n        if a.index(of: b[a.index(of:\
    \ b[0])!]) != nil {\n                           ^\n/tmp/tmpb6hxbo3i.swift:7:28:\
    \ note: use 'firstIndex(of:)' instead\n        if a.index(of: b[a.index(of: b[0])!])\
    \ != nil {\n                           ^~~~~\n                           firstIndex\n\
    /tmp/tmpb6hxbo3i.swift:7:38: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if a.index(of: b[a.index(of:\
    \ b[0])!]) != nil {\n                                     ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        if a[i] != \"1\" {\n            res += \"0\"\n   \
    \     } else {\n            res += \"1\"\n        }\n    }\n    for i in 0..<b.count\
    \ {\n        if b[i] != \"1\" {\n            res += \"0\"\n        } else {\n\
    \            res += \"1\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpavk_dhi2.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpavk_dhi2.swift:14:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwln6csh5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwln6csh5.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwln6csh5.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a[0..<a.count-1] == b[0..<b.count-1] {\n    \
    \        result += a[0..<a.count-1]\n        } else {\n            result += b[0..<b.count-1]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfaqc9dmn.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        if a[0..<a.count-1] == b[0..<b.count-1] {\n           ^~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpfaqc9dmn.swift:7:32: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        if a[0..<a.count-1] == b[0..<b.count-1] {\n        \
    \                       ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpfaqc9dmn.swift:8:23: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n          \
    \  result += a[0..<a.count-1]\n                      ^~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpfaqc9dmn.swift:10:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n            result += b[0..<b.count-1]\n                   \
    \   ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' {\n            result.append(b[index])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmprzzmr6ux.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' {\n                       ^~~\n       \
    \                \"0\"\n/tmp/tmprzzmr6ux.swift:7:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmprzzmr6ux.swift:8:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        if a[i] == b[i] {\n            res += \"0\"\n    \
    \    } else {\n            res += \"1\"\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp0i8v7mh1.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp0i8v7mh1.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        if a[i] != b[i] {\n            res += \"0\"\n    \
    \    } else {\n            res += \"1\"\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_w25m6gg.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp_w25m6gg.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwln6csh5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwln6csh5.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwln6csh5.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzeegldco.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzeegldco.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))),\
    \ in: a) != nil {\n            result += a[a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))),\
    \ in: a)]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwnmz_e_g.swift:7:81: error: expected ',' separator\n        if\
    \ a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))), in: a) != nil\
    \ {\n                                                                        \
    \        ^\n                                                                 \
    \               ,\n/tmp/tmpwnmz_e_g.swift:7:81: error: expected expression in\
    \ list of expressions\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))),\
    \ in: a) != nil {\n                                                          \
    \                      ^\n/tmp/tmpwnmz_e_g.swift:7:30: error: cannot find 'arc4random_uniform'\
    \ in scope\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))),\
    \ in: a) != nil {\n                             ^~~~~~~~~~~~~~~~~~\n/tmp/tmpwnmz_e_g.swift:7:57:\
    \ error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \        if a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))), in:\
    \ a) != nil {\n                                                        ^\nSwift.Collection:2:23:\
    \ note: where 'R' = 'String.Index'\n    @inlinable public subscript<R>(r: R) ->\
    \ Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }\n\
    \                      ^\n/tmp/tmpwnmz_e_g.swift:7:80: error: extra argument 'in'\
    \ in call\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))),\
    \ in: a) != nil {\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n\
    /tmp/tmpwnmz_e_g.swift:7:14: error: optional type 'String.Index?' cannot be used\
    \ as a boolean; test for '!= nil' instead\n        if a.index(of: b[Int(arc4random_uniform(UInt32(b[b.startIndex]))),\
    \ in: a) != nil {\n             ^\n           (\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for _\
    \ in 0..<a.count {\n        res += String(a[Int(arc4random_uniform(UInt32(a.count)))]\
    \ ^ b[Int(arc4random_uniform(UInt32(b.count)))])\n    }\n    return res\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoputrfkw.swift:7:29: error: cannot find 'arc4random_uniform' in\
    \ scope\n        res += String(a[Int(arc4random_uniform(UInt32(a.count)))] ^ b[Int(arc4random_uniform(UInt32(b.count)))])\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpoputrfkw.swift:7:75:\
    \ error: cannot find 'arc4random_uniform' in scope\n        res += String(a[Int(arc4random_uniform(UInt32(a.count)))]\
    \ ^ b[Int(arc4random_uniform(UInt32(b.count)))])\n                           \
    \                                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpoputrfkw.swift:7:67:\
    \ error: binary operator '^' cannot be applied to two 'Character' operands\n \
    \       res += String(a[Int(arc4random_uniform(UInt32(a.count)))] ^ b[Int(arc4random_uniform(UInt32(b.count)))])\n\
    \                                                                  ^\nSwift.BinaryInteger:1:17:\
    \ note: candidate requires that 'Character' conform to 'BinaryInteger' (requirement\
    \ specified as 'Self' : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\n"
  stdout: ''
  timestamp: 1659978765
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' {\n            result.append(b[index])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmprzzmr6ux.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' {\n                       ^~~\n       \
    \                \"0\"\n/tmp/tmprzzmr6ux.swift:7:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmprzzmr6ux.swift:8:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        if a[i] != \"1\" {\n            res += \"0\"\n   \
    \     } else {\n            res += \"1\"\n        }\n    }\n    for i in 0..<b.count\
    \ {\n        if b[i] != \"1\" {\n            res += \"0\"\n        } else {\n\
    \            res += \"1\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpavk_dhi2.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpavk_dhi2.swift:14:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a.index(of: b) != nil {\n            result +=\
    \ a.remove(at: a.index(of: b)) ?? \"\"\n        } else {\n            result +=\
    \ a.remove(at: a.index(of: a)) ?? \"\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp0fcabvpj.swift:7:24: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n        if a.index(of:\
    \ b) != nil {\n                       ^\n/tmp/tmp0fcabvpj.swift:8:52: error: binary\
    \ operator '??' cannot be applied to operands of type 'Character' and 'String'\n\
    \            result += a.remove(at: a.index(of: b)) ?? \"\"\n                \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~\n/tmp/tmp0fcabvpj.swift:8:25: error:\
    \ no exact matches in call to instance method 'remove'\n            result +=\
    \ a.remove(at: a.index(of: b)) ?? \"\"\n                        ^\n/tmp/tmp0fcabvpj.swift:8:25:\
    \ note: found candidate with type '(String.Index) -> Character'\n            result\
    \ += a.remove(at: a.index(of: b)) ?? \"\"\n                        ^\n/tmp/tmp0fcabvpj.swift:8:48:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            result += a.remove(at: a.index(of: b)) ?? \"\"\
    \n                                               ^\n/tmp/tmp0fcabvpj.swift:10:25:\
    \ error: no exact matches in call to instance method 'remove'\n            result\
    \ += a.remove(at: a.index(of: a)) ?? \"\"\n                        ^\n/tmp/tmp0fcabvpj.swift:10:25:\
    \ note: found candidate with type '(String.Index) -> Character'\n            result\
    \ += a.remove(at: a.index(of: a)) ?? \"\"\n                        ^\n/tmp/tmp0fcabvpj.swift:10:52:\
    \ error: binary operator '??' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            result += a.remove(at: a.index(of: a)) ?? \"\"\n \
    \                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~\n/tmp/tmp0fcabvpj.swift:10:48:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            result += a.remove(at: a.index(of: a)) ?? \"\"\
    \n                                               ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] != b[index] {\n            res += \"0\"\
    \n        } else {\n            res += \"1\"\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhxbhp8b.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpdhxbhp8b.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzeegldco.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzeegldco.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(format: \"%02.2X\", a[index])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcsqr5un5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:8:23:\
    \ error: no exact matches in call to initializer \n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:4:23: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\n/tmp/tmpcsqr5un5.swift:8:23: note: candidate has partially matching\
    \ parameter list (repeating: String, count: Int)\n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:3:12: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    public init<S>(_\
    \ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character\n\
    \           ^\nSwift.String:4:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate '(String) -> String' requires 1 argument, but 2 were provided\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpt7nxz7v3.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpt7nxz7v3.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += \"0\"\n        } else {\n            result += \"1\"\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4vwjt4t.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmpx4vwjt4t.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmpx4vwjt4t.swift:7:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' && b[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx4vwjt4t.swift:7:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for _,\
    \ bit := range b {\n        res += string(bit)\n    }\n    for _, a := range a\
    \ {\n        res += string(a)\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpl732n3rp.swift:6:10: error: expected 'in' after for-each pattern\n\
    \    for _, bit := range b {\n         ^\n/tmp/tmpl732n3rp.swift:6:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, bit := range b {\n\
    \         ^\n/tmp/tmpl732n3rp.swift:9:10: error: expected 'in' after for-each\
    \ pattern\n    for _, a := range a {\n         ^\n/tmp/tmpl732n3rp.swift:9:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, a := range\
    \ a {\n         ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(format: \"%02.2X\", a[index])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcsqr5un5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcsqr5un5.swift:8:23:\
    \ error: no exact matches in call to initializer \n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:4:23: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\n/tmp/tmpcsqr5un5.swift:8:23: note: candidate has partially matching\
    \ parameter list (repeating: String, count: Int)\n            result += String(format:\
    \ \"%02.2X\", a[index])\n                      ^\nSwift.String:3:12: note: candidate\
    \ '(String) -> String' requires 1 argument, but 2 were provided\n    public init<S>(_\
    \ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character\n\
    \           ^\nSwift.String:4:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate '(String) -> String' requires 1 argument, but 2 were provided\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += \"0\"\n        } else {\n            result += \"1\"\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4vwjt4t.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmpx4vwjt4t.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmpx4vwjt4t.swift:7:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' && b[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx4vwjt4t.swift:7:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' {\n            result.append(b[index])\n\
    \        } else {\n            result.append(a[index])\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4xfaju4z.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' {\n                       ^~~\n       \
    \                \"0\"\n/tmp/tmp4xfaju4z.swift:7:12: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:8:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4xfaju4z.swift:10:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result.append(a[index])\n         \
    \                 ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += \"0\"\n        } else {\n            result += \"1\"\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4vwjt4t.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmpx4vwjt4t.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmpx4vwjt4t.swift:7:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' && b[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx4vwjt4t.swift:7:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != \"1\" {\n            result += String(a[i])\n\
    \        }\n    }\n    for i in 0..<b.count {\n        if b[i] != \"1\" {\n  \
    \          result += String(b[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpra8ddq8i.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ \"1\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpra8ddq8i.swift:8:30: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:12:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if b[i] != \"1\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpra8ddq8i.swift:13:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(b[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && a[index+1] == '0' {\n\
    \            result = \"0\"\n        } else if a[index] == '0' && a[index+1] ==\
    \ '1' {\n            result = \"1\"\n        } else if a[index] == '1' && a[index+1]\
    \ == '0' {\n            result = \"1\"\n        } else if a[index] == '1' && a[index+1]\
    \ == '1' {\n            result = \"0\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkn2jru5p.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && a[index+1] == '0' {\n              \
    \         ^~~\n                       \"0\"\n/tmp/tmpkn2jru5p.swift:7:45: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ a[index+1] == '0' {\n                                            ^~~\n     \
    \                                       \"0\"\n/tmp/tmpkn2jru5p.swift:9:31: error:\
    \ single-quoted string literal found, use '\"'\n        } else if a[index] ==\
    \ '0' && a[index+1] == '1' {\n                              ^~~\n            \
    \                  \"0\"\n/tmp/tmpkn2jru5p.swift:9:52: error: single-quoted string\
    \ literal found, use '\"'\n        } else if a[index] == '0' && a[index+1] ==\
    \ '1' {\n                                                   ^~~\n            \
    \                                       \"1\"\n/tmp/tmpkn2jru5p.swift:11:31: error:\
    \ single-quoted string literal found, use '\"'\n        } else if a[index] ==\
    \ '1' && a[index+1] == '0' {\n                              ^~~\n            \
    \                  \"1\"\n/tmp/tmpkn2jru5p.swift:11:52: error: single-quoted string\
    \ literal found, use '\"'\n        } else if a[index] == '1' && a[index+1] ==\
    \ '0' {\n                                                   ^~~\n            \
    \                                       \"0\"\n/tmp/tmpkn2jru5p.swift:13:31: error:\
    \ single-quoted string literal found, use '\"'\n        } else if a[index] ==\
    \ '1' && a[index+1] == '1' {\n                              ^~~\n            \
    \                  \"1\"\n/tmp/tmpkn2jru5p.swift:13:52: error: single-quoted string\
    \ literal found, use '\"'\n        } else if a[index] == '1' && a[index+1] ==\
    \ '1' {\n                                                   ^~~\n            \
    \                                       \"1\"\n/tmp/tmpkn2jru5p.swift:7:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if a[index] == '0' && a[index+1] == '0' {\n           ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavail"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(format: \"%0*d\", 0, index)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpaf2k8e6h.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpaf2k8e6h.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpaf2k8e6h.swift:8:29:\
    \ error: incorrect argument labels in call (have 'format:_:_:', expected '_:radix:uppercase:')\n\
    \            result += String(format: \"%0*d\", 0, index)\n                  \
    \          ^~~~~~~~~\n                                             radix:  uppercase:\
    \ \n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for i\
    \ in 0..<a.count {\n        if a[i] == b[i] {\n            res += \"0\"\n    \
    \    } else {\n            res += \"1\"\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp0i8v7mh1.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp0i8v7mh1.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for index\
    \ in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n        \
    \    res += \"0\"\n        } else {\n            res += \"1\"\n        }\n   \
    \ }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpn6isvduo.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmpn6isvduo.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmpn6isvduo.swift:7:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == '0' && b[index] == '0' {\n           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpn6isvduo.swift:7:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var res = \"\"\n    for x\
    \ in 0..<a.count {\n        if a[x] != b[x] {\n            res += \"1\"\n    \
    \    } else {\n            res += \"0\"\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu0zbp584.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[x] !=\
    \ b[x] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpu0zbp584.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[x] != b[x] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ _ in 0..<a.count {\n        if a.index(of: \"1\") != b.index(of: \"1\") {\n\
    \            result += \"0\"\n        } else {\n            result += \"1\"\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmpp9gqy18a/tmpp9gqy18a.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b464835fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4648056b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4648056988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46480557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp9gqy18a                        0x000055d53e6e971b <unavailable> + 5915

    5    libc.so.6                          0x00002b464854b460 __libc_start_main +
    245

    6    tmpp9gqy18a                        0x000055d53e6e9329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == '0' && b[index] == '0' {\n  \
    \          result += '0'\n        } else {\n            result += '1'\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5mu41wui.swift:7:24: error: single-quoted string literal found,\
    \ use '\"'\n        if a[index] == '0' && b[index] == '0' {\n                \
    \       ^~~\n                       \"0\"\n/tmp/tmp5mu41wui.swift:7:43: error:\
    \ single-quoted string literal found, use '\"'\n        if a[index] == '0' &&\
    \ b[index] == '0' {\n                                          ^~~\n         \
    \                                 \"0\"\n/tmp/tmp5mu41wui.swift:8:23: error: single-quoted\
    \ string literal found, use '\"'\n            result += '0'\n                \
    \      ^~~\n                      \"0\"\n/tmp/tmp5mu41wui.swift:10:23: error:\
    \ single-quoted string literal found, use '\"'\n            result += '1'\n  \
    \                    ^~~\n                      \"1\"\n/tmp/tmp5mu41wui.swift:7:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[index] == '0' && b[index] == '0' {\n\
    \           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp5mu41wui.swift:7:31: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[index] == '0' && b[index] == '0' {\n                              ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\
    \ + \"0\"\n        } else {\n            result += String(a[i])\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwi2482eg.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwi2482eg.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwi2482eg.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i]) + \"0\"\n                             ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwi2482eg.swift:10:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[i])\n          \
    \                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwln6csh5.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwln6csh5.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwln6csh5.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzeegldco.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzeegldco.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += String(a[index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfb8wkv7e.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfb8wkv7e.swift:8:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(a[index])\n      \
    \                       ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += a[i]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpu_33clrw.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpu_33clrw.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpu_33clrw.swift:8:24: error: no exact\
    \ matches in call to subscript \n            result += a[i]\n                \
    \       ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpt7nxz7v3.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpt7nxz7v3.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_t53_rhr.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_t53_rhr.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] == b[index] {\n            result\
    \ += a[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd0n5jcf.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ == b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] == b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwd0n5jcf.swift:8:24:\
    \ error: no exact matches in call to subscript \n            result += a[index]\n\
    \                       ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] != b[i] {\n            result += String(a[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6mb648wx.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] !=\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6mb648wx.swift:7:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] != b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6mb648wx.swift:8:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(a[i])\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\nfunc\
    \ string_xor(a: String, b: String) -> String {\n    var result = \"\"\n    for\
    \ index in 0..<a.count {\n        if a[index] != b[index] {\n            result\
    \ += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeipnhtk.swift:7:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[index]\
    \ != b[index] {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpoeipnhtk.swift:7:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[index] != b[index] {\n                       ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978756
