language: swift
name: HumanEval_137_compare_one
results:
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value, b as! Value {\n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_):\n        return a\n    case .intValue(_), .doubleValue(_):\n\
    \        return b\n    case .stringValue(_), .intValue(_):\n        return a\n\
    \    case .stringValue(_), .doubleValue(_):\n        return b\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmptxdfpqaf.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmptxdfpqaf.swift:14:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as! Value, b as! Value {\n                  \
    \    ^\n                      ;\n/tmp/tmptxdfpqaf.swift:14:23: error: expected\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmptxdfpqaf.swift:14:14: warning: forced cast of 'Value' to same type has\
    \ no effect\n    switch a as! Value, b as! Value {\n             ^~~~~~~~~\n \
    \            \n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \        case .intValue(_), .doubleValue(_)\n            return b\n        case\
    \ .stringValue(_), .intValue(_)\n            return a\n        case .stringValue(_),\
    \ .doubleValue(_)\n            return b\n        case .stringValue(_)\n      \
    \      return a\n        case .intValue(_)\n            return b\n        case\
    \ .doubleValue(_)\n            return a\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpf0rogsg6.swift:14:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpf0rogsg6.swift:15:43:\
    \ error: expected ':' after 'case'\n        case .intValue(_), .doubleValue(_)\n\
    \                                          ^\n/tmp/tmpf0rogsg6.swift:17:43: error:\
    \ expected ':' after 'case'\n        case .stringValue(_), .intValue(_)\n    \
    \                                      ^\n/tmp/tmpf0rogsg6.swift:19:46: error:\
    \ expected ':' after 'case'\n        case .stringValue(_), .doubleValue(_)\n \
    \                                            ^\n/tmp/tmpf0rogsg6.swift:21:29:\
    \ error: expected ':' after 'case'\n        case .stringValue(_)\n           \
    \                 ^\n/tmp/tmpf0rogsg6.swift:23:26: error: expected ':' after 'case'\n\
    \        case .intValue(_)\n                         ^\n/tmp/tmpf0rogsg6.swift:25:29:\
    \ error: expected ':' after 'case'\n        case .doubleValue(_)\n           \
    \                 ^\n/tmp/tmpf0rogsg6.swift:15:14: warning: case is already handled\
    \ by previous patterns; consider removing it\n        case .intValue(_), .doubleValue(_)\n\
    \             ^~~~~~~~~~~~\n/tmp/tmpf0rogsg6.swift:15:28: warning: case is already\
    \ handled by previous patterns; consider removing it\n        case .intValue(_),\
    \ .doubleValue(_)\n                           ^~~~~~~~~~~~~~~\n/tmp/tmpf0rogsg6.swift:17:14:\
    \ warning: case is already handled by previous patterns; consider removing it\n\
    \        case .stringValue(_), .intValue(_)\n             ^~~~~~~~~~~~~~~\n/tmp/tmpf0rogsg6.swift:17:31:\
    \ warning: case is already handled by previous patterns; consider removing it\n\
    \        case .stringValue(_), .intValue(_)\n                              ^~~~~~~~~~~~\n\
    /tmp/tmpf0rogsg6.swift:19:14: warning: case is already handled by previous patterns;\
    \ consider removing it\n        case .stringValue(_), .doubleValue(_)\n      \
    \       ^~~~~~~~~~~~~~~\n/tmp/tmpf0rogsg6.swift:19:31: warning: case is already\
    \ handled by previous patterns; consider removing it\n        ca"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        if a < b {\n                return a\n            } else {\n        \
    \        return b\n            }\n        }\n    case .doubleValue(_):\n     \
    \   switch b as! Value {\n        case .intValue(_):\n            return b\n \
    \       case .doubleValue(_):\n            return a\n        case .stringValue(_):\n\
    \            if a < b {\n                return b\n            } else {\n    \
    \            return a\n            }\n        }\n    case .stringValue(_):\n \
    \       switch b as! Value {\n        case .intValue(_):\n            return a\n\
    \        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            if a < b {\n                return a\n            } else {\n    \
    \            return b\n            }\n        }\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppaz7v2dp.swift:14:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmppaz7v2dp.swift:16:18: warning: forced cast of 'Value' to same type\
    \ has no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n \
    \                \n/tmp/tmppaz7v2dp.swift:22:18: error: binary operator '<' cannot\
    \ be applied to two 'Value' operands\n            if a < b {\n               ~\
    \ ^ ~\n/tmp/tmppaz7v2dp.swift:22:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n\
    /tmp/tmppaz7v2dp.swift:29:18: warning: forced cast of 'Value' to same type has\
    \ no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n     \
    \            \n/tmp/tmppaz7v2dp.swift:35:18: error: binary operator '<' cannot\
    \ be applied to two 'Value' operands\n            if a < b {\n               ~\
    \ ^ ~\n/tmp/tmppaz7v2dp.swift:35:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n\
    /tmp/tmppaz7v2dp.swift:42:18: warning: forced cast of 'Value' to same type has\
    \ no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n     \
    \            \n/tmp/tmppaz7v2dp.swift:48:18: error: binary operator '<' cannot\
    \ be applied to two 'Value' operands\n            if a < b {\n               ~\
    \ ^ ~\n/tmp/tmppaz7v2dp.swift:48:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare by type\n    case .intValue(_):\n      \
    \  switch b { // Compare by type\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Compare by type\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare by type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmptxtguwb0.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmptxtguwb0.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmptxtguwb0.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmptxtguwb0.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmptxtguwb0.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmptxtguwb0.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmptxtguwb0.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmptxtguwb0.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmptxtguwb0.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmptxtguwb0.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppeq_psi7.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:18:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmppeq_psi7.swift:20:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmppeq_psi7.swift:22:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n/tmp/tmppeq_psi7.swift:25:22: error: cannot find type 'ValueType' in\
    \ scope\n        switch b as? ValueType {\n                     ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:27:21:\
    \ error: member 'intValue' expects argument of type 'Int'\n            return\
    \ .intValue\n                    ^\n/tmp/tmppeq_psi7.swift:29:21: error: member\
    \ 'doubleValue' expects argument of type 'Double'\n            return .doubleValue\n\
    \                    ^\n/tmp/tmppeq_psi7.swift:31:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n/tmp/tmppeq_psi7.swift:34:22: error: cannot find type 'ValueType'\
    \ in scope\n        switch b as? ValueType {\n                     ^~~~~~~~~\n\
    /tmp/tmppeq_psi7.swift:36:21: error: member 'intValue' expects argument of type\
    \ 'Int'\n            return .intValue\n                    ^\n/tmp/tmppeq_psi7.swift:38:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmppeq_psi7.swift:40:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.stringValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp476gh4dh.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmp476gh4dh.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { case .intValue(_):\n        switch b { case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp4cvbk1pe/tmp4cvbk1pe.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b463721cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4636f13b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4636f13988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4636f127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4cvbk1pe                        0x0000558568951a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b4637408460 __libc_start_main +
    245

    6    tmp4cvbk1pe                        0x0000558568951499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // Both are integers\n    if a.intValue()\
    \ > b.intValue() {\n        return a\n    }\n    \n    return b\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpiqnzqtra.swift:33:19: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() > b.intValue() {\n                  ^\n       \
    \           <#Int#>\n/tmp/tmpiqnzqtra.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpiqnzqtra.swift:33:8: error: enum\
    \ case 'intValue' cannot be used as an instance member\n    if a.intValue() >\
    \ b.intValue() {\n       ^\n       Value\n/tmp/tmpiqnzqtra.swift:33:21: error:\
    \ referencing operator function '>' on 'Comparable' requires that 'Value' conform\
    \ to 'Comparable'\n    if a.intValue() > b.intValue() {\n                    ^\n\
    Swift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol Comparable\
    \ : Equatable {\n                ^\n/tmp/tmpiqnzqtra.swift:33:21: note: binary\
    \ operator '>' cannot be synthesized for enums with associated values\n    if\
    \ a.intValue() > b.intValue() {\n                    ^\n/tmp/tmpiqnzqtra.swift:33:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() > b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpiqnzqtra.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpiqnzqtra.swift:33:23: error: enum case 'intValue' cannot\
    \ be used as an instance member\n    if a.intValue() > b.intValue() {\n      \
    \                ^\n                      Value\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n        switch\
    \ b { // Switch on b.\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpwbc21ux7/tmpwbc21ux7.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4facbddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4fac8d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4fac8d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4fac8d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbc21ux7                        0x0000559414101a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b4facdc9460 __libc_start_main +
    245

    6    tmpwbc21ux7                        0x0000559414101499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value, b as! Value {\n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_):\n        return a\n    case .intValue(_), .doubleValue(_):\n\
    \        return b\n    case .stringValue(_), .intValue(_), .doubleValue(_):\n\
    \        return a\n    case .stringValue(_), .doubleValue(_):\n        return\
    \ b\n    case .intValue(_), .stringValue(_):\n        return a\n    case .doubleValue(_),\
    \ .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpstwka584.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmpstwka584.swift:14:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as! Value, b as! Value {\n                  \
    \    ^\n                      ;\n/tmp/tmpstwka584.swift:14:23: error: expected\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmpstwka584.swift:14:14: warning: forced cast of 'Value' to same type has\
    \ no effect\n    switch a as! Value, b as! Value {\n             ^~~~~~~~~\n \
    \            \n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmhmrwsys/tmpmhmrwsys.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cf2bffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cf28f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cf28f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cf28f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhmrwsys                        0x000056212edcaa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8cf2deb460 __libc_start_main +
    245

    6    tmpmhmrwsys                        0x000056212edca499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpma4p4hx7/tmpma4p4hx7.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77a83e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77a80e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77a80e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77a80df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpma4p4hx7                        0x0000558b294d1a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b77a85d5460 __libc_start_main +
    245

    6    tmpma4p4hx7                        0x0000558b294d1499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case is more efficient than switch-case\n    case\
    \ .intValue(_):\n        switch b { // case is more efficient than switch-case\n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { // case is more efficient\
    \ than switch-case\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // case is more efficient than switch-case\n        case .intValue(_):\n \
    \           return a\n        case .doubleValue(_):\n            return b\n  \
    \      case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpykwf70ny/tmpykwf70ny.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d44ae3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d447dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d447da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d447d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpykwf70ny                        0x0000557197d35a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b7d44ccf460 __libc_start_main +
    245

    6    tmpykwf70ny                        0x0000557197d35499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Switch to switch on enum\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmps_25v9jc/tmps_25v9jc.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b957149cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9571193b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9571193988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95711927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_25v9jc                        0x0000563c4467201a <unavailable> + 12314

    5    libc.so.6                          0x00002b9571688460 __libc_start_main +
    245

    6    tmps_25v9jc                        0x0000563c44670499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of the first value\n    case\
    \ .intValue(_):\n        switch b { // Switch on the type of the second value\n\
    \        case .intValue(_):\n            return .intValue(a.intValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of the second value\n        case .intValue(_):\n       \
    \     return .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on the type\
    \ of the second value\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppr_4wh8l.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmppr_4wh8l.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmppr_4wh8l.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmppr_4wh8l.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmppr_4wh8l.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmppr_4wh8l.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmppr_4wh8l.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmppr_4wh8l.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmppr_4wh8l.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmppr_4wh8l.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // Both are integers\n    if a.intValue >\
    \ b.intValue {\n        return a\n    }\n    \n    if b.intValue > a.intValue\
    \ {\n        return b\n    }\n    \n    // Both are doubles\n    if a.doubleValue\
    \ > b.doubleValue {\n        return a\n    }\n    \n    if b.doubleValue > a.doubleValue\
    \ {\n        return b\n    }\n    \n    // Both are strings\n    if a.stringValue\
    \ > b.stringValue {\n        return a\n    }\n    \n    if b.stringValue > a.stringValue\
    \ {\n        return b\n    }\n    \n    // None are equal\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpk5auny0i.swift:33:19: error: binary operator '>' cannot be applied\
    \ to two '(Int) -> Value' operands\n    if a.intValue > b.intValue {\n       ~~~~~~~~~~\
    \ ^ ~~~~~~~~~~\n/tmp/tmpk5auny0i.swift:37:19: error: binary operator '>' cannot\
    \ be applied to two '(Int) -> Value' operands\n    if b.intValue > a.intValue\
    \ {\n       ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpk5auny0i.swift:42:22: error: binary\
    \ operator '>' cannot be applied to two '(Double) -> Value' operands\n    if a.doubleValue\
    \ > b.doubleValue {\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpk5auny0i.swift:46:22:\
    \ error: binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \    if b.doubleValue > a.doubleValue {\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n\
    /tmp/tmpk5auny0i.swift:51:22: error: binary operator '>' cannot be applied to\
    \ two '(String) -> Value' operands\n    if a.stringValue > b.stringValue {\n \
    \      ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpk5auny0i.swift:55:22: error: binary\
    \ operator '>' cannot be applied to two '(String) -> Value' operands\n    if b.stringValue\
    \ > a.stringValue {\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Switch to switch case for performance\n  \
    \  case .intValue(_):\n        return b\n    case .doubleValue(_):\n        return\
    \ b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpca_vqzns/tmpca_vqzns.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70e169c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af70de60b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af70de60988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af70de5f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpca_vqzns                        0x0000560a3acfa01a <unavailable> + 12314

    5    libc.so.6                          0x00002af70e355460 __libc_start_main +
    245

    6    tmpca_vqzns                        0x0000560a3acf8499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aInt):\n        switch\
    \ b as? Value {\n        case let .intValue(bInt):\n            return aInt >\
    \ bInt ? .intValue(aInt) : .intValue(bInt)\n        case let .doubleValue(bDouble):\n\
    \            return .doubleValue(bDouble)\n        case let .stringValue(bString):\n\
    \            return .stringValue(bString)\n        }\n    case let .doubleValue(aDouble):\n\
    \        switch b as? Value {\n        case let .intValue(bInt):\n           \
    \ return .doubleValue(aDouble)\n        case let .doubleValue(bDouble):\n    \
    \        return bDouble > aDouble ? .doubleValue(aDouble) : .doubleValue(bDouble)\n\
    \        case let .stringValue(bString):\n            return .stringValue(bString)\n\
    \        }\n    case let .stringValue(aString):\n        switch b as? Value {\n\
    \        case let .intValue(bInt):\n            return .stringValue(aString)\n\
    \        case let .doubleValue(bDouble):\n            return .stringValue(aString)\n\
    \        case let .stringValue(bString):\n            return .stringValue(bString)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpl1kfe5ti.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpl1kfe5ti.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpl1kfe5ti.swift:16:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpl1kfe5ti.swift:16:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpl1kfe5ti.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpl1kfe5ti.swift:25:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpl1kfe5ti.swift:25:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpl1kfe5ti.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpl1kfe5ti.swift:34:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpl1kfe5ti.swift:34:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpl1kfe5ti.swift:14:5:\
    \ error: switch must be exhaustive\n    switch a as? Value {\n    ^\n/tmp/tmpl1kfe5ti.swift:14:5:\
    \ note: add missing case: '.none'\n    switch a as? Value {\n    ^\n/tmp/tmpl1kfe5ti.swift:26:28:\
    \ warning: immutable value 'bInt' was never used; consider replacing with '_'\
    \ or removing it\n        case let .intValue(bInt):\n                        \
    \   ^~~~\n                           _\n/tmp/tmpl1kfe5ti.swift:35:28: warning:\
    \ immutable value 'bInt' was never used; consider replacing with '_' or removing\
    \ it\n        case let .intValue(bInt):\n                           ^~~~\n   \
    \                        _\n/tmp/tmpl1kfe5ti.swift:37:31: warning: immutable value\
    \ 'bDouble' was never used; consider replacing with '_' or removing it\n     \
    \   case let .doubleValue(bDouble):\n                              ^~~~~~~\n \
    \                             _\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case is required because Value is a protocol\n \
    \   case .intValue(_):\n        switch b { // case is required because Value is\
    \ a protocol\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { // case is required because\
    \ Value is a protocol\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // case is required because Value is a protocol\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpr_qqf8us/tmpr_qqf8us.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fdd0d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fdcdccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fdcdcc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fdcdcb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr_qqf8us                        0x000055a80b7a3a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b6fdd2c1460 __libc_start_main +
    245

    6    tmpr_qqf8us                        0x000055a80b7a3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return a\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return b\n        case .doubleValue(_):\n       \
    \     return a\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpqtmsby41/tmpqtmsby41.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afaba585c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afaba27cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afaba27c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afaba27b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqtmsby41                        0x0000562646de3a56 <unavailable> + 6742

    5    libc.so.6                          0x00002afaba771460 __libc_start_main +
    245

    6    tmpqtmsby41                        0x0000562646de3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmqcgypdu/tmpmqcgypdu.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f09625c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f0931cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f0931c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f0931b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmqcgypdu                        0x000055b885eae01a <unavailable> + 12314

    5    libc.so.6                          0x00002b7f09811460 __libc_start_main +
    245

    6    tmpmqcgypdu                        0x000055b885eac499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Switch to enum\n    case .intValue(_):\n \
    \       return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpg1loudvg/tmpg1loudvg.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8b8d46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8b8a3db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8b8a3d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8b8a3c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg1loudvg                        0x000056295045c01a <unavailable> + 12314

    5    libc.so.6                          0x00002ad8b8f32460 __libc_start_main +
    245

    6    tmpg1loudvg                        0x000056295045a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        switch\
    \ b { // b is larger\n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpg1mddtvd/tmpg1mddtvd.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac62c9e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac62c6dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac62c6dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac62c6db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg1mddtvd                        0x000055b45d68da56 <unavailable> + 6742

    5    libc.so.6                          0x00002ac62cbd1460 __libc_start_main +
    245

    6    tmpg1mddtvd                        0x000055b45d68d499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to use\n\
    \    case .intValue(_):\n        return b\n    case .doubleValue(_):\n       \
    \ return b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpohpw1wya/tmpohpw1wya.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab674807c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6744feb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6744fe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6744fd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpohpw1wya                        0x00005652b9d8e01a <unavailable> + 12314

    5    libc.so.6                          0x00002ab6749f3460 __libc_start_main +
    245

    6    tmpohpw1wya                        0x00005652b9d8c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare each variable type\n    case .intValue(_):\n\
    \        switch b { // Compare each variable type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare each variable\
    \ type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare each variable type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprujlrd25.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmprujlrd25.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmprujlrd25.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmprujlrd25.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmprujlrd25.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmprujlrd25.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmprujlrd25.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmprujlrd25.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmprujlrd25.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmprujlrd25.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.stringValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp476gh4dh.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmp476gh4dh.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of the first argument.\n    case\
    \ .intValue(_):\n        switch b { // Switch on the type of the second argument.\n\
    \        case .intValue(_):\n            return .intValue(a.intValue > b.intValue\
    \ ? a.intValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on the type of the second argument.\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue ?\
    \ a.doubleValue : b.doubleValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of the second argument.\n        case .intValue(_):\n   \
    \         return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.stringValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpp095v_2y.swift:18:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpp095v_2y.swift:18:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpp095v_2y.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpp095v_2y.swift:18:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpp095v_2y.swift:18:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpp095v_2y.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpp095v_2y.swift:18:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpp095v_2y.swift:18:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n        switch\
    \ b { // Switch on b.\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on b.\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpwbc21ux7/tmpwbc21ux7.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4facbddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4fac8d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4fac8d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4fac8d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbc21ux7                        0x0000559414101a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b4facdc9460 __libc_start_main +
    245

    6    tmpwbc21ux7                        0x0000559414101499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue:\n        switch\
    \ b { // case intValue:\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b { // case doubleValue:\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b { // case stringValue:\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpop0u4_vz.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmpop0u4_vz.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmpop0u4_vz.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpop0u4_vz.swift:27:21: error: member 'intValue'\
    \ expects argument of type 'Int'\n            return .intValue\n             \
    \       ^\n/tmp/tmpop0u4_vz.swift:29:21: error: member 'doubleValue' expects argument\
    \ of type 'Double'\n            return .doubleValue\n                    ^\n/tmp/tmpop0u4_vz.swift:31:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpop0u4_vz.swift:36:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmpop0u4_vz.swift:38:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpop0u4_vz.swift:40:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aIntValue):\n   \
    \     switch b as? Value {\n        case let .intValue(bIntValue):\n         \
    \   return aIntValue > bIntValue ? .intValue(aIntValue) : .intValue(bIntValue)\n\
    \        case let .doubleValue(bDoubleValue):\n            return .doubleValue(aIntValue)\
    \ > bDoubleValue ? .intValue(aIntValue) : .doubleValue(bDoubleValue)\n       \
    \ case let .stringValue(bStringValue):\n            return .stringValue(aIntValue)\
    \ > bStringValue ? .intValue(aIntValue) : .stringValue(bStringValue)\n       \
    \ }\n    case let .doubleValue(aDoubleValue):\n        switch b as? Value {\n\
    \        case let .intValue(bIntValue):\n            return .doubleValue(aDoubleValue)\
    \ > bIntValue ? .doubleValue(aDoubleValue) : .intValue(bIntValue)\n        case\
    \ let .doubleValue(bDoubleValue):\n            return .doubleValue(aDoubleValue)\
    \ > bDoubleValue ? .doubleValue(aDoubleValue) : .doubleValue(bDoubleValue)\n \
    \       case let .stringValue(bStringValue):\n            return .doubleValue(aDoubleValue)\
    \ > bStringValue ? .doubleValue(aDoubleValue) : .stringValue(bStringValue)\n \
    \       }\n    case let .stringValue(aStringValue):\n        switch b as? Value\
    \ {\n        case let .intValue(bIntValue):\n            return .stringValue(aStringValue)\
    \ > bIntValue ? .stringValue(aStringValue) : .intValue(bIntValue)\n        case\
    \ let .doubleValue(bDoubleValue):\n            return .stringValue(aStringValue)\
    \ > bDoubleValue ? .stringValue(aStringValue) : .doubleValue(bDoubleValue)\n \
    \       case let .stringValue(bStringValue):\n            return .stringValue(aStringValue)\
    \ > bStringValue ? .stringValue(aStringValue) : .stringValue(bStringValue)\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwhfc1la7.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpwhfc1la7.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpwhfc1la7.swift:20:21: error: type\
    \ 'Double' has no member 'doubleValue'\n            return .doubleValue(aIntValue)\
    \ > bDoubleValue ? .intValue(aIntValue) : .doubleValue(bDoubleValue)\n       \
    \            ~^~~~~~~~~~~\n/tmp/tmpwhfc1la7.swift:22:21: error: type 'String'\
    \ has no member 'stringValue'\n            return .stringValue(aIntValue) > bStringValue\
    \ ? .intValue(aIntValue) : .stringValue(bStringValue)\n                   ~^~~~~~~~~~~\n\
    /tmp/tmpwhfc1la7.swift:16:9: error: switch must be exhaustive\n        switch\
    \ b as? Value {\n        ^\n/tmp/tmpwhfc1la7.swift:16:9: note: add missing case:\
    \ '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpwhfc1la7.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpwhfc1la7.swift:27:21: error: type\
    \ 'Int' has no member 'doubleValue'\n            return .doubleValue(aDoubleValue)\
    \ > bIntValue ? .doubleValue(aDoubleValue) : .intValue(bIntValue)\n          \
    \         ~^~~~~~~~~~~\n/tmp/tmpwhfc1la7.swift:29:21: error: type 'Double' has\
    \ no member 'doubleValue'\n            return .doubleValue(aDoubleValue) > bDoubleValue\
    \ ? .doubleValue(aDoubleValue) : .doubleValue(bDoubleValue)\n                \
    \   ~^~~~~~~~~~~\n/tmp/tmpwhfc1la7.swift:31:21: error: type 'String' has no member\
    \ 'doubleValue'\n            return .doubleValue(aDoubleValue) > bStringValue\
    \ ? .doubleValue(aDoubleValue) : .stringValue(bStringValue)\n                \
    \   ~^~~~~~~~~~~\n/tmp/tmpwhfc1la7.swift:25:9: error: switch must be exhaustive\n\
    \        switch b as? Value {\n        ^\n/tmp/tmpwhfc1la7.swift:25:9: note: add\
    \ missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpwhfc1la7.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n      "
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.stringValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp476gh4dh.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmp476gh4dh.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return a\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpw6mo91_w/tmpw6mo91_w.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0ca86bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0ca562b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0ca562988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0ca5617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw6mo91_w                        0x000055f1a436ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad0caa57460 __libc_start_main +
    245

    6    tmpw6mo91_w                        0x000055f1a436c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        return b\n    case .doubleValue(_):\n       \
    \ return b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpwcclje34/tmpwcclje34.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e4f0ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e4edf6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e4edf6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e4edf57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwcclje34                        0x000055580bf8501a <unavailable> + 12314

    5    libc.so.6                          0x00002b2e4f2eb460 __libc_start_main +
    245

    6    tmpwcclje34                        0x000055580bf83499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: switch on type\n    case .intValue(_):\n \
    \       return .intValue(a.intValue > b.intValue)\n    case .doubleValue(_):\n\
    \        return .doubleValue(a.doubleValue > b.doubleValue)\n    case .stringValue(_):\n\
    \        return .stringValue(a.stringValue > b.stringValue)\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppz_w6pzq.swift:16:37: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n        return .intValue(a.intValue > b.intValue)\n\
    \                                    ^\n/tmp/tmppz_w6pzq.swift:16:26: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return .intValue(a.intValue\
    \ > b.intValue)\n                         ^\n                         Value\n\
    /tmp/tmppz_w6pzq.swift:16:37: error: type '(Int) -> Value' cannot conform to 'Comparable'\n\
    \        return .intValue(a.intValue > b.intValue)\n                         \
    \           ^\n/tmp/tmppz_w6pzq.swift:16:37: note: only concrete types such as\
    \ structs, enums and classes can conform to protocols\n        return .intValue(a.intValue\
    \ > b.intValue)\n                                    ^\n/tmp/tmppz_w6pzq.swift:16:37:\
    \ note: required by referencing operator function '>' on 'Comparable' where 'Self'\
    \ = '(Int) -> Value'\n        return .intValue(a.intValue > b.intValue)\n    \
    \                                ^\n/tmp/tmppz_w6pzq.swift:16:39: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return .intValue(a.intValue\
    \ > b.intValue)\n                                      ^\n                   \
    \                   Value\n/tmp/tmppz_w6pzq.swift:18:43: error: cannot convert\
    \ value of type 'Bool' to expected argument type 'Double'\n        return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                          ^\n/tmp/tmppz_w6pzq.swift:18:29:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \      ^\n                            Value\n/tmp/tmppz_w6pzq.swift:18:43: error:\
    \ type '(Double) -> Value' cannot conform to 'Comparable'\n        return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                          ^\n/tmp/tmppz_w6pzq.swift:18:43:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        return .doubleValue(a.doubleValue > b.doubleValue)\n    \
    \                "
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aIntValue):\n   \
    \     switch b as? Value {\n        case let .intValue(bIntValue):\n         \
    \   return aIntValue > bIntValue ? .intValue(aIntValue) : .intValue(bIntValue)\n\
    \        case let .doubleValue(bDoubleValue):\n            return .doubleValue(aIntValue)\
    \ > bDoubleValue ? .intValue(aIntValue) : .doubleValue(bDoubleValue)\n       \
    \ case let .stringValue(bStringValue):\n            return .stringValue(aIntValue)\
    \ > bStringValue ? .intValue(aIntValue) : .stringValue(bStringValue)\n       \
    \ }\n    case let .doubleValue(aDoubleValue):\n        switch b as? Value {\n\
    \        case let .intValue(bIntValue):\n            return .doubleValue(aDoubleValue)\
    \ > bIntValue ? .doubleValue(aDoubleValue) : .intValue(bIntValue)\n        case\
    \ let .doubleValue(bDoubleValue):\n            return .doubleValue(aDoubleValue)\
    \ > bDoubleValue ? .doubleValue(aDoubleValue) : .doubleValue(bDoubleValue)\n \
    \       case let .stringValue(bStringValue):\n            return .stringValue(aDoubleValue)\
    \ > bStringValue ? .doubleValue(aDoubleValue) : .stringValue(bStringValue)\n \
    \       }\n    case let .stringValue(aStringValue):\n        switch b as? Value\
    \ {\n        case let .intValue(bIntValue):\n            return .stringValue(aStringValue)\
    \ > bIntValue ? .stringValue(aStringValue) : .intValue(bIntValue)\n        case\
    \ let .doubleValue(bDoubleValue):\n            return .stringValue(aStringValue)\
    \ > bDoubleValue ? .stringValue(aStringValue) : .doubleValue(bDoubleValue)\n \
    \       case let .stringValue(bStringValue):\n            return .stringValue(aStringValue)\
    \ > bStringValue ? .stringValue(aStringValue) : .stringValue(bStringValue)\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpaqg41fz7.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpaqg41fz7.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpaqg41fz7.swift:20:21: error: type\
    \ 'Double' has no member 'doubleValue'\n            return .doubleValue(aIntValue)\
    \ > bDoubleValue ? .intValue(aIntValue) : .doubleValue(bDoubleValue)\n       \
    \            ~^~~~~~~~~~~\n/tmp/tmpaqg41fz7.swift:22:21: error: type 'String'\
    \ has no member 'stringValue'\n            return .stringValue(aIntValue) > bStringValue\
    \ ? .intValue(aIntValue) : .stringValue(bStringValue)\n                   ~^~~~~~~~~~~\n\
    /tmp/tmpaqg41fz7.swift:16:9: error: switch must be exhaustive\n        switch\
    \ b as? Value {\n        ^\n/tmp/tmpaqg41fz7.swift:16:9: note: add missing case:\
    \ '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpaqg41fz7.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpaqg41fz7.swift:27:21: error: type\
    \ 'Int' has no member 'doubleValue'\n            return .doubleValue(aDoubleValue)\
    \ > bIntValue ? .doubleValue(aDoubleValue) : .intValue(bIntValue)\n          \
    \         ~^~~~~~~~~~~\n/tmp/tmpaqg41fz7.swift:29:21: error: type 'Double' has\
    \ no member 'doubleValue'\n            return .doubleValue(aDoubleValue) > bDoubleValue\
    \ ? .doubleValue(aDoubleValue) : .doubleValue(bDoubleValue)\n                \
    \   ~^~~~~~~~~~~\n/tmp/tmpaqg41fz7.swift:31:21: error: type 'String' has no member\
    \ 'stringValue'\n            return .stringValue(aDoubleValue) > bStringValue\
    \ ? .doubleValue(aDoubleValue) : .stringValue(bStringValue)\n                \
    \   ~^~~~~~~~~~~\n/tmp/tmpaqg41fz7.swift:25:9: error: switch must be exhaustive\n\
    \        switch b as? Value {\n        ^\n/tmp/tmpaqg41fz7.swift:25:9: note: add\
    \ missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpaqg41fz7.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n      "
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // Both are integers\n    if a.intValue()\
    \ > b.intValue() {\n        return a\n    }\n    \n    return b\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpiqnzqtra.swift:33:19: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() > b.intValue() {\n                  ^\n       \
    \           <#Int#>\n/tmp/tmpiqnzqtra.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpiqnzqtra.swift:33:8: error: enum\
    \ case 'intValue' cannot be used as an instance member\n    if a.intValue() >\
    \ b.intValue() {\n       ^\n       Value\n/tmp/tmpiqnzqtra.swift:33:21: error:\
    \ referencing operator function '>' on 'Comparable' requires that 'Value' conform\
    \ to 'Comparable'\n    if a.intValue() > b.intValue() {\n                    ^\n\
    Swift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol Comparable\
    \ : Equatable {\n                ^\n/tmp/tmpiqnzqtra.swift:33:21: note: binary\
    \ operator '>' cannot be synthesized for enums with associated values\n    if\
    \ a.intValue() > b.intValue() {\n                    ^\n/tmp/tmpiqnzqtra.swift:33:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() > b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpiqnzqtra.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpiqnzqtra.swift:33:23: error: enum case 'intValue' cannot\
    \ be used as an instance member\n    if a.intValue() > b.intValue() {\n      \
    \                ^\n                      Value\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is bigger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return a\n        }\n        if aString > bString {\n\
    \            return b\n        }\n        return a\n    }\n    \n    // If both\
    \ are integers, compare them numerically\n    if let aInt = a.intValue, bInt =\
    \ b.intValue {\n        if aInt < bInt {\n            return a\n        }\n  \
    \      if aInt > bInt {\n            return b\n        }\n        return a\n \
    \   }\n    \n    // If both are doubles, compare them numerically\n    if let\
    \ aDouble = a.doubleValue, bDouble = b.doubleValue {\n        if aDouble < bDouble\
    \ {\n            return a\n        }\n        if aDouble > bDouble {\n       \
    \     return b\n        }\n        return a\n    }\n    \n    // If both are strings,\
    \ compare them lexicographically\n    if let aString = a.stringValue, bString\
    \ = b.stringValue {\n        if aString < bString {\n            return a\n  \
    \      }\n        if aString > bString {\n            return b\n        }\n  \
    \      return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return a\n        }\n        if aString > bString {\n\
    \            return b\n        }\n        return a\n    }\n    \n    // If both\
    \ are strings, compare them lexicographically\n    if let aString = a.stringValue,\
    \ bString = b.stringValue {\n        if aString < bString {\n            return\
    \ a\n        }\n        if aString > bString {\n            return b\n       \
    \ }\n        return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return a\n        }\n        if aString > bString {\n\
    \            return b\n        }\n        return a\n    }\n    \n    // If both\
    \ are strings, \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwd8ab5hg.swift:33:37: error: expected 'let' in conditional\n  \
    \  if let aString = a.stringValue, bString = b.stringValue {\n               \
    \                     ^\n                                    let \n/tmp/tmpwd8ab5hg.swift:44:31:\
    \ error: expected 'let' in conditional\n    if let aInt = a.intValue, bInt = b.intValue\
    \ {\n                              ^\n                              let \n/tmp/tmpwd8ab5hg.swift:55:37:\
    \ error: expected 'let' in conditional\n    if let aDouble = a.doubleValue, bDouble\
    \ = b.doubleValue {\n                                    ^\n                 \
    \                   let \n/tmp/tmpwd8ab5hg.swift:66:37: error: expected 'let'\
    \ in conditional\n    if let aString = a.stringValue, bString = b.stringValue\
    \ {\n                                    ^\n                                 \
    \   let \n/tmp/tmpwd8ab5hg.swift:77:37: error: expected 'let' in conditional\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n             \
    \                       ^\n                                    let \n/tmp/tmpwd8ab5hg.swift:88:37:\
    \ error: expected 'let' in conditional\n    if let aString = a.stringValue, bString\
    \ = b.stringValue {\n                                    ^\n                 \
    \                   let \n/tmp/tmpwd8ab5hg.swift:99:37: error: expected 'let'\
    \ in conditional\n    if let aString = a.stringValue, bString = b.stringValue\
    \ {\n                                    ^\n                                 \
    \   let \n/tmp/tmpwd8ab5hg.swift:33:22: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n    if let aString = a.stringValue, bString =\
    \ b.stringValue {\n                     ^\n                     Value\n/tmp/tmpwd8ab5hg.swift:33:47:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    if\
    \ let aString = a.stringValue, bString = b.stringValue {\n                   \
    \                           ^\n                                              Value\n\
    /tmp/tmpwd8ab5hg.swift:44:19: error: enum case 'intValue' cannot be used as an\
    \ instance member\n    if let aInt = a.intValue, bInt = b.intValue {\n "
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a's type\n    case .intValue:\n      \
    \  switch b { // Switch on b's type\n        case .intValue:\n            return\
    \ .intValue\n        case .doubleValue:\n            return .doubleValue\n   \
    \     case .stringValue:\n            return .stringValue\n        }\n    case\
    \ .doubleValue:\n        switch b { // Switch on b's type\n        case .intValue:\n\
    \            return .doubleValue\n        case .doubleValue:\n            return\
    \ .doubleValue\n        case .stringValue:\n            return .stringValue\n\
    \        }\n    case .stringValue:\n        switch b { // Switch on b's type\n\
    \        case .intValue:\n            return .stringValue\n        case .doubleValue:\n\
    \            return .stringValue\n        case .stringValue:\n            return\
    \ .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvyqpj46b.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmpvyqpj46b.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmpvyqpj46b.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpvyqpj46b.swift:27:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpvyqpj46b.swift:29:21: error: member 'doubleValue' expects\
    \ argument of type 'Double'\n            return .doubleValue\n               \
    \     ^\n/tmp/tmpvyqpj46b.swift:31:21: error: member 'stringValue' expects argument\
    \ of type 'String'\n            return .stringValue\n                    ^\n/tmp/tmpvyqpj46b.swift:36:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpvyqpj46b.swift:38:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpvyqpj46b.swift:40:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil // equal\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmplru5wtbj/tmplru5wtbj.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b050c617c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b050c30eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b050c30e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b050c30d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplru5wtbj                        0x000055f60ca4e01a <unavailable> + 12314

    5    libc.so.6                          0x00002b050c803460 __libc_start_main +
    245

    6    tmplru5wtbj                        0x000055f60ca4c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpma4p4hx7/tmpma4p4hx7.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77a83e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77a80e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77a80e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77a80df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpma4p4hx7                        0x0000558b294d1a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b77a85d5460 __libc_start_main +
    245

    6    tmpma4p4hx7                        0x0000558b294d1499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value, b as! Value {\n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_):\n        return a\n    case .intValue(_), .doubleValue(_):\n\
    \        return b\n    case .stringValue(_), .intValue(_), .doubleValue(_):\n\
    \        return a\n    case .stringValue(_), .doubleValue(_):\n        return\
    \ b\n    case .intValue(_), .stringValue(_):\n        return a\n    case .doubleValue(_),\
    \ .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpstwka584.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmpstwka584.swift:14:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as! Value, b as! Value {\n                  \
    \    ^\n                      ;\n/tmp/tmpstwka584.swift:14:23: error: expected\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmpstwka584.swift:14:14: warning: forced cast of 'Value' to same type has\
    \ no effect\n    switch a as! Value, b as! Value {\n             ^~~~~~~~~\n \
    \            \n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type\n    case .intValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return .doubleValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return .stringValue\n\
    \        case .doubleValue:\n            return .stringValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq0h2cgic.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmpq0h2cgic.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmpq0h2cgic.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpq0h2cgic.swift:27:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpq0h2cgic.swift:29:21: error: member 'doubleValue' expects\
    \ argument of type 'Double'\n            return .doubleValue\n               \
    \     ^\n/tmp/tmpq0h2cgic.swift:31:21: error: member 'stringValue' expects argument\
    \ of type 'String'\n            return .stringValue\n                    ^\n/tmp/tmpq0h2cgic.swift:36:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpq0h2cgic.swift:38:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpq0h2cgic.swift:40:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return b\n        case .doubleValue(_):\n            return a\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return b\n     \
    \   case .doubleValue(_):\n            return a\n        case .stringValue(_):\n\
    \            return a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpcr2_74_f/tmpcr2_74_f.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b88bd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b888ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b888ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b888cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcr2_74_f                        0x000055fafe1e6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b4b88dc3460 __libc_start_main +
    245

    6    tmpcr2_74_f                        0x000055fafe1e6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value, b as! Value {\n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_):\n        return a\n    case .intValue(_), .doubleValue(_):\n\
    \        return b\n    case .stringValue(_), .doubleValue(_):\n        return\
    \ a\n    case .stringValue(_), .intValue(_):\n        return b\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpoyt_2km6.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmpoyt_2km6.swift:14:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as! Value, b as! Value {\n                  \
    \    ^\n                      ;\n/tmp/tmpoyt_2km6.swift:14:23: error: expected\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmpoyt_2km6.swift:14:14: warning: forced cast of 'Value' to same type has\
    \ no effect\n    switch a as! Value, b as! Value {\n             ^~~~~~~~~\n \
    \            \n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case is more efficient than a switch statement\n\
    \    case .intValue(_):\n        switch b { // case is more efficient than a switch\
    \ statement\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { // case is more efficient\
    \ than a switch statement\n        case .intValue(_):\n            return a\n\
    \        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // case is more efficient than a switch statement\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpcwseq0no/tmpcwseq0no.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69fca64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69fc75bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69fc75b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69fc75a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcwseq0no                        0x000055c0cad0ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b69fcc50460 __libc_start_main +
    245

    6    tmpcwseq0no                        0x000055c0cad0e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzfye53ej.swift:14:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmpzfye53ej.swift:16:18: warning: forced cast of 'Value' to same type\
    \ has no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n \
    \                \n/tmp/tmpzfye53ej.swift:18:41: error: cannot convert value of\
    \ type 'Bool' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpzfye53ej.swift:18:30:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue)\n                             ^\n\
    \                             Value\n/tmp/tmpzfye53ej.swift:18:41: error: type\
    \ '(Int) -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpzfye53ej.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpzfye53ej.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpzfye53ej.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpzfye53ej.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpzfye53ej.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n        switch\
    \ b { // Switch on b.\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b.\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b.\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpd_3rwivg.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpd_3rwivg.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpd_3rwivg.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpd_3rwivg.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpd_3rwivg.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpd_3rwivg.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpd_3rwivg.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpd_3rwivg.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpd_3rwivg.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpd_3rwivg.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two ints\n        case .intValue(_):\n           \
    \ return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare two doubles\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpv07dde1m/tmpv07dde1m.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ce1fddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ce1cd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ce1cd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ce1cd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv07dde1m                        0x0000555bb2165a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8ce21c9460 __libc_start_main +
    245

    6    tmpv07dde1m                        0x0000555bb2165499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Use a switch statement to handle all cases\n\
    \    case .intValue(_):\n        return b\n    case .doubleValue(_):\n       \
    \ return b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpcaxagmql/tmpcaxagmql.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89cf232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89cef29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89cef29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89cef287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcaxagmql                        0x0000557760ee701a <unavailable> + 12314

    5    libc.so.6                          0x00002b89cf41e460 __libc_start_main +
    245

    6    tmpcaxagmql                        0x0000557760ee5499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aIntValue):\n   \
    \     switch b as? Value {\n        case let .intValue(bIntValue):\n         \
    \   return aIntValue > bIntValue ? .intValue(aIntValue) : .intValue(bIntValue)\n\
    \        case let .doubleValue(bDoubleValue):\n            return .doubleValue(aIntValue)\
    \ > bDoubleValue ? .intValue(aIntValue) : .doubleValue(bDoubleValue)\n       \
    \ case let .stringValue(bStringValue):\n            return .stringValue(aIntValue)\
    \ > bStringValue ? .intValue(aIntValue) : .stringValue(bStringValue)\n       \
    \ }\n    case let .doubleValue(aDoubleValue):\n        switch b as? Value {\n\
    \        case let .intValue(bIntValue):\n            return .doubleValue(aDoubleValue)\
    \ > bIntValue ? .doubleValue(aDoubleValue) : .intValue(bIntValue)\n        case\
    \ let .doubleValue(bDoubleValue):\n            return aDoubleValue > bDoubleValue\
    \ ? .doubleValue(aDoubleValue) : .doubleValue(bDoubleValue)\n        case let\
    \ .stringValue(bStringValue):\n            return .stringValue(aDoubleValue) >\
    \ bStringValue ? .doubleValue(aDoubleValue) : .stringValue(bStringValue)\n   \
    \     }\n    case let .stringValue(aStringValue):\n        switch b as? Value\
    \ {\n        case let .intValue(bIntValue):\n            return .stringValue(aStringValue)\
    \ > bIntValue ? .stringValue(aStringValue) : .intValue(bIntValue)\n        case\
    \ let .doubleValue(bDoubleValue):\n            return .stringValue(aStringValue)\
    \ > bDoubleValue ? .stringValue(aStringValue) : .doubleValue(bDoubleValue)\n \
    \       case let .stringValue(bStringValue):\n            return aStringValue\
    \ > bStringValue ? .stringValue(aStringValue) : .stringValue(bStringValue)\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnrc5ot6a.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpnrc5ot6a.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpnrc5ot6a.swift:20:21: error: type\
    \ 'Double' has no member 'doubleValue'\n            return .doubleValue(aIntValue)\
    \ > bDoubleValue ? .intValue(aIntValue) : .doubleValue(bDoubleValue)\n       \
    \            ~^~~~~~~~~~~\n/tmp/tmpnrc5ot6a.swift:22:21: error: type 'String'\
    \ has no member 'stringValue'\n            return .stringValue(aIntValue) > bStringValue\
    \ ? .intValue(aIntValue) : .stringValue(bStringValue)\n                   ~^~~~~~~~~~~\n\
    /tmp/tmpnrc5ot6a.swift:16:9: error: switch must be exhaustive\n        switch\
    \ b as? Value {\n        ^\n/tmp/tmpnrc5ot6a.swift:16:9: note: add missing case:\
    \ '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpnrc5ot6a.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpnrc5ot6a.swift:27:21: error: type\
    \ 'Int' has no member 'doubleValue'\n            return .doubleValue(aDoubleValue)\
    \ > bIntValue ? .doubleValue(aDoubleValue) : .intValue(bIntValue)\n          \
    \         ~^~~~~~~~~~~\n/tmp/tmpnrc5ot6a.swift:31:21: error: type 'String' has\
    \ no member 'stringValue'\n            return .stringValue(aDoubleValue) > bStringValue\
    \ ? .doubleValue(aDoubleValue) : .stringValue(bStringValue)\n                \
    \   ~^~~~~~~~~~~\n/tmp/tmpnrc5ot6a.swift:25:9: error: switch must be exhaustive\n\
    \        switch b as? Value {\n        ^\n/tmp/tmpnrc5ot6a.swift:25:9: note: add\
    \ missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpnrc5ot6a.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpnrc5ot6a.swift:36:21: error: type\
    \ 'Int' has no member 'stringValue'\n            return .stringValue(aStringValue)\
    \ > bIntValue ? .stringValue(aStringValue) : .intValue(bIntValue)\n  "
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue:\n        switch\
    \ b { // case intValue:\n        case .intValue:\n            return a\n     \
    \   case .doubleValue:\n            return b\n        case .stringValue:\n   \
    \         return b\n        }\n    case .doubleValue:\n        switch b { // case\
    \ doubleValue:\n        case .intValue:\n            return a\n        case .doubleValue:\n\
    \            return b\n        case .stringValue:\n            return b\n    \
    \    }\n    case .stringValue:\n        switch b { // case stringValue:\n    \
    \    case .intValue:\n            return a\n        case .doubleValue:\n     \
    \       return b\n        case .stringValue:\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpurkyeeeo/tmpurkyeeeo.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3234f09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3234c00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3234c00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3234bff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpurkyeeeo                        0x00005650784caa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b32350f5460 __libc_start_main +
    245

    6    tmpurkyeeeo                        0x00005650784ca499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of a\n    case .intValue(_):\n\
    \        switch b { // Switch on the type of b\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on the type\
    \ of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpno2k0v4r.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpno2k0v4r.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpno2k0v4r.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpno2k0v4r.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpno2k0v4r.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpno2k0v4r.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpno2k0v4r.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpno2k0v4r.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpno2k0v4r.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpno2k0v4r.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a's type\n    case .intValue:\n      \
    \  switch b { // Switch on b's type\n        case .intValue:\n            return\
    \ .intValue\n        case .doubleValue:\n            return .doubleValue\n   \
    \     case .stringValue:\n            return .stringValue\n        }\n    case\
    \ .doubleValue:\n        switch b { // Switch on b's type\n        case .intValue:\n\
    \            return .intValue\n        case .doubleValue:\n            return\
    \ .doubleValue\n        case .stringValue:\n            return .stringValue\n\
    \        }\n    case .stringValue:\n        switch b { // Switch on b's type\n\
    \        case .intValue:\n            return .intValue\n        case .doubleValue:\n\
    \            return .doubleValue\n        case .stringValue:\n            return\
    \ .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvdaj1qls.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmpvdaj1qls.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmpvdaj1qls.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpvdaj1qls.swift:27:21: error: member 'intValue'\
    \ expects argument of type 'Int'\n            return .intValue\n             \
    \       ^\n/tmp/tmpvdaj1qls.swift:29:21: error: member 'doubleValue' expects argument\
    \ of type 'Double'\n            return .doubleValue\n                    ^\n/tmp/tmpvdaj1qls.swift:31:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpvdaj1qls.swift:36:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmpvdaj1qls.swift:38:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpvdaj1qls.swift:40:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpma4p4hx7/tmpma4p4hx7.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77a83e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77a80e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77a80e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77a80df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpma4p4hx7                        0x0000558b294d1a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b77a85d5460 __libc_start_main +
    245

    6    tmpma4p4hx7                        0x0000558b294d1499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Use a switch statement to improve performance\n\
    \    case .intValue(_):\n        return b\n    case .doubleValue(_):\n       \
    \ return b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpcw6jsnk7/tmpcw6jsnk7.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abbd9c9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abbd9991b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abbd9991988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abbd99907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcw6jsnk7                        0x0000562ada56201a <unavailable> + 12314

    5    libc.so.6                          0x00002abbd9e86460 __libc_start_main +
    245

    6    tmpcw6jsnk7                        0x0000562ada560499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aInt):\n        switch\
    \ b as? Value {\n        case let .intValue(bInt):\n            return aInt >\
    \ bInt ? .intValue(aInt) : .intValue(bInt)\n        case let .doubleValue(bDouble):\n\
    \            return .doubleValue(aInt) > bDouble ? .intValue(aInt) : .doubleValue(bDouble)\n\
    \        case let .stringValue(bString):\n            return .stringValue(aInt)\
    \ > bString ? .intValue(aInt) : .stringValue(bString)\n        }\n    case let\
    \ .doubleValue(aDouble):\n        switch b as? Value {\n        case let .intValue(bInt):\n\
    \            return .doubleValue(aDouble) > bInt ? .doubleValue(aDouble) : .intValue(bInt)\n\
    \        case let .doubleValue(bDouble):\n            return aDouble > bDouble\
    \ ? .doubleValue(aDouble) : .doubleValue(bDouble)\n        case let .stringValue(bString):\n\
    \            return .stringValue(aDouble) > bString ? .doubleValue(aDouble) :\
    \ .stringValue(bString)\n        }\n    case let .stringValue(aString):\n    \
    \    switch b as? Value {\n        case let .intValue(bInt):\n            return\
    \ .stringValue(aString) > bInt ? .stringValue(aString) : .intValue(bInt)\n   \
    \     case let .doubleValue(bDouble):\n            return aString > bDouble ?\
    \ .stringValue(aString) : .doubleValue(bDouble)\n        case let .stringValue(bString):\n\
    \            return aString > bString ? .stringValue(aString) : .stringValue(bString)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp84e5la90.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmp84e5la90.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmp84e5la90.swift:20:21: error: type\
    \ 'Double' has no member 'doubleValue'\n            return .doubleValue(aInt)\
    \ > bDouble ? .intValue(aInt) : .doubleValue(bDouble)\n                   ~^~~~~~~~~~~\n\
    /tmp/tmp84e5la90.swift:22:21: error: type 'String' has no member 'stringValue'\n\
    \            return .stringValue(aInt) > bString ? .intValue(aInt) : .stringValue(bString)\n\
    \                   ~^~~~~~~~~~~\n/tmp/tmp84e5la90.swift:16:9: error: switch must\
    \ be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmp84e5la90.swift:16:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmp84e5la90.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmp84e5la90.swift:27:21: error: type\
    \ 'Int' has no member 'doubleValue'\n            return .doubleValue(aDouble)\
    \ > bInt ? .doubleValue(aDouble) : .intValue(bInt)\n                   ~^~~~~~~~~~~\n\
    /tmp/tmp84e5la90.swift:31:21: error: type 'String' has no member 'stringValue'\n\
    \            return .stringValue(aDouble) > bString ? .doubleValue(aDouble) :\
    \ .stringValue(bString)\n                   ~^~~~~~~~~~~\n/tmp/tmp84e5la90.swift:25:9:\
    \ error: switch must be exhaustive\n        switch b as? Value {\n        ^\n\
    /tmp/tmp84e5la90.swift:25:9: note: add missing case: '.none'\n        switch b\
    \ as? Value {\n        ^\n/tmp/tmp84e5la90.swift:34:18: warning: conditional cast\
    \ from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n    \
    \             ^\n/tmp/tmp84e5la90.swift:36:21: error: type 'Int' has no member\
    \ 'stringValue'\n            return .stringValue(aString) > bInt ? .stringValue(aString)\
    \ : .intValue(bInt)\n                   ~^~~~~~~~~~~\n/tmp/tmp84e5la90.swift:38:28:\
    \ error: binary operator '>' cannot be app"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a's type\n    case .intValue(_):\n   \
    \     switch b { // Switch on b's type\n        case .intValue(_):\n         \
    \   return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3ac3mjz8.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp3ac3mjz8.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp3ac3mjz8.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp3ac3mjz8.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp3ac3mjz8.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp3ac3mjz8.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp3ac3mjz8.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp3ac3mjz8.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp3ac3mjz8.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp3ac3mjz8.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two ints\n    case .intValue(_):\n     \
    \   return .intValue(b) // Compare two ints\n    case .doubleValue(_):\n     \
    \   return .doubleValue(b) // Compare two doubles\n    case .stringValue(_):\n\
    \        return .stringValue(b) // Compare two strings\n    }\n    return nil\
    \ // If they're not the same type, return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9n27520w.swift:16:26: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n        return .intValue(b) // Compare two\
    \ ints\n                         ^\n/tmp/tmp9n27520w.swift:18:29: error: cannot\
    \ convert value of type 'Value' to expected argument type 'Double'\n        return\
    \ .doubleValue(b) // Compare two doubles\n                            ^\n/tmp/tmp9n27520w.swift:20:29:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \        return .stringValue(b) // Compare two strings\n                     \
    \       ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Switch to switch case for efficiency\n   \
    \ case .intValue(_):\n        return b\n    case .doubleValue(_):\n        return\
    \ b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp0yfwh0nj/tmp0yfwh0nj.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d7f920c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d7f617b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d7f617988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d7f6167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0yfwh0nj                        0x00005608749e901a <unavailable> + 12314

    5    libc.so.6                          0x00002b2d7fb0c460 __libc_start_main +
    245

    6    tmp0yfwh0nj                        0x00005608749e7499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to use\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsi73yz3f.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpsi73yz3f.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpsi73yz3f.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpsi73yz3f.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpsi73yz3f.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpsi73yz3f.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpsi73yz3f.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpsi73yz3f.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpsi73yz3f.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpsi73yz3f.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppeq_psi7.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:18:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmppeq_psi7.swift:20:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmppeq_psi7.swift:22:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n/tmp/tmppeq_psi7.swift:25:22: error: cannot find type 'ValueType' in\
    \ scope\n        switch b as? ValueType {\n                     ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:27:21:\
    \ error: member 'intValue' expects argument of type 'Int'\n            return\
    \ .intValue\n                    ^\n/tmp/tmppeq_psi7.swift:29:21: error: member\
    \ 'doubleValue' expects argument of type 'Double'\n            return .doubleValue\n\
    \                    ^\n/tmp/tmppeq_psi7.swift:31:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n/tmp/tmppeq_psi7.swift:34:22: error: cannot find type 'ValueType'\
    \ in scope\n        switch b as? ValueType {\n                     ^~~~~~~~~\n\
    /tmp/tmppeq_psi7.swift:36:21: error: member 'intValue' expects argument of type\
    \ 'Int'\n            return .intValue\n                    ^\n/tmp/tmppeq_psi7.swift:38:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmppeq_psi7.swift:40:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value, b as? Value {\n    case let .intValue(aInt),\
    \ let .intValue(bInt):\n        return aInt > bInt ? .intValue(aInt) : .intValue(bInt)\n\
    \    case let .doubleValue(aDouble), let .doubleValue(bDouble):\n        return\
    \ aDouble > bDouble ? .doubleValue(aDouble) : .doubleValue(bDouble)\n    case\
    \ let .stringValue(aString), let .stringValue(bString):\n        return aString\
    \ > bString ? .stringValue(aString) : .stringValue(bString)\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbrinycxg.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as? Value, b as? Value {\n                      ^\n\
    /tmp/tmpbrinycxg.swift:14:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as? Value, b as? Value {\n                  \
    \    ^\n                      ;\n/tmp/tmpbrinycxg.swift:14:23: error: expected\
    \ expression\n    switch a as? Value, b as? Value {\n                      ^\n\
    /tmp/tmpbrinycxg.swift:14:14: warning: conditional cast from 'Value' to 'Value'\
    \ always succeeds\n    switch a as? Value, b as? Value {\n             ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqqc4cbnf.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqqc4cbnf.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqqc4cbnf.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqqc4cbnf.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqqc4cbnf.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqqc4cbnf.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqqc4cbnf.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqqc4cbnf.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // case intValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    switch a { // case doubleValue:\n    case\
    \ .intValue(_):\n        return b\n    case .doubleValue(_):\n        return a\n\
    \    case .stringValue(_):\n        return a\n    }\n    \n    switch b { // case\
    \ doubleValue:\n    case .intValue(_):\n        return a\n    case .doubleValue(_):\n\
    \        return b\n    case .stringValue(_):\n        return b\n    }\n    \n\
    \    switch a { // case stringValue:\n    case .intValue(_):\n        return b\n\
    \    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n    \
    \    return a\n    }\n    \n    switch b { // case stringValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpn922zgik/tmpn922zgik.swift:91: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c0f462c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c0f159b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c0f159988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c0f1587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn922zgik                        0x000055c5169be01a <unavailable> + 12314

    5    libc.so.6                          0x00002b5c0f64e460 __libc_start_main +
    245

    6    tmpn922zgik                        0x000055c5169bc499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqqc4cbnf.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqqc4cbnf.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqqc4cbnf.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqqc4cbnf.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqqc4cbnf.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqqc4cbnf.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqqc4cbnf.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqqc4cbnf.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case Int\n    case .intValue(_):\n        switch\
    \ b { // case Int\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ case Double\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .stringValue(_):\n        switch b { //\
    \ case String\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpne6g09cf/tmpne6g09cf.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47fe77fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47fe476b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47fe476988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47fe4757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpne6g09cf                        0x000055e59fb4aa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b47fe96b460 __libc_start_main +
    245

    6    tmpne6g09cf                        0x000055e59fb4a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type\n    case .intValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return a.intValue\
    \ > b.intValue\n        case .doubleValue:\n            return a.doubleValue >\
    \ b.doubleValue\n        case .stringValue:\n            return a.stringValue\
    \ > b.stringValue\n        }\n    case .doubleValue:\n        switch b { // Switch\
    \ on type\n        case .intValue:\n            return a.doubleValue > b.intValue\n\
    \        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.doubleValue > b.stringValue\n\
    \        }\n    case .stringValue:\n        switch b { // Switch on type\n   \
    \     case .intValue:\n            return a.stringValue > b.intValue\n       \
    \ case .doubleValue:\n            return a.stringValue > b.doubleValue\n     \
    \   case .stringValue:\n            return a.stringValue > b.stringValue\n   \
    \     }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpr_0snj3i.swift:18:31: error: binary operator '>' cannot be applied\
    \ to two '(Int) -> Value' operands\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpr_0snj3i.swift:18:31: error:\
    \ cannot convert return expression of type 'Bool' to return type 'Value?'\n  \
    \          return a.intValue > b.intValue\n                   ~~~~~~~~~~~^~~~~~~~~~~~\n\
    /tmp/tmpr_0snj3i.swift:20:34: error: binary operator '>' cannot be applied to\
    \ two '(Double) -> Value' operands\n            return a.doubleValue > b.doubleValue\n\
    \                   ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpr_0snj3i.swift:20:34:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpr_0snj3i.swift:22:34: error: binary operator '>' cannot be applied to\
    \ two '(String) -> Value' operands\n            return a.stringValue > b.stringValue\n\
    \                   ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpr_0snj3i.swift:22:34:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpr_0snj3i.swift:27:34: error: binary operator '>' cannot be applied to\
    \ operands of type '(Double) -> Value' and '(Int) -> Value'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpr_0snj3i.swift:27:34: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.doubleValue > b.intValue\n\
    \                   ~~~~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpr_0snj3i.swift:29:34:\
    \ error: binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpr_0snj3i.swift:29:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use.\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use.\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use.\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqa_6h5rm.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqa_6h5rm.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqa_6h5rm.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqa_6h5rm.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqa_6h5rm.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqa_6h5rm.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqa_6h5rm.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqa_6h5rm.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqa_6h5rm.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqa_6h5rm.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to execute\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to execute\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphz3oukhb.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmphz3oukhb.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmphz3oukhb.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmphz3oukhb.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmphz3oukhb.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmphz3oukhb.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmphz3oukhb.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmphz3oukhb.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmphz3oukhb.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmphz3oukhb.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is smaller\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // a and b are equal\n    return nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpsjdpjznf/tmpsjdpjznf.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe47ce0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe479d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe479d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe479d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsjdpjznf                        0x0000558ef8f7501a <unavailable> + 12314

    5    libc.so.6                          0x00002afe47ecc460 __libc_start_main +
    245

    6    tmpsjdpjznf                        0x0000558ef8f73499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aInt):\n        switch\
    \ b as? Value {\n        case let .intValue(bInt):\n            return aInt >\
    \ bInt ? .intValue(aInt) : .intValue(bInt)\n        case let .doubleValue(bDouble):\n\
    \            return .doubleValue(aInt) > bDouble ? .doubleValue(aInt) : .doubleValue(bDouble)\n\
    \        case let .stringValue(bString):\n            return .stringValue(aInt)\
    \ > bString ? .stringValue(aInt) : .stringValue(bString)\n        }\n    case\
    \ let .doubleValue(aDouble):\n        switch b as? Value {\n        case let .intValue(bInt):\n\
    \            return .doubleValue(aDouble) > bInt ? .doubleValue(aDouble) : .doubleValue(bInt)\n\
    \        case let .doubleValue(bDouble):\n            return .doubleValue(aDouble)\
    \ > bDouble ? .doubleValue(aDouble) : .doubleValue(bDouble)\n        case let\
    \ .stringValue(bString):\n            return .doubleValue(aDouble) > bString ?\
    \ .doubleValue(aDouble) : .doubleValue(bString)\n        }\n    case let .stringValue(aString):\n\
    \        switch b as? Value {\n        case let .intValue(bInt):\n           \
    \ return .stringValue(aString) > bInt ? .stringValue(aString) : .stringValue(bInt)\n\
    \        case let .doubleValue(bDouble):\n            return .stringValue(aString)\
    \ > bDouble ? .stringValue(aString) : .stringValue(bDouble)\n        case let\
    \ .stringValue(bString):\n            return .stringValue(aString) > bString ?\
    \ .stringValue(aString) : .stringValue(bString)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpk2ccnun5.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpk2ccnun5.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpk2ccnun5.swift:20:21: error: type\
    \ 'Double' has no member 'doubleValue'\n            return .doubleValue(aInt)\
    \ > bDouble ? .doubleValue(aInt) : .doubleValue(bDouble)\n                   ~^~~~~~~~~~~\n\
    /tmp/tmpk2ccnun5.swift:20:64: error: cannot convert value of type 'Int' to expected\
    \ argument type 'Double'\n            return .doubleValue(aInt) > bDouble ? .doubleValue(aInt)\
    \ : .doubleValue(bDouble)\n                                                  \
    \             ^\n                                                            \
    \   Double( )\n/tmp/tmpk2ccnun5.swift:22:21: error: type 'String' has no member\
    \ 'stringValue'\n            return .stringValue(aInt) > bString ? .stringValue(aInt)\
    \ : .stringValue(bString)\n                   ~^~~~~~~~~~~\n/tmp/tmpk2ccnun5.swift:22:64:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String'\n\
    \            return .stringValue(aInt) > bString ? .stringValue(aInt) : .stringValue(bString)\n\
    \                                                               ^\n/tmp/tmpk2ccnun5.swift:16:9:\
    \ error: switch must be exhaustive\n        switch b as? Value {\n        ^\n\
    /tmp/tmpk2ccnun5.swift:16:9: note: add missing case: '.none'\n        switch b\
    \ as? Value {\n        ^\n/tmp/tmpk2ccnun5.swift:25:18: warning: conditional cast\
    \ from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n    \
    \             ^\n/tmp/tmpk2ccnun5.swift:27:21: error: type 'Int' has no member\
    \ 'doubleValue'\n            return .doubleValue(aDouble) > bInt ? .doubleValue(aDouble)\
    \ : .doubleValue(bInt)\n                   ~^~~~~~~~~~~\n/tmp/tmpk2ccnun5.swift:27:88:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            return .doubleValue(aDouble) > bInt ? .doubleValue(aDouble) : .doubleValue(bInt)\n\
    \           "
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: use switch statement\n    case .intValue(_):\n\
    \        switch b { // TODO: use switch statement\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: use switch statement\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: use switch statement\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp2n5pf7ws/tmp2n5pf7ws.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be7a7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be7772b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be7772988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be77717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2n5pf7ws                        0x000055abf6145a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5be7c67460 __libc_start_main +
    245

    6    tmp2n5pf7ws                        0x000055abf6145499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { case .intValue(aInt), .doubleValue(aDouble), .stringValue(aString):\n\
    \        switch b { case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString):\n\
    \            return aInt > bInt ? .intValue(aInt) : aDouble > bDouble ? .doubleValue(aDouble)\
    \ : aString > bString ? .stringValue(aString) : nil\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzq9ih7vg.swift:14:31: error: cannot find 'aInt' in scope\n    switch\
    \ a { case .intValue(aInt), .doubleValue(aDouble), .stringValue(aString):\n  \
    \                            ^~~~\n/tmp/tmpzq9ih7vg.swift:14:51: error: cannot\
    \ find 'aDouble' in scope\n    switch a { case .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString):\n                                                  ^~~~~~~\n\
    /tmp/tmpzq9ih7vg.swift:14:74: error: cannot find 'aString' in scope\n    switch\
    \ a { case .intValue(aInt), .doubleValue(aDouble), .stringValue(aString):\n  \
    \                                                                       ^~~~~~~\n\
    /tmp/tmpzq9ih7vg.swift:15:35: error: cannot find 'bInt' in scope\n        switch\
    \ b { case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString):\n  \
    \                                ^~~~\n/tmp/tmpzq9ih7vg.swift:15:55: error: cannot\
    \ find 'bDouble' in scope\n        switch b { case .intValue(bInt), .doubleValue(bDouble),\
    \ .stringValue(bString):\n                                                   \
    \   ^~~~~~~\n/tmp/tmpzq9ih7vg.swift:15:78: error: cannot find 'bString' in scope\n\
    \        switch b { case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString):\n\
    \                                                                            \
    \ ^~~~~~~\n/tmp/tmpzq9ih7vg.swift:16:20: error: cannot find 'aInt' in scope\n\
    \            return aInt > bInt ? .intValue(aInt) : aDouble > bDouble ? .doubleValue(aDouble)\
    \ : aString > bString ? .stringValue(aString) : nil\n                   ^~~~\n\
    /tmp/tmpzq9ih7vg.swift:16:27: error: cannot find 'bInt' in scope\n           \
    \ return aInt > bInt ? .intValue(aInt) : aDouble > bDouble ? .doubleValue(aDouble)\
    \ : aString > bString ? .stringValue(aString) : nil\n                        \
    \  ^~~~\n/tmp/tmpzq9ih7vg.swift:16:44: error: cannot find 'aInt' in scope\n  \
    \          return aInt > bInt ? .intValue(aInt) : aDouble > bDouble ? .doubleValue(aDouble)\
    \ : aString > bString ? .stringValue(aString) : nil\n                        \
    \                   ^~~~\n/tmp/tmpzq9ih7vg.swift:16:52: error: cannot find "
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: switch on type\n    case .intValue(_):\n \
    \       switch b { // TODO: switch on type\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: switch on type\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: switch on type\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp_4kiu0oa/tmp_4kiu0oa.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08933c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08930bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08930bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08930be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_4kiu0oa                        0x000055fce7036a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b08935b4460 __libc_start_main +
    245

    6    tmp_4kiu0oa                        0x000055fce7036499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: use switch with case for efficiency\n    case\
    \ .intValue(_):\n        switch b { // TODO: use switch with case for efficiency\n\
    \        case .intValue(_):\n            return .intValue(a.intValue > b.intValue\
    \ ? a.intValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: use switch with case for efficiency\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue ?\
    \ a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ TODO: use switch with case for efficiency\n        case .intValue(_):\n    \
    \        return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprgmezwcx.swift:18:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmprgmezwcx.swift:18:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmprgmezwcx.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprgmezwcx.swift:18:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprgmezwcx.swift:18:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmprgmezwcx.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmprgmezwcx.swift:18:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmprgmezwcx.swift:18:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value, b as? Value {\n    case let .intValue(aInt),\
    \ let .intValue(bInt):\n        if aInt > bInt {\n            return a\n     \
    \   }\n        return b\n    case let .doubleValue(aDouble), let .doubleValue(bDouble):\n\
    \        if aDouble > bDouble {\n            return a\n        }\n        return\
    \ b\n    case let .stringValue(aString), let .stringValue(bString):\n        if\
    \ aString > bString {\n            return a\n        }\n        return b\n   \
    \ default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp52rn4gif.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as? Value, b as? Value {\n                      ^\n\
    /tmp/tmp52rn4gif.swift:14:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as? Value, b as? Value {\n                  \
    \    ^\n                      ;\n/tmp/tmp52rn4gif.swift:14:23: error: expected\
    \ expression\n    switch a as? Value, b as? Value {\n                      ^\n\
    /tmp/tmp52rn4gif.swift:14:14: warning: conditional cast from 'Value' to 'Value'\
    \ always succeeds\n    switch a as? Value, b as? Value {\n             ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to execute\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to execute\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphz3oukhb.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmphz3oukhb.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmphz3oukhb.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmphz3oukhb.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmphz3oukhb.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmphz3oukhb.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmphz3oukhb.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmphz3oukhb.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmphz3oukhb.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmphz3oukhb.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpblvfhvst.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpblvfhvst.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpblvfhvst.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpblvfhvst.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpblvfhvst.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpblvfhvst.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpblvfhvst.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpblvfhvst.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpblvfhvst.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpblvfhvst.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // case intValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpplb3vsbz/tmpplb3vsbz.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acda6652c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acda6349b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acda6349988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acda63487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpplb3vsbz                        0x000055e7f616d01a <unavailable> + 12314

    5    libc.so.6                          0x00002acda683e460 __libc_start_main +
    245

    6    tmpplb3vsbz                        0x000055e7f616b499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.stringValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp476gh4dh.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmp476gh4dh.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp476gh4dh.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value,\n           b as? Value {\n    case let .intValue(aInt),\n\
    \         let .intValue(bInt),\n         let .doubleValue(aDouble),\n        \
    \ let .doubleValue(bDouble),\n         let .stringValue(aString),\n         let\
    \ .stringValue(bString):\n        if aInt == bInt {\n            return aDouble\n\
    \        } else if aDouble == bDouble {\n            return aString\n        }\
    \ else {\n            return nil\n        }\n    case let .doubleValue(aDouble),\n\
    \         let .doubleValue(bDouble):\n        if aDouble == bDouble {\n      \
    \      return aDouble\n        } else {\n            return nil\n        }\n \
    \   case let .stringValue(aString),\n         let .stringValue(bString):\n   \
    \     if aString == bString {\n            return aString\n        } else {\n\
    \            return nil\n        }\n    default:\n        return nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpulsdhxyo.swift:14:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as? Value,\n                      ^\n/tmp/tmpulsdhxyo.swift:14:23:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ a as? Value,\n                      ^\n                      ;\n/tmp/tmpulsdhxyo.swift:14:23:\
    \ error: expected expression\n    switch a as? Value,\n                      ^\n\
    /tmp/tmpulsdhxyo.swift:14:14: warning: conditional cast from 'Value' to 'Value'\
    \ always succeeds\n    switch a as? Value,\n             ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of the first value\n    case\
    \ .intValue(_):\n        switch b { // Switch on the type of the second value\n\
    \        case .intValue(_):\n            return .intValue(a.intValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of the second value\n        case .intValue(_):\n       \
    \     return .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of the second value\n        case .intValue(_):\n       \
    \     return .stringValue(a.stringValue > b.stringValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpex_6aykc.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpex_6aykc.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpex_6aykc.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpex_6aykc.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpex_6aykc.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpex_6aykc.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpex_6aykc.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpex_6aykc.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpex_6aykc.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpex_6aykc.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ switch b { // case intValue:\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // case doubleValue:\n        case .intValue(_):\n            return b\n \
    \       case .doubleValue(_):\n            return a\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // case stringValue:\n        case .intValue(_):\n            return a\n \
    \       case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpopyqvy65/tmpopyqvy65.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b388127ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3880f71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3880f71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3880f707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopyqvy65                        0x000055a4b7040a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b3881466460 __libc_start_main +
    245

    6    tmpopyqvy65                        0x000055a4b7040499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: switch on type\n    case .intValue(_):\n \
    \       switch b { // TODO: switch on type\n        case .intValue(_):\n     \
    \       return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // TODO: switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ TODO: switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa8e357ny.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpa8e357ny.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpa8e357ny.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpa8e357ny.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpa8e357ny.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpa8e357ny.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpa8e357ny.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpa8e357ny.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpa8e357ny.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpa8e357ny.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpol8jmtia.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpol8jmtia.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpol8jmtia.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpol8jmtia.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpol8jmtia.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpol8jmtia.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpol8jmtia.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpol8jmtia.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpol8jmtia.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpol8jmtia.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two integers\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two doubles\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two strings\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpx63050xu.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpx63050xu.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpx63050xu.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpx63050xu.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpx63050xu.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpx63050xu.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpx63050xu.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpx63050xu.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpx63050xu.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpx63050xu.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n       \
    \ switch b { // Switch on type\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Switch on type\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa5kjfan3.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpa5kjfan3.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpa5kjfan3.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpa5kjfan3.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpa5kjfan3.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpa5kjfan3.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpa5kjfan3.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpa5kjfan3.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpa5kjfan3.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpa5kjfan3.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzfye53ej.swift:14:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmpzfye53ej.swift:16:18: warning: forced cast of 'Value' to same type\
    \ has no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n \
    \                \n/tmp/tmpzfye53ej.swift:18:41: error: cannot convert value of\
    \ type 'Bool' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpzfye53ej.swift:18:30:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue)\n                             ^\n\
    \                             Value\n/tmp/tmpzfye53ej.swift:18:41: error: type\
    \ '(Int) -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpzfye53ej.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpzfye53ej.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpzfye53ej.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpzfye53ej.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpzfye53ej.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two integers\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two doubles\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two strings\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpx63050xu.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpx63050xu.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpx63050xu.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpx63050xu.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpx63050xu.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpx63050xu.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpx63050xu.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpx63050xu.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpx63050xu.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpx63050xu.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { case .intValue(_):\n        switch b { case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return a\n        }\n    case .doubleValue(_):\n\
    \        switch b { case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return a\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp9pm5kiyr/tmp9pm5kiyr.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b7873ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b78431b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b78431988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b784307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9pm5kiyr                        0x0000559e50f39a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b3b78926460 __libc_start_main +
    245

    6    tmp9pm5kiyr                        0x0000559e50f39499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if a.stringValue < b.stringValue {\n        return a\n    }\n    \n    return\
    \ b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplz76rwbt.swift:33:22: error: binary operator '<' cannot be applied\
    \ to two '(String) -> Value' operands\n    if a.stringValue < b.stringValue {\n\
    \       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // case intValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    switch a { // case doubleValue:\n    case\
    \ .intValue(_):\n        return b\n    case .doubleValue(_):\n        return a\n\
    \    case .stringValue(_):\n        return a\n    }\n    \n    switch b { // case\
    \ doubleValue:\n    case .intValue(_):\n        return a\n    case .doubleValue(_):\n\
    \        return b\n    case .stringValue(_):\n        return b\n    }\n    \n\
    \    switch a { // case stringValue:\n    case .intValue(_):\n        return b\n\
    \    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n    \
    \    return a\n    }\n    \n    switch b { // case stringValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpn922zgik/tmpn922zgik.swift:91: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c0f462c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c0f159b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c0f159988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c0f1587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn922zgik                        0x000055c5169be01a <unavailable> + 12314

    5    libc.so.6                          0x00002b5c0f64e460 __libc_start_main +
    245

    6    tmpn922zgik                        0x000055c5169bc499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Switch to enum\n    case .intValue(_):\n \
    \       switch b { // TODO: Switch to enum\n        case .intValue(_):\n     \
    \       return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ TODO: Switch to enum\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: Switch to enum\n        case .intValue(_):\n    \
    \        return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7_bwj9nf.swift:18:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp7_bwj9nf.swift:18:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp7_bwj9nf.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp7_bwj9nf.swift:18:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp7_bwj9nf.swift:18:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp7_bwj9nf.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp7_bwj9nf.swift:18:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp7_bwj9nf.swift:18:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Int {\n    case let b as Int:\n        return b\n\
    \    case let b as Double:\n        return b\n    case let b as String:\n    \
    \    return b\n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe673js4g.swift:14:14: warning: cast from 'Value' to unrelated type\
    \ 'Int' always fails\n    switch a as? Int {\n           ~ ^   ~~~\n/tmp/tmpe673js4g.swift:15:16:\
    \ warning: 'as' test is always true\n    case let b as Int:\n               ^\n\
    /tmp/tmpe673js4g.swift:17:16: warning: cast from 'Int' to unrelated type 'Double'\
    \ always fails\n    case let b as Double:\n               ^~ ~~~~~~\n/tmp/tmpe673js4g.swift:19:16:\
    \ warning: cast from 'Int' to unrelated type 'String' always fails\n    case let\
    \ b as String:\n               ^~ ~~~~~~\n/tmp/tmpe673js4g.swift:16:16: error:\
    \ cannot convert return expression of type 'Int' to return type 'Value?'\n   \
    \     return b\n               ^\n/tmp/tmpe673js4g.swift:18:16: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \ return b\n               ^\n/tmp/tmpe673js4g.swift:20:16: error: cannot convert\
    \ return expression of type 'String' to return type 'Value?'\n        return b\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue:\n        switch\
    \ b { // case intValue:\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b { // case doubleValue:\n        case .intValue:\n            return .doubleValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b { // case stringValue:\n        case .intValue:\n            return .stringValue\n\
    \        case .doubleValue:\n            return .stringValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0tg_ious.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmp0tg_ious.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmp0tg_ious.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmp0tg_ious.swift:27:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmp0tg_ious.swift:29:21: error: member 'doubleValue' expects\
    \ argument of type 'Double'\n            return .doubleValue\n               \
    \     ^\n/tmp/tmp0tg_ious.swift:31:21: error: member 'stringValue' expects argument\
    \ of type 'String'\n            return .stringValue\n                    ^\n/tmp/tmp0tg_ious.swift:36:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmp0tg_ious.swift:38:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmp0tg_ious.swift:40:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aInt):\n        switch\
    \ b as? Value {\n        case let .intValue(bInt):\n            return aInt >\
    \ bInt ? .intValue(aInt) : .intValue(bInt)\n        case let .doubleValue(bDouble):\n\
    \            return .doubleValue(bDouble)\n        case let .stringValue(bString):\n\
    \            return .stringValue(bString)\n        }\n    case let .doubleValue(aDouble):\n\
    \        switch b as? Value {\n        case let .intValue(bInt):\n           \
    \ return .doubleValue(aDouble)\n        case let .doubleValue(bDouble):\n    \
    \        return bDouble > aDouble ? .doubleValue(aDouble) : .doubleValue(bDouble)\n\
    \        case let .stringValue(bString):\n            return .stringValue(bString)\n\
    \        }\n    case let .stringValue(aString):\n        switch b as? Value {\n\
    \        case let .intValue(bInt):\n            return .stringValue(aString)\n\
    \        case let .doubleValue(bDouble):\n            return .stringValue(aString)\n\
    \        case let .stringValue(bString):\n            return .stringValue(aString)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpuoofnotl.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpuoofnotl.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpuoofnotl.swift:16:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:16:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpuoofnotl.swift:25:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:25:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpuoofnotl.swift:34:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:34:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:14:5:\
    \ error: switch must be exhaustive\n    switch a as? Value {\n    ^\n/tmp/tmpuoofnotl.swift:14:5:\
    \ note: add missing case: '.none'\n    switch a as? Value {\n    ^\n/tmp/tmpuoofnotl.swift:26:28:\
    \ warning: immutable value 'bInt' was never used; consider replacing with '_'\
    \ or removing it\n        case let .intValue(bInt):\n                        \
    \   ^~~~\n                           _\n/tmp/tmpuoofnotl.swift:35:28: warning:\
    \ immutable value 'bInt' was never used; consider replacing with '_' or removing\
    \ it\n        case let .intValue(bInt):\n                           ^~~~\n   \
    \                        _\n/tmp/tmpuoofnotl.swift:37:31: warning: immutable value\
    \ 'bDouble' was never used; consider replacing with '_' or removing it\n     \
    \   case let .doubleValue(bDouble):\n                              ^~~~~~~\n \
    \                             _\n/tmp/tmpuoofnotl.swift:39:"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpbc4pkrof/tmpbc4pkrof.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bcee32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bceb29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bceb29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bceb287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbc4pkrof                        0x0000561d5547201a <unavailable> + 12314

    5    libc.so.6                          0x00002b0bcf01e460 __libc_start_main +
    245

    6    tmpbc4pkrof                        0x0000561d55470499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is larger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // both are strings\n    if a.stringValue\
    \ < b.stringValue {\n        return a\n    } else {\n        return b\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkw9vup5q.swift:33:22: error: binary operator '<' cannot be applied\
    \ to two '(String) -> Value' operands\n    if a.stringValue < b.stringValue {\n\
    \       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzfye53ej.swift:14:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmpzfye53ej.swift:16:18: warning: forced cast of 'Value' to same type\
    \ has no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n \
    \                \n/tmp/tmpzfye53ej.swift:18:41: error: cannot convert value of\
    \ type 'Bool' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpzfye53ej.swift:18:30:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue)\n                             ^\n\
    \                             Value\n/tmp/tmpzfye53ej.swift:18:41: error: type\
    \ '(Int) -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpzfye53ej.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpzfye53ej.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpzfye53ej.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpzfye53ej.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpzfye53ej.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n        switch\
    \ b { // b is smaller\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpimf959ox/tmpimf959ox.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c68c1bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c68912b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c68912988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c689117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpimf959ox                        0x00005629c25dba56 <unavailable> + 6742

    5    libc.so.6                          0x00002b6c68e07460 __libc_start_main +
    245

    6    tmpimf959ox                        0x00005629c25db499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case .intValue:\n        switch b as?\
    \ Value {\n        case .intValue:\n            return .intValue\n        case\
    \ .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b as? Value {\n        case .intValue:\n            return .doubleValue\n  \
    \      case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b as? Value {\n        case .intValue:\n            return .stringValue\n  \
    \      case .doubleValue:\n            return .stringValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv6gi9fxu.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpv6gi9fxu.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpv6gi9fxu.swift:18:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmpv6gi9fxu.swift:20:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpv6gi9fxu.swift:22:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n/tmp/tmpv6gi9fxu.swift:16:9: error: switch must be exhaustive\n     \
    \   switch b as? Value {\n        ^\n/tmp/tmpv6gi9fxu.swift:16:9: note: add missing\
    \ case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpv6gi9fxu.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpv6gi9fxu.swift:27:21: error: member\
    \ 'doubleValue' expects argument of type 'Double'\n            return .doubleValue\n\
    \                    ^\n/tmp/tmpv6gi9fxu.swift:29:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpv6gi9fxu.swift:31:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n/tmp/tmpv6gi9fxu.swift:25:9: error: switch must be exhaustive\n     \
    \   switch b as? Value {\n        ^\n/tmp/tmpv6gi9fxu.swift:25:9: note: add missing\
    \ case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpv6gi9fxu.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpv6gi9fxu.swift:36:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpv6gi9fxu.swift:38:21: error: member 'stringValue'\
    \ expects"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        switch\
    \ b { // b is larger\n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpg1mddtvd/tmpg1mddtvd.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac62c9e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac62c6dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac62c6dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac62c6db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg1mddtvd                        0x000055b45d68da56 <unavailable> + 6742

    5    libc.so.6                          0x00002ac62cbd1460 __libc_start_main +
    245

    6    tmpg1mddtvd                        0x000055b45d68d499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two values\n        case .intValue(_):\n         \
    \   return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two values\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two values\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppqpgr472.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmppqpgr472.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmppqpgr472.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmppqpgr472.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmppqpgr472.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmppqpgr472.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmppqpgr472.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmppqpgr472.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmppqpgr472.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmppqpgr472.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        return b\n    case\
    \ .doubleValue(_):\n        return b\n    case .stringValue(_):\n        return\
    \ b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpnl3f77be/tmpnl3f77be.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76bf845c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76bf53cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76bf53c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76bf53b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnl3f77be                        0x000055b6746f001a <unavailable> + 12314

    5    libc.so.6                          0x00002b76bfa31460 __libc_start_main +
    245

    6    tmpnl3f77be                        0x000055b6746ee499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two ints\n        case .intValue(_):\n           \
    \ return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n \
    \           return .intValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .intValue(a.stringValue > b.stringValue)\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Compare two doubles\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .intValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two strings\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .intValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5videc54.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp5videc54.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp5videc54.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp5videc54.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp5videc54.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp5videc54.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp5videc54.swift:20:44: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Int'\n            return\
    \ .intValue(a.doubleValue > b.doubleValue)\n                                 \
    \          ^\n/tmp/tmp5videc54.swift:20:30: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n            return .intValue(a.doubleValue >\
    \ b.doubleValue)\n                             ^\n                           \
    \  Value\n/tmp/tmp5videc54.swift:20:44: error: type '(Double) -> Value' cannot\
    \ conform to 'Comparable'\n            return .intValue(a.doubleValue > b.doubleValue)\n\
    \                                           ^\n/tmp/tmp5videc54.swift:20:44: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \            return "
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is bigger\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return a\n        }\n        if aString > bString {\n\
    \            return b\n        }\n        return a\n    }\n    \n    // If both\
    \ are integers, compare them numerically\n    if let aInt = a.intValue, bInt =\
    \ b.intValue {\n        if aInt < bInt {\n            return a\n        }\n  \
    \      if aInt > bInt {\n            return b\n        }\n        return a\n \
    \   }\n    \n    // If both are doubles, compare them numerically\n    if let\
    \ aDouble = a.doubleValue, bDouble = b.doubleValue {\n        if aDouble < bDouble\
    \ {\n            return a\n        }\n        if aDouble > bDouble {\n       \
    \     return b\n        }\n        return a\n    }\n    \n    // If both are strings,\
    \ compare them lexicographically\n    if let aString = a.stringValue, bString\
    \ = b.stringValue {\n        if aString < bString {\n            return a\n  \
    \      }\n        if aString > bString {\n            return b\n        }\n  \
    \      return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return a\n        }\n        if aString > bString {\n\
    \            return b\n        }\n        return a\n    }\n    \n    // If both\
    \ are strings, compare them lexicographically\n    if let aString = a.stringValue,\
    \ bString = b.stringValue {\n        if aString < bString {\n            return\
    \ a\n        }\n        if aString > bString {\n            return b\n       \
    \ }\n        return a\n    }\n    \n    // If both are strings, compare them lexicographically\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return a\n        }\n        if aString > bString {\n\
    \            return b\n        }\n        return a\n    }\n    \n    // If both\
    \ are strings, \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwd8ab5hg.swift:33:37: error: expected 'let' in conditional\n  \
    \  if let aString = a.stringValue, bString = b.stringValue {\n               \
    \                     ^\n                                    let \n/tmp/tmpwd8ab5hg.swift:44:31:\
    \ error: expected 'let' in conditional\n    if let aInt = a.intValue, bInt = b.intValue\
    \ {\n                              ^\n                              let \n/tmp/tmpwd8ab5hg.swift:55:37:\
    \ error: expected 'let' in conditional\n    if let aDouble = a.doubleValue, bDouble\
    \ = b.doubleValue {\n                                    ^\n                 \
    \                   let \n/tmp/tmpwd8ab5hg.swift:66:37: error: expected 'let'\
    \ in conditional\n    if let aString = a.stringValue, bString = b.stringValue\
    \ {\n                                    ^\n                                 \
    \   let \n/tmp/tmpwd8ab5hg.swift:77:37: error: expected 'let' in conditional\n\
    \    if let aString = a.stringValue, bString = b.stringValue {\n             \
    \                       ^\n                                    let \n/tmp/tmpwd8ab5hg.swift:88:37:\
    \ error: expected 'let' in conditional\n    if let aString = a.stringValue, bString\
    \ = b.stringValue {\n                                    ^\n                 \
    \                   let \n/tmp/tmpwd8ab5hg.swift:99:37: error: expected 'let'\
    \ in conditional\n    if let aString = a.stringValue, bString = b.stringValue\
    \ {\n                                    ^\n                                 \
    \   let \n/tmp/tmpwd8ab5hg.swift:33:22: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n    if let aString = a.stringValue, bString =\
    \ b.stringValue {\n                     ^\n                     Value\n/tmp/tmpwd8ab5hg.swift:33:47:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    if\
    \ let aString = a.stringValue, bString = b.stringValue {\n                   \
    \                           ^\n                                              Value\n\
    /tmp/tmpwd8ab5hg.swift:44:19: error: enum case 'intValue' cannot be used as an\
    \ instance member\n    if let aInt = a.intValue, bInt = b.intValue {\n "
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: use switch statement\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp9lkxe9hh/tmp9lkxe9hh.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6737bcfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67378c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67378c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67378c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9lkxe9hh                        0x000056326fca301a <unavailable> + 12314

    5    libc.so.6                          0x00002b6737dbb460 __libc_start_main +
    245

    6    tmp9lkxe9hh                        0x000056326fca1499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a's type\n    case .intValue(_):\n   \
    \     switch b { // Switch on b's type\n        case .intValue(_):\n         \
    \   return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4c3y6rbp.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp4c3y6rbp.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp4c3y6rbp.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp4c3y6rbp.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp4c3y6rbp.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp4c3y6rbp.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp4c3y6rbp.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp4c3y6rbp.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp4c3y6rbp.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp4c3y6rbp.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of the first value\n    case\
    \ .intValue(_):\n        switch b { // Switch on the type of the second value\n\
    \        case .intValue(_):\n            return .intValue(a.intValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on the type of the second value\n        case .intValue(_):\n       \
    \     return .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on the type\
    \ of the second value\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppr_4wh8l.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmppr_4wh8l.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmppr_4wh8l.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmppr_4wh8l.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmppr_4wh8l.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmppr_4wh8l.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmppr_4wh8l.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmppr_4wh8l.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmppr_4wh8l.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmppr_4wh8l.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aInt):\n        switch\
    \ b as? Value {\n        case let .intValue(bInt):\n            return aInt >\
    \ bInt ? .intValue(aInt) : .intValue(bInt)\n        case let .doubleValue(bDouble):\n\
    \            return .doubleValue(bDouble)\n        case let .stringValue(bString):\n\
    \            return .stringValue(bString)\n        }\n    case let .doubleValue(aDouble):\n\
    \        switch b as? Value {\n        case let .intValue(bInt):\n           \
    \ return .doubleValue(aDouble)\n        case let .doubleValue(bDouble):\n    \
    \        return bDouble > aDouble ? .doubleValue(aDouble) : .doubleValue(bDouble)\n\
    \        case let .stringValue(bString):\n            return .stringValue(bString)\n\
    \        }\n    case let .stringValue(aString):\n        switch b as? Value {\n\
    \        case let .intValue(bInt):\n            return .stringValue(aString)\n\
    \        case let .doubleValue(bDouble):\n            return .stringValue(aString)\n\
    \        case let .stringValue(bString):\n            return .stringValue(aString)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpuoofnotl.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpuoofnotl.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpuoofnotl.swift:16:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:16:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpuoofnotl.swift:25:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:25:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:34:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpuoofnotl.swift:34:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:34:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpuoofnotl.swift:14:5:\
    \ error: switch must be exhaustive\n    switch a as? Value {\n    ^\n/tmp/tmpuoofnotl.swift:14:5:\
    \ note: add missing case: '.none'\n    switch a as? Value {\n    ^\n/tmp/tmpuoofnotl.swift:26:28:\
    \ warning: immutable value 'bInt' was never used; consider replacing with '_'\
    \ or removing it\n        case let .intValue(bInt):\n                        \
    \   ^~~~\n                           _\n/tmp/tmpuoofnotl.swift:35:28: warning:\
    \ immutable value 'bInt' was never used; consider replacing with '_' or removing\
    \ it\n        case let .intValue(bInt):\n                           ^~~~\n   \
    \                        _\n/tmp/tmpuoofnotl.swift:37:31: warning: immutable value\
    \ 'bDouble' was never used; consider replacing with '_' or removing it\n     \
    \   case let .doubleValue(bDouble):\n                              ^~~~~~~\n \
    \                             _\n/tmp/tmpuoofnotl.swift:39:"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n        switch\
    \ b { // b is bigger\n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpg_fsg8pm/tmpg_fsg8pm.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8578c71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8578968b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8578968988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85789677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg_fsg8pm                        0x000055900ba29a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8578e5d460 __libc_start_main +
    245

    6    tmpg_fsg8pm                        0x000055900ba29499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return .intValue\n \
    \       case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppeq_psi7.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:18:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmppeq_psi7.swift:20:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmppeq_psi7.swift:22:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n/tmp/tmppeq_psi7.swift:25:22: error: cannot find type 'ValueType' in\
    \ scope\n        switch b as? ValueType {\n                     ^~~~~~~~~\n/tmp/tmppeq_psi7.swift:27:21:\
    \ error: member 'intValue' expects argument of type 'Int'\n            return\
    \ .intValue\n                    ^\n/tmp/tmppeq_psi7.swift:29:21: error: member\
    \ 'doubleValue' expects argument of type 'Double'\n            return .doubleValue\n\
    \                    ^\n/tmp/tmppeq_psi7.swift:31:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n/tmp/tmppeq_psi7.swift:34:22: error: cannot find type 'ValueType'\
    \ in scope\n        switch b as? ValueType {\n                     ^~~~~~~~~\n\
    /tmp/tmppeq_psi7.swift:36:21: error: member 'intValue' expects argument of type\
    \ 'Int'\n            return .intValue\n                    ^\n/tmp/tmppeq_psi7.swift:38:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmppeq_psi7.swift:40:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to use\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsi73yz3f.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpsi73yz3f.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpsi73yz3f.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpsi73yz3f.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpsi73yz3f.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpsi73yz3f.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpsi73yz3f.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpsi73yz3f.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpsi73yz3f.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpsi73yz3f.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case .intValue:\n        switch b as?\
    \ Value {\n        case .intValue:\n            return .intValue\n        case\
    \ .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            if let aString = a as? String, let bString = b as? String {\n   \
    \             if aString == bString {\n                    return .intValue\n\
    \                }\n            }\n            return .stringValue\n        }\n\
    \    case .doubleValue:\n        switch b as? Value {\n        case .intValue:\n\
    \            return .doubleValue\n        case .doubleValue:\n            return\
    \ .doubleValue\n        case .stringValue:\n            if let aString = a as?\
    \ String, let bString = b as? String {\n                if aString == bString\
    \ {\n                    return .doubleValue\n                }\n            }\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b as? Value {\n        case .intValue:\n            return .stringValue\n  \
    \      case .doubleValue:\n            return .stringValue\n        case .stringValue:\n\
    \            if let aString = a as? String, let bString = b as? String {\n   \
    \             if aString == bString {\n                    return .stringValue\n\
    \                }\n            }\n            return .stringValue\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpr4ktqcaq.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpr4ktqcaq.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpr4ktqcaq.swift:18:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmpr4ktqcaq.swift:20:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpr4ktqcaq.swift:22:32: warning: cast from 'Value' to unrelated\
    \ type 'String' always fails\n            if let aString = a as? String, let bString\
    \ = b as? String {\n                             ~ ^   ~~~~~~\n/tmp/tmpr4ktqcaq.swift:22:60:\
    \ warning: cast from 'Value' to unrelated type 'String' always fails\n       \
    \     if let aString = a as? String, let bString = b as? String {\n          \
    \                                               ~ ^   ~~~~~~\n/tmp/tmpr4ktqcaq.swift:24:29:\
    \ error: member 'intValue' expects argument of type 'Int'\n                  \
    \  return .intValue\n                            ^\n/tmp/tmpr4ktqcaq.swift:27:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpr4ktqcaq.swift:16:9: error: switch\
    \ must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmpr4ktqcaq.swift:16:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpr4ktqcaq.swift:30:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpr4ktqcaq.swift:32:21: error: member\
    \ 'doubleValue' expects argument of type 'Double'\n            return .doubleValue\n\
    \                    ^\n/tmp/tmpr4ktqcaq.swift:34:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpr4ktqcaq.swift:36:32: warning: cast from 'Value' to unrelated\
    \ type 'String' always fails\n  "
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n   \
    \         return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue :\
    \ b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b as! Value {\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return .stringValue(a.stringValue > b.intValue ?\
    \ a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzb8or8v2.swift:14:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmpzb8or8v2.swift:16:18: warning: forced cast of 'Value' to same type\
    \ has no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n \
    \                \n/tmp/tmpzb8or8v2.swift:18:54: error: cannot convert value of\
    \ type '(Int) -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpzb8or8v2.swift:18:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpzb8or8v2.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpzb8or8v2.swift:18:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpzb8or8v2.swift:18:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpzb8or8v2.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpzb8or8v2.swift:18:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                  "
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n        return\
    \ b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // b is smaller\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    // both are equal\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpst8nfmt4/tmpst8nfmt4.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8ef95cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8ef653b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8ef653988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8ef6527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpst8nfmt4                        0x000056208b7fc01a <unavailable> + 12314

    5    libc.so.6                          0x00002ba8efb48460 __libc_start_main +
    245

    6    tmpst8nfmt4                        0x000056208b7fa499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmhmrwsys/tmpmhmrwsys.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cf2bffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cf28f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cf28f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cf28f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhmrwsys                        0x000056212edcaa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8cf2deb460 __libc_start_main +
    245

    6    tmpmhmrwsys                        0x000056212edca499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of a\n    case .intValue(_):\n\
    \        switch b { // Switch on the type of b\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on the type\
    \ of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkuds5gbn.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpkuds5gbn.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpkuds5gbn.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpkuds5gbn.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpkuds5gbn.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpkuds5gbn.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpkuds5gbn.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpkuds5gbn.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpkuds5gbn.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpkuds5gbn.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(intValue):\n        switch b { // Switch on type to determine\
    \ which case to return\n        case .intValue(intValue):\n            return\
    \ intValue\n        case .doubleValue(doubleValue):\n            return doubleValue\n\
    \        case .stringValue(stringValue):\n            return stringValue\n   \
    \     }\n    case .doubleValue(doubleValue):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(intValue):\n\
    \            return doubleValue\n        case .doubleValue(doubleValue):\n   \
    \         return doubleValue\n        case .stringValue(stringValue):\n      \
    \      return doubleValue\n        }\n    case .stringValue(stringValue):\n  \
    \      switch b { // Switch on type to determine which case to return\n      \
    \  case .intValue(intValue):\n            return stringValue\n        case .doubleValue(doubleValue):\n\
    \            return stringValue\n        case .stringValue(stringValue):\n   \
    \         return stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4aawklub.swift:15:20: error: cannot find 'intValue' in scope\n\
    \    case .intValue(intValue):\n                   ^~~~~~~~\n/tmp/tmp4aawklub.swift:24:23:\
    \ error: cannot find 'doubleValue' in scope\n    case .doubleValue(doubleValue):\n\
    \                      ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:33:23: error: cannot\
    \ find 'stringValue' in scope\n    case .stringValue(stringValue):\n         \
    \             ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:17:24: error: cannot find 'intValue'\
    \ in scope\n        case .intValue(intValue):\n                       ^~~~~~~~\n\
    /tmp/tmp4aawklub.swift:19:27: error: cannot find 'doubleValue' in scope\n    \
    \    case .doubleValue(doubleValue):\n                          ^~~~~~~~~~~\n\
    /tmp/tmp4aawklub.swift:21:27: error: cannot find 'stringValue' in scope\n    \
    \    case .stringValue(stringValue):\n                          ^~~~~~~~~~~\n\
    /tmp/tmp4aawklub.swift:18:20: error: cannot find 'intValue' in scope\n       \
    \     return intValue\n                   ^~~~~~~~\n/tmp/tmp4aawklub.swift:20:20:\
    \ error: cannot find 'doubleValue' in scope\n            return doubleValue\n\
    \                   ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:22:20: error: cannot find\
    \ 'stringValue' in scope\n            return stringValue\n                   ^~~~~~~~~~~\n\
    /tmp/tmp4aawklub.swift:26:24: error: cannot find 'intValue' in scope\n       \
    \ case .intValue(intValue):\n                       ^~~~~~~~\n/tmp/tmp4aawklub.swift:28:27:\
    \ error: cannot find 'doubleValue' in scope\n        case .doubleValue(doubleValue):\n\
    \                          ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:30:27: error: cannot\
    \ find 'stringValue' in scope\n        case .stringValue(stringValue):\n     \
    \                     ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:27:20: error: cannot\
    \ find 'doubleValue' in scope\n            return doubleValue\n              \
    \     ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:29:20: error: cannot find 'doubleValue'\
    \ in scope\n            return doubleValue\n                   ^~~~~~~~~~~\n/tmp/tmp4aawklub.swift:31:20:\
    \ error: cannot find 'doubleValue' in scope\n            return doubleValue\n\
    \   "
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of a\n    case .intValue(_):\n\
    \        switch b { // Switch on the type of b\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on the type\
    \ of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpno2k0v4r.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpno2k0v4r.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpno2k0v4r.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpno2k0v4r.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpno2k0v4r.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpno2k0v4r.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpno2k0v4r.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpno2k0v4r.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpno2k0v4r.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpno2k0v4r.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Use a switch statement to compare the different\
    \ types\n    case .intValue(_):\n        switch b { // TODO: Use a switch statement\
    \ to compare the different types\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // TODO: Use a switch statement\
    \ to compare the different types\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // TODO: Use a switch\
    \ statement to compare the different types\n        case .intValue(_):\n     \
    \       return .stringValue(a.stringValue > b.stringValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2j03bg38.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp2j03bg38.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp2j03bg38.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp2j03bg38.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp2j03bg38.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp2j03bg38.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp2j03bg38.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp2j03bg38.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp2j03bg38.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp2j03bg38.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return a\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return b\n        case .doubleValue(_):\n       \
    \     return a\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpqtmsby41/tmpqtmsby41.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afaba585c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afaba27cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afaba27c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afaba27b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqtmsby41                        0x0000562646de3a56 <unavailable> + 6742

    5    libc.so.6                          0x00002afaba771460 __libc_start_main +
    245

    6    tmpqtmsby41                        0x0000562646de3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: Switch to switch case for performance\n  \
    \  case .intValue(_):\n        return .intValue(b) // TODO: Switch to switch case\
    \ for performance\n    case .doubleValue(_):\n        return .doubleValue(b) //\
    \ TODO: Switch to switch case for performance\n    case .stringValue(_):\n   \
    \     return .stringValue(b) // TODO: Switch to switch case for performance\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsows0nzo.swift:16:26: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n        return .intValue(b) // TODO: Switch\
    \ to switch case for performance\n                         ^\n/tmp/tmpsows0nzo.swift:18:29:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \        return .doubleValue(b) // TODO: Switch to switch case for performance\n\
    \                            ^\n/tmp/tmpsows0nzo.swift:20:29: error: cannot convert\
    \ value of type 'Value' to expected argument type 'String'\n        return .stringValue(b)\
    \ // TODO: Switch to switch case for performance\n                           \
    \ ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpblvfhvst.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpblvfhvst.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpblvfhvst.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpblvfhvst.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpblvfhvst.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpblvfhvst.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpblvfhvst.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpblvfhvst.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpblvfhvst.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpblvfhvst.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpma4p4hx7/tmpma4p4hx7.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77a83e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77a80e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77a80e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77a80df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpma4p4hx7                        0x0000558b294d1a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b77a85d5460 __libc_start_main +
    245

    6    tmpma4p4hx7                        0x0000558b294d1499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let .intValue(aIntValue):\n   \
    \     switch b as? Value {\n        case let .intValue(bIntValue):\n         \
    \   return bIntValue > aIntValue\n        case let .doubleValue(bDoubleValue):\n\
    \            return bDoubleValue > aIntValue\n        case let .stringValue(bStringValue):\n\
    \            return bStringValue > aIntValue\n        }\n    case let .doubleValue(aDoubleValue):\n\
    \        switch b as? Value {\n        case let .intValue(bIntValue):\n      \
    \      return bIntValue > aDoubleValue\n        case let .doubleValue(bDoubleValue):\n\
    \            return bDoubleValue > aDoubleValue\n        case let .stringValue(bStringValue):\n\
    \            return bStringValue > aDoubleValue\n        }\n    case let .stringValue(aStringValue):\n\
    \        switch b as? Value {\n        case let .intValue(bIntValue):\n      \
    \      return bIntValue > aStringValue\n        case let .doubleValue(bDoubleValue):\n\
    \            return bDoubleValue > aStringValue\n        case let .stringValue(bStringValue):\n\
    \            return bStringValue > aStringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp56tllr8k.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmp56tllr8k.swift:16:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmp56tllr8k.swift:18:30: error: cannot\
    \ convert return expression of type 'Bool' to return type 'Value?'\n         \
    \   return bIntValue > aIntValue\n                   ~~~~~~~~~~^~~~~~~~~~~\n/tmp/tmp56tllr8k.swift:20:33:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'Int'\n            return bDoubleValue > aIntValue\n                   ~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~\n/tmp/tmp56tllr8k.swift:20:33: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n            return bDoubleValue\
    \ > aIntValue\n                                ^\n/tmp/tmp56tllr8k.swift:20:33:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \            return bDoubleValue > aIntValue\n                   ~~~~~~~~~~~~~^~~~~~~~~~~\n\
    /tmp/tmp56tllr8k.swift:22:33: error: binary operator '>' cannot be applied to\
    \ operands of type 'String' and 'Int'\n            return bStringValue > aIntValue\n\
    \                   ~~~~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmp56tllr8k.swift:22:33: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n            return bStringValue > aIntValue\n                        \
    \        ^\n/tmp/tmp56tllr8k.swift:22:33: error: cannot convert return expression\
    \ of type 'Bool' to return type 'Value?'\n            return bStringValue > aIntValue\n\
    \                   ~~~~~~~~~~~~~^~~~~~~~~~~\n/tmp/tmp56tllr8k.swift:16:9: error:\
    \ switch must be exhaustive\n        switch b as? Value {\n        ^\n/tmp/tmp56tllr8k.swift:16:9:\
    \ note: add missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmp56tllr8k.swift:25:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmp56tllr8k.swift:27:30: error: binar"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { \n    case .intValue(_):\n        switch b { \n   \
    \     case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { \n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpl2zbpcwp/tmpl2zbpcwp.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb0bc14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb0b90bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb0b90b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb0b90a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2zbpcwp                        0x000055c450eaba56 <unavailable> + 6742

    5    libc.so.6                          0x00002acb0be00460 __libc_start_main +
    245

    6    tmpl2zbpcwp                        0x000055c450eab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case Int\n    case .intValue(_):\n        switch\
    \ b { // case Int\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ case Double\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ case String\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpd0r4m3co.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpd0r4m3co.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpd0r4m3co.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpd0r4m3co.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpd0r4m3co.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpd0r4m3co.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpd0r4m3co.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpd0r4m3co.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpd0r4m3co.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpd0r4m3co.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv1jck5nq.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpv1jck5nq.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpv1jck5nq.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpv1jck5nq.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpv1jck5nq.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpv1jck5nq.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpv1jck5nq.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpv1jck5nq.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpv1jck5nq.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpv1jck5nq.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue:\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue:\n            return .intValue\n    \
    \    case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b { // Switch on type to determine which case to return\n        case .intValue:\n\
    \            return .intValue\n        case .doubleValue:\n            return\
    \ .doubleValue\n        case .stringValue:\n            return .stringValue\n\
    \        }\n    case .stringValue:\n        switch b { // Switch on type to determine\
    \ which case to return\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2rt59ak5.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmp2rt59ak5.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmp2rt59ak5.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmp2rt59ak5.swift:27:21: error: member 'intValue'\
    \ expects argument of type 'Int'\n            return .intValue\n             \
    \       ^\n/tmp/tmp2rt59ak5.swift:29:21: error: member 'doubleValue' expects argument\
    \ of type 'Double'\n            return .doubleValue\n                    ^\n/tmp/tmp2rt59ak5.swift:31:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmp2rt59ak5.swift:36:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmp2rt59ak5.swift:38:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmp2rt59ak5.swift:40:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a's type\n    case .intValue(_):\n   \
    \     switch b { // Switch on b's type\n        case .intValue(_):\n         \
    \   return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4c3y6rbp.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp4c3y6rbp.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp4c3y6rbp.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp4c3y6rbp.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp4c3y6rbp.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp4c3y6rbp.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp4c3y6rbp.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp4c3y6rbp.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp4c3y6rbp.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp4c3y6rbp.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // TODO: use switch statement\n    case .intValue(_):\n\
    \        switch b { // TODO: use switch statement\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // TODO: use switch\
    \ statement\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ TODO: use switch statement\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7_jy4bb8.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp7_jy4bb8.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp7_jy4bb8.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp7_jy4bb8.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp7_jy4bb8.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp7_jy4bb8.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp7_jy4bb8.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp7_jy4bb8.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp7_jy4bb8.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp7_jy4bb8.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        if a < b {\n                return a\n            } else {\n        \
    \        return b\n            }\n        }\n    case .doubleValue(_):\n     \
    \   switch b as! Value {\n        case .intValue(_):\n            return b\n \
    \       case .doubleValue(_):\n            return a\n        case .stringValue(_):\n\
    \            if a < b {\n                return b\n            } else {\n    \
    \            return a\n            }\n        }\n    case .stringValue(_):\n \
    \       switch b as! Value {\n        case .intValue(_):\n            return a\n\
    \        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            if a < b {\n                return a\n            } else {\n    \
    \            return b\n            }\n        }\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppaz7v2dp.swift:14:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmppaz7v2dp.swift:16:18: warning: forced cast of 'Value' to same type\
    \ has no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n \
    \                \n/tmp/tmppaz7v2dp.swift:22:18: error: binary operator '<' cannot\
    \ be applied to two 'Value' operands\n            if a < b {\n               ~\
    \ ^ ~\n/tmp/tmppaz7v2dp.swift:22:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n\
    /tmp/tmppaz7v2dp.swift:29:18: warning: forced cast of 'Value' to same type has\
    \ no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n     \
    \            \n/tmp/tmppaz7v2dp.swift:35:18: error: binary operator '<' cannot\
    \ be applied to two 'Value' operands\n            if a < b {\n               ~\
    \ ^ ~\n/tmp/tmppaz7v2dp.swift:35:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n\
    /tmp/tmppaz7v2dp.swift:42:18: warning: forced cast of 'Value' to same type has\
    \ no effect\n        switch b as! Value {\n                 ^~~~~~~~~~\n     \
    \            \n/tmp/tmppaz7v2dp.swift:48:18: error: binary operator '<' cannot\
    \ be applied to two 'Value' operands\n            if a < b {\n               ~\
    \ ^ ~\n/tmp/tmppaz7v2dp.swift:48:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare all possible types\n    case .intValue(_):\n\
    \        switch b { // Compare all possible types\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare all possible\
    \ types\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare all possible types\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmnvwud7n.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpmnvwud7n.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpmnvwud7n.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpmnvwud7n.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpmnvwud7n.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpmnvwud7n.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpmnvwud7n.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpmnvwud7n.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpmnvwud7n.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpmnvwud7n.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // case intValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    switch a { // case doubleValue:\n    case\
    \ .doubleValue(_):\n        return b\n    case .stringValue(_):\n        return\
    \ b\n    }\n    \n    switch b { // case doubleValue:\n    case .doubleValue(_):\n\
    \        return a\n    case .stringValue(_):\n        return a\n    }\n    \n\
    \    switch a { // case stringValue:\n    case .stringValue(_):\n        return\
    \ b\n    case .intValue(_):\n        return b\n    case .doubleValue(_):\n   \
    \     return b\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpd_dtjzdk.swift:32:5: error: switch must be exhaustive\n    switch\
    \ a { // case doubleValue:\n    ^\n/tmp/tmpd_dtjzdk.swift:32:5: note: add missing\
    \ case: '.intValue(_)'\n    switch a { // case doubleValue:\n    ^\n/tmp/tmpd_dtjzdk.swift:39:5:\
    \ error: switch must be exhaustive\n    switch b { // case doubleValue:\n    ^\n\
    /tmp/tmpd_dtjzdk.swift:39:5: note: add missing case: '.intValue(_)'\n    switch\
    \ b { // case doubleValue:\n    ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two integers\n        case .intValue(_):\n       \
    \     return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare two doubles\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return b\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp12rigq67/tmp12rigq67.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1799602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17992f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17992f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17992f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp12rigq67                        0x0000556dbc086a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b17997ee460 __libc_start_main +
    245

    6    tmp12rigq67                        0x0000556dbc086499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to execute\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to execute\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp11vlubqs.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp11vlubqs.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp11vlubqs.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp11vlubqs.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp11vlubqs.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp11vlubqs.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp11vlubqs.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp11vlubqs.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp11vlubqs.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp11vlubqs.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    \n    switch b { // case intValue:\n    case .intValue(_):\n\
    \        return a\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpplb3vsbz/tmpplb3vsbz.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acda6652c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acda6349b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acda6349988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acda63487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpplb3vsbz                        0x000055e7f616d01a <unavailable> + 12314

    5    libc.so.6                          0x00002acda683e460 __libc_start_main +
    245

    6    tmpplb3vsbz                        0x000055e7f616b499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // a is larger\n    case .intValue(_):\n        switch\
    \ b { // b is larger\n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return b\n       \
    \ case .doubleValue(_):\n            return a\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp6n089jgg/tmp6n089jgg.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b195db41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b195d838b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b195d838988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b195d8377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6n089jgg                        0x00005617d5dc0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b195dd2d460 __libc_start_main +
    245

    6    tmp6n089jgg                        0x00005617d5dc0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case is redundant but makes the code more readable\n\
    \    case .intValue(_):\n        switch b { // case is redundant but makes the\
    \ code more readable\n        case .intValue(_):\n            return a\n     \
    \   case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // case is redundant but makes the code more readable\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // case is redundant but makes the code more readable\n  \
    \      case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpu9kaoff4/tmpu9kaoff4.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba7702bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba76d22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba76d22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba76d217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu9kaoff4                        0x00005565c6581a56 <unavailable> + 6742

    5    libc.so.6                          0x00002aba77217460 __libc_start_main +
    245

    6    tmpu9kaoff4                        0x00005565c6581499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case is required because Value is a protocol\n \
    \   case .intValue(_):\n        return b\n    case .doubleValue(_):\n        return\
    \ b\n    case .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpup4cueg3/tmpup4cueg3.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4f6ceec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4f69e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4f69e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4f69e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpup4cueg3                        0x000055fdf87a101a <unavailable> + 12314

    5    libc.so.6                          0x00002af4f6eda460 __libc_start_main +
    245

    6    tmpup4cueg3                        0x000055fdf879f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ switch b { // case intValue:\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // case doubleValue:\n        case .intValue(_):\n            return a\n \
    \       case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // case stringValue:\n        case .intValue(_):\n            return a\n \
    \       case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp1r0jz1jf/tmp1r0jz1jf.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d8877fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d88476b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d88476988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d884757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1r0jz1jf                        0x0000561f356e5a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5d8896b460 __libc_start_main +
    245

    6    tmp1r0jz1jf                        0x0000561f356e5499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on the type of a\n    case .intValue(_):\n\
    \        switch b { // Switch on the type of b\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on the type\
    \ of b\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of b\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkuds5gbn.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpkuds5gbn.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpkuds5gbn.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpkuds5gbn.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpkuds5gbn.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpkuds5gbn.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpkuds5gbn.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpkuds5gbn.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpkuds5gbn.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpkuds5gbn.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmhmrwsys/tmpmhmrwsys.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cf2bffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cf28f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cf28f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cf28f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhmrwsys                        0x000056212edcaa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8cf2deb460 __libc_start_main +
    245

    6    tmpmhmrwsys                        0x000056212edca499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which function to call.\n\
    \    case .intValue(_):\n        return .intValue\n    case .doubleValue(_):\n\
    \        return .doubleValue\n    case .stringValue(_):\n        return .stringValue\n\
    \    }\n    \n    switch b { // Switch on type to determine which function to\
    \ call.\n    case .intValue(_):\n        return .intValue\n    case .doubleValue(_):\n\
    \        return .doubleValue\n    case .stringValue(_):\n        return .stringValue\n\
    \    }\n    \n    // If both are strings, compare them lexicographically.\n  \
    \  if let aString = a.stringValue, bString = b.stringValue {\n        if aString\
    \ < bString {\n            return .stringValue\n        }\n        if aString\
    \ > bString {\n            return .stringValue\n        }\n        return .intValue\n\
    \    }\n    \n    // If both are integers, compare them numerically.\n    if let\
    \ aInt = a.intValue, bInt = b.intValue {\n        if aInt < bInt {\n         \
    \   return .intValue\n        }\n        if aInt > bInt {\n            return\
    \ .intValue\n        }\n        return .doubleValue\n    }\n    \n    // If both\
    \ are doubles, compare them numerically.\n    if let aDouble = a.doubleValue,\
    \ bDouble = b.doubleValue {\n        if aDouble < bDouble {\n            return\
    \ .doubleValue\n        }\n        if aDouble > bDouble {\n            return\
    \ .doubleValue\n        }\n        return .intValue\n    }\n    \n    // If both\
    \ are floats, compare them numerically.\n    if let aFloat = a.doubleValue, bFloat\
    \ = b.doubleValue {\n        if aFloat < bFloat {\n            return .doubleValue\n\
    \        }\n        if aFloat > bFloat {\n            return .doubleValue\n  \
    \      }\n        return .intValue\n    }\n    \n    // If both are nil, return\
    \ nil.\n    if a == .nilValue {\n        return b == .nilValue ? .nilValue : .intValue\n\
    \    }\n    \n    // If both are non-nil, return nil.\n    if b == .nilValue {\n\
    \        return a == .nilValue ? .nilValue : .intValue\n    }\n    \n    // If\
    \ both are non-nil, return nil.\n    if a == .nilValue {\n        return b ==\
    \ .nilValue ? .nilValue : .intValue\n    }\n    \n    // If both are non-nil,\
    \ return nil.\n    if b == .nilValue {\n        return a == .nilValue \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzft216oj.swift:33:37: error: expected 'let' in conditional\n  \
    \  if let aString = a.stringValue, bString = b.stringValue {\n               \
    \                     ^\n                                    let \n/tmp/tmpzft216oj.swift:44:31:\
    \ error: expected 'let' in conditional\n    if let aInt = a.intValue, bInt = b.intValue\
    \ {\n                              ^\n                              let \n/tmp/tmpzft216oj.swift:55:37:\
    \ error: expected 'let' in conditional\n    if let aDouble = a.doubleValue, bDouble\
    \ = b.doubleValue {\n                                    ^\n                 \
    \                   let \n/tmp/tmpzft216oj.swift:66:36: error: expected 'let'\
    \ in conditional\n    if let aFloat = a.doubleValue, bFloat = b.doubleValue {\n\
    \                                   ^\n                                   let\
    \ \n/tmp/tmpzft216oj.swift:116:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpzft216oj.swift:13:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpzft216oj.swift:16:17:\
    \ error: member 'intValue' expects argument of type 'Int'\n        return .intValue\n\
    \                ^\n/tmp/tmpzft216oj.swift:18:17: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n        return .doubleValue\n           \
    \     ^\n/tmp/tmpzft216oj.swift:20:17: error: member 'stringValue' expects argument\
    \ of type 'String'\n        return .stringValue\n                ^\n/tmp/tmpzft216oj.swift:25:17:\
    \ error: member 'intValue' expects argument of type 'Int'\n        return .intValue\n\
    \                ^\n/tmp/tmpzft216oj.swift:27:17: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n        return .doubleValue\n           \
    \     ^\n/tmp/tmpzft216oj.swift:29:17: error: member 'stringValue' expects argument\
    \ of type 'String'\n        return .stringValue\n                ^\n/tmp/tmpzft216oj.swift:33:22:\
    \ error: enum case 'stringValue' can"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqqc4cbnf.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqqc4cbnf.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqqc4cbnf.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqqc4cbnf.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqqc4cbnf.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqqc4cbnf.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqqc4cbnf.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqqc4cbnf.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on a's type\n    case .intValue:\n      \
    \  switch b { // Switch on b's type\n        case .intValue:\n            return\
    \ .intValue\n        case .doubleValue:\n            return .doubleValue\n   \
    \     case .stringValue:\n            return .stringValue\n        }\n    case\
    \ .doubleValue:\n        switch b { // Switch on b's type\n        case .intValue:\n\
    \            return .intValue\n        case .doubleValue:\n            return\
    \ .doubleValue\n        case .stringValue:\n            return .stringValue\n\
    \        }\n    case .stringValue:\n        switch b { // Switch on b's type\n\
    \        case .intValue:\n            return .intValue\n        case .doubleValue:\n\
    \            return .doubleValue\n        case .stringValue:\n            return\
    \ .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvdaj1qls.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmpvdaj1qls.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmpvdaj1qls.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpvdaj1qls.swift:27:21: error: member 'intValue'\
    \ expects argument of type 'Int'\n            return .intValue\n             \
    \       ^\n/tmp/tmpvdaj1qls.swift:29:21: error: member 'doubleValue' expects argument\
    \ of type 'Double'\n            return .doubleValue\n                    ^\n/tmp/tmpvdaj1qls.swift:31:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpvdaj1qls.swift:36:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmpvdaj1qls.swift:38:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpvdaj1qls.swift:40:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as! Value {\n    case .intValue(_):\n        switch b\
    \ as! Value {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b as!\
    \ Value {\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b as! Value {\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return a\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmhmrwsys/tmpmhmrwsys.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cf2bffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cf28f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cf28f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cf28f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmhmrwsys                        0x000056212edcaa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8cf2deb460 __libc_start_main +
    245

    6    tmpmhmrwsys                        0x000056212edca499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use.\n    case .intValue:\n        switch b { // Switch on type to determine\
    \ which comparison to use.\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b { // Switch on type to determine which comparison to use.\n        case .intValue:\n\
    \            return .doubleValue\n        case .doubleValue:\n            return\
    \ .doubleValue\n        case .stringValue:\n            return .stringValue\n\
    \        }\n    case .stringValue:\n        switch b { // Switch on type to determine\
    \ which comparison to use.\n        case .intValue:\n            return .stringValue\n\
    \        case .doubleValue:\n            return .stringValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmph3_lvg_h.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmph3_lvg_h.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmph3_lvg_h.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmph3_lvg_h.swift:27:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmph3_lvg_h.swift:29:21: error: member 'doubleValue' expects\
    \ argument of type 'Double'\n            return .doubleValue\n               \
    \     ^\n/tmp/tmph3_lvg_h.swift:31:21: error: member 'stringValue' expects argument\
    \ of type 'String'\n            return .stringValue\n                    ^\n/tmp/tmph3_lvg_h.swift:36:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmph3_lvg_h.swift:38:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmph3_lvg_h.swift:40:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? Value {\n    case let intValue(aInt):\n        switch\
    \ b as? Value {\n        case let intValue(bInt):\n            return intValue\
    \ > bInt ? intValue : bInt\n        case let doubleValue(bDouble):\n         \
    \   return intValue > bDouble ? intValue : bDouble\n        case let stringValue(bString):\n\
    \            return intValue > bString ? intValue : bString\n        }\n    case\
    \ let doubleValue(aDouble):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aDouble > bInt ? aDouble : bInt\n        case let doubleValue(bDouble):\n\
    \            return aDouble > bDouble ? aDouble : bDouble\n        case let stringValue(bString):\n\
    \            return aDouble > bString ? aDouble : bString\n        }\n    case\
    \ let stringValue(aString):\n        switch b as? Value {\n        case let intValue(bInt):\n\
    \            return aString > bInt ? aString : bInt\n        case let doubleValue(bDouble):\n\
    \            return aString > bDouble ? aString : bDouble\n        case let stringValue(bString):\n\
    \            return aString > bString ? aString : bString\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpufgoz28r.swift:14:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpufgoz28r.swift:15:14:\
    \ error: cannot find 'intValue' in scope\n    case let intValue(aInt):\n     \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:24:14: error: cannot find 'doubleValue'\
    \ in scope\n    case let doubleValue(aDouble):\n             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:33:14:\
    \ error: cannot find 'stringValue' in scope\n    case let stringValue(aString):\n\
    \             ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:16:18: warning: conditional\
    \ cast from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n\
    \                 ^\n/tmp/tmpufgoz28r.swift:17:18: error: cannot find 'intValue'\
    \ in scope\n        case let intValue(bInt):\n                 ^~~~~~~~\n/tmp/tmpufgoz28r.swift:19:18:\
    \ error: cannot find 'doubleValue' in scope\n        case let doubleValue(bDouble):\n\
    \                 ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:21:18: error: cannot find\
    \ 'stringValue' in scope\n        case let stringValue(bString):\n           \
    \      ^~~~~~~~~~~\n/tmp/tmpufgoz28r.swift:18:20: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:18:38: error: cannot find 'intValue'\
    \ in scope\n            return intValue > bInt ? intValue : bInt\n           \
    \                          ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:20: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:20:41: error: cannot\
    \ find 'intValue' in scope\n            return intValue > bDouble ? intValue :\
    \ bDouble\n                                        ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:20:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                   ^~~~~~~~\n/tmp/tmpufgoz28r.swift:22:41:\
    \ error: cannot find 'intValue' in scope\n            return intValue > bString\
    \ ? intValue : bString\n                                        ^"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a as? ValueType {\n    case .intValue:\n        switch\
    \ b as? ValueType {\n        case .intValue:\n            return a.intValue >\
    \ b.intValue\n        case .doubleValue:\n            return a.doubleValue > b.doubleValue\n\
    \        case .stringValue:\n            return a.stringValue > b.stringValue\n\
    \        }\n    case .doubleValue:\n        switch b as? ValueType {\n       \
    \ case .intValue:\n            return a.doubleValue > b.intValue\n        case\
    \ .doubleValue:\n            return a.doubleValue > b.doubleValue\n        case\
    \ .stringValue:\n            return a.doubleValue > b.stringValue\n        }\n\
    \    case .stringValue:\n        switch b as? ValueType {\n        case .intValue:\n\
    \            return a.stringValue > b.intValue\n        case .doubleValue:\n \
    \           return a.stringValue > b.doubleValue\n        case .stringValue:\n\
    \            return a.stringValue > b.stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzwcz2yzp.swift:14:18: error: cannot find type 'ValueType' in scope\n\
    \    switch a as? ValueType {\n                 ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:16:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:18:31: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n          \
    \  return a.intValue > b.intValue\n                   ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpzwcz2yzp.swift:18:31: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n            return a.intValue > b.intValue\n\
    \                   ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error:\
    \ binary operator '>' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue > b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:20:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ > b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34:\
    \ error: binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \            return a.stringValue > b.stringValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:22:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.stringValue\
    \ > b.stringValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:25:22:\
    \ error: cannot find type 'ValueType' in scope\n        switch b as? ValueType\
    \ {\n                     ^~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: binary\
    \ operator '>' cannot be applied to operands of type '(Double) -> Value' and '(Int)\
    \ -> Value'\n            return a.doubleValue > b.intValue\n                 \
    \  ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpzwcz2yzp.swift:27:34: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n            return\
    \ a.doubleValue > b.intValue\n                   ~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // case intValue:\n    case .intValue(_):\n       \
    \ switch b { // case intValue:\n        case .intValue(_):\n            return\
    \ .intValue\n        case .doubleValue(_):\n            return .doubleValue\n\
    \        case .stringValue(_):\n            return .stringValue\n        }\n \
    \   case .doubleValue(_):\n        switch b { // case doubleValue:\n        case\
    \ .intValue(_):\n            return .doubleValue\n        case .doubleValue(_):\n\
    \            return .doubleValue\n        case .stringValue(_):\n            return\
    \ .stringValue\n        }\n    case .stringValue(_):\n        switch b { // case\
    \ stringValue:\n        case .intValue(_):\n            return .stringValue\n\
    \        case .doubleValue(_):\n            return .stringValue\n        case\
    \ .stringValue(_):\n            return .stringValue\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmptix9vpek.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmptix9vpek.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmptix9vpek.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmptix9vpek.swift:27:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmptix9vpek.swift:29:21: error: member 'doubleValue' expects\
    \ argument of type 'Double'\n            return .doubleValue\n               \
    \     ^\n/tmp/tmptix9vpek.swift:31:21: error: member 'stringValue' expects argument\
    \ of type 'String'\n            return .stringValue\n                    ^\n/tmp/tmptix9vpek.swift:36:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmptix9vpek.swift:38:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmptix9vpek.swift:40:21: error: member 'stringValue'\
    \ expects argument of type 'String'\n            return .stringValue\n       \
    \             ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqqc4cbnf.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqqc4cbnf.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqqc4cbnf.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqqc4cbnf.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqqc4cbnf.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqqc4cbnf.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqqc4cbnf.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqqc4cbnf.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type\n    case .intValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .doubleValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    case .stringValue:\n        switch\
    \ b { // Switch on type\n        case .intValue:\n            return .intValue\n\
    \        case .doubleValue:\n            return .doubleValue\n        case .stringValue:\n\
    \            return .stringValue\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdb0hyzff.swift:18:21: error: member 'intValue' expects argument\
    \ of type 'Int'\n            return .intValue\n                    ^\n/tmp/tmpdb0hyzff.swift:20:21:\
    \ error: member 'doubleValue' expects argument of type 'Double'\n            return\
    \ .doubleValue\n                    ^\n/tmp/tmpdb0hyzff.swift:22:21: error: member\
    \ 'stringValue' expects argument of type 'String'\n            return .stringValue\n\
    \                    ^\n/tmp/tmpdb0hyzff.swift:27:21: error: member 'intValue'\
    \ expects argument of type 'Int'\n            return .intValue\n             \
    \       ^\n/tmp/tmpdb0hyzff.swift:29:21: error: member 'doubleValue' expects argument\
    \ of type 'Double'\n            return .doubleValue\n                    ^\n/tmp/tmpdb0hyzff.swift:31:21:\
    \ error: member 'stringValue' expects argument of type 'String'\n            return\
    \ .stringValue\n                    ^\n/tmp/tmpdb0hyzff.swift:36:21: error: member\
    \ 'intValue' expects argument of type 'Int'\n            return .intValue\n  \
    \                  ^\n/tmp/tmpdb0hyzff.swift:38:21: error: member 'doubleValue'\
    \ expects argument of type 'Double'\n            return .doubleValue\n       \
    \             ^\n/tmp/tmpdb0hyzff.swift:40:21: error: member 'stringValue' expects\
    \ argument of type 'String'\n            return .stringValue\n               \
    \     ^\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which comparison to\
    \ use\n    case .intValue(_):\n        switch b { // Switch on type to determine\
    \ which comparison to use\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqqc4cbnf.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpqqc4cbnf.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpqqc4cbnf.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpqqc4cbnf.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpqqc4cbnf.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpqqc4cbnf.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpqqc4cbnf.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpqqc4cbnf.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpqqc4cbnf.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Compare two values\n    case .intValue(_):\n   \
    \     switch b { // Compare two integers\n        case .intValue(_):\n       \
    \     return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return a\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare two doubles\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return a\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return a\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpchn2inuv/tmpchn2inuv.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc2b860c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc2b557b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc2b557988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc2b5567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchn2inuv                        0x000055942844aa56 <unavailable> + 6742

    5    libc.so.6                          0x00002acc2ba4c460 __libc_start_main +
    245

    6    tmpchn2inuv                        0x000055942844a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to execute\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to execute\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to execute\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp11vlubqs.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp11vlubqs.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp11vlubqs.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp11vlubqs.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp11vlubqs.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp11vlubqs.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp11vlubqs.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp11vlubqs.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp11vlubqs.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp11vlubqs.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013349
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\nfunc compare_one(a: Value, b: Value) ->\
    \ Value? {\n    switch a { // Switch on type to determine which case to return\n\
    \    case .intValue(_):\n        switch b { // Switch on type to determine which\
    \ case to return\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpol8jmtia.swift:18:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpol8jmtia.swift:18:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpol8jmtia.swift:18:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpol8jmtia.swift:18:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpol8jmtia.swift:18:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpol8jmtia.swift:18:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpol8jmtia.swift:20:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpol8jmtia.swift:20:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpol8jmtia.swift:20:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpol8jmtia.swift:20:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013348
