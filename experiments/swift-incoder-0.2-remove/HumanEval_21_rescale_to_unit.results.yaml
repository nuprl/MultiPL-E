language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.maxFinite)\n    var max: Double = Double(Int.minFinite)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_3lys5la.swift:5:34: error: type 'Int' has no member 'maxFinite'\n\
    \    var min: Double = Double(Int.maxFinite)\n                             ~~~\
    \ ^~~~~~~~~\n/tmp/tmp_3lys5la.swift:6:34: error: type 'Int' has no member 'minFinite'\n\
    \    var max: Double = Double(Int.minFinite)\n                             ~~~\
    \ ^~~~~~~~~\n/tmp/tmp_3lys5la.swift:8:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp_3lys5la.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc03pp5dx.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6vp2dne3.swift:7:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6vp2dne3.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp6vp2dne3.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / max - min)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc7_65xq1.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpc7_65xq1.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuvnup4ua.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpuvnup4ua.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpuvnup4ua.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var min: Double\
    \ = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number /= max - min\n   \
    \ }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpe3ou8xu0.swift:21:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(numbers.count))\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9ctc492k.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9ctc492k.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number / max - min)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc7_65xq1.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpc7_65xq1.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp0um_llvr/tmp0um_llvr.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b722f824c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b722f51bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b722f51b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b722f51a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0um_llvr                        0x00005644c1808693 <unavailable> + 5779

    5    libc.so.6                          0x00002b722fa10460 __libc_start_main +
    245

    6    tmp0um_llvr                        0x00005644c1808299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnrz568ao.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpnrz568ao.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpnrz568ao.swift:16:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        rescaled.append(number - min)\n        rescaled.append(number - max)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpja8nw9ol.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpja8nw9ol.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(Int.max) -\
    \ min)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplch26nar.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplch26nar.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    let min = numbers.min()\n\
    \    let max = numbers.max()\n    var scaled: [Double] = []\n    for i in 0..<numbers.count\
    \ {\n        scaled.append(numbers[i] - min)\n    }\n    for i in 0..<numbers.count\
    \ {\n        scaled[i] = scaled[i] / (max - min)\n    }\n    return scaled\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqzoildd8.swift:10:36: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        scaled.append(numbers[i] -\
    \ min)\n                                   ^\n/tmp/tmpqzoildd8.swift:10:36: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        scaled.append(numbers[i] - min)\n                                   ^\n\
    \                                   (   ?? <#default value#>)\n/tmp/tmpqzoildd8.swift:10:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        scaled.append(numbers[i] - min)\n                           \
    \        ^\n                                      !\n/tmp/tmpqzoildd8.swift:13:38:\
    \ error: binary operator '-' cannot be applied to two 'Double?' operands\n   \
    \     scaled[i] = scaled[i] / (max - min)\n                                 ~~~\
    \ ^ ~~~\n/tmp/tmpqzoildd8.swift:13:38: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double)\n        scaled[i] = scaled[i]\
    \ / (max - min)\n                                     ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(max - min))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp9i4r7wl.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpp9i4r7wl.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp0um_llvr/tmp0um_llvr.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b722f824c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b722f51bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b722f51b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b722f51a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0um_llvr                        0x00005644c1808693 <unavailable> + 5779

    5    libc.so.6                          0x00002b722fa10460 __libc_start_main +
    245

    6    tmp0um_llvr                        0x00005644c1808299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp913wrbhg.swift:7:34: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var largest: Double = Double.lowestFiniteMagnitude\n                    \
    \      ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppvfg7vk6.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmppvfg7vk6.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.max\n    var\
    \ max: Double = Double.min\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3qz5sxmu.swift:6:30: error: type 'Double' has no member 'max'\n\
    \    var min: Double = Double.max\n                      ~~~~~~ ^~~\n/tmp/tmp3qz5sxmu.swift:7:30:\
    \ error: type 'Double' has no member 'min'\n    var max: Double = Double.min\n\
    \                      ~~~~~~ ^~~\n/tmp/tmp3qz5sxmu.swift:10:15: error: cannot\
    \ call value of non-function type 'Double'\n        min = min(min, number)\n \
    \             ^\n/tmp/tmp3qz5sxmu.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl93_2fi6.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpl93_2fi6.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc03pp5dx.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppvfg7vk6.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmppvfg7vk6.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdmua20hp/tmpdmua20hp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c74924c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7461bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7461b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7461a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmua20hp                        0x00005590db5e56f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b5c74b10460 __libc_start_main +
    245

    6    tmpdmua20hp                        0x00005590db5e52f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var smallest = Double(Int.max)\n    var\
    \ largest = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / largest)\n        smallest = min(number, smallest)\n        largest = max(number,\
    \ largest)\n    }\n    for number in numbers {\n        rescaled.append(number\
    \ / smallest)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpr_cifoxh/tmpr_cifoxh.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba6e563c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba6e25ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba6e25a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba6e2597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr_cifoxh                        0x00005594120de743 <unavailable> + 5955

    5    libc.so.6                          0x00002aba6e74f460 __libc_start_main +
    245

    6    tmpr_cifoxh                        0x00005594120de349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdmua20hp/tmpdmua20hp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c74924c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7461bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7461b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7461a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmua20hp                        0x00005590db5e56f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b5c74b10460 __libc_start_main +
    245

    6    tmpdmua20hp                        0x00005590db5e52f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(Int.max))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpt_cbp7g2.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpt_cbp7g2.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double](repeating: 0.0, count: numbers.count)\n    var\
    \ smallest = Double.greatestFiniteMagnitude\n    var largest = Double.leastFiniteMagnitude\n\
    \    for number in numbers {\n        rescaled[numbers.index(of: number)] = number\
    \ / largest\n        smallest += number\n        largest -= number\n    }\n  \
    \  return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc5mulx9l.swift:7:26: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest = Double.leastFiniteMagnitude\n                  ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpc5mulx9l.swift:9:26: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        rescaled[numbers.index(of: number)] = number / largest\n\
    \                         ^\n/tmp/tmpc5mulx9l.swift:9:26: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        rescaled[numbers.index(of:\
    \ number)] = number / largest\n                         ^\n                  \
    \                         ?? <#default value#>\n/tmp/tmpc5mulx9l.swift:9:26: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        rescaled[numbers.index(of: number)] = number / largest\n            \
    \             ^\n                                          !\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max)\n        max = max(max, number)\n        min = min(min, number)\n   \
    \ }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps38a1mh0.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmps38a1mh0.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        min = min(min,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else {\n        return numbers\n    }\n\n   \
    \ var min: Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n\
    \n    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(min\
    \ + ((number - min) / (max - min)) * (max - min))\n    }\n\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpxwooqia4/tmpxwooqia4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49904c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49901b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49901b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49901b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxwooqia4                        0x0000559dfafc4703 <unavailable> + 5891

    5    libc.so.6                          0x00002b49906ae460 __libc_start_main +
    245

    6    tmpxwooqia4                        0x0000559dfafc4309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(number, smallest)\n\
    \        largest = max(number, largest)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpxoyjo3ac/tmpxoyjo3ac.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf8fd19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf8fa10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf8fa10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf8fa0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxoyjo3ac                        0x000055f628b9f6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002abf8ff05460 __libc_start_main +
    245

    6    tmpxoyjo3ac                        0x000055f628b9f2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var smallest = Double(Int.max)\n    var\
    \ largest = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / largest)\n        smallest = min(number, smallest)\n        largest = max(number,\
    \ largest)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp5_b2uybz/tmp5_b2uybz.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72d7fdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72d7cd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72d7cd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72d7cd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5_b2uybz                        0x000055960d6bd743 <unavailable> + 5955

    5    libc.so.6                          0x00002b72d81cb460 __libc_start_main +
    245

    6    tmp5_b2uybz                        0x000055960d6bd349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    scaled.append(max - min)\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm7ozdad0.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpm7ozdad0.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp41khd37z.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max)\n        max = max(max, number)\n        min = min(min, number)\n   \
    \ }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps38a1mh0.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmps38a1mh0.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        min = min(min,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        largest = number\n    }\n    for\
    \ number in numbers {\n        rescaled.append(number / smallest)\n        smallest\
    \ = number\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpaawz746s/tmpaawz746s.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae24513cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae244e33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae244e33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae244e327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaawz746s                        0x00005650c459d603 <unavailable> + 5635

    5    libc.so.6                          0x00002ae245328460 __libc_start_main +
    245

    6    tmpaawz746s                        0x00005650c459d209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n    }\n    for number in rescaled {\n        number /= max - min\n \
    \   }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprrriudkm.swift:20:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(max - min) + min)\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgc0tnfce.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpgc0tnfce.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n    }\n    for number in numbers {\n        rescaled.append(number /\
    \ max - min)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp101m3ln1/tmp101m3ln1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b396c0c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b396bdbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b396bdbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b396bdbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp101m3ln1                        0x000056028f60b603 <unavailable> + 5635

    5    libc.so.6                          0x00002b396c2b2460 __libc_start_main +
    245

    6    tmp101m3ln1                        0x000056028f60b209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuvnup4ua.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpuvnup4ua.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpuvnup4ua.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        largest = number\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / smallest)\n\
    \        smallest = number\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0lqoe9m2.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdmua20hp/tmpdmua20hp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c74924c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7461bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7461b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7461a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmua20hp                        0x00005590db5e56f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b5c74b10460 __libc_start_main +
    245

    6    tmpdmua20hp                        0x00005590db5e52f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number - max)\n    }\n    return rescaled\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmph6sw3o6e.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmph6sw3o6e.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw3ddrs_u.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw3ddrs_u.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var min: Double\
    \ = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n    for\
    \ number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(min + ((number - min) / (max - min) * (max - min)))\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpt5et7z05.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpt5et7z05.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyftn78p4.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpyftn78p4.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp8k31bojt/tmp8k31bojt.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b500b6a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b500b39ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b500b39a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b500b3997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8k31bojt                        0x0000555ea4db36f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b500b88f460 __libc_start_main +
    245

    6    tmp8k31bojt                        0x0000555ea4db32f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max), max: Double = Double(Int.min)\n  \
    \  for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpi8wndch2.swift:7:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpi8wndch2.swift:8:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpi8wndch2.swift:15:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp0um_llvr/tmp0um_llvr.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b722f824c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b722f51bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b722f51b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b722f51a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0um_llvr                        0x00005644c1808693 <unavailable> + 5779

    5    libc.so.6                          0x00002b722fa10460 __libc_start_main +
    245

    6    tmp0um_llvr                        0x00005644c1808299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    if numbers.count < 2 {\n        return numbers\n    }\n\n    var min:\
    \ Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(min\
    \ + ((number - min) / (max - min)) * (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp0nikbqup/tmp0nikbqup.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba06658cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba066283b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba066283988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0662827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0nikbqup                        0x000056248fd00703 <unavailable> + 5891

    5    libc.so.6                          0x00002ba066778460 __libc_start_main +
    245

    6    tmp0nikbqup                        0x000056248fd00309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        min = min(min, number)\n        max = max(max, number)\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / max - min)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9znt1zru.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9znt1zru.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n    }\n    for number in result {\n        if number > 1 {\n       \
    \     number /= max\n        } else {\n            number /= min\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw3dz1t7_.swift:21:20: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n            number /= max\n         \
    \   ~~~~~~ ^\n/tmp/tmpw3dz1t7_.swift:23:20: error: left side of mutating operator\
    \ isn't mutable: 'number' is a 'let' constant\n            number /= min\n   \
    \         ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max), max: Double = Double(Int.min)\n  \
    \  for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuvnup4ua.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpuvnup4ua.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpuvnup4ua.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    var scaled: [Double] = []\n   \
    \ for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in scaled {\n        if number > 1 {\n            number /= max\n   \
    \     } else {\n            number /= min\n        }\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppf_o0fy2.swift:6:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppf_o0fy2.swift:21:20: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n            number /=\
    \ max\n            ~~~~~~ ^\n/tmp/tmppf_o0fy2.swift:23:20: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n            number\
    \ /= min\n            ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n  \
    \      scaled.append((number - smallest) / (largest - smallest))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp8k31bojt/tmp8k31bojt.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b500b6a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b500b39ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b500b39a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b500b3997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8k31bojt                        0x0000555ea4db36f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b500b88f460 __libc_start_main +
    245

    6    tmp8k31bojt                        0x0000555ea4db32f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    if numbers.isEmpty {\n        return numbers\n    }\n    var min = Double(numbers.first!)\n\
    \    var max = Double(numbers.last!)\n    for number in numbers {\n        if\
    \ number < min {\n            min = number\n        }\n        if number > max\
    \ {\n            max = number\n        }\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n    }\n   \
    \ for number in scaled {\n        number /= max - min\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpn4z2u_n8.swift:23:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ min), max))\n        min = max(min, number)\n        max = min(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpj6im6tym.swift:9:25: error: cannot call value of non-function type\
    \ 'Double'\n        rescaled.append(min(max(number, min), max))\n            \
    \            ^\n/tmp/tmpj6im6tym.swift:9:29: error: cannot call value of non-function\
    \ type 'Double'\n        rescaled.append(min(max(number, min), max))\n       \
    \                     ^\n/tmp/tmpj6im6tym.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = max(min, number)\n            \
    \  ^\n/tmp/tmpj6im6tym.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = min(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_82ch8j9.swift:7:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_82ch8j9.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp_82ch8j9.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpoecpvxnc.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(numbers.count))\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9ctc492k.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9ctc492k.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc03pp5dx.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdmua20hp/tmpdmua20hp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c74924c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7461bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7461b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7461a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmua20hp                        0x00005590db5e56f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b5c74b10460 __libc_start_main +
    245

    6    tmpdmua20hp                        0x00005590db5e52f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp8k31bojt/tmp8k31bojt.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b500b6a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b500b39ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b500b39a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b500b3997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8k31bojt                        0x0000555ea4db36f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b500b88f460 __libc_start_main +
    245

    6    tmp8k31bojt                        0x0000555ea4db32f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc03pp5dx.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpi99_yr1h/tmpi99_yr1h.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0113b20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0113817b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0113817988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01138167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi99_yr1h                        0x000055ca523c7743 <unavailable> + 5955

    5    libc.so.6                          0x00002b0113d0c460 __libc_start_main +
    245

    6    tmpi99_yr1h                        0x000055ca523c7349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(number, smallest)\n\
    \        largest = max(number, largest)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpxoyjo3ac/tmpxoyjo3ac.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf8fd19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf8fa10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf8fa10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf8fa0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxoyjo3ac                        0x000055f628b9f6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002abf8ff05460 __libc_start_main +
    245

    6    tmpxoyjo3ac                        0x000055f628b9f2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(Int.max))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg15smqrr.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpg15smqrr.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    if numbers.count < 2 {\n        return numbers\n    }\n    var min: Double\
    \ = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpvb9kagms/tmpvb9kagms.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09b8f3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09b8c31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09b8c31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09b8c307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvb9kagms                        0x0000560613cc8603 <unavailable> + 5635

    5    libc.so.6                          0x00002b09b9126460 __libc_start_main +
    245

    6    tmpvb9kagms                        0x0000560613cc8209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013933
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw3ddrs_u.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpw3ddrs_u.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(numbers.count))\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9ctc492k.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9ctc492k.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    var scaled: [Double] = []\n   \
    \ for number in numbers {\n        scaled.append(number * (max - min) / (max -\
    \ min) + min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0evn7vi5.swift:6:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        if number\
    \ > max {\n            max = number\n        }\n        if number < min {\n  \
    \          min = number\n        }\n    }\n    var scaled: [Double] = []\n   \
    \ for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in scaled {\n        if number > 1 {\n            number /= max\n   \
    \     } else {\n            number /= min\n        }\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpu60w1eir.swift:6:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu60w1eir.swift:21:20: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n            number /=\
    \ max\n            ~~~~~~ ^\n/tmp/tmpu60w1eir.swift:23:20: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n            number\
    \ /= min\n            ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled = [Double]()\n    var smallest = Double(Int.max)\n    var\
    \ largest = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / largest)\n        largest = number\n    }\n    for number in numbers {\n \
    \       rescaled.append(number / smallest)\n        smallest = number\n    }\n\
    \    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp16whippg/tmp16whippg.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acdaa69cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdaa393b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acdaa393988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acdaa3927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16whippg                        0x000055ee2176d653 <unavailable> + 5715

    5    libc.so.6                          0x00002acdaa888460 __libc_start_main +
    245

    6    tmp16whippg                        0x000055ee2176d259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append((number - min) / (max - min))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphvpdk125.swift:6:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmphvpdk125.swift:8:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmphvpdk125.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        min = min(min, number)\n        max = max(max, number)\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / max - min)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9znt1zru.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9znt1zru.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsiooe_2s.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpsiooe_2s.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    if numbers.count < 2 {\n        return numbers\n    }\n    var min: Double\
    \ = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n    }\n    for number in result {\n        result.append(number / max\
    \ - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmplzdlbhjz/tmplzdlbhjz.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afebaf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afebac68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afebac68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afebac677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplzdlbhjz                        0x00005647a1184703 <unavailable> + 5891

    5    libc.so.6                          0x00002afebb15d460 __libc_start_main +
    245

    6    tmplzdlbhjz                        0x00005647a1184309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append((number - min) / (max - min))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqe95hvtd.swift:6:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqe95hvtd.swift:8:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqe95hvtd.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    for number in numbers {\n\
    \        rescaled.append(number / smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdl5clxp2/tmpdl5clxp2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0353171c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0352e68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0352e68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0352e677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdl5clxp2                        0x00005615aebee6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b035335d460 __libc_start_main +
    245

    6    tmpdl5clxp2                        0x00005615aebee2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var smallest: Double = Double(Int.max)\n    var largest: Double = Double(Int.min)\n\
    \    for number in numbers {\n        smallest = min(smallest, number)\n     \
    \   largest = max(largest, number)\n    }\n    var scaled: [Double] = []\n   \
    \ for number in numbers {\n        scaled.append(number * (largest - smallest)\
    \ / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpy2cb_t6s/tmpy2cb_t6s.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad226f4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad226c46b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad226c46988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad226c457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2cb_t6s                        0x000055ebf7bb3743 <unavailable> + 5955

    5    libc.so.6                          0x00002ad22713b460 __libc_start_main +
    245

    6    tmpy2cb_t6s                        0x000055ebf7bb3349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013933
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuvnup4ua.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpuvnup4ua.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpuvnup4ua.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpdmua20hp/tmpdmua20hp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c74924c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7461bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7461b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7461a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmua20hp                        0x00005590db5e56f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b5c74b10460 __libc_start_main +
    245

    6    tmpdmua20hp                        0x00005590db5e52f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    for number in numbers\
    \ {\n        rescaled.append(number / smallest)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc03pp5dx.swift:7:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuvnup4ua.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpuvnup4ua.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpuvnup4ua.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpekpbizzw.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpekpbizzw.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    if numbers.count < 2 {\n        return numbers\n    }\n    var min: Double\
    \ = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmphgzks95w/tmphgzks95w.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6983a32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6983729b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6983729988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69837287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphgzks95w                        0x00005582af64c703 <unavailable> + 5891

    5    libc.so.6                          0x00002b6983c1e460 __libc_start_main +
    245

    6    tmphgzks95w                        0x00005582af64c309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39i0b0sc.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp39i0b0sc.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmp39i0b0sc.swift:16:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        rescaled.append(number * (max - min) / Double(Int.max) -\
    \ min)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplch26nar.swift:9:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplch26nar.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ * (max - min) / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmppgy2bwb1/tmppgy2bwb1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e7372c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e7069b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e7069988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e70687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppgy2bwb1                        0x00005624de102653 <unavailable> + 5715

    5    libc.so.6                          0x00002b45e755e460 __libc_start_main +
    245

    6    tmppgy2bwb1                        0x00005624de102259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0), 1))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpd_ivvxjw/tmpd_ivvxjw.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92640e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9263de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9263de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9263ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_ivvxjw                        0x000055579465d6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b92642d5460 __libc_start_main +
    245

    6    tmpd_ivvxjw                        0x000055579465d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxnvcs0pi.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxnvcs0pi.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpum4l6r43.swift:7:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number * (max - min) / Double(numbers.count))\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9ctc492k.swift:8:15: error: cannot call value of non-function type\
    \ 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp9ctc492k.swift:9:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw0i6huyh.swift:7:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw0i6huyh.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpw0i6huyh.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ / max - min)\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbavbm31e.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpbavbm31e.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013932
