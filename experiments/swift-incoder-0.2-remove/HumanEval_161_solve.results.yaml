language: swift
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += char.lowercaseString\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1pszz0gd.swift:12:28: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            result += char.lowercaseString\n            \
    \          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp1pszz0gd.swift:14:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"A\":\n            result += \"B\"\n        case \"B\":\n            result\
    \ += \"A\"\n        case \"C\":\n            result += \"D\"\n        case \"\
    D\":\n            result += \"C\"\n        case \"E\":\n            result +=\
    \ \"F\"\n        case \"F\":\n            result += \"E\"\n        case \"G\"\
    :\n            result += \"H\"\n        case \"H\":\n            result += \"\
    G\"\n        case \"I\":\n            result += \"J\"\n        case \"J\":\n \
    \           result += \"I\"\n        case \"K\":\n            result += \"L\"\n\
    \        case \"L\":\n            result += \"K\"\n        case \"M\":\n     \
    \       result += \"N\"\n        case \"N\":\n            result += \"M\"\n  \
    \      case \"O\":\n            result += \"P\"\n        case \"P\":\n       \
    \     result += \"O\"\n        case \"Q\":\n            result += \"R\"\n    \
    \    case \"R\":\n            result += \"Q\"\n        case \"S\":\n         \
    \   result += \"T\"\n        case \"T\":\n            result += \"S\"\n      \
    \  case \"U\":\n            result += \"V\"\n        case \"V\":\n           \
    \ result += \"U\"\n        case \"W\":\n            result += \"X\"\n        case\
    \ \"X\":\n            result += \"W\"\n        case \"Y\":\n            result\
    \ += \"Z\"\n        case \"Z\":\n            result += \"Y\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwhmxtrxh.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n        case \"b\":\n        case \"c\":\n        case \"d\":\n    \
    \    case \"e\":\n        case \"f\":\n        case \"g\":\n        case \"h\"\
    :\n        case \"i\":\n        case \"j\":\n        case \"k\":\n        case\
    \ \"l\":\n        case \"m\":\n        case \"n\":\n        case \"o\":\n    \
    \    case \"p\":\n        case \"q\":\n        case \"r\":\n        case \"s\"\
    :\n        case \"t\":\n        case \"u\":\n        case \"v\":\n        case\
    \ \"w\":\n        case \"x\":\n        case \"y\":\n        case \"z\":\n    \
    \    case \"A\":\n        case \"B\":\n        case \"C\":\n        case \"D\"\
    :\n        case \"E\":\n        case \"F\":\n        case \"G\":\n        case\
    \ \"H\":\n        case \"I\":\n        case \"J\":\n        case \"K\":\n    \
    \    case \"L\":\n        case \"M\":\n        case \"N\":\n        case \"O\"\
    :\n        case \"P\":\n        case \"Q\":\n        case \"R\":\n        case\
    \ \"S\":\n        case \"T\":\n        case \"U\":\n        case \"V\":\n    \
    \    case \"W\":\n        case \"X\":\n        case \"Y\":\n        case \"Z\"\
    :\n            result = result + char.lowercased()\n        default:\n       \
    \     result = result + char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aa7d8np.swift:12:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp4aa7d8np.swift:13:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:14:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:16:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:17:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4aa7d8np.swift:24:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiovfmf95.swift:9:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979349
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'A':\n        case 'a':\n            result += \"B\"\n        case\
    \ 'B':\n        case 'b':\n            result += \"A\"\n        case 'C':\n  \
    \      case 'c':\n            result += \"D\"\n        case 'D':\n        case\
    \ 'd':\n            result += \"C\"\n        case 'E':\n        case 'e':\n  \
    \          result += \"F\"\n        case 'F':\n        case 'f':\n           \
    \ result += \"E\"\n        case 'G':\n        case 'g':\n            result +=\
    \ \"H\"\n        case 'H':\n        case 'h':\n            result += \"G\"\n \
    \       case 'I':\n        case 'i':\n            result += \"J\"\n        case\
    \ 'J':\n        case 'j':\n            result += \"I\"\n        case 'K':\n  \
    \      case 'k':\n            result += \"L\"\n        case 'L':\n        case\
    \ 'l':\n            result += \"K\"\n        case 'M':\n        case 'm':\n  \
    \          result += \"N\"\n        case 'N':\n        case 'n':\n           \
    \ result += \"M\"\n        case 'O':\n        case 'o':\n            result +=\
    \ \"P\"\n        case 'P':\n        case 'p':\n            result += \"O\"\n \
    \       case 'Q':\n        case 'q':\n            result += \"R\"\n        case\
    \ 'R':\n        case 'r':\n            result += \"Q\"\n        case 'S':\n  \
    \      case 's':\n            result += \"T\"\n        case 'T':\n        case\
    \ 't':\n            result += \"S\"\n        case 'U':\n        case 'u':\n  \
    \          result += \"V\"\n        case 'V':\n        case 'v':\n           \
    \ result += \"U\"\n        case 'W':\n        case 'w':\n            result +=\
    \ \"X\"\n        case 'X':\n        case 'x':\n            result += \"W\"\n \
    \       case 'Y':\n        case 'y':\n            result += \"Z\"\n        case\
    \ 'Z':\n        case 'z':\n            result += \"Y\"\n        default:\n   \
    \         result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw858a6_6.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmpw858a6_6.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'a':\n   \
    \          ^~~\n             \"a\"\n/tmp/tmpw858a6_6.swift:15:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'B':\n             ^~~\n      \
    \       \"B\"\n/tmp/tmpw858a6_6.swift:15:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'B':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw858a6_6.swift:16:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'b':\n             ^~~\n             \"\
    b\"\n/tmp/tmpw858a6_6.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'C':\n             ^~~\n             \"C\"\n/tmp/tmpw858a6_6.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'C':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmpw858a6_6.swift:21:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'D':\n             ^~~\n      \
    \       \"D\"\n/tmp/tmpw858a6_6.swift:21:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'D':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw858a6_6.swift:22:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'd':\n             ^~~\n             \"\
    d\"\n/tmp/tmpw858a6_6.swift:24:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'E':\n             ^~~\n             \"E\"\n/tmp/tmpw858a6_6.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'E':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char.lowercased() {\n            case \"a\":\n             \
    \   result += \"A\"\n            case \"b\":\n                result += \"B\"\n\
    \            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkugv4e0x.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpkugv4e0x.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpkugv4e0x.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiovfmf95.swift:9:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979349
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += char.lowercased()\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpql__lb9k.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          result += char.lowercaseString\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptu7daizh.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmptu7daizh.swift:12:28: error: value of type 'Character'\
    \ has no member 'lowercaseString'\n            result += char.lowercaseString\n\
    \                      ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmptu7daizh.swift:14:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'A':\n        case 'a':\n            result += \"B\"\n        case\
    \ 'B':\n        case 'b':\n            result += \"A\"\n        case 'C':\n  \
    \      case 'c':\n            result += \"D\"\n        case 'D':\n        case\
    \ 'd':\n            result += \"C\"\n        case 'E':\n        case 'e':\n  \
    \          result += \"F\"\n        case 'F':\n        case 'f':\n           \
    \ result += \"E\"\n        case 'G':\n        case 'g':\n            result +=\
    \ \"H\"\n        case 'H':\n        case 'h':\n            result += \"G\"\n \
    \       case 'I':\n        case 'i':\n            result += \"J\"\n        case\
    \ 'J':\n        case 'j':\n            result += \"I\"\n        case 'K':\n  \
    \      case 'k':\n            result += \"L\"\n        case 'L':\n        case\
    \ 'l':\n            result += \"K\"\n        case 'M':\n        case 'm':\n  \
    \          result += \"N\"\n        case 'N':\n        case 'n':\n           \
    \ result += \"M\"\n        case 'O':\n        case 'o':\n            result +=\
    \ \"P\"\n        case 'P':\n        case 'p':\n            result += \"O\"\n \
    \       case 'Q':\n        case 'q':\n            result += \"R\"\n        case\
    \ 'R':\n        case 'r':\n            result += \"Q\"\n        case 'S':\n  \
    \      case 's':\n            result += \"T\"\n        case 'T':\n        case\
    \ 't':\n            result += \"S\"\n        case 'U':\n        case 'u':\n  \
    \          result += \"V\"\n        case 'V':\n        case 'v':\n           \
    \ result += \"U\"\n        case 'W':\n        case 'w':\n            result +=\
    \ \"X\"\n        case 'X':\n        case 'x':\n            result += \"W\"\n \
    \       case 'Y':\n        case 'y':\n            result += \"Z\"\n        case\
    \ 'Z':\n        case 'z':\n            result += \"Y\"\n        default:\n   \
    \         result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw858a6_6.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmpw858a6_6.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'a':\n   \
    \          ^~~\n             \"a\"\n/tmp/tmpw858a6_6.swift:15:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'B':\n             ^~~\n      \
    \       \"B\"\n/tmp/tmpw858a6_6.swift:15:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'B':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw858a6_6.swift:16:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'b':\n             ^~~\n             \"\
    b\"\n/tmp/tmpw858a6_6.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'C':\n             ^~~\n             \"C\"\n/tmp/tmpw858a6_6.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'C':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmpw858a6_6.swift:21:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'D':\n             ^~~\n      \
    \       \"D\"\n/tmp/tmpw858a6_6.swift:21:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'D':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw858a6_6.swift:22:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'd':\n             ^~~\n             \"\
    d\"\n/tmp/tmpw858a6_6.swift:24:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'E':\n             ^~~\n             \"E\"\n/tmp/tmpw858a6_6.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'E':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            result = char.uppercaseString\
    \ + result\n        case let c where !c.isLetter:\n            result = c + result\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp22k9l4vt.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp22k9l4vt.swift:13:27:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   result = char.uppercaseString + result\n                     ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp22k9l4vt.swift:15:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = c + result\n      \
    \               ^\n/tmp/tmp22k9l4vt.swift:11:9: error: switch must be exhaustive\n\
    \        switch char {\n        ^\n/tmp/tmp22k9l4vt.swift:11:9: note: do you want\
    \ to add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char.lowercased() {\n            case \"a\":\n             \
    \   result += \"A\"\n            case \"b\":\n                result += \"B\"\n\
    \            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkugv4e0x.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpkugv4e0x.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpkugv4e0x.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n        case \"b\":\n        case \"c\":\n        case \"d\":\n    \
    \    case \"e\":\n        case \"f\":\n        case \"g\":\n        case \"h\"\
    :\n        case \"i\":\n        case \"j\":\n        case \"k\":\n        case\
    \ \"l\":\n        case \"m\":\n        case \"n\":\n        case \"o\":\n    \
    \    case \"p\":\n        case \"q\":\n        case \"r\":\n        case \"s\"\
    :\n        case \"t\":\n        case \"u\":\n        case \"v\":\n        case\
    \ \"w\":\n        case \"x\":\n        case \"y\":\n        case \"z\":\n    \
    \    case \"A\":\n        case \"B\":\n        case \"C\":\n        case \"D\"\
    :\n        case \"E\":\n        case \"F\":\n        case \"G\":\n        case\
    \ \"H\":\n        case \"I\":\n        case \"J\":\n        case \"K\":\n    \
    \    case \"L\":\n        case \"M\":\n        case \"N\":\n        case \"O\"\
    :\n        case \"P\":\n        case \"Q\":\n        case \"R\":\n        case\
    \ \"S\":\n        case \"T\":\n        case \"U\":\n        case \"V\":\n    \
    \    case \"W\":\n        case \"X\":\n        case \"Y\":\n        case \"Z\"\
    :\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case\
    \ \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n    \
    \    case \"7\":\n        case \"8\":\n        case \"9\":\n        case \"+\"\
    :\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case\
    \ \"%\":\n        case \"&\":\n        case \"|\":\n        case \"!\":\n    \
    \    case \"@\":\n        case \"#\":\n        case \"$\":\n        case \"%\"\
    :\n        case \"^\":\n        case \"&\":\n        case \"*\":\n        case\
    \ \"(\":\n        case \")\":\n        case \"[\":\n        case \"]\":\n    \
    \    case \"{\":\n        case \"}\":\n        case \"<\":\n        case \">\"\
    :\n        case \"/\":\n        case \"?\":\n        case \"=\":\n        case\
    \ \"\\\\\":\n        case \"|\":\n        case \"`\":\n        case \"~\":\n \
    \       case \"`\":\n        case \"{\":\n        case \"}\":\n        case \"\
    [\":\n        case \"]\":\n        case \"(\":\n        case \")\":\n        case\
    \ \"<\":\n        case \">\":\n        case \"/\":\n        case \"?\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmputvfr5tk.swift:12:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmputvfr5tk.swift:13:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:14:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:16:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:17:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmputvfr5tk.swift:24:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter() {\n     \
    \       res = char.uppercased() + res\n        } else {\n            res = char\
    \ + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx83bxnqz.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpx83bxnqz.swift:14:19: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            res = char\
    \ + res\n                  ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += char.lowercaseString\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1pszz0gd.swift:12:28: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            result += char.lowercaseString\n            \
    \          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp1pszz0gd.swift:14:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, char) -> String in\n\
    \        if let _ = String(char).range(of: String(result)) {\n            return\
    \ String(char).uppercased()\n        } else {\n            return String(char).lowercased()\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpty4h4fp9.swift:10:33: error: value of type 'String' has no member\
    \ 'range'\n        if let _ = String(char).range(of: String(result)) {\n     \
    \              ~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\"\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += \"a\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpupll74oc.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpupll74oc.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpupll74oc.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpupll74oc.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpupll74oc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpupll74oc.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char {\n            case \"A\":\n                result += \"\
    B\"\n            case \"B\":\n                result += \"A\"\n            case\
    \ \"C\":\n                result += \"D\"\n            case \"D\":\n         \
    \       result += \"C\"\n            case \"E\":\n                result += \"\
    F\"\n            case \"F\":\n                result += \"E\"\n            case\
    \ \"G\":\n                result += \"H\"\n            case \"H\":\n         \
    \       result += \"G\"\n            case \"I\":\n                result += \"\
    J\"\n            case \"J\":\n                result += \"I\"\n            case\
    \ \"K\":\n                result += \"L\"\n            case \"L\":\n         \
    \       result += \"K\"\n            case \"M\":\n                result += \"\
    N\"\n            case \"N\":\n                result += \"M\"\n            case\
    \ \"O\":\n                result += \"P\"\n            case \"P\":\n         \
    \       result += \"O\"\n            case \"Q\":\n                result += \"\
    R\"\n            case \"R\":\n                result += \"Q\"\n            case\
    \ \"S\":\n                result += \"T\"\n            case \"T\":\n         \
    \       result += \"S\"\n            case \"U\":\n                result += \"\
    V\"\n            case \"V\":\n                result += \"U\"\n            case\
    \ \"W\":\n                result += \"X\"\n            case \"X\":\n         \
    \       result += \"W\"\n            case \"Y\":\n                result += \"\
    Z\"\n            case \"Z\":\n                result += \"Y\"\n            default:\n\
    \                result += char\n            }\n        } else {\n           \
    \ result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxablte8d.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpxablte8d.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpxablte8d.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, char) -> String in\n\
    \        if let c = Character(char) {\n            switch c.unicodeScalars.first!.value\
    \ {\n            case 0x41:\n                let upper = Character(UnicodeScalar(c.unicodeScalars.first!.value).value\
    \ + 32)\n                return result + String(UnicodeScalar(upper).value)\n\
    \            case 0x42:\n                let lower = Character(UnicodeScalar(c.unicodeScalars.first!.value).value\
    \ - 32)\n                return result + String(UnicodeScalar(lower).value)\n\
    \            default:\n                return result + char\n            }\n \
    \       } else {\n            return result + char\n        }\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpf8mn9obu.swift:10:30: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        if let c = Character(char) {\n                            \
    \ ^\n                             extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += char.lowercaseString\n        case 'A':\n\
    \        case 'E':\n        case 'I':\n        case 'O':\n        case 'U':\n\
    \            result += char.uppercaseString\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy6qqmx5a.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpy6qqmx5a.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpy6qqmx5a.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpy6qqmx5a.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpy6qqmx5a.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpy6qqmx5a.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'A':\n             ^~~\n      \
    \       \"A\"\n/tmp/tmpy6qqmx5a.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'A':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpy6qqmx5a.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'E':\n             ^~~\n             \"\
    E\"\n/tmp/tmpy6qqmx5a.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'E':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpy6qqmx5a.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'I':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += String(c).uppercased()\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += String(c).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqymukwfo.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpqymukwfo.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpqymukwfo.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpqymukwfo.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpqymukwfo.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqymukwfo.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char {\n            case \"A\":\n                result += \"\
    B\"\n            case \"B\":\n                result += \"A\"\n            case\
    \ \"C\":\n                result += \"D\"\n            case \"D\":\n         \
    \       result += \"C\"\n            case \"E\":\n                result += \"\
    F\"\n            case \"F\":\n                result += \"E\"\n            case\
    \ \"G\":\n                result += \"H\"\n            case \"H\":\n         \
    \       result += \"G\"\n            case \"I\":\n                result += \"\
    J\"\n            case \"J\":\n                result += \"I\"\n            case\
    \ \"K\":\n                result += \"L\"\n            case \"L\":\n         \
    \       result += \"K\"\n            case \"M\":\n                result += \"\
    N\"\n            case \"N\":\n                result += \"M\"\n            case\
    \ \"O\":\n                result += \"P\"\n            case \"P\":\n         \
    \       result += \"O\"\n            case \"Q\":\n                result += \"\
    R\"\n            case \"R\":\n                result += \"Q\"\n            case\
    \ \"S\":\n                result += \"T\"\n            case \"T\":\n         \
    \       result += \"S\"\n            case \"U\":\n                result += \"\
    V\"\n            case \"V\":\n                result += \"U\"\n            case\
    \ \"W\":\n                result += \"X\"\n            case \"X\":\n         \
    \       result += \"W\"\n            case \"Y\":\n                result += \"\
    Z\"\n            case \"Z\":\n                result += \"Y\"\n            default:\n\
    \                result += char\n            }\n        } else {\n           \
    \ result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxablte8d.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpxablte8d.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpxablte8d.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxzrubi4c.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxzrubi4c.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:17:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += char.lowercaseString\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1pszz0gd.swift:12:28: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            result += char.lowercaseString\n            \
    \          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp1pszz0gd.swift:14:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter {\n       \
    \     res += String(char.uppercased())\n        } else {\n            res += char\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmh7e_qq7.swift:14:20: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            res += char\n              \
    \     ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += \"A\"\n         \
    \   case let c as Character.uppercaseLetter:\n                result += \"a\"\n\
    \            default:\n                result += c\n            }\n        case\
    \ let c as Character.whitespace:\n            result += \" \"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpifz2462p.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpifz2462p.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpifz2462p.swift:21:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmpifz2462p.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpifz2462p.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpifz2462p.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpifz2462p.swift:24:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += String(char.lowercase)\n        default:\n\
    \            result += String(char)\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp21ubu34i.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp21ubu34i.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmp21ubu34i.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp21ubu34i.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmp21ubu34i.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmp21ubu34i.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmp21ubu34i.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmp21ubu34i.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmp21ubu34i.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmp21ubu34i.swift:10:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp21ubu34i.swift:17:35: error: value of type 'Character' has no member\
    \ 'lowercase'\n            result += String(char.lowercase)\n                \
    \             ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += char.lowercaseString\n        case 'A':\n\
    \        case 'E':\n        case 'I':\n        case 'O':\n        case 'U':\n\
    \            result += char.uppercaseString\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy6qqmx5a.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpy6qqmx5a.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpy6qqmx5a.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpy6qqmx5a.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpy6qqmx5a.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpy6qqmx5a.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'A':\n             ^~~\n      \
    \       \"A\"\n/tmp/tmpy6qqmx5a.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'A':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpy6qqmx5a.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'E':\n             ^~~\n             \"\
    E\"\n/tmp/tmpy6qqmx5a.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'E':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpy6qqmx5a.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'I':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            switch char {\n         \
    \   case let .uppercase(let char):\n                result += char\n         \
    \   case let .lowercase(let char):\n                result += char.uppercased()\n\
    \            case let .uppercase(let char):\n                result += char.lowercased()\n\
    \            default:\n                result += char\n            }\n       \
    \ case let .uppercase(let char):\n            result += char\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8h53t7uu.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmp8h53t7uu.swift:14:33: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n            case let .uppercase(let\
    \ char):\n                                ^\n/tmp/tmp8h53t7uu.swift:16:33: error:\
    \ 'let' cannot appear nested inside another 'var' or 'let' pattern\n         \
    \   case let .lowercase(let char):\n                                ^\n/tmp/tmp8h53t7uu.swift:18:33:\
    \ error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  \
    \          case let .uppercase(let char):\n                                ^\n\
    /tmp/tmp8h53t7uu.swift:23:29: error: 'let' cannot appear nested inside another\
    \ 'var' or 'let' pattern\n        case let .uppercase(let char):\n           \
    \                 ^\n/tmp/tmp8h53t7uu.swift:10:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in s.characters {\n               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8h53t7uu.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmp8h53t7uu.swift:23:19: error: type\
    \ 'Character' has no member 'uppercase'\n        case let .uppercase(let char):\n\
    \                 ~^~~~~~~~~\n/tmp/tmp8h53t7uu.swift:26:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            res += String(char.uppercased())\n        } else {\n        \
    \    res += String(char)\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9j9ndcz.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiovfmf95.swift:9:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979349
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"\\(c)\"\
    \n        case let c where c >= 'A' && c <= 'Z':\n            result += \"\\(c)\"\
    \n        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmped7mwmy1.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmped7mwmy1.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmped7mwmy1.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmped7mwmy1.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmped7mwmy1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmped7mwmy1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter()\
    \ {\n            let upperCaseChar = char.uppercased()\n            if upperCaseChar\
    \ == char {\n                result += char\n            } else {\n          \
    \      result += upperCaseChar\n            }\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcv7gn2j2.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcv7gn2j2.swift:11:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpcv7gn2j2.swift:13:30:\
    \ error: binary operator '==' cannot be applied to operands of type 'String' and\
    \ 'Character'\n            if upperCaseChar == char {\n               ~~~~~~~~~~~~~\
    \ ^  ~~~~\n/tmp/tmpcv7gn2j2.swift:13:30: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \            if upperCaseChar == char {\n                             ^\n/tmp/tmpcv7gn2j2.swift:14:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmpcv7gn2j2.swift:19:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += \"A\"\n        case 'b':\n        case\
    \ 'f':\n        case 'n':\n        case 'r':\n            result += \"B\"\n  \
    \      case 'c':\n        case 'h':\n        case 'k':\n        case 'p':\n  \
    \          result += \"C\"\n        case 'd':\n        case 'j':\n        case\
    \ 'q':\n        case 's':\n            result += \"D\"\n        case 'e':\n  \
    \      case 'h':\n        case 'l':\n        case 'n':\n            result +=\
    \ \"E\"\n        case 'f':\n        case 'o':\n        case 'r':\n        case\
    \ 'u':\n            result += \"F\"\n        case 'g':\n        case 'k':\n  \
    \      case 'p':\n            result += \"G\"\n        case 'h':\n        case\
    \ 'j':\n        case 'q':\n        case 's':\n            result += \"H\"\n  \
    \      case 'i':\n        case 'k':\n        case 'p':\n            result +=\
    \ \"I\"\n        case 'j':\n        case 'q':\n        case 's':\n           \
    \ result += \"J\"\n        case 'k':\n        case 'p':\n            result +=\
    \ \"K\"\n        case 'l':\n        case 'n':\n            result += \"L\"\n \
    \       case 'm':\n        case 'o':\n        case 'r':\n        case 'u':\n \
    \           result += \"M\"\n        case 'n':\n        case 'r':\n        case\
    \ 'u':\n            result += \"N\"\n        case 'o':\n        case 'r':\n  \
    \      case 'u':\n            result += \"O\"\n        case 'p':\n        case\
    \ 'q':\n        case 's':\n            result += \"P\"\n        case 'r':\n  \
    \      case 'u':\n            result += \"R\"\n        case 's':\n        case\
    \ 't':\n        case 'u':\n            result += \"S\"\n        case 't':\n  \
    \      case 'u':\n            result += \"T\"\n        case 'u':\n           \
    \ result += \"U\"\n        case 'v':\n            result += \"V\"\n        case\
    \ 'w':\n            result += \"W\"\n        case 'x':\n            result +=\
    \ \"X\"\n        case 'y':\n            result += \"Y\"\n        case 'z':\n \
    \           result += \"Z\"\n        default:\n            result += char\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw8bt6uhv.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw8bt6uhv.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw8bt6uhv.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw8bt6uhv.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw8bt6uhv.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpw8bt6uhv.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw8bt6uhv.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpw8bt6uhv.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw8bt6uhv.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpw8bt6uhv.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'b':\n             ^~~\n      \
    \       \"b\"\n/tmp/tmpw8bt6uhv.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'b':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw8bt6uhv.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'f':\n             ^~~\n             \"\
    f\"\n/tmp/tmpw8bt6uhv.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'f':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpw8bt6uhv.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'n':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxzrubi4c.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxzrubi4c.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:17:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += \"A\"\n        case 'b':\n        case\
    \ 'f':\n        case 'n':\n        case 'r':\n        case 's':\n            result\
    \ += \"B\"\n        case 'c':\n        case 'g':\n        case 'm':\n        case\
    \ 'p':\n        case 't':\n            result += \"C\"\n        case 'd':\n  \
    \      case 'h':\n        case 'j':\n        case 'k':\n        case 'l':\n  \
    \          result += \"D\"\n        case 'e':\n        case 'j':\n        case\
    \ 'm':\n        case 'p':\n        case 's':\n            result += \"E\"\n  \
    \      case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n  \
    \          result += \"F\"\n        case 'g':\n        case 'n':\n        case\
    \ 's':\n            result += \"G\"\n        case 'h':\n        case 'p':\n  \
    \      case 't':\n            result += \"H\"\n        case 'i':\n        case\
    \ 'o':\n        case 'u':\n            result += \"I\"\n        case 'j':\n  \
    \      case 'k':\n        case 'l':\n            result += \"J\"\n        case\
    \ 'k':\n        case 'l':\n            result += \"K\"\n        case 'm':\n  \
    \      case 'p':\n        case 'r':\n            result += \"M\"\n        case\
    \ 'n':\n        case 'r':\n        case 's':\n            result += \"N\"\n  \
    \      case 'p':\n        case 's':\n            result += \"P\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9orhro5u.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp9orhro5u.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9orhro5u.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp9orhro5u.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9orhro5u.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmp9orhro5u.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9orhro5u.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmp9orhro5u.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9orhro5u.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmp9orhro5u.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'b':\n             ^~~\n      \
    \       \"b\"\n/tmp/tmp9orhro5u.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'b':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp9orhro5u.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'f':\n             ^~~\n             \"\
    f\"\n/tmp/tmp9orhro5u.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'f':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmp9orhro5u.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'n':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        if let c = c.toUppercase() {\n            return result + c\n       \
    \ }\n        return result + c\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw8r36q9z.swift:10:22: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toUppercase'\n        if let c = c.toUppercase()\
    \ {\n                   ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += \"A\"\n        case 'b':\n        case\
    \ 'f':\n        case 'n':\n        case 'r':\n        case 's':\n            result\
    \ += \"B\"\n        case 'c':\n        case 'd':\n        case 'm':\n        case\
    \ 'p':\n        case 'v':\n            result += \"C\"\n        case 'e':\n  \
    \      case 'f':\n        case 'g':\n        case 'h':\n        case 'j':\n  \
    \          result += \"D\"\n        case 'f':\n        case 'g':\n        case\
    \ 'h':\n        case 'j':\n            result += \"E\"\n        case 'a':\n  \
    \      case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n  \
    \      case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n  \
    \      case 'j':\n            result += \"F\"\n        case 'a':\n        case\
    \ 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case\
    \ 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n        case\
    \ 'j':\n            result += \"G\"\n        case 'a':\n        case 'b':\n  \
    \      case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n  \
    \      case 'g':\n        case 'h':\n        case 'i':\n        case 'j':\n  \
    \          result += \"H\"\n        case 'a':\n        case 'b':\n        case\
    \ 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case\
    \ 'g':\n        case 'h':\n        case 'i':\n        case 'j':\n            result\
    \ += \"I\"\n        case 'a':\n        case 'b':\n        case 'c':\n        case\
    \ 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n        case\
    \ 'h':\n        case 'i':\n        case 'j':\n            result += \"J\"\n  \
    \      case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n  \
    \      case 'e':\n        case 'f':\n        case 'g':\n        case 'h':\n  \
    \      case 'i':\n        case 'j':\n            result += \"K\"\n        case\
    \ 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case\
    \ 'e':\n        case 'f':\n        case 'g':\n        case 'h':\n        case\
    \ 'i':\n        case 'j':\n            result += \"L\"\n        case 'a':\n  \
    \      case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n  \
    \      case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n  \
    \      case 'j':\n            result += \"M\"\n        case 'a':\n        case\
    \ 'b':\n        case 'c':\n        case '\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzv417b5t.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpzv417b5t.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpzv417b5t.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpzv417b5t.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpzv417b5t.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpzv417b5t.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpzv417b5t.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpzv417b5t.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpzv417b5t.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpzv417b5t.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'b':\n             ^~~\n      \
    \       \"b\"\n/tmp/tmpzv417b5t.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'b':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpzv417b5t.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'f':\n             ^~~\n             \"\
    f\"\n/tmp/tmpzv417b5t.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'f':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpzv417b5t.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'n':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"\\(c)\"\
    \n        case let c where c >= 'A' && c <= 'Z':\n            result += \"\\(c)\"\
    \n        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmped7mwmy1.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmped7mwmy1.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmped7mwmy1.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmped7mwmy1.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmped7mwmy1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmped7mwmy1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += char.lowercaseString\n        case 'b':\n\
    \        case 'f':\n        case 'h':\n        case 'j':\n        case 'k':\n\
    \        case 'l':\n            result += char.uppercaseString\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpf5rhs00q.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpf5rhs00q.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpf5rhs00q.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpf5rhs00q.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpf5rhs00q.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpf5rhs00q.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpf5rhs00q.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpf5rhs00q.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpf5rhs00q.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpf5rhs00q.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'b':\n             ^~~\n      \
    \       \"b\"\n/tmp/tmpf5rhs00q.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'b':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpf5rhs00q.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'f':\n             ^~~\n             \"\
    f\"\n/tmp/tmpf5rhs00q.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'f':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpf5rhs00q.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'h':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s.characters {\n        switch char {\n \
    \       case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n \
    \       case 'u':\n            char += char.lowercased()\n        case 'A':\n\
    \        case 'E':\n        case 'I':\n        case 'O':\n        case 'U':\n\
    \            char += char.uppercased()\n        default:\n            res = char\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpncqswbcv.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpncqswbcv.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpncqswbcv.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpncqswbcv.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpncqswbcv.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpncqswbcv.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpncqswbcv.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpncqswbcv.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpncqswbcv.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpncqswbcv.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'A':\n             ^~~\n      \
    \       \"A\"\n/tmp/tmpncqswbcv.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'A':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpncqswbcv.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'E':\n             ^~~\n             \"\
    E\"\n/tmp/tmpncqswbcv.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'E':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpncqswbcv.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'I':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            switch char.lowercaseString {\n            case \"a\":\n    \
    \            result += \"B\"\n            case \"b\":\n                result\
    \ += \"a\"\n            case \"c\":\n                result += \"D\"\n       \
    \     case \"d\":\n                result += \"c\"\n            case \"e\":\n\
    \                result += \"f\"\n            case \"f\":\n                result\
    \ += \"e\"\n            case \"g\":\n                result += \"h\"\n       \
    \     case \"h\":\n                result += \"g\"\n            case \"i\":\n\
    \                result += \"j\"\n            case \"j\":\n                result\
    \ += \"i\"\n            case \"k\":\n                result += \"l\"\n       \
    \     case \"l\":\n                result += \"k\"\n            case \"m\":\n\
    \                result += \"n\"\n            case \"n\":\n                result\
    \ += \"m\"\n            case \"o\":\n                result += \"p\"\n       \
    \     case \"p\":\n                result += \"o\"\n            case \"q\":\n\
    \                result += \"r\"\n            case \"r\":\n                result\
    \ += \"q\"\n            case \"s\":\n                result += \"t\"\n       \
    \     case \"t\":\n                result += \"s\"\n            case \"u\":\n\
    \                result += \"v\"\n            case \"v\":\n                result\
    \ += \"u\"\n            case \"w\":\n                result += \"x\"\n       \
    \     case \"x\":\n                result += \"w\"\n            case \"y\":\n\
    \                result += \"z\"\n            case \"z\":\n                result\
    \ += \"y\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg7g9duer.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpg7g9duer.swift:12:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpg7g9duer.swift:66:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmpg7g9duer.swift:69:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        case let c as String:\n            result += c\n       \
    \ default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpprlfx_hr.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpprlfx_hr.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpprlfx_hr.swift:21:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpprlfx_hr.swift:14:37: error: 'lowercaseLetter'\
    \ is not a member type of struct 'Swift.Character'\n            case let c as\
    \ Character.lowercaseLetter:\n                          ~~~~~~~~~ ^\nSwift.Character:1:23:\
    \ note: 'Character' declared here\n@frozen public struct Character : Sendable\
    \ {\n                      ^\n/tmp/tmpprlfx_hr.swift:16:37: error: 'uppercaseLetter'\
    \ is not a member type of struct 'Swift.Character'\n            case let c as\
    \ Character.uppercaseLetter:\n                          ~~~~~~~~~ ^\nSwift.Character:1:23:\
    \ note: 'Character' declared here\n@frozen public struct Character : Sendable\
    \ {\n                      ^\n/tmp/tmpprlfx_hr.swift:19:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += c\n                          ^\n/tmp/tmpprlfx_hr.swift:24:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"\\(c)\"\
    \n        case let c where c >= 'A' && c <= 'Z':\n            result += \"\\(c)\"\
    \n        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmped7mwmy1.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmped7mwmy1.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmped7mwmy1.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmped7mwmy1.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmped7mwmy1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmped7mwmy1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        guard let c = c.toUppercase() else { return result }\n        return\
    \ result + c\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_4n4ifmk.swift:10:25: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toUppercase'\n        guard let c = c.toUppercase()\
    \ else { return result }\n                      ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            result += c.uppercased()\n\
    \        case let c where !c.isLetter:\n            result += c\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5d62but7.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5d62but7.swift:15:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += c\n                      ^\n/tmp/tmp5d62but7.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char.lowercased() {\n            case \"a\":\n             \
    \   result += \"A\"\n            case \"b\":\n                result += \"B\"\n\
    \            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkugv4e0x.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpkugv4e0x.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpkugv4e0x.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += c.uppercased()\n            case .uppercase:\n    \
    \            result += c.lowercased()\n            default:\n                result\
    \ += c\n            }\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph28vvb26.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph28vvb26.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmph28vvb26.swift:14:19: error: type 'Character' has no\
    \ member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmph28vvb26.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmph28vvb26.swift:19:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += c\n                          ^\n/tmp/tmph28vvb26.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        if let c = c.uppercased() {\n            return result + c\n        }\
    \ else {\n            return result + c.lowercased()\n        }\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv1jadfwl.swift:10:12: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n        if let c = c.uppercased() {\n\
    \           ^       ~~~~~~~~~~~~~~\n/tmp/tmpv1jadfwl.swift:9:14: error: 'characters'\
    \ is unavailable: Please use String directly\n    return s.characters.reversed().reduce(\"\
    \") { (result, c) -> String in\n             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result = char.uppercaseString + result\n        } else {\n  \
    \          result = char.lowercaseString + result\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpt1s92lm8.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpt1s92lm8.swift:12:27:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   result = char.uppercaseString + result\n                     ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpt1s92lm8.swift:14:27: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            result = char.lowercaseString + result\n                     ~~~~\
    \ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        switch char.lowercaseString {\n            case \"a\":\n            \
    \    result += \"A\"\n            case \"b\":\n                result += \"B\"\
    \n            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgbsi058e.swift:12:25: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            switch char.lowercaseString {\n             \
    \      ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpgbsi058e.swift:66:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += char\n                          ^\n/tmp/tmpgbsi058e.swift:69:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != lower {\n                result += upper\n          \
    \  } else {\n                result += lower\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwzlyv62e.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpwzlyv62e.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\"\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += \"a\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpupll74oc.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpupll74oc.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpupll74oc.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpupll74oc.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpupll74oc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpupll74oc.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        if let c = c.toUpper() {\n            return result + c\n        }\n\
    \        return result + c\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp60316duf.swift:10:22: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toUpper'\n        if let c = c.toUpper() {\n   \
    \                ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += \"A\"\n        case 'b':\n        case\
    \ 'f':\n        case 'n':\n        case 'r':\n        case 's':\n            result\
    \ += \"B\"\n        case 'c':\n        case 'd':\n        case 'm':\n        case\
    \ 'p':\n        case 't':\n            result += \"C\"\n        case 'e':\n  \
    \      case 'g':\n        case 'h':\n        case 'j':\n            result +=\
    \ \"D\"\n        case 'f':\n        case 'k':\n        case 'l':\n        case\
    \ 'n':\n            result += \"E\"\n        case 'g':\n        case 'j':\n  \
    \      case 'p':\n        case 's':\n            result += \"F\"\n        case\
    \ 'h':\n        case 'k':\n        case 'n':\n            result += \"G\"\n  \
    \      case 'i':\n        case 'l':\n        case 'r':\n        case 's':\n  \
    \          result += \"H\"\n        case 'j':\n        case 'p':\n        case\
    \ 't':\n            result += \"I\"\n        case 'k':\n        case 'n':\n  \
    \          result += \"J\"\n        case 'l':\n        case 'r':\n        case\
    \ 't':\n            result += \"K\"\n        case 'm':\n        case 'p':\n  \
    \      case 's':\n            result += \"L\"\n        case 'n':\n        case\
    \ 'r':\n        case 't':\n            result += \"M\"\n        case 'p':\n  \
    \      case 't':\n            result += \"N\"\n        case 's':\n           \
    \ result += \"O\"\n        case 't':\n            result += \"P\"\n        case\
    \ 'u':\n            result += \"Q\"\n        case 'v':\n            result +=\
    \ \"R\"\n        case 'w':\n            result += \"S\"\n        case 'x':\n \
    \           result += \"T\"\n        case 'y':\n            result += \"U\"\n\
    \        case 'z':\n            result += \"V\"\n        case 'A':\n         \
    \   result += \"W\"\n        case 'B':\n            result += \"X\"\n        case\
    \ 'C':\n            result += \"Y\"\n        case 'D':\n            result +=\
    \ \"Z\"\n        case 'E':\n            result += \"A\"\n        case 'F':\n \
    \           result += \"B\"\n        case 'G':\n            result += \"C\"\n\
    \        case 'H':\n            result += \"D\"\n        case 'I':\n         \
    \   result += \"E\"\n        case 'J':\n            result += \"F\"\n        case\
    \ 'K':\n            result += \"G\"\n        case 'L':\n            result +=\
    \ \"H\"\n        case 'M':\n            result += \"I\"\n        case 'N':\n \
    \           result += \"J\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmphrafhav1.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmphrafhav1.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmphrafhav1.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmphrafhav1.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmphrafhav1.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmphrafhav1.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmphrafhav1.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmphrafhav1.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmphrafhav1.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmphrafhav1.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'b':\n             ^~~\n      \
    \       \"b\"\n/tmp/tmphrafhav1.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'b':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmphrafhav1.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'f':\n             ^~~\n             \"\
    f\"\n/tmp/tmphrafhav1.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'f':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmphrafhav1.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'n':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter()\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjbho_nb1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjbho_nb1.swift:11:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, char) -> String in\n\
    \        if let c = Character(char) {\n            switch c {\n            case\
    \ .lowercase:\n                result += c.uppercased()\n            case .uppercase:\n\
    \                result += c.lowercased()\n            default:\n            \
    \    result += char\n            }\n        }\n        return result\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0h30tj72.swift:10:30: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        if let c = Character(char) {\n                            \
    \ ^\n                             extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659978910
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += String(char.lowercased())\n        } else {\n            result\
    \ += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpgrnzjghm/tmpgrnzjghm.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b07fd2fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07fcff4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07fcff4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07fcff37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgrnzjghm                        0x000056109fcd0657 <unavailable> + 5719

    5    libc.so.6                          0x00002b07fd4e9460 __libc_start_main +
    245

    6    tmpgrnzjghm                        0x000056109fcd0299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            case .digit:\n                result += \"0\"\
    \n            case .other:\n                result += String(UnicodeScalar(c))\n\
    \            }\n        case let c as UnicodeScalar:\n            result += String(UnicodeScalar(c))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpj11wzjer.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpj11wzjer.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpj11wzjer.swift:23:20: warning: cast from 'Character'\
    \ to unrelated type 'UnicodeScalar' (aka 'Unicode.Scalar') always fails\n    \
    \    case let c as UnicodeScalar:\n                   ^~ ~~~~~~~~~~~~~\n/tmp/tmpj11wzjer.swift:14:19:\
    \ error: type 'Character' has no member 'lowercase'\n            case .lowercase:\n\
    \                 ~^~~~~~~~~\n/tmp/tmpj11wzjer.swift:16:19: error: type 'Character'\
    \ has no member 'uppercase'\n            case .uppercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpj11wzjer.swift:18:19: error: type 'Character' has no member 'digit'\n\
    \            case .digit:\n                 ~^~~~~\n/tmp/tmpj11wzjer.swift:20:19:\
    \ error: type 'Character' has no member 'other'\n            case .other:\n  \
    \               ~^~~~~\n/tmp/tmpj11wzjer.swift:21:34: error: no exact matches\
    \ in call to initializer \n                result += String(UnicodeScalar(c))\n\
    \                                 ^\nSwift.Unicode.Scalar:7:23: note: candidate\
    \ expects value of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'Character')\n    @inlinable public init(_ v: Unicode.Scalar)\n            \
    \          ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'A':\n        case 'a':\n            result += \"B\"\n        case\
    \ 'B':\n        case 'b':\n            result += \"A\"\n        default:\n   \
    \         result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgxfcmg45.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmpgxfcmg45.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmpgxfcmg45.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'a':\n   \
    \          ^~~\n             \"a\"\n/tmp/tmpgxfcmg45.swift:15:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'B':\n             ^~~\n      \
    \       \"B\"\n/tmp/tmpgxfcmg45.swift:15:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'B':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpgxfcmg45.swift:16:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'b':\n             ^~~\n             \"\
    b\"\n/tmp/tmpgxfcmg45.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgxfcmg45.swift:19:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += char.lowercaseString\n        case 'A':\n\
    \        case 'E':\n        case 'I':\n        case 'O':\n        case 'U':\n\
    \            result += char.uppercaseString\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy6qqmx5a.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpy6qqmx5a.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpy6qqmx5a.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpy6qqmx5a.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpy6qqmx5a.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpy6qqmx5a.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'A':\n             ^~~\n      \
    \       \"A\"\n/tmp/tmpy6qqmx5a.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'A':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpy6qqmx5a.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'E':\n             ^~~\n             \"\
    E\"\n/tmp/tmpy6qqmx5a.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'E':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpy6qqmx5a.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'I':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += String(c).uppercased()\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += String(c).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqymukwfo.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpqymukwfo.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpqymukwfo.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpqymukwfo.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpqymukwfo.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqymukwfo.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\" +\
    \ String(c - 'a')\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \  result += \"a\" + String(c - 'A')\n        default:\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjqs4cm9r.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpjqs4cm9r.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpjqs4cm9r.swift:13:40: error:\
    \ single-quoted string literal found, use '\"'\n            result += \"A\" +\
    \ String(c - 'a')\n                                       ^~~\n              \
    \                         \"a\"\n/tmp/tmpjqs4cm9r.swift:14:31: error: single-quoted\
    \ string literal found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n\
    \                              ^~~\n                              \"A\"\n/tmp/tmpjqs4cm9r.swift:14:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'A' && c <= 'Z':\n                                          ^~~\n     \
    \                                     \"Z\"\n/tmp/tmpjqs4cm9r.swift:15:40: error:\
    \ single-quoted string literal found, use '\"'\n            result += \"a\" +\
    \ String(c - 'A')\n                                       ^~~\n              \
    \                         \"A\"\n/tmp/tmpjqs4cm9r.swift:10:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjqs4cm9r.swift:13:38: error: referencing operator function '-' on\
    \ 'SIMD' requires that 'Unicode.Scalar' conform to 'SIMD'\n            result\
    \ += \"A\" + String(c - 'a')\n                                     ^\nSwift.SIMD:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension SIMD where Self.Scalar : FloatingPoint\
    \ {\n          ^\n/tmp/tmpjqs4cm9r.swift:15:38: error: referencing operator function\
    \ '-' on 'SIMD' requires that 'Unicode.Scalar' conform to 'SIMD'\n           \
    \ result += \"a\" + String(c - 'A')\n        "
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += char.lowercaseString\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1pszz0gd.swift:12:28: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            result += char.lowercaseString\n            \
    \          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp1pszz0gd.swift:14:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char.lowercased() {\n            case \"a\":\n             \
    \   result += \"A\"\n            case \"b\":\n                result += \"B\"\n\
    \            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkugv4e0x.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpkugv4e0x.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpkugv4e0x.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter() {\n     \
    \       res = char.lowercased() + res\n        } else {\n            res = char\
    \ + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcug36tdx.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpcug36tdx.swift:14:19: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            res = char\
    \ + res\n                  ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'A':\n        case 'a':\n            result += \"B\"\n        case\
    \ 'B':\n        case 'b':\n            result += \"A\"\n        case 'C':\n  \
    \      case 'c':\n            result += \"D\"\n        case 'D':\n        case\
    \ 'd':\n            result += \"C\"\n        case 'E':\n        case 'e':\n  \
    \          result += \"F\"\n        case 'F':\n        case 'f':\n           \
    \ result += \"E\"\n        case 'G':\n        case 'g':\n            result +=\
    \ \"H\"\n        case 'H':\n        case 'h':\n            result += \"G\"\n \
    \       case 'I':\n        case 'i':\n            result += \"J\"\n        case\
    \ 'J':\n        case 'j':\n            result += \"I\"\n        case 'K':\n  \
    \      case 'k':\n            result += \"L\"\n        case 'L':\n        case\
    \ 'l':\n            result += \"K\"\n        case 'M':\n        case 'm':\n  \
    \          result += \"N\"\n        case 'N':\n        case 'n':\n           \
    \ result += \"M\"\n        case 'O':\n        case 'o':\n            result +=\
    \ \"P\"\n        case 'P':\n        case 'p':\n            result += \"O\"\n \
    \       case 'Q':\n        case 'q':\n            result += \"R\"\n        case\
    \ 'R':\n        case 'r':\n            result += \"Q\"\n        case 'S':\n  \
    \      case 's':\n            result += \"T\"\n        case 'T':\n        case\
    \ 't':\n            result += \"S\"\n        case 'U':\n        case 'u':\n  \
    \          result += \"V\"\n        case 'V':\n        case 'v':\n           \
    \ result += \"U\"\n        case 'W':\n        case 'w':\n            result +=\
    \ \"X\"\n        case 'X':\n        case 'x':\n            result += \"W\"\n \
    \       case 'Y':\n        case 'y':\n            result += \"Z\"\n        case\
    \ 'Z':\n        case 'z':\n            result += \"Y\"\n        default:\n   \
    \         result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw858a6_6.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmpw858a6_6.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'a':\n   \
    \          ^~~\n             \"a\"\n/tmp/tmpw858a6_6.swift:15:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'B':\n             ^~~\n      \
    \       \"B\"\n/tmp/tmpw858a6_6.swift:15:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'B':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw858a6_6.swift:16:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'b':\n             ^~~\n             \"\
    b\"\n/tmp/tmpw858a6_6.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'C':\n             ^~~\n             \"C\"\n/tmp/tmpw858a6_6.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'C':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmpw858a6_6.swift:21:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'D':\n             ^~~\n      \
    \       \"D\"\n/tmp/tmpw858a6_6.swift:21:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'D':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw858a6_6.swift:22:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'd':\n             ^~~\n             \"\
    d\"\n/tmp/tmpw858a6_6.swift:24:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'E':\n             ^~~\n             \"E\"\n/tmp/tmpw858a6_6.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'E':\n        ^~~~~~~~~\n                  break\n/tmp/tmpw858a6_6"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            switch char {\n           \
    \ case let c where c.isUpper:\n                result += c.lowercaseString\n \
    \           case let c where c.isLower:\n                result += c.uppercaseString\n\
    \            default:\n                result += char\n            }\n       \
    \ default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz0q_kv69.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpz0q_kv69.swift:14:32:\
    \ error: value of type 'Character' has no member 'isUpper'\n            case let\
    \ c where c.isUpper:\n                             ~ ^~~~~~~\n/tmp/tmpz0q_kv69.swift:16:32:\
    \ error: value of type 'Character' has no member 'isLower'\n            case let\
    \ c where c.isLower:\n                             ~ ^~~~~~~\n/tmp/tmpz0q_kv69.swift:15:29:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \       result += c.lowercaseString\n                          ~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpz0q_kv69.swift:17:29: error: value of type 'Character' has no member 'uppercaseString'\n\
    \                result += c.uppercaseString\n                          ~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpz0q_kv69.swift:19:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result += char\n       \
    \                   ^\n/tmp/tmpz0q_kv69.swift:22:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        let upperCase = char.uppercased()\n            let lowerCase = char.lowercased()\n\
    \            if upperCase == lowerCase {\n                result += upperCase\n\
    \            } else {\n                result += lowerCase\n            }\n  \
    \      } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpn2tqpgk5.swift:20:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            result += \"\\(c)\"\n     \
    \   case let c where !c.isLetter:\n            result += char\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5t3popqh.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5t3popqh.swift:15:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmp5t3popqh.swift:11:9:\
    \ error: switch must be exhaustive\n        switch char {\n        ^\n/tmp/tmp5t3popqh.swift:11:9:\
    \ note: do you want to add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s.characters {\n        switch char {\n \
    \       case 'a':\n            res += \"A\"\n        case 'b':\n            res\
    \ += \"B\"\n        case 'c':\n            res += \"C\"\n        case 'd':\n \
    \           res += \"D\"\n        case 'e':\n            res += \"E\"\n      \
    \  case 'f':\n            res += \"F\"\n        case 'g':\n            res +=\
    \ \"G\"\n        case 'h':\n            res += \"H\"\n        case 'i':\n    \
    \        res += \"I\"\n        case 'j':\n            res += \"J\"\n        case\
    \ 'k':\n            res += \"K\"\n        case 'l':\n            res += \"L\"\n\
    \        case 'm':\n            res += \"M\"\n        case 'n':\n            res\
    \ += \"N\"\n        case 'o':\n            res += \"O\"\n        case 'p':\n \
    \           res += \"P\"\n        case 'q':\n            res += \"Q\"\n      \
    \  case 'r':\n            res += \"R\"\n        case 's':\n            res +=\
    \ \"S\"\n        case 't':\n            res += \"T\"\n        case 'u':\n    \
    \        res += \"U\"\n        case 'v':\n            res += \"V\"\n        case\
    \ 'w':\n            res += \"W\"\n        case 'x':\n            res += \"X\"\n\
    \        case 'y':\n            res += \"Y\"\n        case 'z':\n            res\
    \ += \"Z\"\n        default:\n            res += char\n        }\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp295tmf1z.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp295tmf1z.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp295tmf1z.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmp295tmf1z.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmp295tmf1z.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp295tmf1z.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmp295tmf1z.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmp295tmf1z.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmp295tmf1z.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmp295tmf1z.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmp295tmf1z.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmp295tmf1z.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmp295tmf1z.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmp295tmf1z.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmp295tmf1z.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmp295tmf1z.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            res = char.uppercaseString + res\n        } else {\n        \
    \    res = char + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx2fptzun.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpx2fptzun.swift:12:24:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   res = char.uppercaseString + res\n                  ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpx2fptzun.swift:14:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            res = char + res\n         \
    \         ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            let upper = char.uppercaseString\n            let lower = char.lowercaseString\n\
    \            if upper != lower {\n                result += upper\n          \
    \  } else {\n                result += lower\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3j3ecgjo.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3j3ecgjo.swift:12:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp3j3ecgjo.swift:13:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp3j3ecgjo.swift:20:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          result += char.lowercased()\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvmt0vgn2.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpvmt0vgn2.swift:14:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, char) -> String in\n\
    \        guard let result = result.characters.last else {\n            return\
    \ result + String(char)\n        }\n        guard let lastChar = result.characters.last\
    \ else {\n            return result + String(char)\n        }\n        guard char.isUppercase\
    \ else {\n            return result + String(lastChar)\n        }\n        return\
    \ result + String(char.lowercased())\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsqdeb3jz.swift:13:37: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'characters'\n        guard let lastChar = result.characters.last\
    \ else {\n                             ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\":\n    \
    \    case \"u\":\n            result += char.lowercased()\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqw3o2d4z.swift:12:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpqw3o2d4z.swift:13:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpqw3o2d4z.swift:14:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqw3o2d4z.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqw3o2d4z.swift:19:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        switch char.lowercaseString {\n            case \"a\":\n            \
    \    result += \"A\"\n            case \"b\":\n                result += \"B\"\
    \n            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgbsi058e.swift:12:25: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            switch char.lowercaseString {\n             \
    \      ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpgbsi058e.swift:66:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += char\n                          ^\n/tmp/tmpgbsi058e.swift:69:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != lower  {\n                result += upper\n         \
    \   } else {\n                result += lower\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyibnklbn.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpyibnklbn.swift:20:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            switch char {\n           \
    \ case let c where c.isLower:\n                result = result + c.uppercased()\n\
    \            case let c where c.isUpper:\n                result = result + c.lowercased()\n\
    \            default:\n                result = result + char\n            }\n\
    \        case let c where !c.isLetter:\n            result = result + char\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvrcpqvon.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvrcpqvon.swift:14:32:\
    \ error: value of type 'Character' has no member 'isLower'\n            case let\
    \ c where c.isLower:\n                             ~ ^~~~~~~\n/tmp/tmpvrcpqvon.swift:16:32:\
    \ error: value of type 'Character' has no member 'isUpper'\n            case let\
    \ c where c.isUpper:\n                             ~ ^~~~~~~\n/tmp/tmpvrcpqvon.swift:19:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result = result + char\n                                  ^\n\
    /tmp/tmpvrcpqvon.swift:22:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = result + char\n   \
    \                           ^\n/tmp/tmpvrcpqvon.swift:11:9: error: switch must\
    \ be exhaustive\n        switch char {\n        ^\n/tmp/tmpvrcpqvon.swift:11:9:\
    \ note: do you want to add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxzrubi4c.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxzrubi4c.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:17:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            default:\n                result += c\n     \
    \       }\n        case let c as String:\n            result += c\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmtq0gt0p.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmtq0gt0p.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpmtq0gt0p.swift:21:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpmtq0gt0p.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpmtq0gt0p.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpmtq0gt0p.swift:19:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += c\n                          ^\n/tmp/tmpmtq0gt0p.swift:24:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        case let c as Character.whitespace:\n            result\
    \ += c\n        default:\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpql75hy1q.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpql75hy1q.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpql75hy1q.swift:21:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmpql75hy1q.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpql75hy1q.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpql75hy1q.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpql75hy1q.swift:24:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            case .digit:\n                result += \"0\"\
    \n            default:\n                result += c\n            }\n        case\
    \ let c as String:\n            result += c\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmnfn32wg.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmnfn32wg.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpmnfn32wg.swift:23:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpmnfn32wg.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpmnfn32wg.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpmnfn32wg.swift:18:19:\
    \ error: type 'Character' has no member 'digit'\n            case .digit:\n  \
    \               ~^~~~~\n/tmp/tmpmnfn32wg.swift:21:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += c\n                          ^\n/tmp/tmpmnfn32wg.swift:26:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m4vuc25.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += \"\\(c)\"\
    \n        case let c where c >= 'a' && c <= 'z':\n            result += \"\\(c)\"\
    \n        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6g14cpbc.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n                 \
    \             ^~~\n                              \"A\"\n/tmp/tmp6g14cpbc.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'A' && c <= 'Z':\n                                          ^~~\n     \
    \                                     \"Z\"\n/tmp/tmp6g14cpbc.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'a' && c <= 'z':\n                              ^~~\n                      \
    \        \"a\"\n/tmp/tmp6g14cpbc.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'a' && c <= 'z':\n          \
    \                                ^~~\n                                       \
    \   \"z\"\n/tmp/tmp6g14cpbc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6g14cpbc.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m4vuc25.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m4vuc25.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter() {\n     \
    \       res = res.uppercased()\n        } else {\n            res = res.lowercased()\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuu5ornw6.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += String(c)\n     \
    \       case let c as Character.uppercaseLetter:\n                result += String(c)\n\
    \            default:\n                result += char\n            }\n       \
    \ default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpp_lu9z9z.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpp_lu9z9z.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpp_lu9z9z.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpp_lu9z9z.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpp_lu9z9z.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += char\n\
    \                          ^\n/tmp/tmpp_lu9z9z.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        if let c = c.uppercased() {\n            return result + c\n        }\n\
    \        return result + c\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy1fxyh7h.swift:13:25: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        return result\
    \ + c\n                        ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            default:\n                result += char\n  \
    \          }\n        case let c as String:\n            result += c\n       \
    \ default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp564q1nom.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp564q1nom.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmp564q1nom.swift:21:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmp564q1nom.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmp564q1nom.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmp564q1nom.swift:19:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmp564q1nom.swift:24:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiovfmf95.swift:9:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979349
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter()\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9zz3hq1u.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9zz3hq1u.swift:11:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp9zz3hq1u.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp9zz3hq1u.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += \"A\"\n         \
    \   case let c as Character.uppercaseLetter:\n                result += \"a\"\n\
    \            default:\n                result += c\n            }\n        case\
    \ let c as Character.whitespace:\n            result += \" \"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpifz2462p.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpifz2462p.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpifz2462p.swift:21:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmpifz2462p.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpifz2462p.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpifz2462p.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpifz2462p.swift:24:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n        case \"b\":\n        case \"c\":\n        case \"d\":\n    \
    \    case \"e\":\n        case \"f\":\n        case \"g\":\n        case \"h\"\
    :\n        case \"i\":\n        case \"j\":\n        case \"k\":\n        case\
    \ \"l\":\n        case \"m\":\n        case \"n\":\n        case \"o\":\n    \
    \    case \"p\":\n        case \"q\":\n        case \"r\":\n        case \"s\"\
    :\n        case \"t\":\n        case \"u\":\n        case \"v\":\n        case\
    \ \"w\":\n        case \"x\":\n        case \"y\":\n        case \"z\":\n    \
    \        result += char.lowercaseString\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuzahp7ok.swift:12:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpuzahp7ok.swift:13:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:14:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:16:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:17:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpuzahp7ok.swift:24:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            case .digit:\n                result += \"0\"\
    \n            default:\n                result += String(char)\n            }\n\
    \        case let c as String:\n            result += c\n        default:\n  \
    \          result += String(char)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd20zyir7.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd20zyir7.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpd20zyir7.swift:23:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpd20zyir7.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpd20zyir7.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpd20zyir7.swift:18:19:\
    \ error: type 'Character' has no member 'digit'\n            case .digit:\n  \
    \               ~^~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxzrubi4c.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxzrubi4c.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:17:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += c.uppercased()\n            case .uppercase:\n    \
    \            result += c.lowercased()\n            case .other:\n            \
    \    result += c\n            }\n        case let c as String:\n            result\
    \ += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvxjj2oxx.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvxjj2oxx.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvxjj2oxx.swift:21:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpvxjj2oxx.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpvxjj2oxx.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpvxjj2oxx.swift:18:19:\
    \ error: type 'Character' has no member 'other'\n            case .other:\n  \
    \               ~^~~~~\n/tmp/tmpvxjj2oxx.swift:19:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += c\n                          ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reverse().reduce(\"\") { (result, char) -> String in\n\
    \        if char.isLetter() {\n            return result + String(char.uppercased())\n\
    \        } else {\n            return result + String(char)\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgexkah83.swift:9:25: error: value of type 'String' has no member\
    \ 'reverse'\n    return s.characters.reverse().reduce(\"\") { (result, char) ->\
    \ String in\n           ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        case let c as Character.whitespace:\n            result\
    \ += c\n        default:\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpql75hy1q.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpql75hy1q.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpql75hy1q.swift:21:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmpql75hy1q.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpql75hy1q.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpql75hy1q.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpql75hy1q.swift:24:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"\\(c)\"\
    \n        case let c where c >= 'A' && c <= 'Z':\n            result += \"\\(c)\"\
    \n        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmped7mwmy1.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmped7mwmy1.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmped7mwmy1.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmped7mwmy1.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmped7mwmy1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmped7mwmy1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        if let c = c.toUppercase() {\n            return result + c\n       \
    \ }\n        return result + c\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw8r36q9z.swift:10:22: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toUppercase'\n        if let c = c.toUppercase()\
    \ {\n                   ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).lowercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).uppercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjhaba2hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjhaba2hm.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpjhaba2hm.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmpjhaba2hm.swift:17:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) in\n        if\
    \ let c = c.toUpper() {\n            return result + c\n        } else {\n   \
    \         return result + c.toLower()\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp4j0s64kr.swift:10:22: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toUpper'\n        if let c = c.toUpper() {\n   \
    \                ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += c.uppercased()\n            case .uppercase:\n    \
    \            result += c.lowercased()\n            default:\n                result\
    \ += c\n            }\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph28vvb26.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph28vvb26.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmph28vvb26.swift:14:19: error: type 'Character' has no\
    \ member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmph28vvb26.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmph28vvb26.swift:19:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += c\n                          ^\n/tmp/tmph28vvb26.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter {\n    \
    \        result += char.lowercaseString\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1pszz0gd.swift:12:28: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n            result += char.lowercaseString\n            \
    \          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp1pszz0gd.swift:14:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\"\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += \"a\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpupll74oc.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpupll74oc.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpupll74oc.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpupll74oc.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpupll74oc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpupll74oc.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter {\n       \
    \     res.uppercased()\n        } else {\n            res.lowercased()\n     \
    \   }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp7pyqiro3/tmp7pyqiro3.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b833fbf1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b833f8e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b833f8e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b833f8e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7pyqiro3                        0x00005588d94d24c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b833fddd460 __libc_start_main +
    245

    6    tmp7pyqiro3                        0x00005588d94d2109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m4vuc25.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += char.lowercaseString\n        } else {\n          \
    \  result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3tri1hm.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu3tri1hm.swift:12:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpu3tri1hm.swift:14:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            case .other:\n                result += String(c)\n\
    \            }\n        case let c as String:\n            result += String(c)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdlmf0rku.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdlmf0rku.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpdlmf0rku.swift:21:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpdlmf0rku.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpdlmf0rku.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpdlmf0rku.swift:18:19:\
    \ error: type 'Character' has no member 'other'\n            case .other:\n  \
    \               ~^~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m4vuc25.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp8nn5kn.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpjp8nn5kn.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpjp8nn5kn.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpjp8nn5kn.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpjp8nn5kn.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpjp8nn5kn.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpjp8nn5kn.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpjp8nn5kn.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpjp8nn5kn.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpjp8nn5kn.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpjp8nn5kn.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpjp8nn5kn.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpjp8nn5kn.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpjp8nn5kn.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpjp8nn5kn.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpjp8nn5kn.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            let upper = char.uppercaseString\n            let lower = char.lowercaseString\n\
    \            result = result + upper\n            result = result + lower\n  \
    \      } else {\n            result = result + char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiw_lexwh.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpiw_lexwh.swift:12:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpiw_lexwh.swift:13:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpiw_lexwh.swift:17:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = result + char\n   \
    \                           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result = result.uppercased()\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ = result.lowercased()\n            default:\n                result = result\n\
    \            }\n        case let c as Character.whitespace:\n            result\
    \ = result\n        default:\n            result = result\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpypltvhzk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpypltvhzk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpypltvhzk.swift:21:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmpypltvhzk.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpypltvhzk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpypltvhzk.swift:19:24: error: assigning a variable to itself\n\
    \                result = result\n                ~~~~~~ ^ ~~~~~~\n/tmp/tmpypltvhzk.swift:22:20:\
    \ error: assigning a variable to itself\n            result = result\n       \
    \     ~~~~~~ ^ ~~~~~~\n/tmp/tmpypltvhzk.swift:24:20: error: assigning a variable\
    \ to itself\n            result = result\n            ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        case let c as String:\n            result += c\n       \
    \ default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpprlfx_hr.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpprlfx_hr.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpprlfx_hr.swift:21:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpprlfx_hr.swift:14:37: error: 'lowercaseLetter'\
    \ is not a member type of struct 'Swift.Character'\n            case let c as\
    \ Character.lowercaseLetter:\n                          ~~~~~~~~~ ^\nSwift.Character:1:23:\
    \ note: 'Character' declared here\n@frozen public struct Character : Sendable\
    \ {\n                      ^\n/tmp/tmpprlfx_hr.swift:16:37: error: 'uppercaseLetter'\
    \ is not a member type of struct 'Swift.Character'\n            case let c as\
    \ Character.uppercaseLetter:\n                          ~~~~~~~~~ ^\nSwift.Character:1:23:\
    \ note: 'Character' declared here\n@frozen public struct Character : Sendable\
    \ {\n                      ^\n/tmp/tmpprlfx_hr.swift:19:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += c\n                          ^\n/tmp/tmpprlfx_hr.swift:24:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\"\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += \"a\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpupll74oc.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpupll74oc.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpupll74oc.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpupll74oc.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpupll74oc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpupll74oc.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpby76h7ou.swift:9:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            switch char {\n           \
    \ case let c where c.isLower:\n                result += String(c)\n         \
    \   case let c where c.isUpper:\n                result += String(c)\n       \
    \     default:\n                result += char\n            }\n        case let\
    \ c where !c.isLetter:\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpk_l4psq1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk_l4psq1.swift:14:32:\
    \ error: value of type 'Character' has no member 'isLower'\n            case let\
    \ c where c.isLower:\n                             ~ ^~~~~~~\n/tmp/tmpk_l4psq1.swift:16:32:\
    \ error: value of type 'Character' has no member 'isUpper'\n            case let\
    \ c where c.isUpper:\n                             ~ ^~~~~~~\n/tmp/tmpk_l4psq1.swift:19:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmpk_l4psq1.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmpk_l4psq1.swift:11:9:\
    \ error: switch must be exhaustive\n        switch char {\n        ^\n/tmp/tmpk_l4psq1.swift:11:9:\
    \ note: do you want to add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char.lowercased() {\n            case \"a\":\n             \
    \   result += \"A\"\n            case \"b\":\n                result += \"B\"\n\
    \            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkugv4e0x.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpkugv4e0x.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpkugv4e0x.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\":\n    \
    \    case \"u\":\n            result += \"A\"\n        case \"b\":\n        case\
    \ \"f\":\n        case \"j\":\n        case \"k\":\n        case \"l\":\n    \
    \        result += \"B\"\n        case \"c\":\n        case \"m\":\n        case\
    \ \"n\":\n        case \"p\":\n        case \"q\":\n        case \"r\":\n    \
    \    case \"s\":\n            result += \"C\"\n        case \"d\":\n        case\
    \ \"h\":\n        case \"g\":\n        case \"f\":\n        case \"e\":\n    \
    \    case \"d\":\n            result += \"D\"\n        case \"e\":\n        case\
    \ \"g\":\n        case \"h\":\n        case \"f\":\n        case \"i\":\n    \
    \    case \"j\":\n        case \"k\":\n        case \"l\":\n            result\
    \ += \"E\"\n        case \"f\":\n        case \"j\":\n        case \"k\":\n  \
    \      case \"l\":\n        case \"m\":\n        case \"n\":\n        case \"\
    p\":\n        case \"q\":\n        case \"r\":\n        case \"s\":\n        \
    \    result += \"F\"\n        case \"g\":\n        case \"h\":\n        case \"\
    f\":\n        case \"i\":\n        case \"j\":\n        case \"k\":\n        case\
    \ \"l\":\n        case \"m\":\n        case \"n\":\n        case \"p\":\n    \
    \    case \"q\":\n        case \"r\":\n        case \"s\":\n            result\
    \ += \"G\"\n        case \"h\":\n        case \"g\":\n        case \"f\":\n  \
    \      case \"i\":\n        case \"j\":\n        case \"k\":\n        case \"\
    l\":\n        case \"m\":\n        case \"n\":\n        case \"p\":\n        case\
    \ \"q\":\n        case \"r\":\n        case \"s\":\n            result += \"H\"\
    \n        case \"i\":\n        case \"j\":\n        case \"k\":\n        case\
    \ \"l\":\n        case \"m\":\n        case \"n\":\n        case \"p\":\n    \
    \    case \"q\":\n        case \"r\":\n        case \"s\":\n            result\
    \ += \"I\"\n        case \"o\":\n        case \"k\":\n        case \"l\":\n  \
    \      case \"m\":\n        case \"n\":\n        case \"p\":\n        case \"\
    q\":\n        case \"r\":\n        case \"s\":\n            result += \"O\"\n\
    \        case \"u\":\n        case \"j\":\n        case \"k\":\n        case \"\
    l\":\n        case \"m\":\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpk65btlgk.swift:12:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpk65btlgk.swift:13:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:14:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"b\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:25:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"m\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:26:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"n\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:27:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"p\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpk65btlgk.swift:28:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { (result, c) -> String in\n\
    \        if let c = c.uppercased() {\n            return result + c\n        }\n\
    \        return result + c\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy1fxyh7h.swift:13:25: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        return result\
    \ + c\n                        ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            case .digit:\n                result += \"0\"\
    \n            default:\n                result += String(char)\n            }\n\
    \        case let c as String:\n            result += c\n        default:\n  \
    \          result += String(char)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd20zyir7.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd20zyir7.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpd20zyir7.swift:23:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpd20zyir7.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpd20zyir7.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpd20zyir7.swift:18:19:\
    \ error: type 'Character' has no member 'digit'\n            case .digit:\n  \
    \               ~^~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != lower{\n                result += upper\n           \
    \ } else {\n                result += lower\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpfrksc3oa.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpfrksc3oa.swift:20:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        if char.isLetter() {\n  \
    \          switch char.lowercased() {\n            case \"a\":\n             \
    \   result += \"A\"\n            case \"b\":\n                result += \"B\"\n\
    \            case \"c\":\n                result += \"C\"\n            case \"\
    d\":\n                result += \"D\"\n            case \"e\":\n             \
    \   result += \"E\"\n            case \"f\":\n                result += \"F\"\n\
    \            case \"g\":\n                result += \"G\"\n            case \"\
    h\":\n                result += \"H\"\n            case \"i\":\n             \
    \   result += \"I\"\n            case \"j\":\n                result += \"J\"\n\
    \            case \"k\":\n                result += \"K\"\n            case \"\
    l\":\n                result += \"L\"\n            case \"m\":\n             \
    \   result += \"M\"\n            case \"n\":\n                result += \"N\"\n\
    \            case \"o\":\n                result += \"O\"\n            case \"\
    p\":\n                result += \"P\"\n            case \"q\":\n             \
    \   result += \"Q\"\n            case \"r\":\n                result += \"R\"\n\
    \            case \"s\":\n                result += \"S\"\n            case \"\
    t\":\n                result += \"T\"\n            case \"u\":\n             \
    \   result += \"U\"\n            case \"v\":\n                result += \"V\"\n\
    \            case \"w\":\n                result += \"W\"\n            case \"\
    x\":\n                result += \"X\"\n            case \"y\":\n             \
    \   result += \"Y\"\n            case \"z\":\n                result += \"Z\"\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkugv4e0x.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpkugv4e0x.swift:66:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpkugv4e0x.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            result += c.lowercaseString\n\
    \        case let c where !c.isLetter:\n            result += c\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3k7cggo1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3k7cggo1.swift:13:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += c.lowercaseString\n                      ~ ^~~~~~~~~~~~~~~\n/tmp/tmp3k7cggo1.swift:15:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += c\n                      ^\n/tmp/tmp3k7cggo1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"A\":\n            result += \"B\"\n        case \"B\":\n            result\
    \ += \"A\"\n        case \"C\":\n            result += \"D\"\n        case \"\
    D\":\n            result += \"C\"\n        case \"E\":\n            result +=\
    \ \"F\"\n        case \"F\":\n            result += \"E\"\n        case \"G\"\
    :\n            result += \"H\"\n        case \"H\":\n            result += \"\
    G\"\n        case \"I\":\n            result += \"J\"\n        case \"J\":\n \
    \           result += \"I\"\n        case \"K\":\n            result += \"L\"\n\
    \        case \"L\":\n            result += \"K\"\n        case \"M\":\n     \
    \       result += \"N\"\n        case \"N\":\n            result += \"M\"\n  \
    \      case \"O\":\n            result += \"P\"\n        case \"P\":\n       \
    \     result += \"O\"\n        case \"Q\":\n            result += \"R\"\n    \
    \    case \"R\":\n            result += \"Q\"\n        case \"S\":\n         \
    \   result += \"T\"\n        case \"T\":\n            result += \"S\"\n      \
    \  case \"U\":\n            result += \"V\"\n        case \"V\":\n           \
    \ result += \"U\"\n        case \"W\":\n            result += \"X\"\n        case\
    \ \"X\":\n            result += \"W\"\n        case \"Y\":\n            result\
    \ += \"Z\"\n        case \"Z\":\n            result += \"Y\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwhmxtrxh.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += char.lowercaseString\n        case 'A':\n\
    \        case 'E':\n        case 'I':\n        case 'O':\n        case 'U':\n\
    \            result += char.uppercaseString\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpy6qqmx5a.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpy6qqmx5a.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpy6qqmx5a.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpy6qqmx5a.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpy6qqmx5a.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6qqmx5a.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpy6qqmx5a.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'A':\n             ^~~\n      \
    \       \"A\"\n/tmp/tmpy6qqmx5a.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'A':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpy6qqmx5a.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'E':\n             ^~~\n             \"\
    E\"\n/tmp/tmpy6qqmx5a.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'E':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmpy6qqmx5a.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'I':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxzrubi4c.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxzrubi4c.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmpxzrubi4c.swift:17:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += String(char)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjoaysbse.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjoaysbse.swift:12:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmpjoaysbse.swift:14:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'A':\n            result += \"B\"\n        case 'B':\n         \
    \   result += \"A\"\n        case 'C':\n            result += \"D\"\n        case\
    \ 'D':\n            result += \"C\"\n        case 'E':\n            result +=\
    \ \"F\"\n        case 'F':\n            result += \"E\"\n        case 'G':\n \
    \           result += \"H\"\n        case 'H':\n            result += \"G\"\n\
    \        case 'I':\n            result += \"J\"\n        case 'J':\n         \
    \   result += \"I\"\n        case 'K':\n            result += \"L\"\n        case\
    \ 'L':\n            result += \"K\"\n        case 'M':\n            result +=\
    \ \"N\"\n        case 'N':\n            result += \"M\"\n        case 'O':\n \
    \           result += \"P\"\n        case 'P':\n            result += \"O\"\n\
    \        case 'Q':\n            result += \"R\"\n        case 'R':\n         \
    \   result += \"Q\"\n        case 'S':\n            result += \"T\"\n        case\
    \ 'T':\n            result += \"S\"\n        case 'U':\n            result +=\
    \ \"V\"\n        case 'V':\n            result += \"U\"\n        case 'W':\n \
    \           result += \"X\"\n        case 'X':\n            result += \"W\"\n\
    \        case 'Y':\n            result += \"Z\"\n        case 'Z':\n         \
    \   result += \"Y\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsce77vj3.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmpsce77vj3.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'B':\n   \
    \          ^~~\n             \"B\"\n/tmp/tmpsce77vj3.swift:16:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'C':\n             ^~~\n      \
    \       \"C\"\n/tmp/tmpsce77vj3.swift:18:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'D':\n             ^~~\n             \"D\"\n/tmp/tmpsce77vj3.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'E':\n   \
    \          ^~~\n             \"E\"\n/tmp/tmpsce77vj3.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'F':\n             ^~~\n      \
    \       \"F\"\n/tmp/tmpsce77vj3.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'G':\n             ^~~\n             \"G\"\n/tmp/tmpsce77vj3.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'H':\n   \
    \          ^~~\n             \"H\"\n/tmp/tmpsce77vj3.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'I':\n             ^~~\n      \
    \       \"I\"\n/tmp/tmpsce77vj3.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'J':\n             ^~~\n             \"J\"\n/tmp/tmpsce77vj3.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'K':\n   \
    \          ^~~\n             \"K\"\n/tmp/tmpsce77vj3.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'L':\n             ^~~\n      \
    \       \"L\"\n/tmp/tmpsce77vj3.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'M':\n             ^~~\n             \"M\"\n/tmp/tmpsce77vj3.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'N':\n   \
    \          ^~~\n             \"N\"\n/tmp/tmpsce77vj3.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'O':\n             ^~~\n      \
    \       \"O\"\n/tmp/tmpsce77vj3.swift:42:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += c.uppercaseString\n\
    \            case let c as Character.uppercaseLetter:\n                result\
    \ += c.lowercaseString\n            default:\n                result += c\n  \
    \          }\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhs1n3pk.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvhs1n3pk.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpvhs1n3pk.swift:14:37: error: 'lowercaseLetter' is not\
    \ a member type of struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpvhs1n3pk.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpvhs1n3pk.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\"\n\
    \        case let c where c >= 'A' && c <= 'Z':\n            result += \"a\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpupll74oc.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpupll74oc.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpupll74oc.swift:14:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpupll74oc.swift:14:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpupll74oc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpupll74oc.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        if char.isLetter\
    \ {\n            let upper = char.uppercaseString\n            let lower = char.lowercaseString\n\
    \            result = upper.characters.isEmpty ? lower: upper\n        } else\
    \ {\n            result = char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpe58dyxyc.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe58dyxyc.swift:12:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpe58dyxyc.swift:13:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpe58dyxyc.swift:16:22: error: cannot assign value of type 'Character' to\
    \ type 'String'\n            result = char\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c >= 'a' && c <= 'z':\n            result += \"A\" +\
    \ String(c - 'a')\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \  result += \"a\" + String(c - 'A')\n        default:\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjqs4cm9r.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpjqs4cm9r.swift:12:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpjqs4cm9r.swift:13:40: error:\
    \ single-quoted string literal found, use '\"'\n            result += \"A\" +\
    \ String(c - 'a')\n                                       ^~~\n              \
    \                         \"a\"\n/tmp/tmpjqs4cm9r.swift:14:31: error: single-quoted\
    \ string literal found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n\
    \                              ^~~\n                              \"A\"\n/tmp/tmpjqs4cm9r.swift:14:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'A' && c <= 'Z':\n                                          ^~~\n     \
    \                                     \"Z\"\n/tmp/tmpjqs4cm9r.swift:15:40: error:\
    \ single-quoted string literal found, use '\"'\n            result += \"a\" +\
    \ String(c - 'A')\n                                       ^~~\n              \
    \                         \"A\"\n/tmp/tmpjqs4cm9r.swift:10:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjqs4cm9r.swift:13:38: error: referencing operator function '-' on\
    \ 'SIMD' requires that 'Unicode.Scalar' conform to 'SIMD'\n            result\
    \ += \"A\" + String(c - 'a')\n                                     ^\nSwift.SIMD:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension SIMD where Self.Scalar : FloatingPoint\
    \ {\n          ^\n/tmp/tmpjqs4cm9r.swift:15:38: error: referencing operator function\
    \ '-' on 'SIMD' requires that 'Unicode.Scalar' conform to 'SIMD'\n           \
    \ result += \"a\" + String(c - 'A')\n        "
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter() {\n     \
    \       res = char.uppercased().append(res)\n        } else {\n            res\
    \ = char.append(res)\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz6hig_5_.swift:11:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpz6hig_5_.swift:12:37: error: cannot assign value\
    \ of type '()' to type 'String'\n            res = char.uppercased().append(res)\n\
    \                  ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n/tmp/tmpz6hig_5_.swift:12:37:\
    \ error: cannot use mutating member on immutable value: function call returns\
    \ immutable value\n            res = char.uppercased().append(res)\n         \
    \         ~~~~~~~~~~~~~~~~~ ^\n/tmp/tmpz6hig_5_.swift:14:24: error: value of type\
    \ 'Character' has no member 'append'\n            res = char.append(res)\n   \
    \               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n            result += \"A\"\n        case 'b':\n        case\
    \ 'f':\n        case 'j':\n        case 'k':\n        case 'l':\n            result\
    \ += \"B\"\n        case 'c':\n        case 'm':\n        case 'p':\n        case\
    \ 'q':\n        case 'r':\n            result += \"C\"\n        case 'd':\n  \
    \      case 'g':\n        case 's':\n        case 't':\n            result +=\
    \ \"D\"\n        case 'e':\n        case 'h':\n        case 'v':\n           \
    \ result += \"E\"\n        case 'f':\n        case 'i':\n        case 'l':\n \
    \           result += \"F\"\n        case 'g':\n        case 'j':\n        case\
    \ 'k':\n        case 'm':\n            result += \"G\"\n        case 'h':\n  \
    \      case 'l':\n            result += \"H\"\n        case 'i':\n        case\
    \ 'o':\n        case 'p':\n        case 'q':\n        case 'r':\n            result\
    \ += \"I\"\n        case 'j':\n        case 'k':\n        case 'l':\n        \
    \    result += \"J\"\n        case 'm':\n        case 'n':\n        case 'o':\n\
    \        case 'p':\n        case 'q':\n        case 'r':\n            result +=\
    \ \"K\"\n        case 'n':\n        case 'o':\n        case 'p':\n        case\
    \ 'q':\n        case 'r':\n            result += \"N\"\n        case 'o':\n  \
    \      case 'p':\n        case 'q':\n        case 'r':\n            result +=\
    \ \"O\"\n        case 'p':\n        case 'q':\n        case 'r':\n           \
    \ result += \"P\"\n        case 'q':\n        case 'r':\n            result +=\
    \ \"Q\"\n        case 'r':\n            result += \"R\"\n        case 's':\n \
    \       case 't':\n            result += \"S\"\n        case 'u':\n        case\
    \ 'v':\n            result += \"U\"\n        case 'w':\n        case 'x':\n  \
    \      case 'y':\n        case 'z':\n            result += \"V\"\n        case\
    \ 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n        case\
    \ 'U':\n            result += \"a\"\n        case 'B':\n        case 'F':\n  \
    \      case 'J':\n        case 'K':\n        case 'L':\n            result +=\
    \ \"b\"\n        case 'C':\n        case 'M':\n        case 'P':\n        case\
    \ 'Q':\n        case 'R':\n            result += \"c\"\n        case 'D':\n  \
    \      case 'G':\n        case 'S':\n        case 'T':\n            result +=\
    \ \"d\"\n        case 'E':\n        case 'H':\n        case 'V':\n           \
    \ result += \"e\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ngredmu.swift:12:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp7ngredmu.swift:12:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmp7ngredmu.swift:13:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp7ngredmu.swift:13:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmp7ngredmu.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmp7ngredmu.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmp7ngredmu.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmp7ngredmu.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmp7ngredmu.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmp7ngredmu.swift:18:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'b':\n             ^~~\n      \
    \       \"b\"\n/tmp/tmp7ngredmu.swift:18:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 'b':\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp7ngredmu.swift:19:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'f':\n             ^~~\n             \"\
    f\"\n/tmp/tmp7ngredmu.swift:19:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 'f':\n        ^~~~~~~~~\n  \
    \                break\n/tmp/tmp7ngredmu.swift:20:14: error: single-quoted string\
    \ literal found, use '\"'\n        case 'j':\n             ^~~"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\":\n            result += \"A\"\n        case \"b\":\n            result\
    \ += \"B\"\n        case \"c\":\n            result += \"C\"\n        case \"\
    d\":\n            result += \"D\"\n        case \"e\":\n            result +=\
    \ \"E\"\n        case \"f\":\n            result += \"F\"\n        case \"g\"\
    :\n            result += \"G\"\n        case \"h\":\n            result += \"\
    H\"\n        case \"i\":\n            result += \"I\"\n        case \"j\":\n \
    \           result += \"J\"\n        case \"k\":\n            result += \"K\"\n\
    \        case \"l\":\n            result += \"L\"\n        case \"m\":\n     \
    \       result += \"M\"\n        case \"n\":\n            result += \"N\"\n  \
    \      case \"o\":\n            result += \"O\"\n        case \"p\":\n       \
    \     result += \"P\"\n        case \"q\":\n            result += \"Q\"\n    \
    \    case \"r\":\n            result += \"R\"\n        case \"s\":\n         \
    \   result += \"S\"\n        case \"t\":\n            result += \"T\"\n      \
    \  case \"u\":\n            result += \"U\"\n        case \"v\":\n           \
    \ result += \"V\"\n        case \"w\":\n            result += \"W\"\n        case\
    \ \"x\":\n            result += \"X\"\n        case \"y\":\n            result\
    \ += \"Y\"\n        case \"z\":\n            result += \"Z\"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w6q7xjv.swift:65:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    return s.characters.reversed().reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiovfmf95.swift:9:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979349
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += \"A\"\n         \
    \   case let c as Character.uppercaseLetter:\n                result += \"a\"\n\
    \            case let c as Character.digit:\n                result += \"0\"\n\
    \            default:\n                result += c\n            }\n        case\
    \ let c as Character.whitespace:\n            result += \" \"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3rzh2jy8.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3rzh2jy8.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmp3rzh2jy8.swift:23:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmp3rzh2jy8.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmp3rzh2jy8.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmp3rzh2jy8.swift:18:37: error: 'digit' is not a member type\
    \ of struct 'Swift.Character'\n            case let c as Character.digit:\n  \
    \                        ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmp3rzh2jy8.swift:21:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmp3rzh2jy8.swift:26:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let .lowercase(let char):\n            result += char.uppercased()\n\
    \        case let .uppercase(let char):\n            result += char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplyruek05.swift:12:29: error: 'let' cannot appear nested inside\
    \ another 'var' or 'let' pattern\n        case let .lowercase(let char):\n   \
    \                         ^\n/tmp/tmplyruek05.swift:14:29: error: 'let' cannot\
    \ appear nested inside another 'var' or 'let' pattern\n        case let .uppercase(let\
    \ char):\n                            ^\n/tmp/tmplyruek05.swift:10:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in s.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplyruek05.swift:12:19: error: type 'Character' has no member 'lowercase'\n\
    \        case let .lowercase(let char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:14:19:\
    \ error: type 'Character' has no member 'uppercase'\n        case let .uppercase(let\
    \ char):\n                 ~^~~~~~~~~\n/tmp/tmplyruek05.swift:17:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c where c.isLetter:\n            result += c.lowercaseString\n\
    \        case let c where !c.isLetter:\n            result += c\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3k7cggo1.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3k7cggo1.swift:13:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += c.lowercaseString\n                      ~ ^~~~~~~~~~~~~~~\n/tmp/tmp3k7cggo1.swift:15:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += c\n                      ^\n/tmp/tmp3k7cggo1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case let\
    \ c as Character.lowercaseLetter:\n                result += \"A\"\n         \
    \   case let c as Character.uppercaseLetter:\n                result += \"a\"\n\
    \            default:\n                result += c\n            }\n        case\
    \ let c as Character.whitespace:\n            result += \" \"\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpifz2462p.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpifz2462p.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpifz2462p.swift:21:33: error: 'whitespace' is not a member\
    \ type of struct 'Swift.Character'\n        case let c as Character.whitespace:\n\
    \                      ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character' declared\
    \ here\n@frozen public struct Character : Sendable {\n                      ^\n\
    /tmp/tmpifz2462p.swift:14:37: error: 'lowercaseLetter' is not a member type of\
    \ struct 'Swift.Character'\n            case let c as Character.lowercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpifz2462p.swift:16:37: error: 'uppercaseLetter' is not a member\
    \ type of struct 'Swift.Character'\n            case let c as Character.uppercaseLetter:\n\
    \                          ~~~~~~~~~ ^\nSwift.Character:1:23: note: 'Character'\
    \ declared here\n@frozen public struct Character : Sendable {\n              \
    \        ^\n/tmp/tmpifz2462p.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += c\n\
    \                          ^\n/tmp/tmpifz2462p.swift:24:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\nfunc solve(s: String) -> String {\n\
    \    var result = \"\"\n    for char in s.characters {\n        switch char {\n\
    \        case let c as Character:\n            switch c {\n            case .lowercase:\n\
    \                result += \"A\"\n            case .uppercase:\n             \
    \   result += \"a\"\n            case .digit:\n                result += \"0\"\
    \n            default:\n                result += c\n            }\n        case\
    \ let c as String:\n            result += c\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmnfn32wg.swift:10:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmnfn32wg.swift:12:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpmnfn32wg.swift:23:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpmnfn32wg.swift:14:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpmnfn32wg.swift:16:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpmnfn32wg.swift:18:19:\
    \ error: type 'Character' has no member 'digit'\n            case .digit:\n  \
    \               ~^~~~~\n/tmp/tmpmnfn32wg.swift:21:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += c\n                          ^\n/tmp/tmpmnfn32wg.swift:26:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978910
