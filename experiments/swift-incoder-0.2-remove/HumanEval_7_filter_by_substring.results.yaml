language: swift
name: HumanEval_7_filter_by_substring
results:
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let substringRange\
    \ = string.range(of: substring)\n        return substringRange.lowerBound != nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvr1ajj0q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        let range = ($0.lowercased()).range(of:\
    \ substring.lowercased())\n        return range != nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp2wnafo2.swift:5:39: error: value of type 'String' has no member\
    \ 'range'\n        let range = ($0.lowercased()).range(of: substring.lowercased())\n\
    \                    ~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        $0.contains(substring)\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        contains($0, substring)\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa8eyz0o1.swift:5:9: error: cannot find 'contains' in scope\n  \
    \      contains($0, substring)\n        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        let range = Range(uncheckedBounds:\
    \ (lower: String.Index(encodedOffset: substring.startIndex, in: strings.startIndex,\
    \ offsetBy: 0), upper: String.Index(encodedOffset: substring.endIndex, in: strings.endIndex,\
    \ offsetBy: 0)));\n        return range.contains(String.Index(encodedOffset: $0,\
    \ in: strings, offsetBy: 0));\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmph0atxheh.swift:5:64: error: extra arguments at positions #2, #3\
    \ in call\n        let range = Range(uncheckedBounds: (lower: String.Index(encodedOffset:\
    \ substring.startIndex, in: strings.startIndex, offsetBy: 0), upper: String.Index(encodedOffset:\
    \ substring.endIndex, in: strings.endIndex, offsetBy: 0)));\n                \
    \                                               ^\nSwift.String.Index:7:23: note:\
    \ 'init(encodedOffset:)' declared here\n    @inlinable public init(encodedOffset\
    \ offset: Int)\n                      ^\n/tmp/tmph0atxheh.swift:5:90: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   let range = Range(uncheckedBounds: (lower: String.Index(encodedOffset: substring.startIndex,\
    \ in: strings.startIndex, offsetBy: 0), upper: String.Index(encodedOffset: substring.endIndex,\
    \ in: strings.endIndex, offsetBy: 0)));\n                                    \
    \                                                     ^\n/tmp/tmph0atxheh.swift:5:159:\
    \ error: extra arguments at positions #2, #3 in call\n        let range = Range(uncheckedBounds:\
    \ (lower: String.Index(encodedOffset: substring.startIndex, in: strings.startIndex,\
    \ offsetBy: 0), upper: String.Index(encodedOffset: substring.endIndex, in: strings.endIndex,\
    \ offsetBy: 0)));\n                                                          \
    \                                                                            \
    \                        ^\nSwift.String.Index:7:23: note: 'init(encodedOffset:)'\
    \ declared here\n    @inlinable public init(encodedOffset offset: Int)\n     \
    \                 ^\n/tmp/tmph0atxheh.swift:5:185: error: cannot convert value\
    \ of type 'String.Index' to expected argument type 'Int'\n        let range =\
    \ Range(uncheckedBounds: (lower: String.Index(encodedOffset: substring.startIndex,\
    \ in: strings.startIndex, offsetBy: 0), upper: String.Index(encodedOffset: substring.endIndex,\
    \ in: strings.endIndex, offsetBy: 0)));\n                                    \
    \                                                                            \
    \              "
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let range = string.range(of: substring)\n        return range != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjw_dvpi7.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let range = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let range = string.range(of: substring)\n        return range != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjw_dvpi7.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let range = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let substringRange\
    \ = string.rangeOfString(substring)\n        return substringRange.location !=\
    \ NSNotFound\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvpfyymxg.swift:6:43: error: cannot find 'NSNotFound' in scope\n\
    \        return substringRange.location != NSNotFound\n                      \
    \                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        if let index = string.range(of:\
    \ substring) {\n            return true\n        }\n        return false\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo1quiip8.swift:5:24: error: cannot find 'string' in scope\n   \
    \     if let index = string.range(of: substring) {\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        contains($0, substring)\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa8eyz0o1.swift:5:9: error: cannot find 'contains' in scope\n  \
    \      contains($0, substring)\n        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        contains($0, substring)\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa8eyz0o1.swift:5:9: error: cannot find 'contains' in scope\n  \
    \      contains($0, substring)\n        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let index = string.index(of: substring)\n        return index != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsu9ae875.swift:5:38: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n        let index\
    \ = string.index(of: substring)\n                                     ^\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        guard let range = Range(uncheckedBounds:\
    \ (lower: String.Index(encodedOffset: substring.startIndex, in: strings.startIndex,\
    \ offsetBy: 0), upper: String.Index(encodedOffset: substring.endIndex, in: strings.endIndex,\
    \ offsetBy: 0))) else {\n            return false\n        }\n        return range.contains(String.Index(encodedOffset:\
    \ $0.startIndex, in: strings.startIndex, offsetBy: 0))\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp2fcemec.swift:5:70: error: extra arguments at positions #2, #3\
    \ in call\n        guard let range = Range(uncheckedBounds: (lower: String.Index(encodedOffset:\
    \ substring.startIndex, in: strings.startIndex, offsetBy: 0), upper: String.Index(encodedOffset:\
    \ substring.endIndex, in: strings.endIndex, offsetBy: 0))) else {\n          \
    \                                                           ^\nSwift.String.Index:7:23:\
    \ note: 'init(encodedOffset:)' declared here\n    @inlinable public init(encodedOffset\
    \ offset: Int)\n                      ^\n/tmp/tmpp2fcemec.swift:5:96: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   guard let range = Range(uncheckedBounds: (lower: String.Index(encodedOffset:\
    \ substring.startIndex, in: strings.startIndex, offsetBy: 0), upper: String.Index(encodedOffset:\
    \ substring.endIndex, in: strings.endIndex, offsetBy: 0))) else {\n          \
    \                                                                            \
    \         ^\n/tmp/tmpp2fcemec.swift:5:165: error: extra arguments at positions\
    \ #2, #3 in call\n        guard let range = Range(uncheckedBounds: (lower: String.Index(encodedOffset:\
    \ substring.startIndex, in: strings.startIndex, offsetBy: 0), upper: String.Index(encodedOffset:\
    \ substring.endIndex, in: strings.endIndex, offsetBy: 0))) else {\n          \
    \                                                                            \
    \                                                                            \
    \  ^\nSwift.String.Index:7:23: note: 'init(encodedOffset:)' declared here\n  \
    \  @inlinable public init(encodedOffset offset: Int)\n                      ^\n\
    /tmp/tmpp2fcemec.swift:5:191: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        guard let range = Range(uncheckedBounds:\
    \ (lower: String.Index(encodedOffset: substring.startIndex, in: strings.startIndex,\
    \ offsetBy: 0), upper: String.Index(encodedOffset: substring.endIndex, in: strings.endIndex,\
    \ offsetBy: 0))) else {\n                                                    \
    \        "
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let range = string.rangeOfString(substring)\n        return range != nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp054os5m5.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let index = string.range(of: substring)\n        return index != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp78llju__.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let index = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        let range = ($0.lowercased(),\
    \ $0.lowercased().range(of: substring))\n        return range.count == 2\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6byc4gqq.swift:5:55: error: value of type 'String' has no member\
    \ 'range'\n        let range = ($0.lowercased(), $0.lowercased().range(of: substring))\n\
    \                                      ~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let index = string.index(of: substring)\n        return index != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsu9ae875.swift:5:38: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n        let index\
    \ = string.index(of: substring)\n                                     ^\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let index = string.range(of: substring)\n        return index != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp78llju__.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let index = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        if let index = string.range(of:\
    \ substring) {\n            return true\n        }\n        return false\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo1quiip8.swift:5:24: error: cannot find 'string' in scope\n   \
    \     if let index = string.range(of: substring) {\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let index = string.rangeOfString(substring)\n        return index != nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp71dcilhc.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let index = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        $0.contains(substring)\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let substringRange\
    \ = string.range(of: substring)\n        return substringRange.lowerBound != nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvr1ajj0q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let index = string.range(of: substring)\n        return index != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp78llju__.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let index = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        guard let index = string.range(of:\
    \ substring) else { return false }\n        return index != nil\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpor0h5ot3.swift:5:27: error: cannot find 'string' in scope\n   \
    \     guard let index = string.range(of: substring) else { return false }\n  \
    \                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let range\
    \ = string.rangeOfString(substring)\n        return range != nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8t5v8vno.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let range = (string as NSString).rangeOfString(substring)\n        return range\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7s15car8.swift:5:32: error: cannot find type 'NSString' in scope\n\
    \        let range = (string as NSString).rangeOfString(substring)\n         \
    \                      ^~~~~~~~\n/tmp/tmp7s15car8.swift:5:42: error: value of\
    \ type 'String' has no member 'rangeOfString'\n        let range = (string as\
    \ NSString).rangeOfString(substring)\n                    ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let range = (string as NSString).rangeOfString(substring)\n        return range\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7s15car8.swift:5:32: error: cannot find type 'NSString' in scope\n\
    \        let range = (string as NSString).rangeOfString(substring)\n         \
    \                      ^~~~~~~~\n/tmp/tmp7s15car8.swift:5:42: error: value of\
    \ type 'String' has no member 'rangeOfString'\n        let range = (string as\
    \ NSString).rangeOfString(substring)\n                    ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (string: String) -> Bool in\n      \
    \  let range = string.rangeOfString(substring)\n        return range != nil\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaj6fnksm.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let range\
    \ = string.rangeOfString(substring)\n        return range != nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8t5v8vno.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        let range = ($0.lowercased(),\
    \ $0.lowercased().range(of: substring))\n        return range.count == 2\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6byc4gqq.swift:5:55: error: value of type 'String' has no member\
    \ 'range'\n        let range = ($0.lowercased(), $0.lowercased().range(of: substring))\n\
    \                                      ~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        guard let index = string.range(of:\
    \ substring) else { return false }\n        return index != nil\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpor0h5ot3.swift:5:27: error: cannot find 'string' in scope\n   \
    \     guard let index = string.range(of: substring) else { return false }\n  \
    \                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings = [String]()\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let index\
    \ = string.range(of: substring)\n        return index != nil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmcm6z_a8.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let index = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let range\
    \ = string.rangeOfString(substring)\n        return range != nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8t5v8vno.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter {\n        let substringIndex = string.range(of:\
    \ substring)\n        return substringIndex != nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpicdbdg1m.swift:5:30: error: cannot find 'string' in scope\n   \
    \     let substringIndex = string.range(of: substring)\n                     \
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let index\
    \ = string.range(of: substring)\n        return index != nil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmcm6z_a8.swift:5:28: error: value of type 'String' has no member\
    \ 'range'\n        let index = string.range(of: substring)\n                 \
    \   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaotv9v4q.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter({ (string: String) -> Bool in\n      \
    \  let substringRange = string.range(of: substring)\n        return substringRange.lowerBound\
    \ != nil\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpua4ooqer.swift:5:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringRange = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered: [String] = []\n    for string in strings {\n \
    \       if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filtered = [String]()\n    for string in strings {\n   \
    \     if string.contains(substring) {\n            filtered.append(string)\n \
    \       }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013421
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let range\
    \ = string.rangeOfString(substring)\n        return range != nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8t5v8vno.swift:5:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = string.rangeOfString(substring)\n     \
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    var filteredStrings: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that contain given\
    \ substring\nfunc filter_by_substring(strings: [String], substring: String) ->\
    \ [String] {\n    return strings.filter { (string) -> Bool in\n        let substringRange\
    \ = string.rangeOfString(substring)\n        return substringRange.location !=\
    \ NSNotFound\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvpfyymxg.swift:6:43: error: cannot find 'NSNotFound' in scope\n\
    \        return substringRange.location != NSNotFound\n                      \
    \                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013578
