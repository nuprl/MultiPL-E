language: swift
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayLength = alphabetArray.length\n    var\
    \ alphabetArrayLength = alphabetArrayLength / 2\n    var alphabetArrayLength =\
    \ alphabetArrayLength * 2\n    var alphabetArrayLength = alphabetArrayLength +\
    \ 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n    var alphabetArrayLength = alphabetArrayLength + 2\n    var alphabetArrayLength\
    \ = alphabetArrayLength + 2\n    var alphabetArrayLength = alphabetArrayLength\
    \ + 2\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpeqn0c64p.swift:10:45: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'length'\n    var alphabetArrayLength = alphabetArray.length\n\
    \                              ~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newString = \"\
    \"\n    for c in s.characters {\n        newString += alphabet[alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp01slxlal.swift:11:2594: error: expected member name following '.'\n\
    \        newString += alphabet[alphabet.characters.index(alphabet, startIndex:\
    \ alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.index(alphabet,\
    \ startIndex: alphabet.characters.index(alphabet, startIndex: alphabet.characters.inde"
  stdout: ''
  timestamp: 1660028480
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayReversed = Array(alphabet.reverse())\n\
    \    var alphabetArrayRotated: Array<String> = []\n    var alphabetArrayRotatedReversed:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed2: Array<String> = []\n\
    \    var alphabetArrayRotatedReversed3: Array<String> = []\n    var alphabetArrayRotatedReversed4:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed5: Array<String> = []\n\
    \    var alphabetArrayRotatedReversed6: Array<String> = []\n    var alphabetArrayRotatedReversed7:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed8: Array<String> = []\n\
    \    var alphabetArrayRotatedReversed9: Array<String> = []\n    var alphabetArrayRotatedReversed10:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed11: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed12: Array<String> = []\n    var alphabetArrayRotatedReversed13:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed14: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed15: Array<String> = []\n    var alphabetArrayRotatedReversed16:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed17: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed18: Array<String> = []\n    var alphabetArrayRotatedReversed19:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed20: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed21: Array<String> = []\n    var alphabetArrayRotatedReversed22:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed23: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed24: Array<String> = []\n    var alphabetArrayRotatedReversed25:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed26: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed27: Array<String> = []\n    var alphabetArrayRotatedReversed28:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed29: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed30: Array<String> = []\n    var alphabetArrayRotatedReversed31:\
    \ Array<String> = []\n    var alphabetArrayRotatedReversed32: Array<String> =\
    \ []\n    var alphabetArrayRotatedReversed33: Array<String> = []\n    var alphabetArrayRotatedReversed34:\
    \ Array<String> = []\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpof2k352t.swift:46:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpof2k352t.swift:10:48: error: value of type 'String' has no member\
    \ 'reverse'\n    var alphabetArrayReversed = Array(alphabet.reverse())\n     \
    \                                 ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwmjk8mbt.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:11:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:12:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:17:31: error: missing argument label '"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    for char in s.characters {\n        var index = alphabet.index(of:\
    \ char)\n        index = index! + 2\n        index = index % alphabetLength\n\
    \        encryptedString += alphabetRotated[index]\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoc3t__l2.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpoc3t__l2.swift:14:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        var\
    \ index = alphabet.index(of: char)\n                             ^\n/tmp/tmpoc3t__l2.swift:14:30:\
    \ note: use 'firstIndex(of:)' instead\n        var index = alphabet.index(of:\
    \ char)\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpoc3t__l2.swift:15:24: error: binary operator '+' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n        index = index! + 2\n    \
    \            ~~~~~~ ^ ~\n/tmp/tmpoc3t__l2.swift:16:23: error: referencing operator\
    \ function '%' on 'SIMD' requires that 'String.Index' conform to 'SIMD'\n    \
    \    index = index % alphabetLength\n                      ^\nSwift.SIMD:1:11:\
    \ note: where 'Self' = 'String.Index'\nextension SIMD where Self.Scalar : FixedWidthInteger\
    \ {\n          ^\n/tmp/tmpoc3t__l2.swift:16:17: error: value of optional type\
    \ 'String.Index?' must be unwrapped to a value of type 'String.Index'\n      \
    \  index = index % alphabetLength\n                ^\n/tmp/tmpoc3t__l2.swift:16:17:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        index = index % alphabetLength\n                ^\n         \
    \       (     ?? <#default value#>)\n/tmp/tmpoc3t__l2.swift:16:17: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        index\
    \ = index % alphabetLength\n                ^\n                     !\n/tmp/tmpoc3t__l2.swift:17:43:\
    \ error: no exact matches in call to subscript \n        encryptedString += alphabetRotated[index]\n\
    \                                          ^\nSwift.String:3:12: note: candidate\
    \ expects value of type 'Range<String.Index>' for parameter #1 (got 'String.Index?')\n\
    \    public subscript(r: Range<String.In"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    for _ in 0..<s.count {\n        newAlphabet = alphabet[newAlphabet.startIndex.advancedBy(2)]\n\
    \    }\n    return newAlphabet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsk6pnyqv.swift:11:55: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n        newAlphabet = alphabet[newAlphabet.startIndex.advancedBy(2)]\n\
    \                               ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var newAlphabet = \"\"\n    var newAlphabetLength = alphabet.count\n\
    \    var newAlphabetIndex = 0\n    var newAlphabetIndex2 = 0\n    var newAlphabetIndex3\
    \ = 0\n    var newAlphabetIndex4 = 0\n    var newAlphabetIndex5 = 0\n    var newAlphabetIndex6\
    \ = 0\n    var newAlphabetIndex7 = 0\n    var newAlphabetIndex8 = 0\n    var newAlphabetIndex9\
    \ = 0\n    var newAlphabetIndex10 = 0\n    var newAlphabetIndex11 = 0\n    var\
    \ newAlphabetIndex12 = 0\n    var newAlphabetIndex13 = 0\n    var newAlphabetIndex14\
    \ = 0\n    var newAlphabetIndex15 = 0\n    var newAlphabetIndex16 = 0\n    var\
    \ newAlphabetIndex17 = 0\n    var newAlphabetIndex18 = 0\n    var newAlphabetIndex19\
    \ = 0\n    var newAlphabetIndex20 = 0\n    var newAlphabetIndex21 = 0\n    var\
    \ newAlphabetIndex22 = 0\n    var newAlphabetIndex23 = 0\n    var newAlphabetIndex24\
    \ = 0\n    var newAlphabetIndex25 = 0\n    var newAlphabetIndex26 = 0\n    var\
    \ newAlphabetIndex27 = 0\n    var newAlphabetIndex28 = 0\n    var newAlphabetIndex29\
    \ = 0\n    var newAlphabetIndex30 = 0\n    var newAlphabetIndex31 = 0\n    var\
    \ newAlphabetIndex32 = 0\n    var newAlphabetIndex33 = 0\n    var newAlphabetIndex34\
    \ = 0\n    var newAlphabetIndex35 = 0\n    var newAlphabetIndex36 = 0\n    var\
    \ newAlphabetIndex37 = 0\n    var newAlphabetIndex38 = 0\n    var newAlphabetIndex39\
    \ = 0\n    var newAlphabetIndex40 = 0\n    var newAlphabetIndex41 = 0\n    var\
    \ newAlphabetIndex42 = 0\n    var newAlphabetIndex43 = 0\n    var newAlphabetIndex44\
    \ = 0\n    var newAlphabetIndex45 = 0\n    var newAlphabetIndex46 = 0\n    var\
    \ newAlphabetIndex47 = 0\n    var newAlphabetIndex48 = 0\n    var newAlphabetIndex49\
    \ = 0\n    var newAlphabetIndex50 = 0\n    var newAlphabetIndex51 = 0\n    var\
    \ newAlphabetIndex52 = 0\n    var newAlphabetIndex53 = 0\n    var newAlphabetIndex54\
    \ = 0\n    var newAlphabetIndex55 = 0\n    var newAlphabetIndex56 = 0\n    var\
    \ newAlphabetIndex57 = 0\n    var newAlphabetIndex58 = 0\n    var newAlphabetIndex59\
    \ = 0\n    var newAlphab\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w1k7q0g.swift:71:9: error: type annotation missing in pattern\n\
    \    var newAlphab\n        ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var encrypted:\
    \ [Character] = []\n    for letter in s {\n        encrypted.append(alphabet[alphabet.index(letter,\
    \ offsetBy: 2)])\n    }\n    return String(encrypted)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpswrzy62t.swift:11:50: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        encrypted.append(alphabet[alphabet.index(letter,\
    \ offsetBy: 2)])\n                                                 ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for letter in s {\n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n\
    \        alphabetIndex++\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0_sz6bf.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpc0_sz6bf.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    for character in s {\n        var index = alphabet.index(of: character)!\n\
    \        index = index + 2\n        index = index % alphabetLength\n        encryptedString\
    \ += alphabetRotated[index]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc8u_0_qu.swift:14:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: character)!\n \
    \                            ^\n/tmp/tmpc8u_0_qu.swift:14:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: character)!\n              \
    \               ^~~~~\n                             firstIndex\n/tmp/tmpc8u_0_qu.swift:15:23:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        index = index + 2\n                ~~~~~ ^ ~\n/tmp/tmpc8u_0_qu.swift:15:23:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        index = index + 2\n                      ^\n/tmp/tmpc8u_0_qu.swift:16:23:\
    \ error: binary operator '%' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        index = index % alphabetLength\n                ~~~~~ ^ ~~~~~~~~~~~~~~\n\
    /tmp/tmpc8u_0_qu.swift:16:23: note: overloads for '%' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        index = index % alphabetLength\n\
    \                      ^\n/tmp/tmpc8u_0_qu.swift:17:43: error: subscript 'subscript(_:)'\
    \ requires that 'String.Index' conform to 'RangeExpression'\n        encryptedString\
    \ += alphabetRotated[index]\n                                          ^\nSwift.Collection:2:23:\
    \ note: where 'R' = 'String.Index'\n    @inlinable public subscript<R>(r: R) ->\
    \ Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpae5g3h9t.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:11:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:12:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:17:31: error: missing argument label 'e"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk0b3a0h9.swift:41:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpk0b3a0h9.swift:40:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpk0b3a0h9.swift:9:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:10:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpk0b3a0h9.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:11:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpk0b3a0h9.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:12:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n/"
  stdout: ''
  timestamp: 1660028459
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var result = [Character]()\n\
    \    \n    for char in s {\n        var index = alphabet.index(of: char)!\n  \
    \      var newIndex = index * 2\n        \n        if newIndex > 26 {\n      \
    \      newIndex -= 26\n        }\n        \n        result.append(alphabet[newIndex])\n\
    \    }\n    \n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxw9e6ckf/tmpxw9e6ckf.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33aaf98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33aac8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33aac8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33aac8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxw9e6ckf                        0x0000556904cb3787 <unavailable> + 6023

    5    libc.so.6                          0x00002b33ab184460 __libc_start_main +
    245

    6    tmpxw9e6ckf                        0x0000556904cb33c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)!\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpodds21zj.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpodds21zj.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    alphabet.append(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    alphabet.append(\"\
    0123456789\")\n    alphabet.append(\"!@#$%^&*()\")\n    alphabet.append(\"~`-_=+[]{}\\\
    \\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\"\
    )\n    alphabet.append(\"~`-_=+[]{}\\\\|;:'\\\",<>?\")\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgemikiwb.swift:36:21: error: unterminated string literal\n    alphabet.append(\"\
    ~`-_=+[]{}\\\\|;:'\n                    ^\n/tmp/tmpgemikiwb.swift:36:21: error:\
    \ missing argument for parameter #1 in call\n    alphabet.append(\"~`-_=+[]{}\\\
    \\|;:'\n                    ^\n                    <#String#>\nSwift.Array:6:37:\
    \ note: 'append' declared here\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk0b3a0h9.swift:41:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpk0b3a0h9.swift:40:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpk0b3a0h9.swift:9:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:10:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpk0b3a0h9.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:11:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpk0b3a0h9.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:12:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n/"
  stdout: ''
  timestamp: 1660028459
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkdtgy7i7.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkdtgy7i7.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpkdtgy7i7.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetReversed\
    \ = alphabet.reversed()\n    var alphabetReversedLength = alphabetReversed.count\n\
    \    var alphabetReversedString = \"\"\n    for _ in 0..<s.count {\n        alphabetReversedString\
    \ += alphabetReversed[Int(arc4random_uniform(UInt32(alphabetReversedLength)))]\n\
    \    }\n    var alphabetReversedStringLength = alphabetReversedString.count\n\
    \    var alphabetReversedStringString = \"\"\n    for _ in 0..<s.count {\n   \
    \     alphabetReversedStringString += alphabetReversedString[Int(arc4random_uniform(UInt32(alphabetReversedStringLength)))]\n\
    \    }\n    var alphabetReversedStringStringLength = alphabetReversedStringString.count\n\
    \    var alphabetReversedStringStringString = \"\"\n    for _ in 0..<s.count {\n\
    \        alphabetReversedStringStringString += alphabetReversedStringString[Int(arc4random_uniform(UInt32(alphabetReversedStringStringLength)))]\n\
    \    }\n    var alphabetReversedStringStringStringLength = alphabetReversedStringStringString.count\n\
    \    var alphabetReversedStringStringStringString = \"\"\n    for _ in 0..<s.count\
    \ {\n        alphabetReversedStringStringStringString += alphabetReversedStringStringString[Int(arc4random_uniform(UInt32(alphabetReversedStringStringStringLength)))]\n\
    \    }\n    var alphabetReversedStringStringStringStringLength = alphabetReversedStringStringStringString.count\n\
    \    var alphabetReversedStringStringStringStringString = \"\"\n    for _ in 0..<s.count\
    \ {\n        alphabetReversedStringStringStringStringString += alphabetReversedStringStringStringString[Int(arc4random_uniform(UInt32(alphabetReversedStringStringStringStringLength)))]\n\
    \    }\n    var alphabetReversedStringStringStringStringStringLength = alphabetReversedStringStringStringStringString.count\n\
    \    var alphabetReversedStringStringStringStringStringString = \"\"\n    for\
    \ _ in 0..<s.count {\n        alphabetReversedStringStringStringStringStringString\
    \ += alphabetReversedStringStringStringStringString[Int(arc4random_uniform(UInt32(alphabetReversedStringStringStringStringStringLength)))]\n\
    \    }\n    var alphabetReversedStringStringStringStringStringStringLength = alphabetReversedStringStringStringStringStringStringString.count\n\
    \    var alphabetReversedStringStringStringStringStringStringString = \"\"\n \
    \   for _ in 0..<s.count {\n        alphabetReversedStringStringStringStringStringStringString\
    \ += alphabetReversedStringStringStringStringStringString[Int(arc4random_uniform(UInt32(alphabetReversedStringStringString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1e33vv8r.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp1e33vv8r.swift:43:153: note: to match this opening '('\n        alphabetReversedStringStringStringStringStringStringString\
    \ += alphabetReversedStringStringStringStringStringString[Int(arc4random_uniform(UInt32(alphabetReversedStringStringString\n\
    \                                                                            \
    \                                                                            ^\n\
    /tmp/tmp1e33vv8r.swift:66:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmp1e33vv8r.swift:7:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmp1e33vv8r.swift:13:56: error: cannot find\
    \ 'arc4random_uniform' in scope\n        alphabetReversedString += alphabetReversed[Int(arc4random_uniform(UInt32(alphabetReversedLength)))]\n\
    \                                                       ^~~~~~~~~~~~~~~~~~\n/tmp/tmp1e33vv8r.swift:13:51:\
    \ error: no exact matches in call to subscript \n        alphabetReversedString\
    \ += alphabetReversed[Int(arc4random_uniform(UInt32(alphabetReversedLength)))]\n\
    \                                                  ^\n/tmp/tmp1e33vv8r.swift:13:51:\
    \ note: found candidate with type '(Range<ReversedCollection<String>.Index>) ->\
    \ Slice<ReversedCollection<String>>'\n        alphabetReversedString += alphabetReversed[Int(arc4random_uniform(UInt32(alphabetReversedLength)))]\n\
    \                                                  ^\n/tmp/tmp1e33vv8r.swift:13:51:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> Slice<ReversedCollection<String>>'\n\
    \        alphabetReversedString += alphabetReversed[Int(arc4random_uniform(UInt32(alphabetReversedLength)))]\n\
    \                                                  ^\n/tmp/tmp1e33vv8r.swift:18:68:\
    \ error: cannot find 'arc4random_uniform' in scope\n        alphabetReversedStringString\
    \ += alphabetReversedString[Int(arc4random_uniform(UInt32(alphabetReversedStringLength)))]\n\
    \       "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"A\"))))\n \
    \   alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"B\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"C\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"D\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"E\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"F\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"G\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"H\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"I\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"J\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"K\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"L\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"M\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"N\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"O\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"P\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"Q\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"R\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"S\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"T\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"U\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"V\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"W\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"X\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"Y\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"Z\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"a\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"b\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"c\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"d\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgqa5zpna.swift:42:58: error: unterminated string literal\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"\n                                                         ^\n/tmp/tmpgqa5zpna.swift:9:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for c in s {\n        let index = alphabet.characters.indexOf(c)\n      \
    \  let newIndex = index + 2\n        result += alphabet[newIndex]\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpptjc51rl.swift:11:41: error: value of type 'String' has no member\
    \ 'indexOf'\n        let index = alphabet.characters.indexOf(c)\n            \
    \        ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2isi3_se.swift:10:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:11:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:12:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:13:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:14:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:15:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:16:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:17:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for character in s {\n        encryptedString += alphabet[alphabetIndex %\
    \ alphabetLength]\n        alphabetIndex++\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8auid2k9.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmp8auid2k9.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"A\"))\n\
    \    alphabet.append(Character(\"B\"))\n    alphabet.append(Character(\"C\"))\n\
    \    alphabet.append(Character(\"D\"))\n    alphabet.append(Character(\"E\"))\n\
    \    alphabet.append(Character(\"F\"))\n    alphabet.append(Character(\"G\"))\n\
    \    alphabet.append(Character(\"H\"))\n    alphabet.append(Character(\"I\"))\n\
    \    alphabet.append(Character(\"J\"))\n    alphabet.append(Character(\"K\"))\n\
    \    alphabet.append(Character(\"L\"))\n    alphabet.append(Character(\"M\"))\n\
    \    alphabet.append(Character(\"N\"))\n    alphabet.append(Character(\"O\"))\n\
    \    alphabet.append(Character(\"P\"))\n    alphabet.append(Character(\"Q\"))\n\
    \    alphabet.append(Character(\"R\"))\n    alphabet.append(Character(\"S\"))\n\
    \    alphabet.append(Character(\"T\"))\n    alphabet.append(Character(\"U\"))\n\
    \    alphabet.append(Character(\"V\"))\n    alphabet.append(Character(\"W\"))\n\
    \    alphabet.append(Character(\"X\"))\n    alphabet.append(Character(\"Y\"))\n\
    \    alphabet.append(Character(\"Z\"))\n    \n    var result = [Character]()\n\
    \    \n    for char in s {\n        var index = alphabet.index(of: char)!\n  \
    \      let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n  \
    \      result.append(newChar)\n    }\n    \n    return String(result)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppzn3oku3/tmppzn3oku3.swift:87: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17b8f46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17b8c3db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17b8c3d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17b8c3c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppzn3oku3                        0x0000563d5b8f3787 <unavailable> + 6023

    5    libc.so.6                          0x00002b17b9132460 __libc_start_main +
    245

    6    tmppzn3oku3                        0x0000563d5b8f33c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(UnicodeScalar(UInt8(UInt8(0xE3)\
    \ + UInt8(i)))))\n    }\n    \n    var result = \"\"\n    for char in s {\n  \
    \      let index = alphabet.index(of: char)!\n        let newIndex = index + 2\n\
    \        let newChar = alphabet[newIndex]\n        result += String(UnicodeScalar(newChar))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpj97u40zd.swift:10:75: error: cannot find 'i' in scope\n       \
    \ alphabet.append(Character(UnicodeScalar(UInt8(UInt8(0xE3) + UInt8(i)))))\n \
    \                                                                         ^\n\
    /tmp/tmpj97u40zd.swift:15:30: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let index = alphabet.index(of: char)!\n         \
    \                    ^\n/tmp/tmpj97u40zd.swift:15:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)!\n                   \
    \          ^~~~~\n                             firstIndex\n/tmp/tmpj97u40zd.swift:18:26:\
    \ error: no exact matches in call to initializer \n        result += String(UnicodeScalar(newChar))\n\
    \                         ^\nSwift.Unicode.Scalar:7:23: note: candidate expects\
    \ value of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable public\
    \ init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23: note:\
    \ candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'Character')\n\
    \    @inlinable public init(_ v: Unicode.Scalar)\n                      ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpw1uoxfa7.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw1uoxfa7.swift:10:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    let alphabetLength = alphabet.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw1uoxfa7.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n     \
    \   ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmpw1uoxfa7.swift:11:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw1uoxfa7.swift:11:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmpw1uoxfa7.swift:12:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw1uoxfa7.swift:12:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphab"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(24))))\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(25))))\n\
    \    alphabet.append(Character(s.character\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpje35er1d.swift:36:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpje35er1d.swift:35:30: note: to match this opening '('\n    alphabet.append(Character(s.character\n\
    \                             ^\n/tmp/tmpje35er1d.swift:9:33: error: value of\
    \ type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpje35er1d.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpje35er1d.swift:10:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpje35er1d.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpje35er1d.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpje35er1d.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpje35er1d.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpje35er1d.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\n\
    \                    "
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2isi3_se.swift:10:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:11:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:12:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:13:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:14:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:15:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:16:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:17:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var newAlphabet = String()\n    var newAlphabetLength\
    \ = newAlphabet.count\n    var newAlphabetIndex = 0\n    var newAlphabetIndex2\
    \ = 0\n    var newAlphabetIndex3 = 0\n    var newAlphabetIndex4 = 0\n    var newAlphabetIndex5\
    \ = 0\n    var newAlphabetIndex6 = 0\n    var newAlphabetIndex7 = 0\n    var newAlphabetIndex8\
    \ = 0\n    var newAlphabetIndex9 = 0\n    var newAlphabetIndex10 = 0\n    var\
    \ newAlphabetIndex11 = 0\n    var newAlphabetIndex12 = 0\n    var newAlphabetIndex13\
    \ = 0\n    var newAlphabetIndex14 = 0\n    var newAlphabetIndex15 = 0\n    var\
    \ newAlphabetIndex16 = 0\n    var newAlphabetIndex17 = 0\n    var newAlphabetIndex18\
    \ = 0\n    var newAlphabetIndex19 = 0\n    var newAlphabetIndex20 = 0\n    var\
    \ newAlphabetIndex21 = 0\n    var newAlphabetIndex22 = 0\n    var newAlphabetIndex23\
    \ = 0\n    var newAlphabetIndex24 = 0\n    var newAlphabetIndex25 = 0\n    var\
    \ newAlphabetIndex26 = 0\n    var newAlphabetIndex27 = 0\n    var newAlphabetIndex28\
    \ = 0\n    var newAlphabetIndex29 = 0\n    var newAlphabetIndex30 = 0\n    var\
    \ newAlphabetIndex31 = 0\n    var newAlphabetIndex32 = 0\n    var newAlphabetIndex33\
    \ = 0\n    var newAlphabetIndex34 = 0\n    var newAlphabetIndex35 = 0\n    var\
    \ newAlphabetIndex36 = 0\n    var newAlphabetIndex37 = 0\n    var newAlphabetIndex38\
    \ = 0\n    var newAlphabetIndex39 = 0\n    var newAlphabetIndex40 = 0\n    var\
    \ newAlphabetIndex41 = 0\n    var newAlphabetIndex42 = 0\n    var newAlphabetIndex43\
    \ = 0\n    var newAlphabetIndex44 = 0\n    var newAlphabetIndex45 = 0\n    var\
    \ newAlphabetIndex46 = 0\n    var newAlphabetIndex47 = 0\n    var newAlphabetIndex48\
    \ = 0\n    var newAlphabetIndex49 = 0\n    var newAlphabetIndex50 = 0\n    var\
    \ newAlphabetIndex51 = 0\n    var newAlphabetIndex52 = 0\n    var newAlphabetIndex53\
    \ = 0\n    var newAlphabetIndex54 = 0\n    var newAlphabetIndex55 = 0\n    var\
    \ newAlphabetIndex56 = 0\n    var newAlphabetIndex57 = 0\n    var newAlphabetIndex58\
    \ = 0\n    var newAlphabetIndex59 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1nxlt_vq.swift:8:9: warning: variable 'alphabet' was never mutated;\
    \ consider changing to 'let' constant\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    ~~~ ^\n    let\n/tmp/tmp1nxlt_vq.swift:9:9: warning: initialization of variable\
    \ 'alphabetLength' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var alphabetLength = alphabet.count\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp1nxlt_vq.swift:10:9: warning: variable 'newAlphabet' was never\
    \ mutated; consider changing to 'let' constant\n    var newAlphabet = String()\n\
    \    ~~~ ^\n    let\n/tmp/tmp1nxlt_vq.swift:11:9: warning: initialization of variable\
    \ 'newAlphabetLength' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var newAlphabetLength = newAlphabet.count\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp1nxlt_vq.swift:12:9: warning: initialization of variable 'newAlphabetIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var newAlphabetIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1nxlt_vq.swift:13:9:\
    \ warning: initialization of variable 'newAlphabetIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var newAlphabetIndex2 =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1nxlt_vq.swift:14:9: warning: initialization\
    \ of variable 'newAlphabetIndex3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var newAlphabetIndex3 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp1nxlt_vq.swift:15:9: warning: initialization of variable 'newAlphabetIndex4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var newAlphabetIndex4 = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1nxlt_vq.swift:16:9:\
    \ warning: initialization of variable 'newAlphabetIndex5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var newAlphabetIndex5 =\
    \ 0\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1nxlt_vq.swift:17:9: warning: initialization\
    \ of variable 'newAlphabetIndex6' was never used; consider replacing with assignment\
    \ to '_' or rem"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for char in s.characters {\n      \
    \  alphabet.append(char.uppercased())\n    }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc9pwkd5a.swift:37:66: error: expected member name following '.'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.\n        \
    \                                                         ^\n/tmp/tmpc9pwkd5a.swift:38:1:\
    \ error: expected ')' in expression list\n}\n^\n/tmp/tmpc9pwkd5a.swift:37:60:\
    \ note: to match this opening '('\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.\n\
    \                                                           ^\n/tmp/tmpc9pwkd5a.swift:9:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpc9pwkd5a.swift:10:18: error: no exact matches in call\
    \ to instance method 'append'\n        alphabet.append(char.uppercased())\n  \
    \               ^\nSwift.Array:7:37: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(contentsOf:)')\n    @inlinable public mutating func append<S>(contentsOf\
    \ newElements: __owned S) where Element == S.Element, S : Sequence\n         \
    \                           ^\nSwift.RangeReplaceableCollection:5:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable\
    \ public mutating func append<S>(contentsOf newElements: __owned S) where S :\
    \ Sequence, Self.Element == S.Element\n                                    ^\n\
    /tmp/tmpc9pwkd5a.swift:12:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max) + 2)))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpc9pwkd5a.swift:13:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpc9pwkd5a.swift:14:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n              "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var result = \"\"\n    for letter\
    \ in s {\n        var index = alphabet.index(letter)\n        index = index +\
    \ 2\n        index = index % alphabet.count\n        result = result + alphabet[index]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpceio12bl.swift:38:36: error: missing argument label 'of:' in call\n\
    \        var index = alphabet.index(letter)\n                                \
    \   ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayReversed = Array(alphabet)\n    for\
    \ var i = 0; i < alphabetArray.count; i++ {\n        alphabetArrayReversed[i]\
    \ = alphabetArray[alphabetArray.count - i - 1]\n    }\n    var result = \"\"\n\
    \    for var i = 0; i < s.count; i++ {\n        var index = alphabet.index(s.characters[i])\n\
    \        index = alphabetArrayReversed[index % alphabet.count]\n        result\
    \ += String(index)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7bqie0ep.swift:11:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < alphabetArray.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7bqie0ep.swift:15:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for var i = 0; i < s.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7bqie0ep.swift:16:36: error: missing argument label 'of:' in call\n  \
    \      var index = alphabet.index(s.characters[i])\n                         \
    \          ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetReversed\
    \ = alphabet.reversed()\n    var alphabetReversedLength = alphabetReversed.count\n\
    \    var alphabetReversedString = \"\"\n    for _ in 0..<alphabetReversedLength\
    \ {\n        alphabetReversedString += alphabetReversed\n    }\n    var alphabetReversedStringLength\
    \ = alphabetReversedString.count\n    var alphabetReversedStringArray = Array(alphabetReversedString)\n\
    \    var alphabetReversedStringArrayLength = alphabetReversedStringArray.count\n\
    \    var alphabetReversedStringArrayReversed = Array(alphabetReversedStringArray.reversed())\n\
    \    var alphabetReversedStringArrayReversedLength = alphabetReversedStringArrayReversed.count\n\
    \    var alphabetReversedStringArrayReversedString = \"\"\n    for _ in 0..<alphabetReversedStringArrayReversedLength\
    \ {\n        alphabetReversedStringArrayReversedString += alphabetReversedStringArrayReversed\n\
    \    }\n    var alphabetReversedStringArrayReversedStringLength = alphabetReversedStringArrayReversedString.count\n\
    \    var alphabetReversedStringArrayReversedStringArray = Array(alphabetReversedStringArrayReversedString)\n\
    \    var alphabetReversedStringArrayReversedStringArrayLength = alphabetReversedStringArrayReversedStringArray.count\n\
    \    var alphabetReversedStringArrayReversedStringArrayReversed = Array(alphabetReversedStringArrayReversedStringArray.reversed())\n\
    \    var alphabetReversedStringArrayReversedStringArrayReversedLength = alphabetReversedStringArrayReversedStringArrayReversed.count\n\
    \    var alphabetReversedStringArrayReversedStringArrayReversedString = \"\"\n\
    \    for _ in 0..<alphabetReversedStringArrayReversedStringArrayLength {\n   \
    \     alphabetReversedStringArrayReversedStringArrayReversedString += alphabetReversedStringArrayReversedStringArrayReversed\n\
    \    }\n    var alphabetReversedStringArrayReversedStringArrayReversedStringLength\
    \ = alphabetReversedStringArrayReversedStringArrayReversedString.count\n    var\
    \ alphabetReversedStringArrayReversedStringArrayReversedStringArray = Array(alphabetReversedStringArrayReversedStringArrayReversedString)\n\
    \    var alphabetReversedStringArrayReversedStringArrayReversedStringArrayLength\
    \ = alphabetReversedStringArrayReversedStringArrayReversedStringArray.count\n\
    \    var alphabetReversedStringArrayReversedStringArrayReversedStringArrayReversed\
    \ = Array(alphabetReversedStringArrayReversedStringArrayReversedStringArray.reversed())\n\
    \    var alphabetReversedStringArrayReversedStringArrayReversedStringArrayReversedLength\
    \ = alphabetReversedStringArrayReversedStringArrayReversedStringArrayReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbhm6h0od.swift:37:91: error: cannot find 'alphabetReversedStringArrayReversedStringArrayReversedStringArrayReverse'\
    \ in scope\n    var alphabetReversedStringArrayReversedStringArrayReversedStringArrayReversedLength\
    \ = alphabetReversedStringArrayReversedStringArrayReversedStringArrayReverse\n\
    \                                                                            \
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append (\"a\")\n    alphabet.append\
    \ (\"b\")\n    alphabet.append (\"c\")\n    alphabet.append (\"d\")\n    alphabet.append\
    \ (\"e\")\n    alphabet.append (\"f\")\n    alphabet.append (\"g\")\n    alphabet.append\
    \ (\"h\")\n    alphabet.append (\"i\")\n    alphabet.append (\"j\")\n    alphabet.append\
    \ (\"k\")\n    alphabet.append (\"l\")\n    alphabet.append (\"m\")\n    alphabet.append\
    \ (\"n\")\n    alphabet.append (\"o\")\n    alphabet.append (\"p\")\n    alphabet.append\
    \ (\"q\")\n    alphabet.append (\"r\")\n    alphabet.append (\"s\")\n    alphabet.append\
    \ (\"t\")\n    alphabet.append (\"u\")\n    alphabet.append (\"v\")\n    alphabet.append\
    \ (\"w\")\n    alphabet.append (\"x\")\n    alphabet.append (\"y\")\n    alphabet.append\
    \ (\"z\")\n    \n    var newString = \"\"\n    for char in s {\n        var index\
    \ = alphabet.index(char)\n        index = index + 2\n        index = index % alphabet.count\n\
    \        newString = newString + alphabet[index]\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_q35tsy4.swift:38:36: error: missing argument label 'of:' in call\n\
    \        var index = alphabet.index(char)\n                                  \
    \ ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\
    \ // fifth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\
    \ // sixth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\
    \ // seventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\
    \ // eighth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\
    \ // ninth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\
    \ // tenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\
    \ // eleventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\
    \ // twelfth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\
    \ // thirteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\
    \ // fourteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\
    \ // fifteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\
    \ // sixteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\
    \ // seventeenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\
    \ // eighteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\
    \ // nineteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\
    \ // twentieth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\
    \ // twenty-first letter\n    alphabet.append(Character(s.characterAt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprl5n3xqr.swift:31:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmprl5n3xqr.swift:30:30: note: to match this opening '('\n    alphabet.append(Character(s.characterAt\n\
    \                             ^\n/tmp/tmprl5n3xqr.swift:9:33: error: value of\
    \ type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.a"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotated\
    \ = \"zyxwvutsrqponmlkjihgfedcba\"\n    var encryptedString = \"\"\n    for letter\
    \ in s {\n        encryptedString += alphabetRotated[alphabet.index(letter)! +\
    \ 2]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0z_jep4_.swift:12:43: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabetRotated[alphabet.index(letter)! + 2]\n\
    \                                          ^\n/tmp/tmp0z_jep4_.swift:12:43: note:\
    \ candidate expects value of type 'Range<String.Index>' for parameter #1 (got\
    \ 'Character')\n        encryptedString += alphabetRotated[alphabet.index(letter)!\
    \ + 2]\n                                          ^\n/tmp/tmp0z_jep4_.swift:12:43:\
    \ note: found candidate with type '(String.Index) -> String.SubSequence' (aka\
    \ '(String.Index) -> Substring')\n        encryptedString += alphabetRotated[alphabet.index(letter)!\
    \ + 2]\n                                          ^\n/tmp/tmp0z_jep4_.swift:12:43:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Character')\n        encryptedString += alphabetRotated[alphabet.index(letter)!\
    \ + 2]\n                                          ^\n/tmp/tmp0z_jep4_.swift:12:68:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        encryptedString += alphabetRotated[alphabet.index(letter)!\
    \ + 2]\n                                           ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n\
    /tmp/tmp0z_jep4_.swift:12:68: note: overloads for '+' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        encryptedString += alphabetRotated[alphabet.index(letter)!\
    \ + 2]\n                                                                   ^\n\
    /tmp/tmp0z_jep4_.swift:12:59: error: missing argument label 'of:' in call\n  \
    \      encryptedString += alphabetRotated[alphabet.index(letter)! + 2]\n     \
    \                                                     ^\n                    \
    \                                      of: \n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var encryptedString = \"\"\n\
    \    for char in s {\n        encryptedString += alphabet[alphabet.index(char.lowercased())!]\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkz4sqsdj.swift:38:36: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        encryptedString += alphabet[alphabet.index(char.lowercased())!]\n\
    \                                   ^\n/tmp/tmpkz4sqsdj.swift:38:46: error: no\
    \ exact matches in call to instance method 'index'\n        encryptedString +=\
    \ alphabet[alphabet.index(char.lowercased())!]\n                             \
    \                ^\n/tmp/tmpkz4sqsdj.swift:38:46: note: candidate expects value\
    \ of type '(Character) throws -> Bool' for parameter #1 (got 'String')\n     \
    \   encryptedString += alphabet[alphabet.index(char.lowercased())!]\n        \
    \                                     ^\n/tmp/tmpkz4sqsdj.swift:38:46: note: candidate\
    \ expects value of type 'Character' for parameter #1 (got 'String')\n        encryptedString\
    \ += alphabet[alphabet.index(char.lowercased())!]\n                          \
    \                   ^\n/tmp/tmpkz4sqsdj.swift:38:36: error: no exact matches in\
    \ call to subscript \n        encryptedString += alphabet[alphabet.index(char.lowercased())!]\n\
    \                                   ^\n/tmp/tmpkz4sqsdj.swift:38:36: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'String')\n        encryptedString\
    \ += alphabet[alphabet.index(char.lowercased())!]\n                          \
    \         ^\n/tmp/tmpkz4sqsdj.swift:38:36: note: candidate expects value of type\
    \ 'Range<Int>' for parameter #1 (got 'String')\n        encryptedString += alphabet[alphabet.index(char.lowercased())!]\n\
    \                                   ^\n/tmp/tmpkz4sqsdj.swift:38:36: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'String')\n\
    \        encryptedString += alphabet[alphabet.index(char.lowercased())!]\n   \
    \                                ^\n/tmp/tmpkz4sqsdj.swift:38:36: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'String')\n\
    \        encryptedString += alphabet[alphabet.index(char.lowercased())!]\n   \
    \                                ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var encryptedString = \"\"\n\
    \    for char in s {\n        var index = alphabet.index(of: char)\n        index\
    \ = index + 2\n        index = index % alphabet.count\n        encryptedString\
    \ += alphabet[index]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2r8b5v6k.swift:38:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: char)\n       \
    \                      ^\n/tmp/tmp2r8b5v6k.swift:38:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: char)\n                    \
    \         ^~~~~\n                             firstIndex\n/tmp/tmp2r8b5v6k.swift:39:17:\
    \ error: value of optional type 'Array<Character>.Index?' (aka 'Optional<Int>')\
    \ must be unwrapped to a value of type 'Array<Character>.Index' (aka 'Int')\n\
    \        index = index + 2\n                ^\n/tmp/tmp2r8b5v6k.swift:39:17: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        index = index + 2\n                ^\n                (     ?? <#default\
    \ value#>)\n/tmp/tmp2r8b5v6k.swift:39:17: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        index = index + 2\n\
    \                ^\n                     !\n/tmp/tmp2r8b5v6k.swift:40:17: error:\
    \ value of optional type 'Array<Character>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Character>.Index' (aka 'Int')\n     \
    \   index = index % alphabet.count\n                ^\n/tmp/tmp2r8b5v6k.swift:40:17:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        index = index % alphabet.count\n                ^\n         \
    \       (     ?? <#default value#>)\n/tmp/tmp2r8b5v6k.swift:40:17: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        index\
    \ = index % alphabet.count\n                ^\n                     !\n/tmp/tmp2r8b5v6k.swift:41:36:\
    \ error: no exact matches in call to subscript \n        encryptedString += alphabet[index]\n\
    \                                   ^\nSwift.Array:17:23: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got 'Array<Character>.Index?' (aka\
    \ 'Optional<Int>'))\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(s.characters)\n    alphabet.append(s.characters.reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed())\n    alphabet.append(s.characters.reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx755yfk7.swift:27:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpx755yfk7.swift:26:20: note: to match this opening '('\n    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reverse\n\
    \                   ^\n/tmp/tmpx755yfk7.swift:9:23: error: 'characters' is unavailable:\
    \ Please use String directly\n    alphabet.append(s.characters)\n            \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpx755yfk7.swift:10:14: error: no exact matches in call to instance method\
    \ 'append'\n    alphabet.append(s.characters.reversed())\n             ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got '[String.Element]'\
    \ (aka 'Array<Character>'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got '[String.Element]'\
    \ (aka 'Array<Character>'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpx755yfk7.swift:10:14:\
    \ note: found candidate with type '(__owned [String.Element]) -> ()' (aka '(__owned\
    \ Array<Character>) -> ()')\n    alphabet.append(s.characters.reversed())\n  \
    \           ^\n/tmp/tmpx755yfk7.swift:11:23: error: 'characters' is unavailable:\
    \ Please use String directly\n    alphabet.append(s.characters.reversed().reversed())\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx755yfk7.swift:12:14: error: no exact matches in call to instance\
    \ method 'append'\n    alphabet.append(s.characters.reversed().reversed().reversed())\n\
    \             ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n "
  stdout: ''
  timestamp: 1660028810
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += alphabet[0]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoveoduej.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpoveoduej.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmpoveoduej.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        if newIndex < alphabet.count {\n              \
    \        ^~~~~~~~\n/tmp/tmpoveoduej.swift:13:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[newIndex]\n                      ^~~~~~~~\n\
    /tmp/tmpoveoduej.swift:15:23: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayReversed = Array(alphabet)\n    for\
    \ i in 0..<alphabetArray.count {\n        alphabetArrayReversed[i] = alphabetArray[alphabetArray.count\
    \ - i - 1]\n    }\n    var result = \"\"\n    for i in 0..<s.count {\n       \
    \ var index = alphabet.index(s.characters[i])\n        index = alphabetArrayReversed[index]\n\
    \        result += String(index)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpom4jhw_w.swift:16:36: error: missing argument label 'of:' in call\n\
    \        var index = alphabet.index(s.characters[i])\n                       \
    \            ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\
    \    alphabet.append(s)\n    alphabet.append(s)\n    alphabet.append(s)\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpq1b002m8.swift:111:1: error: missing return in global function
    expected to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for letter in s {\n        let index = alphabet.index(of: letter)!\n    \
    \    let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n  \
    \      result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt6_rbzho.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: letter)!\n    \
    \                         ^\n/tmp/tmpt6_rbzho.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: letter)!\n                 \
    \            ^~~~~\n                             firstIndex\n/tmp/tmpt6_rbzho.swift:12:24:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index + 2\n                       ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters[s.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+1]))\n    alphabet.append(Character(s.characters[s.startIndex+2]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+3]))\n    alphabet.append(Character(s.characters[s.startIndex+4]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+5]))\n    alphabet.append(Character(s.characters[s.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+7]))\n    alphabet.append(Character(s.characters[s.startIndex+8]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+9]))\n    alphabet.append(Character(s.characters[s.startIndex+10]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+11]))\n    alphabet.append(Character(s.characters[s.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+13]))\n    alphabet.append(Character(s.characters[s.startIndex+14]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+15]))\n    alphabet.append(Character(s.characters[s.startIndex+16]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+17]))\n    alphabet.append(Character(s.characters[s.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+19]))\n    alphabet.append(Character(s.characters[s.startIndex+20]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+21]))\n    alphabet.append(Character(s.characters[s.startIndex+22]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+23]))\n    alphabet.append(Character(s.characters[s.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+25]))\n    alphabet.append(Character(s.characters[s.startIndex+26]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+27]))\n    alphabet.append(Character(s.characters[s.startIndex+28]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+29]))\n    alphabet.append(Character(s.characters[s.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+31]))\n    alphabet.append(Character(s.characters[s.startIndex+32]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+33\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp67heoyam.swift:43:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp67heoyam.swift:42:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.startIndex+33\n\
    \                                          ^\n/tmp/tmp67heoyam.swift:9:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.startIndex+1]))\n    \
    \                          ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:10:46: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.startIndex+1]))\n\
    \                                             ^\n/tmp/tmp67heoyam.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.startIndex+2]))\n                \
    \              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:11:46: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.startIndex+2]))\n\
    \                                             ^\n/tmp/tmp67heoyam.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.startIndex+3]))\n                \
    \              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:12:46: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.startIndex+3]))\n\
    \                                             ^\n/tmp/tmp67heoyam.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.appe"
  stdout: ''
  timestamp: 1660028460
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpp3enfdhb.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpp3enfdhb.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    var encryptedStringLength = s.count\n    for i in 0..<encryptedStringLength\
    \ {\n        var encryptedChar = alphabet[Int(arc4random_uniform(UInt32(alphabetLength)))]\n\
    \        encryptedString += encryptedChar\n        encryptedString += alphabet[Int(arc4random_uniform(UInt32(alphabetRotatedLength)))]\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpksh83zq8.swift:15:42: error: cannot find 'arc4random_uniform' in\
    \ scope\n        var encryptedChar = alphabet[Int(arc4random_uniform(UInt32(alphabetLength)))]\n\
    \                                         ^~~~~~~~~~~~~~~~~~\n/tmp/tmpksh83zq8.swift:17:41:\
    \ error: cannot find 'arc4random_uniform' in scope\n        encryptedString +=\
    \ alphabet[Int(arc4random_uniform(UInt32(alphabetRotatedLength)))]\n         \
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpksh83zq8.swift:17:36:\
    \ error: no exact matches in call to subscript \n        encryptedString += alphabet[Int(arc4random_uniform(UInt32(alphabetRotatedLength)))]\n\
    \                                   ^\n/tmp/tmpksh83zq8.swift:17:36: note: found\
    \ candidate with type '(Range<String.Index>) -> Substring'\n        encryptedString\
    \ += alphabet[Int(arc4random_uniform(UInt32(alphabetRotatedLength)))]\n      \
    \                             ^\n/tmp/tmpksh83zq8.swift:17:36: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> String.SubSequence' (aka '((UnboundedRange_)\
    \ -> ()) -> Substring')\n        encryptedString += alphabet[Int(arc4random_uniform(UInt32(alphabetRotatedLength)))]\n\
    \                                   ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpatjcy9z_.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpatjcy9z_.swift:12:23:\
    \ error: cannot find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n\
    \                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabetLength * 2\n \
    \   let alphabetLength = alphabetLength + 2\n    var newString = \"\"\n    for\
    \ character in s.characters {\n        let index = alphabet.characters.index(of:\
    \ character)!\n        let newIndex = index % alphabetLength\n        newString\
    \ = newString + alphabet[newIndex]\n    }\n    return newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmph_gf35i4.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph_gf35i4.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabetLength * 2\n        ^\n/tmp/tmph_gf35i4.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmph_gf35i4.swift:13:24: error: 'characters' is unavailable:\
    \ Please use String directly\n    for character in s.characters {\n          \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmph_gf35i4.swift:14:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        let index = alphabet.characters.index(of: character)!\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph_gf35i4.swift:14:41: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let index = alphabet.characters.index(of:\
    \ character)!\n                                        ^\n/tmp/tmph_gf35i4.swift:14:41:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.characters.index(of:\
    \ character)!\n                                        ^~~~~\n               \
    \                         firstIndex\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1bjp5nmq.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp1bjp5nmq.swift:12:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp1bjp5nmq.swift:13:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp1bjp5nmq.swift:15:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.insert(Character(UnicodeScalar(UInt8(97)).value),\
    \ at: 0)\n    alphabet.insert(Character(UnicodeScalar(UInt8(98)).value), at: 1)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(99)).value), at: 2)\n    alphabet.insert(Character(UnicodeScalar(UInt8(100)).value),\
    \ at: 3)\n    alphabet.insert(Character(UnicodeScalar(UInt8(101)).value), at:\
    \ 4)\n    alphabet.insert(Character(UnicodeScalar(UInt8(102)).value), at: 5)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(103)).value), at: 6)\n    alphabet.insert(Character(UnicodeScalar(UInt8(104)).value),\
    \ at: 7)\n    alphabet.insert(Character(UnicodeScalar(UInt8(105)).value), at:\
    \ 8)\n    alphabet.insert(Character(UnicodeScalar(UInt8(106)).value), at: 9)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(107)).value), at: 10)\n   \
    \ alphabet.insert(Character(UnicodeScalar(UInt8(108)).value), at: 11)\n    alphabet.insert(Character(UnicodeScalar(UInt8(109)).value),\
    \ at: 12)\n    alphabet.insert(Character(UnicodeScalar(UInt8(110)).value), at:\
    \ 13)\n    alphabet.insert(Character(UnicodeScalar(UInt8(111)).value), at: 14)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(112)).value), at: 15)\n   \
    \ alphabet.insert(Character(UnicodeScalar(UInt8(113)).value), at: 16)\n    alphabet.insert(Character(UnicodeScalar(UInt8(114)).value),\
    \ at: 17)\n    alphabet.insert(Character(UnicodeScalar(UInt8(115)).value), at:\
    \ 18)\n    alphabet.insert(Character(UnicodeScalar(UInt8(116)).value), at: 19)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(117)).value), at: 20)\n   \
    \ alphabet.insert(Character(UnicodeScalar(UInt8(118)).value), at: 21)\n    alphabet.insert(Character(UnicodeScalar(UInt8(119)).value),\
    \ at: 22)\n    alphabet.insert(Character(UnicodeScalar(UInt8(120)).value), at:\
    \ 23)\n    alphabet.insert(Character(UnicodeScalar(UInt8(121)).value), at: 24)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(122)).value), at: 25)\n   \
    \ alphabet.insert(Character(UnicodeScalar(UInt\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsj7fmqfx.swift:36:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpsj7fmqfx.swift:35:44: note: to match this opening '('\n    alphabet.insert(Character(UnicodeScalar(UInt\n\
    \                                           ^\n/tmp/tmpsj7fmqfx.swift:9:21: error:\
    \ no exact matches in call to initializer \n    alphabet.insert(Character(UnicodeScalar(UInt8(97)).value),\
    \ at: 0)\n                    ^\nSwift.Character:2:23: note: candidate expects\
    \ value of type 'Unicode.Scalar' for parameter #1 (got 'UInt32')\n    @inlinable\
    \ public init(_ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'UInt32')\n\
    \    @inlinable public init(_ s: String)\n                      ^\n/tmp/tmpsj7fmqfx.swift:10:21:\
    \ error: no exact matches in call to initializer \n    alphabet.insert(Character(UnicodeScalar(UInt8(98)).value),\
    \ at: 1)\n                    ^\nSwift.Character:2:23: note: candidate expects\
    \ value of type 'Unicode.Scalar' for parameter #1 (got 'UInt32')\n    @inlinable\
    \ public init(_ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'UInt32')\n\
    \    @inlinable public init(_ s: String)\n                      ^\n/tmp/tmpsj7fmqfx.swift:11:21:\
    \ error: no exact matches in call to initializer \n    alphabet.insert(Character(UnicodeScalar(UInt8(99)).value),\
    \ at: 2)\n                    ^\nSwift.Character:2:23: note: candidate expects\
    \ value of type 'Unicode.Scalar' for parameter #1 (got 'UInt32')\n    @inlinable\
    \ public init(_ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'UInt32')\n\
    \    @inlinable public init(_ s: String)\n                      ^\n/tmp/tmpsj7fmqfx.swift:12:21:\
    \ error: no exact matches in call to initializer \n    alphabet.insert(Character(UnicodeScalar(UInt8(100)).value),\
    \ at: 3)\n                    ^\nSwift.Character:2:23: note: candidate expects\
    \ value of type 'Unicode.Scalar' for par"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    for character in s {\n        encryptedString += alphabet[alphabet.index(alphabet,\
    \ character) + alphabetRotated.index(alphabetRotated, character)]\n    }\n   \
    \ return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbuoor46g.swift:14:36: error: subscript 'subscript(_:)' requires\
    \ that 'String.Index' conform to 'RangeExpression'\n        encryptedString +=\
    \ alphabet[alphabet.index(alphabet, character) + alphabetRotated.index(alphabetRotated,\
    \ character)]\n                                   ^\nSwift.Collection:2:23: note:\
    \ where 'R' = 'String.Index'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\n/tmp/tmpbuoor46g.swift:14:37: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'Character' conform to 'BinaryInteger'\n        encryptedString\
    \ += alphabet[alphabet.index(alphabet, character) + alphabetRotated.index(alphabetRotated,\
    \ character)]\n                                    ^\nSwift.Collection:3:17: note:\
    \ where 'T' = 'Character'\n    public func index<T>(_ i: Self.Index, offsetBy\
    \ n: T) -> Self.Index where T : BinaryInteger\n                ^\n/tmp/tmpbuoor46g.swift:14:51:\
    \ error: missing argument label 'offsetBy:' in call\n        encryptedString +=\
    \ alphabet[alphabet.index(alphabet, character) + alphabetRotated.index(alphabetRotated,\
    \ character)]\n                                                  ^\n         \
    \                                                    offsetBy: \n/tmp/tmpbuoor46g.swift:14:52:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Index'\n\
    \        encryptedString += alphabet[alphabet.index(alphabet, character) + alphabetRotated.index(alphabetRotated,\
    \ character)]\n                                                   ^\n/tmp/tmpbuoor46g.swift:14:73:\
    \ error: referencing operator function '+' on 'FloatingPoint' requires that 'String.Index'\
    \ conform to 'FloatingPoint'\n        encryptedString += alphabet[alphabet.index(alphabet,\
    \ character) + alphabetRotated.index(alphabetRotated, character)]\n          \
    \                                                              ^\nSwift.FloatingPoint:1:17:\
    \ note: where 'Self' = 'String.Index'\npublic protocol FloatingPoint : Hashable,\
    \ SignedNumeric, Strideable where Self =="
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpw1uoxfa7.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw1uoxfa7.swift:10:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    let alphabetLength = alphabet.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw1uoxfa7.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n     \
    \   ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmpw1uoxfa7.swift:11:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw1uoxfa7.swift:11:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmpw1uoxfa7.swift:12:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw1uoxfa7.swift:12:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphab"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    newAlphabet = alphabet[newAlphabet.count - 2] + alphabet[newAlphabet.count\
    \ - 1]\n    return newAlphabet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3mzneilm.swift:10:51: error: binary operator '+' cannot be applied\
    \ to operands of type 'Substring' and 'Character'\n    newAlphabet = alphabet[newAlphabet.count\
    \ - 2] + alphabet[newAlphabet.count - 1]\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3mzneilm.swift:10:27: error: no exact\
    \ matches in call to subscript \n    newAlphabet = alphabet[newAlphabet.count\
    \ - 2] + alphabet[newAlphabet.count - 1]\n                          ^\n/tmp/tmp3mzneilm.swift:10:27:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \    newAlphabet = alphabet[newAlphabet.count - 2] + alphabet[newAlphabet.count\
    \ - 1]\n                          ^\n/tmp/tmp3mzneilm.swift:10:27: note: candidate\
    \ has partially matching parameter list (Int)\n    newAlphabet = alphabet[newAlphabet.count\
    \ - 2] + alphabet[newAlphabet.count - 1]\n                          ^\n/tmp/tmp3mzneilm.swift:10:27:\
    \ note: candidate has partially matching parameter list ((UnboundedRange_) ->\
    \ ())\n    newAlphabet = alphabet[newAlphabet.count - 2] + alphabet[newAlphabet.count\
    \ - 1]\n                          ^\n/tmp/tmp3mzneilm.swift:10:61: error: no exact\
    \ matches in call to subscript \n    newAlphabet = alphabet[newAlphabet.count\
    \ - 2] + alphabet[newAlphabet.count - 1]\n                                   \
    \                         ^\n/tmp/tmp3mzneilm.swift:10:61: note: candidate has\
    \ partially matching parameter list (Int)\n    newAlphabet = alphabet[newAlphabet.count\
    \ - 2] + alphabet[newAlphabet.count - 1]\n                                   \
    \                         ^\n/tmp/tmp3mzneilm.swift:10:61: note: candidate has\
    \ partially matching parameter list (Range<String.Index>)\n    newAlphabet = alphabet[newAlphabet.count\
    \ - 2] + alphabet[newAlphabet.count - 1]\n                                   \
    \                         ^\n/tmp/tmp3mzneilm.swift:10:61: note: candidate has\
    \ partially matching parameter list ((UnboundedRange_) -> ())\n    newAlphabet\
    \ = alphabet[newAlphabet.count - 2] + alphabet[newAlphabet.count - 1]\n      \
    \                 "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for c in s.characters {\n        let index = alphabet.characters.indexOf(c)\n\
    \        let newIndex = index + 2\n        result += alphabet[newIndex]\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprcz74xso.swift:10:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprcz74xso.swift:11:41:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = alphabet.characters.indexOf(c)\n\
    \                    ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character : Character]()\n    alphabet[\"A\"] = \"Z\"\
    \n    alphabet[\"B\"] = \"Y\"\n    alphabet[\"C\"] = \"X\"\n    alphabet[\"D\"\
    ] = \"W\"\n    alphabet[\"E\"] = \"V\"\n    alphabet[\"F\"] = \"U\"\n    alphabet[\"\
    G\"] = \"T\"\n    alphabet[\"H\"] = \"S\"\n    alphabet[\"I\"] = \"R\"\n    alphabet[\"\
    J\"] = \"Q\"\n    alphabet[\"K\"] = \"P\"\n    alphabet[\"L\"] = \"O\"\n    alphabet[\"\
    M\"] = \"N\"\n    alphabet[\"N\"] = \"M\"\n    alphabet[\"O\"] = \"L\"\n    alphabet[\"\
    P\"] = \"K\"\n    alphabet[\"Q\"] = \"J\"\n    alphabet[\"R\"] = \"I\"\n    alphabet[\"\
    S\"] = \"H\"\n    alphabet[\"T\"] = \"G\"\n    alphabet[\"U\"] = \"F\"\n    alphabet[\"\
    V\"] = \"E\"\n    alphabet[\"W\"] = \"D\"\n    alphabet[\"X\"] = \"C\"\n    alphabet[\"\
    Y\"] = \"B\"\n    alphabet[\"Z\"] = \"A\"\n    var newString = \"\"\n    for c\
    \ in s {\n        newString += alphabet[c]\n    }\n    return newString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpds2o1une.swift:37:30: error: cannot convert value of type 'Character?'\
    \ to expected argument type 'String'\n        newString += alphabet[c]\n     \
    \                        ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // A\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // B\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // C\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // D\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\
    \ // E\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\
    \ // F\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\
    \ // G\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\
    \ // H\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\
    \ // I\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\
    \ // J\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\
    \ // K\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\
    \ // L\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\
    \ // M\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\
    \ // N\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\
    \ // O\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\
    \ // P\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\
    \ // Q\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\
    \ // R\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\
    \ // S\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\
    \ // T\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\
    \ // U\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21))))\
    \ // V\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22))))\
    \ // W\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23))))\
    \ // X\n    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ynz6utl.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp8ynz6utl.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmp8ynz6utl.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // A\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // A\n                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8ynz6utl.swift:10:33: error: value of type 'String' has no member 'characterAtIndex'\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // B\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // B\n                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8ynz6utl.swift:11:33: error: value of type 'String' has no member 'characterAtIndex'\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // C\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // C\n                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8ynz6utl.swift:12:33: error: value of type 'String' has no member 'characterAtIndex'\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // D\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // D\n                                    "
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var encryptedString = \"\"\n\
    \    for letter in s {\n        encryptedString += alphabet[alphabet.index(letter)!\
    \ + 2]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqnxdcxvq.swift:38:52: error: missing argument label 'of:' in call\n\
    \        encryptedString += alphabet[alphabet.index(letter)! + 2]\n          \
    \                                         ^\n                                \
    \                   of: \n/tmp/tmpqnxdcxvq.swift:38:36: error: no exact matches\
    \ in call to subscript \n        encryptedString += alphabet[alphabet.index(letter)!\
    \ + 2]\n                                   ^\n/tmp/tmpqnxdcxvq.swift:38:36: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'Character')\n \
    \       encryptedString += alphabet[alphabet.index(letter)! + 2]\n           \
    \                        ^\n/tmp/tmpqnxdcxvq.swift:38:36: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got 'Character')\n        encryptedString\
    \ += alphabet[alphabet.index(letter)! + 2]\n                                 \
    \  ^\n/tmp/tmpqnxdcxvq.swift:38:36: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Character')\n        encryptedString += alphabet[alphabet.index(letter)!\
    \ + 2]\n                                   ^\n/tmp/tmpqnxdcxvq.swift:38:36: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Character')\n        encryptedString += alphabet[alphabet.index(letter)! +\
    \ 2]\n                                   ^\n/tmp/tmpqnxdcxvq.swift:38:36: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        encryptedString += alphabet[alphabet.index(letter)! + 2]\n          \
    \                         ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabetLength / 2\n \
    \   let alphabetLength = alphabetLength * 2\n    var newString = \"\"\n    for\
    \ char in s.characters {\n        newString += alphabet[alphabet.characters.index(of:\
    \ char) + alphabetLength]\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpnkc7r9mw.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpnkc7r9mw.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabetLength / 2\n        ^\n/tmp/tmpnkc7r9mw.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpnkc7r9mw.swift:13:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in s.characters {\n               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var newString = \"\"\n    for\
    \ letter in s {\n        newString += alphabet[alphabetIndex % alphabetLength]\n\
    \        alphabetIndex++\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpumw3b4je.swift:13:30: error: no exact matches in call to subscript\
    \ \n        newString += alphabet[alphabetIndex % alphabetLength]\n          \
    \                   ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpumw3b4je.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(0)))\n\
    \    alphabet.append(Character(s.characterAtIndex(1)))\n    alphabet.append(Character(s.characterAtIndex(2)))\n\
    \    alphabet.append(Character(s.characterAtIndex(3)))\n    alphabet.append(Character(s.characterAtIndex(4)))\n\
    \    alphabet.append(Character(s.characterAtIndex(5)))\n    alphabet.append(Character(s.characterAtIndex(6)))\n\
    \    alphabet.append(Character(s.characterAtIndex(7)))\n    alphabet.append(Character(s.characterAtIndex(8)))\n\
    \    alphabet.append(Character(s.characterAtIndex(9)))\n    alphabet.append(Character(s.characterAtIndex(10)))\n\
    \    alphabet.append(Character(s.characterAtIndex(11)))\n    alphabet.append(Character(s.characterAtIndex(12)))\n\
    \    alphabet.append(Character(s.characterAtIndex(13)))\n    alphabet.append(Character(s.characterAtIndex(14)))\n\
    \    alphabet.append(Character(s.characterAtIndex(15)))\n    alphabet.append(Character(s.characterAtIndex(16)))\n\
    \    alphabet.append(Character(s.characterAtIndex(17)))\n    alphabet.append(Character(s.characterAtIndex(18)))\n\
    \    alphabet.append(Character(s.characterAtIndex(19)))\n    alphabet.append(Character(s.characterAtIndex(20)))\n\
    \    alphabet.append(Character(s.characterAtIndex(21)))\n    alphabet.append(Character(s.characterAtIndex(22)))\n\
    \    alphabet.append(Character(s.characterAtIndex(23)))\n    alphabet.append(Character(s.characterAtIndex(24)))\n\
    \    alphabet.append(Character(s.characterAtIndex(25)))\n    alphabet.append(Character(s.characterAtIndex(26)))\n\
    \    alphabet.append(Character(s.characterAtIndex(27)))\n    alphabet.append(Character(s.characterAtIndex(28)))\n\
    \    alphabet.append(Character(s.characterAtIndex(29)))\n    alphabet.append(Character(s.characterAtIndex(30)))\n\
    \    alphabet.append(Character(s.characterAtIndex(31)))\n    alphabet.append(Character(s.characterAtIndex(32)))\n\
    \    alphabet.append(Character(s.characterAtIndex(33)))\n    alphabet.append(Character(s.characterAtIndex(34)))\n\
    \    alphabet.append(Character(s.characterAtIndex(35)))\n    alphabet.append(Character(s.characterAtIndex(36)))\n\
    \    alphabet.append(Character(s.characterAtIndex(37)))\n    alphabet.append(Character(s.characterAtIndex(38)))\n\
    \    alphabet.append(Character(s.characterAtIndex(39)))\n    alphabet.append(Character(s.characterAtIndex(40)))\n\
    \    alphabet.append(Character(s.characterAtIndex(41)))\n    alphabet.append(Character(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpav8q5jse.swift:52:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpav8q5jse.swift:9:33: error: value of type 'String' has no member\
    \ 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(0)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(1)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(2)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(3)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:13:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(4)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:14:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(5)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:15:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(6)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:16:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(7)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:17:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(8)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:18:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(9)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/t"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    for character in s {\n        var index = alphabet.index(of: character)!\n\
    \        var encryptedIndex = alphabetRotated.index(of: alphabet[index])!\n  \
    \      encryptedString += alphabetRotated[encryptedIndex]\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpf82sbehx.swift:14:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: character)!\n \
    \                            ^\n/tmp/tmpf82sbehx.swift:14:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: character)!\n              \
    \               ^~~~~\n                             firstIndex\n/tmp/tmpf82sbehx.swift:15:46:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        var\
    \ encryptedIndex = alphabetRotated.index(of: alphabet[index])!\n             \
    \                                ^\n/tmp/tmpf82sbehx.swift:15:46: note: use 'firstIndex(of:)'\
    \ instead\n        var encryptedIndex = alphabetRotated.index(of: alphabet[index])!\n\
    \                                             ^~~~~\n                        \
    \                     firstIndex\n/tmp/tmpf82sbehx.swift:16:43: error: subscript\
    \ 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \        encryptedString += alphabetRotated[encryptedIndex]\n                \
    \                          ^\nSwift.Collection:2:23: note: where 'R' = 'String.Index'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(UnicodeScalar(UInt32(97\
    \ + _))))\n    }\n    \n    var result = \"\"\n    for c in s {\n        let index\
    \ = alphabet.index(of: c)!\n        let newIndex = index + 2\n        result +=\
    \ alphabet[newIndex]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdgbif8dd.swift:10:61: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        alphabet.append(Character(UnicodeScalar(UInt32(97\
    \ + _))))\n                                                            ^\n/tmp/tmpdgbif8dd.swift:15:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.index(of: c)!\n                             ^\n/tmp/tmpdgbif8dd.swift:15:30:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.index(of:\
    \ c)!\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpdgbif8dd.swift:17:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        result += alphabet[newIndex]\n \
    \                         ^\n/tmp/tmpdgbif8dd.swift:17:27: error: no exact matches\
    \ in call to subscript \n        result += alphabet[newIndex]\n              \
    \            ^\nSwift.String:3:35: note: candidate expects value of type 'String'\
    \ for parameter #2 (got 'Character')\n    @inlinable public static func += (lhs:\
    \ inout String, rhs: String)\n                                  ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += alphabet[alphabet.count - 1]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppz5qplz_.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppz5qplz_.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmppz5qplz_.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        if newIndex < alphabet.count {\n              \
    \        ^~~~~~~~\n/tmp/tmppz5qplz_.swift:13:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[newIndex]\n                      ^~~~~~~~\n\
    /tmp/tmppz5qplz_.swift:15:23: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[alphabet.count - 1]\n                      ^~~~~~~~\n\
    /tmp/tmppz5qplz_.swift:15:32: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[alphabet.count - 1]\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2isi3_se.swift:10:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:11:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:12:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:13:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:14:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:15:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:16:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:17:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var encryptedString = \"\"\n\
    \    for character in s {\n        var index = alphabet.index(of: character)!\n\
    \        index = index + 2\n        index = index % 26\n        encryptedString\
    \ += alphabet[index]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdqa4gf8r.swift:38:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: character)!\n \
    \                            ^\n/tmp/tmpdqa4gf8r.swift:38:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: character)!\n              \
    \               ^~~~~\n                             firstIndex\n/tmp/tmpdqa4gf8r.swift:41:36:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        encryptedString += alphabet[index]\n                                \
    \   ^\n/tmp/tmpdqa4gf8r.swift:41:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[index]\n                             \
    \      ^\nSwift.String:3:35: note: candidate expects value of type 'String' for\
    \ parameter #2 (got 'Character')\n    @inlinable public static func += (lhs: inout\
    \ String, rhs: String)\n                                  ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable public subscript(x:\
    \ (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character : Character]()\n    alphabet[\"A\"] = \"Z\"\
    \n    alphabet[\"B\"] = \"Y\"\n    alphabet[\"C\"] = \"X\"\n    alphabet[\"D\"\
    ] = \"W\"\n    alphabet[\"E\"] = \"V\"\n    alphabet[\"F\"] = \"U\"\n    alphabet[\"\
    G\"] = \"T\"\n    alphabet[\"H\"] = \"S\"\n    alphabet[\"I\"] = \"R\"\n    alphabet[\"\
    J\"] = \"Q\"\n    alphabet[\"K\"] = \"P\"\n    alphabet[\"L\"] = \"O\"\n    alphabet[\"\
    M\"] = \"N\"\n    alphabet[\"N\"] = \"M\"\n    alphabet[\"O\"] = \"L\"\n    alphabet[\"\
    P\"] = \"K\"\n    alphabet[\"Q\"] = \"J\"\n    alphabet[\"R\"] = \"I\"\n    alphabet[\"\
    S\"] = \"H\"\n    alphabet[\"T\"] = \"G\"\n    alphabet[\"U\"] = \"F\"\n    alphabet[\"\
    V\"] = \"E\"\n    alphabet[\"W\"] = \"D\"\n    alphabet[\"X\"] = \"C\"\n    alphabet[\"\
    Y\"] = \"B\"\n    alphabet[\"Z\"] = \"A\"\n    var newString = \"\"\n    for char\
    \ in s {\n        newString += alphabet[char]\n    }\n    return newString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp35t95jkg.swift:37:30: error: cannot convert value of type 'Character?'\
    \ to expected argument type 'String'\n        newString += alphabet[char]\n  \
    \                           ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbbji8vi.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmbbji8vi.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpmbbji8vi.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for char in s {\n        encryptedString += alphabet[(alphabetIndex + alphabet.count\
    \ - alphabet.count / 2) % alphabetLength]\n        alphabetIndex++\n    }\n  \
    \  return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpewcxddtj.swift:13:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        encryptedString += alphabet[(alphabetIndex + alphabet.count\
    \ - alphabet.count / 2) % alphabetLength]\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpewcxddtj.swift:14:22: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        alphabetIndex++\n                     ^~\n"
  stdout: ''
  timestamp: 1660028477
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var result = \"\"\n    for c\
    \ in s {\n        let index = alphabet.index(of: c)!\n        let newIndex = index\
    \ % alphabet.count\n        let newChar = alphabet[newIndex]\n        result +=\
    \ String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmph2fga8k0/tmph2fga8k0.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6fdb02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6fd7f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6fd7f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6fd7f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph2fga8k0                        0x0000558918e07827 <unavailable> + 6183

    5    libc.so.6                          0x00002ba6fdcee460 __libc_start_main +
    245

    6    tmph2fga8k0                        0x0000558918e07469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var newAlphabet = Array(alphabet[0 ..< alphabetLength])\n\
    \    var newAlphabetLength = newAlphabet.count\n    var newAlphabetCount = newAlphabet.count\n\
    \    var newAlphabetString = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n\
    \    var newAlphabetStringCount = newAlphabetString.count\n    var newAlphabetString\
    \ = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n    var newAlphabetStringCount\
    \ = newAlphabetString.count\n    var newAlphabetString = \"\"\n    var newAlphabetStringLength\
    \ = newAlphabetString.count\n    var newAlphabetStringCount = newAlphabetString.count\n\
    \    var newAlphabetString = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n\
    \    var newAlphabetStringCount = newAlphabetString.count\n    var newAlphabetString\
    \ = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n    var newAlphabetStringCount\
    \ = newAlphabetString.count\n    var newAlphabetString = \"\"\n    var newAlphabetStringLength\
    \ = newAlphabetString.count\n    var newAlphabetStringCount = newAlphabetString.count\n\
    \    var newAlphabetString = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n\
    \    var newAlphabetStringCount = newAlphabetString.count\n    var newAlphabetString\
    \ = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n    var newAlphabetStringCount\
    \ = newAlphabetString.count\n    var newAlphabetString = \"\"\n    var newAlphabetStringLength\
    \ = newAlphabetString.count\n    var newAlphabetStringCount = newAlphabetString.count\n\
    \    var newAlphabetString = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n\
    \    var newAlphabetStringCount = newAlphabetString.count\n    var newAlphabetString\
    \ = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n    var newAlphabetStringCount\
    \ = newAlphabetString.count\n    var newAlphabetString = \"\"\n    var newAlphabetStringLength\
    \ = newAlphabetString.count\n    var newAlphabetStringCount = newAlphabetString.count\n\
    \    var newAlphabetString = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n\
    \    var newAlphabetStringCount = newAlphabetString.count\n    var newAlphabetString\
    \ = \"\"\n    var newAlphabetStringLength = newAlphabetString.count\n    var newAlphabetStringCount\
    \ = newAlphabetString.count\n    var newAlphabetString = \"\"\n    var newAlphabetStringLength\
    \ = newAlphabetString.count\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp71p5ty9t.swift:57:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp71p5ty9t.swift:10:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \    var newAlphabet = Array(alphabet[0 ..< alphabetLength])\n               \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp71p5ty9t.swift:16:9: error: invalid redeclaration of 'newAlphabetString'\n\
    \    var newAlphabetString = \"\"\n        ^\n/tmp/tmp71p5ty9t.swift:13:9: note:\
    \ 'newAlphabetString' previously declared here\n    var newAlphabetString = \"\
    \"\n        ^\n/tmp/tmp71p5ty9t.swift:19:9: error: invalid redeclaration of 'newAlphabetString'\n\
    \    var newAlphabetString = \"\"\n        ^\n/tmp/tmp71p5ty9t.swift:13:9: note:\
    \ 'newAlphabetString' previously declared here\n    var newAlphabetString = \"\
    \"\n        ^\n/tmp/tmp71p5ty9t.swift:22:9: error: invalid redeclaration of 'newAlphabetString'\n\
    \    var newAlphabetString = \"\"\n        ^\n/tmp/tmp71p5ty9t.swift:13:9: note:\
    \ 'newAlphabetString' previously declared here\n    var newAlphabetString = \"\
    \"\n        ^\n/tmp/tmp71p5ty9t.swift:25:9: error: invalid redeclaration of 'newAlphabetString'\n\
    \    var newAlphabetString = \"\"\n        ^\n/tmp/tmp71p5ty9t.swift:13:9: note:\
    \ 'newAlphabetString' previously declared here\n    var newAlphabetString = \"\
    \"\n        ^\n/tmp/tmp71p5ty9t.swift:28:9: error: invalid redeclaration of 'newAlphabetString'\n\
    \    var newAlphabetString = \"\"\n        ^\n/tmp/tmp71p5ty9t.swift:13:9: note:\
    \ 'newAlphabetString' previously declared here\n    var newAlphabetString = \"\
    \"\n        ^\n/tmp/tmp71p5ty9t.swift:31:9: error: invalid redeclaration of 'newAlphabetString'\n\
    \    var newAlphabetString = \"\"\n        ^\n/tmp/tmp71p5ty9t.swift:13:9: note:\
    \ 'newAlphabetString' previously declared here\n    var newAlphabetString = \"\
    \"\n        ^\n/tmp/tmp71p5ty9t.swift:34:9: error: invalid redeclaration"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\
    \ // fifth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\
    \ // sixth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\
    \ // seventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\
    \ // eighth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\
    \ // ninth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\
    \ // tenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\
    \ // eleventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\
    \ // twelfth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\
    \ // thirteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\
    \ // fourteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\
    \ // fifteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\
    \ // sixteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\
    \ // seventeenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\
    \ // eighteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\
    \ // nineteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\
    \ // twentieth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\
    \ // twenty-first letter\n    alphabet.append(Character(s.characterAt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprl5n3xqr.swift:31:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmprl5n3xqr.swift:30:30: note: to match this opening '('\n    alphabet.append(Character(s.characterAt\n\
    \                             ^\n/tmp/tmprl5n3xqr.swift:9:33: error: value of\
    \ type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.a"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpae5g3h9t.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:11:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:12:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpae5g3h9t.swift:17:31: error: missing argument label 'e"
  stdout: ''
  timestamp: 1660028457
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var result = [Character]()\n\
    \    \n    for char in s {\n        var index = alphabet.index(of: char)!\n  \
    \      index = index * 2\n        index = index + 2\n        index = index % alphabet.count\n\
    \        result.append(alphabet[index])\n    }\n    \n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp776q3kly/tmp776q3kly.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac36b546c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac36b23db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac36b23d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac36b23c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp776q3kly                        0x000056071f32a7d7 <unavailable> + 6103

    5    libc.so.6                          0x00002ac36b732460 __libc_start_main +
    245

    6    tmp776q3kly                        0x000056071f32a419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.count\n    var result = \"\"\n    for c in s.characters {\n     \
    \   let index = alphabet.index(of: c)!\n        let newIndex = index % alphabetLength\n\
    \        let newChar = alphabet[newIndex]\n        result += newChar\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpatydh_oh.swift:11:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpatydh_oh.swift:12:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.index(of: c)!\n                             ^\n/tmp/tmpatydh_oh.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.index(of:\
    \ c)!\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpatydh_oh.swift:13:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        let newIndex = index % alphabetLength\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\
    \ // fifth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\
    \ // sixth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\
    \ // seventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\
    \ // eighth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\
    \ // ninth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\
    \ // tenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\
    \ // eleventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\
    \ // twelfth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\
    \ // thirteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\
    \ // fourteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\
    \ // fifteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\
    \ // sixteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\
    \ // seventeenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\
    \ // eighteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\
    \ // nineteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\
    \ // twentieth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\
    \ // twenty-first letter\n    alphabet.append(Character(s.characterAt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprl5n3xqr.swift:31:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmprl5n3xqr.swift:30:30: note: to match this opening '('\n    alphabet.append(Character(s.characterAt\n\
    \                             ^\n/tmp/tmprl5n3xqr.swift:9:33: error: value of\
    \ type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.a"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var resultString =\
    \ \"\"\n    for letter in s {\n        let index = alphabet.index(of: letter)!\n\
    \        let indexRotated = alphabetRotated.index(of: alphabet[index])!\n    \
    \    resultString += alphabetRotated[indexRotated]\n    }\n    return resultString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2888x_m_.swift:14:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: letter)!\n    \
    \                         ^\n/tmp/tmp2888x_m_.swift:14:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: letter)!\n                 \
    \            ^~~~~\n                             firstIndex\n/tmp/tmp2888x_m_.swift:15:44:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ indexRotated = alphabetRotated.index(of: alphabet[index])!\n               \
    \                            ^\n/tmp/tmp2888x_m_.swift:15:44: note: use 'firstIndex(of:)'\
    \ instead\n        let indexRotated = alphabetRotated.index(of: alphabet[index])!\n\
    \                                           ^~~~~\n                          \
    \                 firstIndex\n/tmp/tmp2888x_m_.swift:16:40: error: subscript 'subscript(_:)'\
    \ requires that 'String.Index' conform to 'RangeExpression'\n        resultString\
    \ += alphabetRotated[indexRotated]\n                                       ^\n\
    Swift.Collection:2:23: note: where 'R' = 'String.Index'\n    @inlinable public\
    \ subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabetLength * 2\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = alphabetLength + alphabetLength\n    let alphabetLength = alphabetLength +\
    \ alphabetLength\n    let alphabetLength = alphabetLength + alphabetLength\n \
    \   let alphabetLength = alphabetLength + alphabetLength\n    let alphabetLength\
    \ = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\"\
    )\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\"\
    ) == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2qmh7cle.swift:64:25: error: expected initial value after '='\n\
    \    let alphabetLength = \n                        ^\n/tmp/tmp2qmh7cle.swift:9:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2qmh7cle.swift:10:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabetLength\
    \ * 2\n        ^\n/tmp/tmp2qmh7cle.swift:9:9: note: 'alphabetLength' previously\
    \ declared here\n    let alphabetLength = alphabet.characters.count\n        ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = [Character]()\n\
    \    for c in s {\n        let index = alphabet.index(of: c)!\n        let newIndex\
    \ = index + 2\n        result.append(alphabet[newIndex])\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp22xfe018.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmp22xfe018.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmp22xfe018.swift:12:24:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index + 2\n                       ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    for letter in s {\n        var index = alphabet.index(letter)\n\
    \        index = index + 2\n        index = index % alphabetLength\n        encryptedString\
    \ = encryptedString + alphabetRotated[index]\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdxe76jrk.swift:14:36: error: missing argument label 'of:' in call\n\
    \        var index = alphabet.index(letter)\n                                \
    \   ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\
    \ // fifth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\
    \ // sixth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\
    \ // seventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\
    \ // eighth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\
    \ // ninth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\
    \ // tenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\
    \ // eleventh letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\
    \ // twelfth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\
    \ // thirteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\
    \ // fourteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\
    \ // fifteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\
    \ // sixteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\
    \ // seventeenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\
    \ // eighteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\
    \ // nineteenth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\
    \ // twentieth letter\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\
    \ // twenty-first letter\n    alphabet.append(Character(s.characterAt\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprl5n3xqr.swift:31:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmprl5n3xqr.swift:30:30: note: to match this opening '('\n    alphabet.append(Character(s.characterAt\n\
    \                             ^\n/tmp/tmprl5n3xqr.swift:9:33: error: value of\
    \ type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // first letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // second letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // third letter\n                                                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:33: error: value of type 'String' has\
    \ no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // fourth letter\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmprl5n3xqr.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.a"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbbji8vi.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmbbji8vi.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpmbbji8vi.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for letter in s {\n        let index = alphabet.index(of: letter)!\n    \
    \    let newIndex = index + 2\n        result += alphabet[newIndex]\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphxba0dut.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: letter)!\n    \
    \                         ^\n/tmp/tmphxba0dut.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: letter)!\n                 \
    \            ^~~~~\n                             firstIndex\n/tmp/tmphxba0dut.swift:12:24:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index + 2\n                       ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbbji8vi.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmbbji8vi.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpmbbji8vi.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newString = \"\
    \"\n    for letter in s {\n        newString += alphabet[(alphabet.index(letter,\
    \ offsetBy: 2)) % (alphabet.count)]\n    }\n    return newString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz1dyejig.swift:11:47: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String.Index'\n        newString += alphabet[(alphabet.index(letter,\
    \ offsetBy: 2)) % (alphabet.count)]\n                                        \
    \      ^\n/tmp/tmpz1dyejig.swift:11:41: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        newString += alphabet[(alphabet.index(letter,\
    \ offsetBy: 2)) % (alphabet.count)]\n                                        ^\n\
    /tmp/tmpz1dyejig.swift:11:69: error: cannot convert value of type 'Int' to expected\
    \ argument type 'Range<String.Index>'\n        newString += alphabet[(alphabet.index(letter,\
    \ offsetBy: 2)) % (alphabet.count)]\n                                        \
    \                            ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.characters.count\n    var alphabetArray = Array(alphabet)\n    var\
    \ alphabetArrayLength = alphabetArray.count\n    var alphabetIndex = 0\n    var\
    \ alphabetIndex2 = 0\n    var alphabetIndex3 = 0\n    var alphabetIndex4 = 0\n\
    \    var alphabetIndex5 = 0\n    var alphabetIndex6 = 0\n    var alphabetIndex7\
    \ = 0\n    var alphabetIndex8 = 0\n    var alphabetIndex9 = 0\n    var alphabetIndex10\
    \ = 0\n    var alphabetIndex11 = 0\n    var alphabetIndex12 = 0\n    var alphabetIndex13\
    \ = 0\n    var alphabetIndex14 = 0\n    var alphabetIndex15 = 0\n    var alphabetIndex16\
    \ = 0\n    var alphabetIndex17 = 0\n    var alphabetIndex18 = 0\n    var alphabetIndex19\
    \ = 0\n    var alphabetIndex20 = 0\n    var alphabetIndex21 = 0\n    var alphabetIndex22\
    \ = 0\n    var alphabetIndex23 = 0\n    var alphabetIndex24 = 0\n    var alphabetIndex25\
    \ = 0\n    var alphabetIndex26 = 0\n    var alphabetIndex27 = 0\n    var alphabetIndex28\
    \ = 0\n    var alphabetIndex29 = 0\n    var alphabetIndex30 = 0\n    var alphabetIndex31\
    \ = 0\n    var alphabetIndex32 = 0\n    var alphabetIndex33 = 0\n    var alphabetIndex34\
    \ = 0\n    var alphabetIndex35 = 0\n    var alphabetIndex36 = 0\n    var alphabetIndex37\
    \ = 0\n    var alphabetIndex38 = 0\n    var alphabetIndex39 = 0\n    var alphabetIndex40\
    \ = 0\n    var alphabetIndex41 = 0\n    var alphabetIndex42 = 0\n    var alphabetIndex43\
    \ = 0\n    var alphabetIndex44 = 0\n    var alphabetIndex45 = 0\n    var alphabetIndex46\
    \ = 0\n    var alphabetIndex47 = 0\n    var alphabetIndex48 = 0\n    var alphabetIndex49\
    \ = 0\n    var alphabetIndex50 = 0\n    var alphabetIndex51 = 0\n    var alphabetIndex52\
    \ = 0\n    var alphabetIndex53 = 0\n    var alphabetIndex54 = 0\n    var alphabetIndex55\
    \ = 0\n    var alphabetIndex56 = 0\n    var alphabetIndex57 = 0\n    var alphabetIndex58\
    \ = 0\n    var alphabetIndex59 = 0\n    var alphabetIndex60 = 0\n    var alphabetIndex61\
    \ = 0\n    var alphabetIndex62 = 0\n    var alphabetIndex63 = 0\n    var alphabetIndex64\
    \ = 0\n    var alphabetIndex65 = 0\n    var alphabetIndex66 = 0\n    var alphabetIndex67\
    \ = 0\n    var alphabetIndex68 = 0\n    var alphabetIndex69 = 0\n    var alphabetIndex70\
    \ = 0\n    var alphabetIndex71 = 0\n    var alphabetIndex72 = 0\n    var alphabetIndex73\
    \ = 0\n    var alphabetIndex74 = 0\n    var alphabetIndex75 = 0\n    var alphabetIndex76\
    \ = 0\n    var alphabetIndex77 = 0\n    var alphabetIndex78 = 0\n    var alphabetIndex79\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt8rva6om.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    var alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt8rva6om.swift:8:9: warning: variable 'alphabet' was\
    \ never mutated; consider changing to 'let' constant\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    ~~~ ^\n    let\n/tmp/tmpt8rva6om.swift:9:9: warning: initialization of variable\
    \ 'alphabetLength' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var alphabetLength = alphabet.characters.count\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpt8rva6om.swift:10:9: warning: variable 'alphabetArray' was never\
    \ mutated; consider changing to 'let' constant\n    var alphabetArray = Array(alphabet)\n\
    \    ~~~ ^\n    let\n/tmp/tmpt8rva6om.swift:11:9: warning: initialization of variable\
    \ 'alphabetArrayLength' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var alphabetArrayLength = alphabetArray.count\n    ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpt8rva6om.swift:12:9: warning: initialization of variable 'alphabetIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var alphabetIndex = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpt8rva6om.swift:13:9:\
    \ warning: initialization of variable 'alphabetIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var alphabetIndex2 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpt8rva6om.swift:14:9: warning: initialization\
    \ of variable 'alphabetIndex3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var alphabetIndex3 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpt8rva6om.swift:15:9: warning: initialization of variable 'alphabetIndex4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var alphabetIndex4 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpt8rva6om.swift:16:9:\
    \ warning: initialization of var"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.characters.count\n    var alphabetIndex = 0\n    var encryptedString\
    \ = \"\"\n    for character in s {\n        encryptedString += alphabet[alphabetIndex\
    \ % alphabetLength]\n        alphabetIndex++\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp31e46lbn.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    var alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp31e46lbn.swift:13:36: error: no exact matches in call\
    \ to subscript \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n\
    \                                   ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmp31e46lbn.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // A\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // B\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // C\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // D\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4))))\
    \ // E\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5))))\
    \ // F\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6))))\
    \ // G\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7))))\
    \ // H\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8))))\
    \ // I\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9))))\
    \ // J\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10))))\
    \ // K\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11))))\
    \ // L\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12))))\
    \ // M\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13))))\
    \ // N\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14))))\
    \ // O\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15))))\
    \ // P\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16))))\
    \ // Q\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17))))\
    \ // R\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18))))\
    \ // S\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19))))\
    \ // T\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20))))\
    \ // U\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21))))\
    \ // V\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22))))\
    \ // W\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23))))\
    \ // X\n    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ynz6utl.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp8ynz6utl.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmp8ynz6utl.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // A\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0))))\
    \ // A\n                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8ynz6utl.swift:10:33: error: value of type 'String' has no member 'characterAtIndex'\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // B\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1))))\
    \ // B\n                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8ynz6utl.swift:11:33: error: value of type 'String' has no member 'characterAtIndex'\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // C\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2))))\
    \ // C\n                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8ynz6utl.swift:12:33: error: value of type 'String' has no member 'characterAtIndex'\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // D\n                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8ynz6utl.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3))))\
    \ // D\n                                    "
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character : Int]()\n    alphabet[\"a\"] = 2\n    alphabet[\"\
    b\"] = 3\n    alphabet[\"c\"] = 4\n    alphabet[\"d\"] = 5\n    alphabet[\"e\"\
    ] = 6\n    alphabet[\"f\"] = 7\n    alphabet[\"g\"] = 8\n    alphabet[\"h\"] =\
    \ 9\n    alphabet[\"i\"] = 1\n    alphabet[\"j\"] = 2\n    alphabet[\"k\"] = 3\n\
    \    alphabet[\"l\"] = 4\n    alphabet[\"m\"] = 5\n    alphabet[\"n\"] = 6\n \
    \   alphabet[\"o\"] = 7\n    alphabet[\"p\"] = 8\n    alphabet[\"q\"] = 9\n  \
    \  alphabet[\"r\"] = 1\n    alphabet[\"s\"] = 2 \n    alphabet[\"t\"] = 3\n  \
    \  alphabet[\"u\"] = 4\n    alphabet[\"v\"] = 5\n    alphabet[\"w\"] = 6\n   \
    \ alphabet[\"x\"] = 7\n    alphabet[\"y\"] = 8\n    alphabet[\"z\"] = 9\n    \n\
    \    var result = \"\"\n    for char in s {\n        var index = alphabet.index(char)\n\
    \        index = index + 2\n        index = index % alphabet.count\n        result\
    \ = result + alphabet[index]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqjxvgw9t.swift:38:36: error: missing argument label 'forKey:' in\
    \ call\n        var index = alphabet.index(char)\n                           \
    \        ^\n                                   forKey: \n/tmp/tmpqjxvgw9t.swift:41:25:\
    \ error: operator function '+' requires the types 'String.Element' (aka 'Character')\
    \ and 'Slice<[Character : Int]>.Element' (aka '(key: Character, value: Int)')\
    \ be equivalent\n        result = result + alphabet[index]\n                 \
    \       ^\nSwift.RangeReplaceableCollection:2:35: note: where 'Self.Element' =\
    \ 'String.Element' (aka 'Character'), 'Other.Element' = 'Slice<[Character : Int]>.Element'\
    \ (aka '(key: Character, value: Int)')\n    @inlinable public static func + <Other>(lhs:\
    \ Self, rhs: Other) -> Self where Other : Sequence, Self.Element == Other.Element\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for char in s {\n        let index = alphabet.index(of: char)!\n        let\
    \ newIndex = index * 2\n        let newChar = alphabet[newIndex]\n        result\
    \ += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqc56gcfz.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)!\n      \
    \                       ^\n/tmp/tmpqc56gcfz.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)!\n                   \
    \          ^~~~~\n                             firstIndex\n/tmp/tmpqc56gcfz.swift:12:30:\
    \ error: binary operator '*' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        let newIndex = index * 2\n                       ~~~~~ ^\
    \ ~\n/tmp/tmpqc56gcfz.swift:12:30: note: overloads for '*' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        let newIndex = index * 2\n   \
    \                          ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    newAlphabet = rotate(newAlphabet, 2)\n    return s.characters.map\
    \ { newAlphabet[$0] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyisy5uss.swift:10:19: error: cannot find 'rotate' in scope\n  \
    \  newAlphabet = rotate(newAlphabet, 2)\n                  ^~~~~~\n/tmp/tmpyisy5uss.swift:11:42:\
    \ error: no exact matches in call to subscript \n    return s.characters.map {\
    \ newAlphabet[$0] }\n                                         ^\n/tmp/tmpyisy5uss.swift:11:42:\
    \ note: found candidate with type '(String.Index) -> Character'\n    return s.characters.map\
    \ { newAlphabet[$0] }\n                                         ^\n/tmp/tmpyisy5uss.swift:11:42:\
    \ note: found candidate with type '(Range<String.Index>) -> Substring'\n    return\
    \ s.characters.map { newAlphabet[$0] }\n                                     \
    \    ^\n/tmp/tmpyisy5uss.swift:11:42: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> String.SubSequence' (aka '((UnboundedRange_) -> ()) -> Substring')\n\
    \    return s.characters.map { newAlphabet[$0] }\n                           \
    \              ^\n/tmp/tmpyisy5uss.swift:11:25: error: no 'map' candidates produce\
    \ the expected contextual result type 'String'\n    return s.characters.map {\
    \ newAlphabet[$0] }\n                        ^\nSwift.Collection:2:28: note: 'map'\
    \ produces '[Character]', not the expected contextual result type 'String'\n \
    \   @inlinable public func map<T>(_ transform: (Self.Element) throws -> T) rethrows\
    \ -> [T]\n                           ^\nSwift.Collection:2:28: note: 'map' produces\
    \ '[Substring]', not the expected contextual result type 'String'\n    @inlinable\
    \ public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n\
    \                           ^\nSwift.Collection:2:28: note: 'map' produces '[String.SubSequence]'\
    \ (aka 'Array<Substring>'), not the expected contextual result type 'String'\n\
    \    @inlinable public func map<T>(_ transform: (Self.Element) throws -> T) rethrows\
    \ -> [T]\n                           ^\nSwift.Sequence:2:28: note: 'map' produces\
    \ '[Character]', not the expected contextual result type 'String'\n    @inlinable\
    \ public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n\
    \                          "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    for _ in 0..<s.count {\n        newAlphabet = alphabet[newAlphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpmalg_6.swift:12:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmpmalg_6.swift:11:1925: note: to match this opening '('\n        newAlphabet\
    \ = alphabet[newAlphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[al"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(\"a\")\n    alphabet.append(\"\
    b\")\n    alphabet.append(\"c\")\n    alphabet.append(\"d\")\n    alphabet.append(\"\
    e\")\n    alphabet.append(\"f\")\n    alphabet.append(\"g\")\n    alphabet.append(\"\
    h\")\n    alphabet.append(\"i\")\n    alphabet.append(\"j\")\n    alphabet.append(\"\
    k\")\n    alphabet.append(\"l\")\n    alphabet.append(\"m\")\n    alphabet.append(\"\
    n\")\n    alphabet.append(\"o\")\n    alphabet.append(\"p\")\n    alphabet.append(\"\
    q\")\n    alphabet.append(\"r\")\n    alphabet.append(\"s\")\n    alphabet.append(\"\
    t\")\n    alphabet.append(\"u\")\n    alphabet.append(\"v\")\n    alphabet.append(\"\
    w\")\n    alphabet.append(\"x\")\n    alphabet.append(\"y\")\n    alphabet.append(\"\
    z\")\n    \n    var newString = \"\"\n    for char in s {\n        newString +=\
    \ alphabet[alphabet.index(char) + 2]\n    }\n    return newString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ol8vt5v.swift:38:40: error: no exact matches in call to instance\
    \ method 'index'\n        newString += alphabet[alphabet.index(char) + 2]\n  \
    \                                     ^\n/tmp/tmp2ol8vt5v.swift:38:40: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'Character')\n        newString\
    \ += alphabet[alphabet.index(char) + 2]\n                                    \
    \   ^\n/tmp/tmp2ol8vt5v.swift:38:40: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Character')\n        newString += alphabet[alphabet.index(char)\
    \ + 2]\n                                       ^\n/tmp/tmp2ol8vt5v.swift:38:40:\
    \ note: candidate expects value of type 'Array<String>.Index' (aka 'Int') for\
    \ parameter #1 (got 'Character')\n        newString += alphabet[alphabet.index(char)\
    \ + 2]\n                                       ^\n/tmp/tmp2ol8vt5v.swift:38:40:\
    \ note: candidate expects value of type 'Array<String>.Index' (aka 'Int') for\
    \ parameter #1 (got 'Character')\n        newString += alphabet[alphabet.index(char)\
    \ + 2]\n                                       ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(0)))\n\
    \    alphabet.append(Character(s.characterAtIndex(1)))\n    alphabet.append(Character(s.characterAtIndex(2)))\n\
    \    alphabet.append(Character(s.characterAtIndex(3)))\n    alphabet.append(Character(s.characterAtIndex(4)))\n\
    \    alphabet.append(Character(s.characterAtIndex(5)))\n    alphabet.append(Character(s.characterAtIndex(6)))\n\
    \    alphabet.append(Character(s.characterAtIndex(7)))\n    alphabet.append(Character(s.characterAtIndex(8)))\n\
    \    alphabet.append(Character(s.characterAtIndex(9)))\n    alphabet.append(Character(s.characterAtIndex(10)))\n\
    \    alphabet.append(Character(s.characterAtIndex(11)))\n    alphabet.append(Character(s.characterAtIndex(12)))\n\
    \    alphabet.append(Character(s.characterAtIndex(13)))\n    alphabet.append(Character(s.characterAtIndex(14)))\n\
    \    alphabet.append(Character(s.characterAtIndex(15)))\n    alphabet.append(Character(s.characterAtIndex(16)))\n\
    \    alphabet.append(Character(s.characterAtIndex(17)))\n    alphabet.append(Character(s.characterAtIndex(18)))\n\
    \    alphabet.append(Character(s.characterAtIndex(19)))\n    alphabet.append(Character(s.characterAtIndex(20)))\n\
    \    alphabet.append(Character(s.characterAtIndex(21)))\n    alphabet.append(Character(s.characterAtIndex(22)))\n\
    \    alphabet.append(Character(s.characterAtIndex(23)))\n    alphabet.append(Character(s.characterAtIndex(24)))\n\
    \    alphabet.append(Character(s.characterAtIndex(25)))\n    alphabet.append(Character(s.characterAtIndex(26)))\n\
    \    alphabet.append(Character(s.characterAtIndex(27)))\n    alphabet.append(Character(s.characterAtIndex(28)))\n\
    \    alphabet.append(Character(s.characterAtIndex(29)))\n    alphabet.append(Character(s.characterAtIndex(30)))\n\
    \    alphabet.append(Character(s.characterAtIndex(31)))\n    alphabet.append(Character(s.characterAtIndex(32)))\n\
    \    alphabet.append(Character(s.characterAtIndex(33)))\n    alphabet.append(Character(s.characterAtIndex(34)))\n\
    \    alphabet.append(Character(s.characterAtIndex(35)))\n    alphabet.append(Character(s.characterAtIndex(36)))\n\
    \    alphabet.append(Character(s.characterAtIndex(37)))\n    alphabet.append(Character(s.characterAtIndex(38)))\n\
    \    alphabet.append(Character(s.characterAtIndex(39)))\n    alphabet.append(Character(s.characterAtIndex(40)))\n\
    \    alphabet.append(Character(s.characterAtIndex(41)))\n    alphabet.append(Character(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpav8q5jse.swift:52:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpav8q5jse.swift:9:33: error: value of type 'String' has no member\
    \ 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(0)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(1)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(2)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(3)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:13:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(4)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:14:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(5)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:15:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(6)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:16:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(7)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:17:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(8)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpav8q5jse.swift:18:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(9)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/t"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for character in s {\n        encryptedString += alphabet[alphabetIndex %\
    \ alphabetLength]\n        alphabetIndex += 2\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpcqothrv2.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"A\"))\n\
    \    alphabet.append(Character(\"B\"))\n    alphabet.append(Character(\"C\"))\n\
    \    alphabet.append(Character(\"D\"))\n    alphabet.append(Character(\"E\"))\n\
    \    alphabet.append(Character(\"F\"))\n    alphabet.append(Character(\"G\"))\n\
    \    alphabet.append(Character(\"H\"))\n    alphabet.append(Character(\"I\"))\n\
    \    alphabet.append(Character(\"J\"))\n    alphabet.append(Character(\"K\"))\n\
    \    alphabet.append(Character(\"L\"))\n    alphabet.append(Character(\"M\"))\n\
    \    alphabet.append(Character(\"N\"))\n    alphabet.append(Character(\"O\"))\n\
    \    alphabet.append(Character(\"P\"))\n    alphabet.append(Character(\"Q\"))\n\
    \    alphabet.append(Character(\"R\"))\n    alphabet.append(Character(\"S\"))\n\
    \    alphabet.append(Character(\"T\"))\n    alphabet.append(Character(\"U\"))\n\
    \    alphabet.append(Character(\"V\"))\n    alphabet.append(Character(\"W\"))\n\
    \    alphabet.append(Character(\"X\"))\n    alphabet.append(Character(\"Y\"))\n\
    \    alphabet.append(Character(\"Z\"))\n    \n    var encryptedString = \"\"\n\
    \    for character in s {\n        encryptedString += alphabet[alphabet.index(character)!\
    \ + 2]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp11g__nnu.swift:64:36: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        encryptedString += alphabet[alphabet.index(character)!\
    \ + 2]\n                                   ^\n/tmp/tmp11g__nnu.swift:64:36: error:\
    \ no exact matches in call to subscript \n        encryptedString += alphabet[alphabet.index(character)!\
    \ + 2]\n                                   ^\n/tmp/tmp11g__nnu.swift:64:36: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'Character')\n \
    \       encryptedString += alphabet[alphabet.index(character)! + 2]\n        \
    \                           ^\n/tmp/tmp11g__nnu.swift:64:36: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got 'Character')\n        encryptedString\
    \ += alphabet[alphabet.index(character)! + 2]\n                              \
    \     ^\n/tmp/tmp11g__nnu.swift:64:36: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Character')\n        encryptedString += alphabet[alphabet.index(character)!\
    \ + 2]\n                                   ^\n/tmp/tmp11g__nnu.swift:64:36: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Character')\n        encryptedString += alphabet[alphabet.index(character)!\
    \ + 2]\n                                   ^\n/tmp/tmp11g__nnu.swift:64:52: error:\
    \ missing argument label 'of:' in call\n        encryptedString += alphabet[alphabet.index(character)!\
    \ + 2]\n                                                   ^\n               \
    \                                    of: \n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    alphabet.append(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    alphabet.append(\"\
    0123456789\")\n    alphabet.append(\"!@#$%^&*()\")\n    \n    var result = [String]()\n\
    \    for letter in s {\n        var index = alphabet.index(letter)\n        var\
    \ newIndex = index + 2\n        if newIndex > alphabet.count {\n            newIndex\
    \ = 0\n        }\n        result.append(alphabet[newIndex])\n    }\n    return\
    \ result.joined(separator: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp706arcbf.swift:16:30: error: no exact matches in call to instance\
    \ method 'index'\n        var index = alphabet.index(letter)\n               \
    \              ^\n/tmp/tmp706arcbf.swift:16:30: note: candidate expects value\
    \ of type 'Int' for parameter #1 (got 'Character')\n        var index = alphabet.index(letter)\n\
    \                             ^\n/tmp/tmp706arcbf.swift:16:30: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'Character')\n        var\
    \ index = alphabet.index(letter)\n                             ^\n/tmp/tmp706arcbf.swift:16:30:\
    \ note: candidate expects value of type '(String) throws -> Bool' for parameter\
    \ #1 (got 'Character')\n        var index = alphabet.index(letter)\n         \
    \                    ^\n/tmp/tmp706arcbf.swift:16:30: note: candidate expects\
    \ value of type 'String' for parameter #1 (got 'Character')\n        var index\
    \ = alphabet.index(letter)\n                             ^\n/tmp/tmp706arcbf.swift:16:30:\
    \ note: candidate expects value of type 'Array<String>.Index' (aka 'Int') for\
    \ parameter #1 (got 'Character')\n        var index = alphabet.index(letter)\n\
    \                             ^\n/tmp/tmp706arcbf.swift:16:30: note: candidate\
    \ expects value of type 'Array<String>.Index' (aka 'Int') for parameter #1 (got\
    \ 'Character')\n        var index = alphabet.index(letter)\n                 \
    \            ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)!\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpodds21zj.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpodds21zj.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbbji8vi.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmbbji8vi.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpmbbji8vi.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabetLength * 2\n \
    \   var newString = \"\"\n    for letter in s.characters {\n        let index\
    \ = alphabet.index(of: letter)!\n        let newIndex = index - alphabetLength\n\
    \        newString += alphabet[newIndex]\n    }\n    return newString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_nnw0fp7.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_nnw0fp7.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabetLength * 2\n        ^\n/tmp/tmp_nnw0fp7.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmp_nnw0fp7.swift:12:21: error: 'characters' is unavailable:\
    \ Please use String directly\n    for letter in s.characters {\n             \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_nnw0fp7.swift:13:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.index(of: letter)!\n                             ^\n/tmp/tmp_nnw0fp7.swift:13:30:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.index(of:\
    \ letter)!\n                             ^~~~~\n                             firstIndex\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var alphabet2:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var alphabet3: [Character] =\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n    var alphabet4: [Character] = [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"]\n    var alphabet5: [Character] = [\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n    var alphabet6: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var alphabet7:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var alphabet8: [Character] =\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n    var alphabet9: [Character] = [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"]\n    var alphabet10: [Character] = [\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n    var alphabet11: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8c6el5oi.swift:18:61: error: unterminated string literal\n    var\
    \ alphabet11: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\n         \
    \                                                   ^\n/tmp/tmp8c6el5oi.swift:8:9:\
    \ warning: variable 'alphabet' was never used; consider replacing with '_' or\
    \ removing it\n    var alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \       ^~~~~~~~\n        _\n/tmp/tmp8c6el5oi.swift:9:9: warning: variable 'alphabet2'\
    \ was never used; consider replacing with '_' or removing it\n    var alphabet2:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        ^~~~~~~~~\n        _\n/tmp/tmp8c6el5oi.swift:10:9:\
    \ warning: variable 'alphabet3' was never used; consider replacing with '_' or\
    \ removing it\n    var alphabet3: [Character] = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \       ^~~~~~~~~\n        _\n/tmp/tmp8c6el5oi.swift:11:9: warning: variable 'alphabet4'\
    \ was never used; consider replacing with '_' or removing it\n    var alphabet4:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        ^~~~~~~~~\n        _\n/tmp/tmp8c6el5oi.swift:12:9:\
    \ warning: variable 'alphabet5' was never used; consider replacing with '_' or\
    \ removing it\n    var alphabet5: [Character] = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \       ^~~~~~~~~\n        _\n/tmp/tmp8c6el5oi.swift:13:9: warning: variable 'alphabet6'\
    \ was never used; consider replacing with '_' or removing it\n    var alphabet6:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        ^~~~~~~~~\n        _\n/tmp"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)!\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpodds21zj.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpodds21zj.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for c in s {\n        result += alphabet[(alphabet.indexOf(c) + 2) % 26]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpebxfiyyj.swift:11:38: error: value of type 'String' has no member\
    \ 'indexOf'\n        result += alphabet[(alphabet.indexOf(c) + 2) % 26]\n    \
    \                        ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += alphabet[0]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoveoduej.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpoveoduej.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmpoveoduej.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        if newIndex < alphabet.count {\n              \
    \        ^~~~~~~~\n/tmp/tmpoveoduej.swift:13:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[newIndex]\n                      ^~~~~~~~\n\
    /tmp/tmpoveoduej.swift:15:23: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    for _ in 0..<s.count {\n        newAlphabet = alphabet[newAlphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpmalg_6.swift:12:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmpmalg_6.swift:11:1925: note: to match this opening '('\n        newAlphabet\
    \ = alphabet[newAlphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[al"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmwirfmcx.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmwirfmcx.swift:12:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:13:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:14:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:15:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:20:41:\
    \ error: type "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for letter in s {\n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n\
    \        alphabetIndex++\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0_sz6bf.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpc0_sz6bf.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)!\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpodds21zj.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpodds21zj.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayReversed = Array(alphabet.reverse())\n\
    \    var alphabetArrayRotated: Array<String> = []\n    var alphabetArrayRotatedReversed:\
    \ Array<String> = []\n    \n    for i in 0..<s.count {\n        let index = alphabet.index(s.characters[i])\n\
    \        let indexRotated = alphabetArrayReversed.index(alphabetArray[index])\n\
    \        let indexRotatedRotated = alphabetArrayRotated.index(alphabetArrayRotated[indexRotated])\n\
    \        alphabetArrayRotated.append(alphabetArray[indexRotatedRotated])\n   \
    \     alphabetArrayRotatedReversed.append(alphabetArrayRotated[index])\n    }\n\
    \    \n    var resultString = \"\"\n    for i in 0..<alphabetArrayRotated.count\
    \ {\n        resultString += alphabetArrayRotatedReversed[i]\n    }\n    return\
    \ resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpr0vl2brb.swift:10:48: error: value of type 'String' has no member\
    \ 'reverse'\n    var alphabetArrayReversed = Array(alphabet.reverse())\n     \
    \                                 ~~~~~~~~ ^~~~~~~\n/tmp/tmpr0vl2brb.swift:15:36:\
    \ error: missing argument label 'of:' in call\n        let index = alphabet.index(s.characters[i])\n\
    \                                   ^\n                                   of:\
    \ \n/tmp/tmpr0vl2brb.swift:17:62: error: missing argument label 'of:' in call\n\
    \        let indexRotatedRotated = alphabetArrayRotated.index(alphabetArrayRotated[indexRotated])\n\
    \                                                             ^\n            \
    \                                                 of: \n/tmp/tmpr0vl2brb.swift:18:30:\
    \ error: no exact matches in call to instance method 'append'\n        alphabetArrayRotated.append(alphabetArray[indexRotatedRotated])\n\
    \                             ^\n/tmp/tmpr0vl2brb.swift:18:30: note: found candidate\
    \ with type '(__owned String) -> ()'\n        alphabetArrayRotated.append(alphabetArray[indexRotatedRotated])\n\
    \                             ^\n/tmp/tmpr0vl2brb.swift:18:30: note: found candidate\
    \ with type '(__owned ArraySlice<String.Element>) -> ()' (aka '(__owned ArraySlice<Character>)\
    \ -> ()')\n        alphabetArrayRotated.append(alphabetArray[indexRotatedRotated])\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    for _ in 0..<s.count {\n        newAlphabet = alphabet[newAlphabet.startIndex.advancedBy(2)]\n\
    \    }\n    return s.characters.map { alphabet[alphabet.index(alphabet, $0)] }\n\
    \        .joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpw6zcrcq1.swift:11:55: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n        newAlphabet = alphabet[newAlphabet.startIndex.advancedBy(2)]\n\
    \                               ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpw6zcrcq1.swift:13:54:\
    \ error: missing argument label 'offsetBy:' in call\n    return s.characters.map\
    \ { alphabet[alphabet.index(alphabet, $0)] }\n                               \
    \                      ^\n                                                   \
    \             offsetBy: \n/tmp/tmpw6zcrcq1.swift:13:39: error: cannot convert\
    \ value of type 'Character' to closure result type 'String'\n    return s.characters.map\
    \ { alphabet[alphabet.index(alphabet, $0)] }\n                              ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2isi3_se.swift:10:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:11:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:12:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:13:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:14:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:15:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:16:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:17:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    for _ in 0..<s.count {\n        newAlphabet = alphabet[newAlphabet.startIndex.advancedBy(2)]\n\
    \    }\n    return newAlphabet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsk6pnyqv.swift:11:55: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n        newAlphabet = alphabet[newAlphabet.startIndex.advancedBy(2)]\n\
    \                               ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.removeLast()\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.insert(contentsOf: alphabet)\n\
    \    alphabet.insert(contentsOf: alphabet)\n    alphabet.\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9ov67gi.swift:61:13: error: expected member name following '.'\n\
    \    alphabet.\n            ^\n/tmp/tmpa9ov67gi.swift:9:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpa9ov67gi.swift:13:52: error: missing argument for parameter 'at'\
    \ in call\n    alphabet.insert(contentsOf: alphabet.dropLast())\n            \
    \                                       ^\n                                  \
    \                 , at: <#Array<Character>.Index#>\nSwift.RangeReplaceableCollection:7:37:\
    \ note: 'insert(contentsOf:at:)' declared here\n    @inlinable public mutating\
    \ func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C\
    \ : Collection, Self.Element == C.Element\n                                  \
    \  ^\n/tmp/tmpa9ov67gi.swift:14:41: error: missing argument for parameter 'at'\
    \ in call\n    alphabet.insert(contentsOf: alphabet)\n                       \
    \                 ^\n                                        , at: <#Array<Character>.Index#>\n\
    Swift.RangeReplaceableCollection:7:37: note: 'insert(contentsOf:at:)' declared\
    \ here\n    @inlinable public mutating func insert<C>(contentsOf newElements:\
    \ __owned C, at i: Self.Index) where C : Collection, Self.Element == C.Element\n\
    \                                    ^\n/tmp/tmpa9ov67gi.swift:15:41: error: missing\
    \ argument for parameter 'at' in call\n    alphabet.insert(contentsOf: alphabet)\n\
    \                                        ^\n                                 \
    \       , at: <#Array<Character>.Index#>\nSwift.RangeReplaceableCollection:7:37:\
    \ note: 'insert(contentsOf:at:)' declared here\n    @inlinable public mutating\
    \ func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C\
    \ : Collection, Self.Element == C.Element\n                                  \
    \  ^\n/tmp/tmpa9ov67gi.swift:16:41: error: missing argument for parameter 'at'\
    \ in call\n    alphabet.insert(contentsOf: alphabe"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpauihg93q.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpauihg93q.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)\n                    ^~~~~~~~\n/tmp/tmpauihg93q.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character : Character]()\n    alphabet[\"a\"] = \"b\"\
    \n    alphabet[\"b\"] = \"a\"\n    alphabet[\"c\"] = \"d\"\n    alphabet[\"d\"\
    ] = \"c\"\n    alphabet[\"e\"] = \"f\"\n    alphabet[\"f\"] = \"e\"\n    alphabet[\"\
    g\"] = \"h\"\n    alphabet[\"h\"] = \"g\"\n    alphabet[\"i\"] = \"j\"\n    alphabet[\"\
    j\"] = \"i\"\n    alphabet[\"k\"] = \"l\"\n    alphabet[\"l\"] = \"k\"\n    alphabet[\"\
    m\"] = \"n\"\n    alphabet[\"n\"] = \"m\"\n    alphabet[\"o\"] = \"p\"\n    alphabet[\"\
    p\"] = \"o\"\n    alphabet[\"q\"] = \"r\"\n    alphabet[\"r\"] = \"q\"\n    alphabet[\"\
    s\"] = \"t\"\n    alphabet[\"t\"] = \"s\"\n    alphabet[\"u\"] = \"v\"\n    alphabet[\"\
    v\"] = \"u\"\n    alphabet[\"w\"] = \"x\"\n    alphabet[\"x\"] = \"w\"\n    alphabet[\"\
    y\"] = \"z\"\n    alphabet[\"z\"] = \"y\"\n    \n    var result = \"\"\n    for\
    \ c in s.characters {\n        result += alphabet[Character(c)]\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmps_sz3zhf.swift:37:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmps_sz3zhf.swift:38:27:\
    \ error: cannot convert value of type 'Character?' to expected argument type 'String'\n\
    \        result += alphabet[Character(c)]\n                          ^\n/tmp/tmps_sz3zhf.swift:38:38:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      result += alphabet[Character(c)]\n                                    \
    \ ^\n                                     extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotated\
    \ = \"zyxwvutsrqponmlkjihgfedcba\"\n    var result = \"\"\n    for c in s {\n\
    \        result = alphabetRotated[alphabet.indexOf(c) + alphabetRotated.indexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphhzg8ewx.swift:12:43: error: value of type 'String' has no member\
    \ 'indexOf'\n        result = alphabetRotated[alphabet.indexOf(c) + alphabetRotated.indexOf(c)\
    \ + 2]\n                                 ~~~~~~~~ ^~~~~~~\n/tmp/tmphhzg8ewx.swift:12:72:\
    \ error: value of type 'String' has no member 'indexOf'\n        result = alphabetRotated[alphabet.indexOf(c)\
    \ + alphabetRotated.indexOf(c) + 2]\n                                        \
    \               ~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbbji8vi.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmbbji8vi.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpmbbji8vi.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        result += alphabet.index(letter)!\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2648mba7.swift:10:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet.index(letter)!\n                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabetLength * 2\n \
    \   let alphabetLength = alphabetLength + 2\n    var newString = \"\"\n    for\
    \ char in s.characters {\n        let index = alphabet.characters.index(of: char)!\n\
    \        let newIndex = index % alphabetLength\n        newString += alphabet[newIndex]\n\
    \    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpss__w9wi.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpss__w9wi.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabetLength * 2\n        ^\n/tmp/tmpss__w9wi.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpss__w9wi.swift:13:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in s.characters {\n               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpss__w9wi.swift:14:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ index = alphabet.characters.index(of: char)!\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpss__w9wi.swift:14:41:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.characters.index(of: char)!\n                             \
    \           ^\n/tmp/tmpss__w9wi.swift:14:41: note: use 'firstIndex(of:)' instead\n\
    \        let index = alphabet.characters.index(of: char)!\n                  \
    \                      ^~~~~\n                                        firstIndex\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwmjk8mbt.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:11:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:12:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpwmjk8mbt.swift:17:31: error: missing argument label '"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    newAlphabet = rotate(newAlphabet, 2)\n    return newAlphabet\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxoyfrt61.swift:10:19: error: cannot find 'rotate' in scope\n  \
    \  newAlphabet = rotate(newAlphabet, 2)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var alphabetLength\
    \ = alphabetLength + 2\n    var alphabetLength = alphabetLength * 2\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxxm4k1kd.swift:71:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpxxm4k1kd.swift:10:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabetLength * 2\n        ^\n/tmp/tmpxxm4k1kd.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \    var alphabetLength = alphabet.characters.count\n    var alphabetLength =\
    \ alphabet.characters.count\n    var alphabetLength = alphabet.characters.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_soz6yvs.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    var alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_soz6yvs.swift:10:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    var alphabetLength = alphabet.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_soz6yvs.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    var alphabetLength = alphabet.characters.count\n     \
    \   ^\n/tmp/tmp_soz6yvs.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    var alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmp_soz6yvs.swift:11:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    var alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_soz6yvs.swift:11:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    var alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmp_soz6yvs.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    var alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmp_soz6yvs.swift:12:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    var alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_soz6yvs.swift:12:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    var alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmp_soz6yvs.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    var alphab"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for letter in s.characters {\n        let index = alphabet.index(of: letter)!\n\
    \        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += String(newLetter)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vytagha.swift:10:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1vytagha.swift:11:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.index(of: letter)!\n                             ^\n/tmp/tmp1vytagha.swift:11:30:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.index(of:\
    \ letter)!\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmp1vytagha.swift:12:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        let newIndex = index + 2\n        \
    \               ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayLength = alphabetArray.count\n    var\
    \ alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n\
    \    var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n    var alphabetArrayLength\
    \ = alphabetArray.count\n    var alphabetArrayLength = alphabetArray.count\n \
    \   var alphabetArrayLength = alphabetArray.count\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpop0repn1.swift:11:9: error: invalid redeclaration of 'alphabetArrayLength'\n\
    \    var alphabetArrayLength = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:10:9:\
    \ note: 'alphabetArrayLength' previously declared here\n    var alphabetArrayLength\
    \ = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:12:9: error: invalid\
    \ redeclaration of 'alphabetArrayLength'\n    var alphabetArrayLength = alphabetArray.count\n\
    \        ^\n/tmp/tmpop0repn1.swift:10:9: note: 'alphabetArrayLength' previously\
    \ declared here\n    var alphabetArrayLength = alphabetArray.count\n        ^\n\
    /tmp/tmpop0repn1.swift:13:9: error: invalid redeclaration of 'alphabetArrayLength'\n\
    \    var alphabetArrayLength = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:10:9:\
    \ note: 'alphabetArrayLength' previously declared here\n    var alphabetArrayLength\
    \ = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:14:9: error: invalid\
    \ redeclaration of 'alphabetArrayLength'\n    var alphabetArrayLength = alphabetArray.count\n\
    \        ^\n/tmp/tmpop0repn1.swift:10:9: note: 'alphabetArrayLength' previously\
    \ declared here\n    var alphabetArrayLength = alphabetArray.count\n        ^\n\
    /tmp/tmpop0repn1.swift:15:9: error: invalid redeclaration of 'alphabetArrayLength'\n\
    \    var alphabetArrayLength = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:10:9:\
    \ note: 'alphabetArrayLength' previously declared here\n    var alphabetArrayLength\
    \ = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:16:9: error: invalid\
    \ redeclaration of 'alphabetArrayLength'\n    var alphabetArrayLength = alphabetArray.count\n\
    \        ^\n/tmp/tmpop0repn1.swift:10:9: note: 'alphabetArrayLength' previously\
    \ declared here\n    var alphabetArrayLength = alphabetArray.count\n        ^\n\
    /tmp/tmpop0repn1.swift:17:9: error: invalid redeclaration of 'alphabetArrayLength'\n\
    \    var alphabetArrayLength = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:10:9:\
    \ note: 'alphabetArrayLength' previously declared here\n    var alphabetArrayLength\
    \ = alphabetArray.count\n        ^\n/tmp/tmpop0repn1.swift:18:9: error: invalid\
    \ redeclara"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.characters.count\n    var alphabetRotation = alphabet.characters.map\
    \ { $0.characters.count }\n    var alphabetRotation2 = alphabet.characters.map\
    \ { $0.characters.count * 2 }\n    var alphabetRotation3 = alphabet.characters.map\
    \ { $0.characters.count * 3 }\n    var alphabetRotation4 = alphabet.characters.map\
    \ { $0.characters.count * 4 }\n    var alphabetRotation5 = alphabet.characters.map\
    \ { $0.characters.count * 5 }\n    var alphabetRotation6 = alphabet.characters.map\
    \ { $0.characters.count * 6 }\n    var alphabetRotation7 = alphabet.characters.map\
    \ { $0.characters.count * 7 }\n    var alphabetRotation8 = alphabet.characters.map\
    \ { $0.characters.count * 8 }\n    var alphabetRotation9 = alphabet.characters.map\
    \ { $0.characters.count * 9 }\n    var alphabetRotation10 = alphabet.characters.map\
    \ { $0.characters.count * 10 }\n    var alphabetRotation11 = alphabet.characters.map\
    \ { $0.characters.count * 11 }\n    var alphabetRotation12 = alphabet.characters.map\
    \ { $0.characters.count * 12 }\n    var alphabetRotation13 = alphabet.characters.map\
    \ { $0.characters.count * 13 }\n    var alphabetRotation14 = alphabet.characters.map\
    \ { $0.characters.count * 14 }\n    var alphabetRotation15 = alphabet.characters.map\
    \ { $0.characters.count * 15 }\n    var alphabetRotation16 = alphabet.characters.map\
    \ { $0.characters.count * 16 }\n    var alphabetRotation17 = alphabet.characters.map\
    \ { $0.characters.count * 17 }\n    var alphabetRotation18 = alphabet.characters.map\
    \ { $0.characters.count * 18 }\n    var alphabetRotation19 = alphabet.characters.map\
    \ { $0.characters.count * 19 }\n    var alphabetRotation20 = alphabet.characters.map\
    \ { $0.characters.count * 20 }\n    var alphabetRotation21 = alphabet.characters.map\
    \ { $0.characters.count * 21 }\n    var alphabetRotation22 = alphabet.characters.map\
    \ { $0.characters.count * 22 }\n    var alphabetRotation23 = alphabet.characters.map\
    \ { $0.characters.count * 23 }\n    var alphabetRotation24 = alphabet.characters.map\
    \ { $0.characters.count * 24 }\n    var alphabetRotation25 = alphabet.characters.map\
    \ { $0.characters.count * 25 }\n    var alphabetRotation26 = alphabet.characters.map\
    \ { $0.characters.count * 26 }\n    var alphabetRotation27 = alphabet.characters.map\
    \ { $0.characters.count * 27 }\n    var alphabetRotation28 = alphabet.characters.map\
    \ { $0.characters.count * 28\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpatnjxduv.swift:60:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmpatnjxduv.swift:7:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmpatnjxduv.swift:9:35: error: 'characters'\
    \ is unavailable: Please use String directly\n    var alphabetLength = alphabet.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpatnjxduv.swift:10:57: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'characters'\n    var alphabetRotation = alphabet.characters.map\
    \ { $0.characters.count }\n                                                  \
    \   ~~ ^~~~~~~~~~\n/tmp/tmpatnjxduv.swift:11:58: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'characters'\n    var alphabetRotation2 = alphabet.characters.map\
    \ { $0.characters.count * 2 }\n                                              \
    \        ~~ ^~~~~~~~~~\n/tmp/tmpatnjxduv.swift:12:58: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'characters'\n    var alphabetRotation3 = alphabet.characters.map\
    \ { $0.characters.count * 3 }\n                                              \
    \        ~~ ^~~~~~~~~~\n/tmp/tmpatnjxduv.swift:13:58: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'characters'\n    var alphabetRotation4 = alphabet.characters.map\
    \ { $0.characters.count * 4 }\n                                              \
    \        ~~ ^~~~~~~~~~\n/tmp/tmpatnjxduv.swift:14:58: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'characters'\n    var alphabetRotation5 = alphabet.characters.map\
    \ { $0.characters.count * 5 }\n                                              \
    \        ~~ ^~~~~~~~~~\n/tmp/tmpatnjxduv.swift:15:58: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'characters'\n    var alphabetRotation6 = alphabet.characters."
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += alphabet[alphabet.count - 1]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppz5qplz_.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppz5qplz_.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmppz5qplz_.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        if newIndex < alphabet.count {\n              \
    \        ^~~~~~~~\n/tmp/tmppz5qplz_.swift:13:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[newIndex]\n                      ^~~~~~~~\n\
    /tmp/tmppz5qplz_.swift:15:23: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[alphabet.count - 1]\n                      ^~~~~~~~\n\
    /tmp/tmppz5qplz_.swift:15:32: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[alphabet.count - 1]\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s.characters {\n        result +=\
    \ alphabet.characters[alphabet.characters.index(letter) + 2]\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprqxeakev.swift:9:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprqxeakev.swift:10:19:\
    \ error: cannot find 'alphabet' in scope\n        result += alphabet.characters[alphabet.characters.index(letter)\
    \ + 2]\n                  ^~~~~~~~\n/tmp/tmprqxeakev.swift:10:39: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet.characters[alphabet.characters.index(letter)\
    \ + 2]\n                                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        result += alphabet.index(letter)!\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2648mba7.swift:10:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet.index(letter)!\n                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var encryptedString = \"\"\n\
    \    \n    for letter in s {\n        encryptedString += alphabet[alphabet.index(letter)!\
    \ + 2]\n    }\n    \n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc86in1h3.swift:39:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabet.index(letter)! + 2]\n       \
    \                            ^\n/tmp/tmpc86in1h3.swift:39:36: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'Character')\n        encryptedString\
    \ += alphabet[alphabet.index(letter)! + 2]\n                                 \
    \  ^\n/tmp/tmpc86in1h3.swift:39:36: note: candidate expects value of type 'Range<Int>'\
    \ for parameter #1 (got 'Character')\n        encryptedString += alphabet[alphabet.index(letter)!\
    \ + 2]\n                                   ^\n/tmp/tmpc86in1h3.swift:39:36: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Character')\n        encryptedString += alphabet[alphabet.index(letter)! +\
    \ 2]\n                                   ^\n/tmp/tmpc86in1h3.swift:39:36: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Character')\n        encryptedString += alphabet[alphabet.index(letter)! +\
    \ 2]\n                                   ^\n/tmp/tmpc86in1h3.swift:39:36: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        encryptedString += alphabet[alphabet.index(letter)! + 2]\n          \
    \                         ^\n/tmp/tmpc86in1h3.swift:39:52: error: missing argument\
    \ label 'of:' in call\n        encryptedString += alphabet[alphabet.index(letter)!\
    \ + 2]\n                                                   ^\n               \
    \                                    of: \n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayReversed = Array(alphabet)\n    for\
    \ i in 0..<alphabetArray.count {\n        alphabetArrayReversed[i] = alphabetArray[alphabetArray.count-i-1]\n\
    \    }\n    var alphabetArrayReversedArray = Array(alphabetArrayReversed)\n  \
    \  var alphabetArrayReversedArrayReversed = Array(alphabetArrayReversed)\n   \
    \ for i in 0..<alphabetArrayReversed.count {\n        alphabetArrayReversedArrayReversed[i]\
    \ = alphabetArrayReversed[alphabetArrayReversed.count-i-1]\n    }\n    var alphabetArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversed)\n    var alphabetArrayReversedArrayReversedArrayReversed\
    \ = Array(alphabetArrayReversedArrayReversedArray)\n    var alphabetArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversed)\n    var alphabetArrayReversedArrayReversedArrayReversedArrayReversed\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArray)\n    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversed)\n    var\
    \ alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed =\
    \ Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArray)\n \
    \   var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArray)\n\
    \    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed)\n\
    \    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed)\n\
    \    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray)\n\
    \    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed)\n\
    \    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray)\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpv624h7ju.swift:27:9: error: invalid redeclaration of 'alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray'\n\
    \    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversed)\n\
    \        ^\n/tmp/tmpv624h7ju.swift:25:9: note: 'alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray'\
    \ previously declared here\n    var alphabetArrayReversedArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = Array(alphabetArrayReversedArrayReversedArrayReversedArrayReversedArray)\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.insert(Character(\"a\"), at:\
    \ 0)\n    alphabet.insert(Character(\"b\"), at: 1)\n    alphabet.insert(Character(\"\
    c\"), at: 2)\n    alphabet.insert(Character(\"d\"), at: 3)\n    alphabet.insert(Character(\"\
    e\"), at: 4)\n    alphabet.insert(Character(\"f\"), at: 5)\n    alphabet.insert(Character(\"\
    g\"), at: 6)\n    alphabet.insert(Character(\"h\"), at: 7)\n    alphabet.insert(Character(\"\
    i\"), at: 8)\n    alphabet.insert(Character(\"j\"), at: 9)\n    alphabet.insert(Character(\"\
    k\"), at: 10)\n    alphabet.insert(Character(\"l\"), at: 11)\n    alphabet.insert(Character(\"\
    m\"), at: 12)\n    alphabet.insert(Character(\"n\"), at: 13)\n    alphabet.insert(Character(\"\
    o\"), at: 14)\n    alphabet.insert(Character(\"p\"), at: 15)\n    alphabet.insert(Character(\"\
    q\"), at: 16)\n    alphabet.insert(Character(\"r\"), at: 17)\n    alphabet.insert(Character(\"\
    s\"), at: 18)\n    alphabet.insert(Character(\"t\"), at: 19)\n    alphabet.insert(Character(\"\
    u\"), at: 20)\n    alphabet.insert(Character(\"v\"), at: 21)\n    alphabet.insert(Character(\"\
    w\"), at: 22)\n    alphabet.insert(Character(\"x\"), at: 23)\n    alphabet.insert(Character(\"\
    y\"), at: 24)\n    alphabet.insert(Character(\"z\"), at: 25)\n    alphabet.insert(Character(\"\
    A\"), at: 26)\n    alphabet.insert(Character(\"B\"), at: 27)\n    alphabet.insert(Character(\"\
    C\"), at: 28)\n    alphabet.insert(Character(\"D\"), at: 29)\n    alphabet.insert(Character(\"\
    E\"), at: 30)\n    alphabet.insert(Character(\"F\"), at: 31)\n    alphabet.insert(Character(\"\
    G\"), at: 32)\n    alphabet.insert(Character(\"H\"), at: 33)\n    alphabet.insert(Character(\"\
    I\"), at: 34)\n    alphabet.insert(Character(\"J\"), at: 35)\n    alphabet.insert(Character(\"\
    K\"), at: 36)\n    alphabet.insert(Character(\"L\"), at: 37)\n    alphabet.insert(Character(\"\
    M\"), at: 38)\n    alphabet.insert(Character(\"N\"), at: 39)\n    alphabet.insert(Character(\"\
    O\"), at: 40)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpcqhpdsoh.swift:50:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpauihg93q.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpauihg93q.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)\n                    ^~~~~~~~\n/tmp/tmpauihg93q.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetArray\
    \ = Array(alphabet)\n    var alphabetArrayLength = alphabetArray.length\n    var\
    \ alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n    var alphabetArrayLength\
    \ = alphabetArray.length\n    var alphabetArrayLength = alphabetArray.length\n\
    \    var alphabetArrayLength = alphabetArray.length\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp58jzzmuj.swift:10:45: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'length'\n    var alphabetArrayLength = alphabetArray.length\n\
    \                              ~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp58jzzmuj.swift:11:45:\
    \ error: value of type '[String.Element]' (aka 'Array<Character>') has no member\
    \ 'length'\n    var alphabetArrayLength = alphabetArray.length\n             \
    \                 ~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp58jzzmuj.swift:12:45: error: value\
    \ of type '[String.Element]' (aka 'Array<Character>') has no member 'length'\n\
    \    var alphabetArrayLength = alphabetArray.length\n                        \
    \      ~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp58jzzmuj.swift:13:45: error: value of type\
    \ '[String.Element]' (aka 'Array<Character>') has no member 'length'\n    var\
    \ alphabetArrayLength = alphabetArray.length\n                              ~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp58jzzmuj.swift:14:45: error: value of type '[String.Element]'\
    \ (aka 'Array<Character>') has no member 'length'\n    var alphabetArrayLength\
    \ = alphabetArray.length\n                              ~~~~~~~~~~~~~ ^~~~~~\n\
    /tmp/tmp58jzzmuj.swift:15:45: error: value of type '[String.Element]' (aka 'Array<Character>')\
    \ has no member 'length'\n    var alphabetArrayLength = alphabetArray.length\n\
    \                              ~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp58jzzmuj.swift:16:45:\
    \ error: value of type '[String.Element]' (aka 'Array<Character>') has no member\
    \ 'length'\n    var alphabetArrayLength = alphabetArray.length\n             \
    \                 ~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp58jzzmuj.swift:17:45: error: value\
    \ of type '[String.Element]' (aka 'Array<Character>') has no member 'length'\n\
    \    var alphabetArrayLength = alphabetArray.length\n                        \
    \      ~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp58jzzmuj.swift:18:45: error: value of type\
    \ '[String.Element]' (aka 'Array<Character>') has no member 'length'\n    var\
    \ alphabetArrayLength = alphabetArray.length\n                              ~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp58jzzmuj.swift:19:45: error: value of type '[String.Element]"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var result = [Character]()\n\
    \    var index = 0\n    for char in s {\n        result.append(alphabet[(alphabet.index(of:\
    \ char) + 2) % alphabet.count])\n    }\n    return String(result)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz0su9mrl.swift:39:42: error: value of optional type 'Array<Character>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Character>.Index'\
    \ (aka 'Int')\n        result.append(alphabet[(alphabet.index(of: char) + 2) %\
    \ alphabet.count])\n                                         ^\n/tmp/tmpz0su9mrl.swift:39:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result.append(alphabet[(alphabet.index(of: char) + 2) % alphabet.count])\n\
    \                                         ^\n                                (\
    \                        ?? <#default value#>)\n/tmp/tmpz0su9mrl.swift:39:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        result.append(alphabet[(alphabet.index(of: char) + 2) % alphabet.count])\n\
    \                                         ^\n                                \
    \                        !\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmwirfmcx.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmwirfmcx.swift:12:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:13:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:14:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:15:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmwirfmcx.swift:20:41:\
    \ error: type "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)!\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpodds21zj.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpodds21zj.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \    let alphabetLength = alphabet.characters.count\n    let alphabetLength =\
    \ alphabet.characters.count\n    let alphabetLength = alphabet.characters.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpw1uoxfa7.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw1uoxfa7.swift:10:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    let alphabetLength = alphabet.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw1uoxfa7.swift:10:9: error: invalid redeclaration of\
    \ 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n     \
    \   ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmpw1uoxfa7.swift:11:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw1uoxfa7.swift:11:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphabetLength = alphabet.characters.count\n        ^\n/tmp/tmpw1uoxfa7.swift:12:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let alphabetLength\
    \ = alphabet.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw1uoxfa7.swift:12:9:\
    \ error: invalid redeclaration of 'alphabetLength'\n    let alphabetLength = alphabet.characters.count\n\
    \        ^\n/tmp/tmpw1uoxfa7.swift:9:9: note: 'alphabetLength' previously declared\
    \ here\n    let alphab"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)!\n        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpodds21zj.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpodds21zj.swift:12:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.insert(Character(UnicodeScalar(UInt8(97))),\
    \ at: 0)\n    alphabet.insert(Character(UnicodeScalar(UInt8(98))), at: 1)\n  \
    \  alphabet.insert(Character(UnicodeScalar(UInt8(99))), at: 2)\n    alphabet.insert(Character(UnicodeScalar(UInt8(100))),\
    \ at: 3)\n    alphabet.insert(Character(UnicodeScalar(UInt8(101))), at: 4)\n \
    \   alphabet.insert(Character(UnicodeScalar(UInt8(102))), at: 5)\n    alphabet.insert(Character(UnicodeScalar(UInt8(103))),\
    \ at: 6)\n    alphabet.insert(Character(UnicodeScalar(UInt8(104))), at: 7)\n \
    \   alphabet.insert(Character(UnicodeScalar(UInt8(105))), at: 8)\n    alphabet.insert(Character(UnicodeScalar(UInt8(106))),\
    \ at: 9)\n    alphabet.insert(Character(UnicodeScalar(UInt8(107))), at: 10)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(108))), at: 11)\n    alphabet.insert(Character(UnicodeScalar(UInt8(109))),\
    \ at: 12)\n    alphabet.insert(Character(UnicodeScalar(UInt8(110))), at: 13)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(111))), at: 14)\n    alphabet.insert(Character(UnicodeScalar(UInt8(112))),\
    \ at: 15)\n    alphabet.insert(Character(UnicodeScalar(UInt8(113))), at: 16)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(114))), at: 17)\n    alphabet.insert(Character(UnicodeScalar(UInt8(115))),\
    \ at: 18)\n    alphabet.insert(Character(UnicodeScalar(UInt8(116))), at: 19)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(117))), at: 20)\n    alphabet.insert(Character(UnicodeScalar(UInt8(118))),\
    \ at: 21)\n    alphabet.insert(Character(UnicodeScalar(UInt8(119))), at: 22)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(120))), at: 23)\n    alphabet.insert(Character(UnicodeScalar(UInt8(121))),\
    \ at: 24)\n    alphabet.insert(Character(UnicodeScalar(UInt8(122))), at: 25)\n\
    \    alphabet.insert(Character(UnicodeScalar(UInt8(123))), at: 26)\n    alphabet.insert(Character(UnicodeScalar(UInt8(124))),\
    \ at: 27\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpily5qq1f.swift:37:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpily5qq1f.swift:36:20: note: to match this opening '('\n    alphabet.insert(Character(UnicodeScalar(UInt8(124))),\
    \ at: 27\n                   ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ alphabet\n    for _ in 0..<s.count {\n        newAlphabet = alphabet[newAlphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpmalg_6.swift:12:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmpmalg_6.swift:11:1925: note: to match this opening '('\n        newAlphabet\
    \ = alphabet[newAlphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[alphabet.index(of: alphabet[alphabet.index(of:\
    \ alphabet[alphabet.index(of: alphabet[al"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for letter in s {\n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n\
    \        alphabetIndex++\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0_sz6bf.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpc0_sz6bf.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += c\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsgww2jw_.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsgww2jw_.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmpsgww2jw_.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        if newIndex < alphabet.count {\n              \
    \        ^~~~~~~~\n/tmp/tmpsgww2jw_.swift:13:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[newIndex]\n                      ^~~~~~~~\n\
    /tmp/tmpsgww2jw_.swift:15:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += c\n              \
    \        ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var result = [Character]()\n\
    \    \n    for char in s.characters {\n        var index = alphabet.index(of:\
    \ char)!\n        var newIndex = index + 2\n        if newIndex < alphabet.count\
    \ {\n            result.append(alphabet[newIndex])\n        } else {\n       \
    \     result.append(alphabet[0])\n        }\n    }\n    \n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmu_a2eob.swift:38:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmu_a2eob.swift:39:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        var\
    \ index = alphabet.index(of: char)!\n                             ^\n/tmp/tmpmu_a2eob.swift:39:30:\
    \ note: use 'firstIndex(of:)' instead\n        var index = alphabet.index(of:\
    \ char)!\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpmu_a2eob.swift:39:13: warning: variable 'index' was never mutated; consider\
    \ changing to 'let' constant\n        var index = alphabet.index(of: char)!\n\
    \        ~~~ ^\n        let\n/tmp/tmpmu_a2eob.swift:40:13: warning: variable 'newIndex'\
    \ was never mutated; consider changing to 'let' constant\n        var newIndex\
    \ = index + 2\n        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkdtgy7i7.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkdtgy7i7.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpkdtgy7i7.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"A\"))\n\
    \    alphabet.append(Character(\"B\"))\n    alphabet.append(Character(\"C\"))\n\
    \    alphabet.append(Character(\"D\"))\n    alphabet.append(Character(\"E\"))\n\
    \    alphabet.append(Character(\"F\"))\n    alphabet.append(Character(\"G\"))\n\
    \    alphabet.append(Character(\"H\"))\n    alphabet.append(Character(\"I\"))\n\
    \    alphabet.append(Character(\"J\"))\n    alphabet.append(Character(\"K\"))\n\
    \    alphabet.append(Character(\"L\"))\n    alphabet.append(Character(\"M\"))\n\
    \    alphabet.append(Character(\"N\"))\n    alphabet.append(Character(\"O\"))\n\
    \    alphabet.append(Character(\"P\"))\n    alphabet.append(Character(\"Q\"))\n\
    \    alphabet.append(Character(\"R\"))\n    alphabet.append(Character(\"S\"))\n\
    \    alphabet.append(Character(\"T\"))\n    alphabet.append(Character(\"U\"))\n\
    \    alphabet.append(Character(\"V\"))\n    alphabet.append(Character(\"W\"))\n\
    \    alphabet.append(Character(\"X\"))\n    alphabet.append(Character(\"Y\"))\n\
    \    alphabet.append(Character(\"Z\"))\n    \n    var result = [Character]()\n\
    \    for char in s {\n        var index = alphabet.index(of: char)!\n        result.insert(char,\
    \ at: index)\n    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/Array.swift:418: Fatal error: Array index is out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48daa31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48da728561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48da728286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48da72813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48da727bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b48da711196 <unavailable> + 1339798

    6    libswiftCore.so                    0x00002b48da715020 Array.insert(_:at:)
    + 80

    7    tmpqzgte4_6                        0x0000562832e30dd5 <unavailable> + 11733

    8    tmpqzgte4_6                        0x0000562832e2f6d6 <unavailable> + 5846

    9    libc.so.6                          0x00002b48dac1d460 __libc_start_main +
    245

    10   tmpqzgte4_6                        0x0000562832e2f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(\"a\"))\n\
    \    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"c\"))\n\
    \    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"e\"))\n\
    \    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"g\"))\n\
    \    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"i\"))\n\
    \    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"k\"))\n\
    \    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"m\"))\n\
    \    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"o\"))\n\
    \    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"q\"))\n\
    \    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"s\"))\n\
    \    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"u\"))\n\
    \    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"w\"))\n\
    \    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"y\"))\n\
    \    alphabet.append(Character(\"z\"))\n    \n    var encryptedString = \"\"\n\
    \    for char in s.characters {\n        encryptedString += alphabet[alphabet.index(char)\
    \ + 2]\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpu9m336bn.swift:37:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu9m336bn.swift:38:52:\
    \ error: missing argument label 'of:' in call\n        encryptedString += alphabet[alphabet.index(char)\
    \ + 2]\n                                                   ^\n               \
    \                                    of: \n/tmp/tmpu9m336bn.swift:38:36: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        encryptedString += alphabet[alphabet.index(char) + 2]\n             \
    \                      ^\n/tmp/tmpu9m336bn.swift:38:36: error: no exact matches\
    \ in call to subscript \n        encryptedString += alphabet[alphabet.index(char)\
    \ + 2]\n                                   ^\n/tmp/tmpu9m336bn.swift:38:36: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'Character')\n \
    \       encryptedString += alphabet[alphabet.index(char) + 2]\n              \
    \                     ^\n/tmp/tmpu9m336bn.swift:38:36: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got 'Character')\n        encryptedString\
    \ += alphabet[alphabet.index(char) + 2]\n                                   ^\n\
    /tmp/tmpu9m336bn.swift:38:36: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Character')\n        encryptedString += alphabet[alphabet.index(char)\
    \ + 2]\n                                   ^\n/tmp/tmpu9m336bn.swift:38:36: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Character')\n        encryptedString += alphabet[alphabet.index(char) + 2]\n\
    \                                   ^\n/tmp/tmpu9m336bn.swift:38:46: error: value\
    \ of optional type 'Array<Character>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Character>.Index' (aka 'Int')\n        encryptedString\
    \ += alphabet[alphabet.index(char) + 2]\n            "
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.insert(Character(s.characters.first!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.first!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!), at: 0)\n    alphabet.insert(Character(s.characters.last!),\
    \ at: 0)\n    alphabet.insert(Character(s.characters.last!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpghajrbrn.swift:43:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpghajrbrn.swift:42:30: note: to match this opening '('\n    alphabet.insert(Character(s.characters.last!\n\
    \                             ^\n/tmp/tmpghajrbrn.swift:9:31: error: missing argument\
    \ label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.insert(Character(s.characters.first!),\
    \ at: 0)\n                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.insert(Character(s.characters.last!), at: 0)\n       \
    \                       ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:11:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.insert(Character(s.characters.last!), at: 0)\n       \
    \                       ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:12:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.insert(Character(s.characters.first!), at: 0)\n      \
    \                        ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.insert(Character(s.characters.last!), at: 0)\n       \
    \                       ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.insert(Character(s.characters.last!), at: 0)\n       \
    \                       ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.insert(Character(s.characters.last!), at: 0)\n       \
    \                       ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpghajrbrn.swift:16:31: error: missing arg"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpclpy95uv.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpclpy95uv.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmpclpy95uv.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n            \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for letter in s {\n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n\
    \        alphabetIndex++\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0_sz6bf.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpc0_sz6bf.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk0b3a0h9.swift:41:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpk0b3a0h9.swift:40:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpk0b3a0h9.swift:9:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:10:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpk0b3a0h9.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:11:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpk0b3a0h9.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpk0b3a0h9.swift:12:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n/"
  stdout: ''
  timestamp: 1660028459
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.count\n    var newString = \"\"\n    for letter in s {\n        let\
    \ index = alphabet.index(of: letter)!\n        let newIndex = index * 2\n    \
    \    let newLetter = alphabet[newIndex]\n        newString += newLetter\n    }\n\
    \    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpu2i5wdhc.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: letter)!\n    \
    \                         ^\n/tmp/tmpu2i5wdhc.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: letter)!\n                 \
    \            ^~~~~\n                             firstIndex\n/tmp/tmpu2i5wdhc.swift:13:30:\
    \ error: binary operator '*' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        let newIndex = index * 2\n                       ~~~~~ ^\
    \ ~\n/tmp/tmpu2i5wdhc.swift:13:30: note: overloads for '*' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        let newIndex = index * 2\n   \
    \                          ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.insert(Character(\" \"), at:\
    \ 0)\n    alphabet.insert(Character(\" \"), at: 1)\n    alphabet.insert(Character(\"\
    \ \"), at: 2)\n    alphabet.insert(Character(\" \"), at: 3)\n    alphabet.insert(Character(\"\
    \ \"), at: 4)\n    alphabet.insert(Character(\" \"), at: 5)\n    alphabet.insert(Character(\"\
    \ \"), at: 6)\n    alphabet.insert(Character(\" \"), at: 7)\n    alphabet.insert(Character(\"\
    \ \"), at: 8)\n    alphabet.insert(Character(\" \"), at: 9)\n    alphabet.insert(Character(\"\
    \ \"), at: 10)\n    alphabet.insert(Character(\" \"), at: 11)\n    alphabet.insert(Character(\"\
    \ \"), at: 12)\n    alphabet.insert(Character(\" \"), at: 13)\n    alphabet.insert(Character(\"\
    \ \"), at: 14)\n    alphabet.insert(Character(\" \"), at: 15)\n    alphabet.insert(Character(\"\
    \ \"), at: 16)\n    alphabet.insert(Character(\" \"), at: 17)\n    alphabet.insert(Character(\"\
    \ \"), at: 18)\n    alphabet.insert(Character(\" \"), at: 19)\n    alphabet.insert(Character(\"\
    \ \"), at: 20)\n    alphabet.insert(Character(\" \"), at: 21)\n    alphabet.insert(Character(\"\
    \ \"), at: 22)\n    alphabet.insert(Character(\" \"), at: 23)\n    alphabet.insert(Character(\"\
    \ \"), at: 24)\n    alphabet.insert(Character(\" \"), at: 25)\n    alphabet.insert(Character(\"\
    \ \"), at: 26)\n    alphabet.insert(Character(\" \"), at: 27)\n    alphabet.insert(Character(\"\
    \ \"), at: 28)\n    alphabet.insert(Character(\" \"), at: 29)\n    alphabet.insert(Character(\"\
    \ \"), at: 30)\n    alphabet.insert(Character(\" \"), at: 31)\n    alphabet.insert(Character(\"\
    \ \"), at: 32)\n    alphabet.insert(Character(\" \"), at: 33)\n    alphabet.insert(Character(\"\
    \ \"), at: 34)\n    alphabet.insert(Character(\" \"), at: 35)\n    alphabet.insert(Character(\"\
    \ \"), at: 36)\n    alphabet.insert(Character(\" \"), at: 37)\n    alphabet.insert(Character(\"\
    \ \"), at: 38)\n    alphabet.insert(Character(\" \"), at: 39)\n    alphabet.insert(Character(\"\
    \ \"), at: 40)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpk5udzuaf.swift:50:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpam12xc5r.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpam12xc5r.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)\n                    ^~~~~~~~\n/tmp/tmpam12xc5r.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var newAlphabet = \"\"\n    var newAlphabetLength = alphabet.count\n\
    \    var newAlphabetIndex = 0\n    var newAlphabetIndex2 = 0\n    var newAlphabetIndex3\
    \ = 0\n    var newAlphabetIndex4 = 0\n    var newAlphabetIndex5 = 0\n    var newAlphabetIndex6\
    \ = 0\n    var newAlphabetIndex7 = 0\n    var newAlphabetIndex8 = 0\n    var newAlphabetIndex9\
    \ = 0\n    var newAlphabetIndex10 = 0\n    var newAlphabetIndex11 = 0\n    var\
    \ newAlphabetIndex12 = 0\n    var newAlphabetIndex13 = 0\n    var newAlphabetIndex14\
    \ = 0\n    var newAlphabetIndex15 = 0\n    var newAlphabetIndex16 = 0\n    var\
    \ newAlphabetIndex17 = 0\n    var newAlphabetIndex18 = 0\n    var newAlphabetIndex19\
    \ = 0\n    var newAlphabetIndex20 = 0\n    var newAlphabetIndex21 = 0\n    var\
    \ newAlphabetIndex22 = 0\n    var newAlphabetIndex23 = 0\n    var newAlphabetIndex24\
    \ = 0\n    var newAlphabetIndex25 = 0\n    var newAlphabetIndex26 = 0\n    var\
    \ newAlphabetIndex27 = 0\n    var newAlphabetIndex28 = 0\n    var newAlphabetIndex29\
    \ = 0\n    var newAlphabetIndex30 = 0\n    var newAlphabetIndex31 = 0\n    var\
    \ newAlphabetIndex32 = 0\n    var newAlphabetIndex33 = 0\n    var newAlphabetIndex34\
    \ = 0\n    var newAlphabetIndex35 = 0\n    var newAlphabetIndex36 = 0\n    var\
    \ newAlphabetIndex37 = 0\n    var newAlphabetIndex38 = 0\n    var newAlphabetIndex39\
    \ = 0\n    var newAlphabetIndex40 = 0\n    var newAlphabetIndex41 = 0\n    var\
    \ newAlphabetIndex42 = 0\n    var newAlphabetIndex43 = 0\n    var newAlphabetIndex44\
    \ = 0\n    var newAlphabetIndex45 = 0\n    var newAlphabetIndex46 = 0\n    var\
    \ newAlphabetIndex47 = 0\n    var newAlphabetIndex48 = 0\n    var newAlphabetIndex49\
    \ = 0\n    var newAlphabetIndex50 = 0\n    var newAlphabetIndex51 = 0\n    var\
    \ newAlphabetIndex52 = 0\n    var newAlphabetIndex53 = 0\n    var newAlphabetIndex54\
    \ = 0\n    var newAlphabetIndex55 = 0\n    var newAlphabetIndex56 = 0\n    var\
    \ newAlphabetIndex57 = 0\n    var newAlphabetIndex58 = 0\n    var newAlphabetIndex59\
    \ = 0\n    var newAlphab\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5w1k7q0g.swift:71:9: error: type annotation missing in pattern\n\
    \    var newAlphab\n        ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbybwuwab.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:11:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:12:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpbybwuwab.swift:17:31: error: missing argument label '"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characters[s.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+1]))\n    alphabet.append(Character(s.characters[s.startIndex+2]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+3]))\n    alphabet.append(Character(s.characters[s.startIndex+4]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+5]))\n    alphabet.append(Character(s.characters[s.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+7]))\n    alphabet.append(Character(s.characters[s.startIndex+8]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+9]))\n    alphabet.append(Character(s.characters[s.startIndex+10]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+11]))\n    alphabet.append(Character(s.characters[s.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+13]))\n    alphabet.append(Character(s.characters[s.startIndex+14]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+15]))\n    alphabet.append(Character(s.characters[s.startIndex+16]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+17]))\n    alphabet.append(Character(s.characters[s.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+19]))\n    alphabet.append(Character(s.characters[s.startIndex+20]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+21]))\n    alphabet.append(Character(s.characters[s.startIndex+22]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+23]))\n    alphabet.append(Character(s.characters[s.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+25]))\n    alphabet.append(Character(s.characters[s.startIndex+26]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+27]))\n    alphabet.append(Character(s.characters[s.startIndex+28]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+29]))\n    alphabet.append(Character(s.characters[s.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+31]))\n    alphabet.append(Character(s.characters[s.startIndex+32]))\n\
    \    alphabet.append(Character(s.characters[s.startIndex+33\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp67heoyam.swift:43:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp67heoyam.swift:42:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.startIndex+33\n\
    \                                          ^\n/tmp/tmp67heoyam.swift:9:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:10:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.startIndex+1]))\n    \
    \                          ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:10:46: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.startIndex+1]))\n\
    \                                             ^\n/tmp/tmp67heoyam.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.startIndex+2]))\n                \
    \              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:11:46: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.startIndex+2]))\n\
    \                                             ^\n/tmp/tmp67heoyam.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.startIndex+3]))\n                \
    \              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp67heoyam.swift:12:46: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.startIndex+3]))\n\
    \                                             ^\n/tmp/tmp67heoyam.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.appe"
  stdout: ''
  timestamp: 1660028460
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabet2 = \"\
    nopqrstuvwxyzabcdefghijklm\"\n    var alphabet3 = \"nopqrstuvwxyzabcdefghijklmno\"\
    \n    var alphabet4 = \"nopqrstuvwxyzabcdefghijklmnopq\"\n    var alphabet5 =\
    \ \"nopqrstuvwxyzabcdefghijklmnopqrst\"\n    var alphabet6 = \"nopqrstuvwxyzabcdefghijklmnopqrstuv\"\
    \n    var alphabet7 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvw\"\n    var alphabet8\
    \ = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxy\"\n    var alphabet9 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"\
    \n    var alphabet10 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab\"\n    var\
    \ alphabet11 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabce\"\n    var alphabet12\
    \ = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefg\"\n    var alphabet13 = \"\
    nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefgh\"\n    var alphabet14 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghij\"\
    \n    var alphabet15 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghijkl\"\n\
    \    var alphabet16 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghijklm\"\n\
    \    var alphabet17 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghijklmno\"\
    \n    var alphabet18 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghijklmnopq\"\
    \n    var alphabet19 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghijklmnopqrst\"\
    \n    var alphabet20 = \"nopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcefghijklmnopqrstuv\"\
    \n    var alphabet21 = \"nopqrstuvwxyzabcdefghij\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpax5gg09a.swift:28:22: error: unterminated string literal\n    var\
    \ alphabet21 = \"nopqrstuvwxyzabcdefghij\n                     ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let alphabetLength\
    \ = alphabet.characters.count\n    let alphabetLengthHalf = alphabetLength / 2\n\
    \    var newString = \"\"\n    for char in s.characters {\n        let index =\
    \ alphabet.index(of: char)!\n        let newIndex = index - alphabetLengthHalf\n\
    \        newString += alphabet[newIndex]\n    }\n    return newString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpaee5dgag.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpaee5dgag.swift:12:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in s.characters {\n               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpaee5dgag.swift:13:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.index(of: char)!\n                             ^\n/tmp/tmpaee5dgag.swift:13:30:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.index(of:\
    \ char)!\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpaee5dgag.swift:14:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        let newIndex = index - alphabetLengthHalf\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        result = result + alphabet[newIndex]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7uv6fgk7.swift:10:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp7uv6fgk7.swift:12:27:\
    \ error: cannot find 'alphabet' in scope\n        result = result + alphabet[newIndex]\n\
    \                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        if newIndex < alphabet.count {\n  \
    \          result += alphabet[newIndex]\n        } else {\n            result\
    \ += alphabet[alphabet.count - 1]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppz5qplz_.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppz5qplz_.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmppz5qplz_.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        if newIndex < alphabet.count {\n              \
    \        ^~~~~~~~\n/tmp/tmppz5qplz_.swift:13:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[newIndex]\n                      ^~~~~~~~\n\
    /tmp/tmppz5qplz_.swift:15:23: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[alphabet.count - 1]\n                      ^~~~~~~~\n\
    /tmp/tmppz5qplz_.swift:15:32: error: cannot find 'alphabet' in scope\n       \
    \     result += alphabet[alphabet.count - 1]\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetLength = alphabet.count\n    var alphabetLength\
    \ = alphabet.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2isi3_se.swift:10:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:11:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:12:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:13:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:14:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:15:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:16:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se.swift:17:9: error: invalid redeclaration of 'alphabetLength'\n\
    \    var alphabetLength = alphabet.count\n        ^\n/tmp/tmp2isi3_se.swift:9:9:\
    \ note: 'alphabetLength' previously declared here\n    var alphabetLength = alphabet.count\n\
    \        ^\n/tmp/tmp2isi3_se"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var result = \"\"\n\
    \    for letter in s {\n        var index = alphabet.index(letter)\n        index\
    \ = index + alphabetRotatedLength\n        index = index % alphabetLength\n  \
    \      result = result + alphabetRotated[index]\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbma2tu1.swift:14:36: error: missing argument label 'of:' in call\n\
    \        var index = alphabet.index(letter)\n                                \
    \   ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp43s3tap2.swift:40:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp43s3tap2.swift:39:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmp43s3tap2.swift:9:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp43s3tap2.swift:12:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2.swift:13:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2.swift:14:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2.swift:15:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp43s3tap2."
  stdout: ''
  timestamp: 1660028459
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.sort()\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"Z\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"A\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"B\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"C\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"D\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"E\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"F\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"G\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"H\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"I\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"J\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"K\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"L\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"M\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"N\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"O\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"P\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"Q\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"R\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"S\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"T\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"U\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"V\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"W\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"X\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"Y\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"Z\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii:\
    \ \"a\"))))\n    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"b\"))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(ascii: \"c\"))))\n    alphabet.append(Character(UnicodeScalar\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7q_unhid.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp7q_unhid.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(UnicodeScalar\n\
    \                             ^\n/tmp/tmp7q_unhid.swift:9:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7q_unhid.swift:43:21: error: no exact matches in call to initializer\
    \ \n    alphabet.append(Character(UnicodeScalar\n                    ^\nSwift.Character:2:23:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'UnicodeScalar.Type' (aka 'Unicode.Scalar.Type'))\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'UnicodeScalar.Type'\
    \ (aka 'Unicode.Scalar.Type'))\n    @inlinable public init(_ s: String)\n    \
    \                  ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var newAlphabet:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var newAlphabet2: [Character]\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n    var newAlphabet3: [Character] = [\"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"]\n    var newAlphabet4: [Character] = [\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"]\n    var newAlphabet5: [Character] = [\"a\", \"b\", \"c\", \"d\",\
    \ \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n    var newAlphabet6: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var newAlphabet7:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var newAlphabet8: [Character]\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n    var newAlphabet9: [Character] = [\"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_w31byoi.swift:17:158: error: unterminated string literal\n   \
    \ var newAlphabet9: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\n                          \
    \                                                                            \
    \                                                       ^\n/tmp/tmp_w31byoi.swift:8:9:\
    \ warning: variable 'alphabet' was never used; consider replacing with '_' or\
    \ removing it\n    var alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \       ^~~~~~~~\n        _\n/tmp/tmp_w31byoi.swift:9:9: warning: variable 'newAlphabet'\
    \ was never used; consider replacing with '_' or removing it\n    var newAlphabet:\
    \ [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmp_w31byoi.swift:10:9: warning: variable 'newAlphabet2' was never used;\
    \ consider replacing with '_' or removing it\n    var newAlphabet2: [Character]\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n        ^~~~~~~~~~~~\n        _\n/tmp/tmp_w31byoi.swift:11:9:\
    \ warning: variable 'newAlphabet3' was never used; consider replacing with '_'\
    \ or removing it\n    var newAlphabet3: [Character] = [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n        ^~~~~~~~~~~~\n        _\n/tmp/tmp_w31byoi.swift:12:9: warning: variable\
    \ 'newAlphabet4' was never used; consider replacing with '_' or removing it\n\
    \    var newAlphabet4: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        ^~~~~~~~~~~~\n\
    \        _\n/tmp/tmp_w31byoi.swift:13:9: warning: variable 'newAlphabet5' was\
    \ never used; consider"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(s.first!))\n\
    \    alphabet.append(Character(s.last!))\n    alphabet.append(Character(\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8oxh1wh.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpk8oxh1wh.swift:9:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:10:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:11:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:12:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:13:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpk8oxh1wh.swift:17:31:\
    \ error: missing argument label 'exten"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbbji8vi.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmbbji8vi.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ c)!\n                    ^~~~~~~~\n/tmp/tmpmbbji8vi.swift:12:23: error: cannot\
    \ find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n       \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(s.lowercaseString)\n \
    \   alphabet.append(s.uppercaseString)\n    alphabet.append(s.capitalizedString)\n\
    \    \n    var result = [String]()\n    for letter in alphabet {\n        var\
    \ rotatedLetter = letter\n        \n        for _ in 0..<2 {\n            rotatedLetter\
    \ = alphabet[(alphabet.index(of: rotatedLetter) + 2) % alphabet.count]\n     \
    \   }\n        \n        result.append(rotatedLetter)\n    }\n    \n    return\
    \ result.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8dnlg878.swift:9:23: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    alphabet.append(s.lowercaseString)\n                \
    \    ~ ^~~~~~~~~~~~~~~\n/tmp/tmp8dnlg878.swift:10:23: error: value of type 'String'\
    \ has no member 'uppercaseString'\n    alphabet.append(s.uppercaseString)\n  \
    \                  ~ ^~~~~~~~~~~~~~~\n/tmp/tmp8dnlg878.swift:11:23: error: value\
    \ of type 'String' has no member 'capitalizedString'\n    alphabet.append(s.capitalizedString)\n\
    \                    ~ ^~~~~~~~~~~~~~~~~\n/tmp/tmp8dnlg878.swift:18:48: error:\
    \ value of optional type 'Array<String>.Index?' (aka 'Optional<Int>') must be\
    \ unwrapped to a value of type 'Array<String>.Index' (aka 'Int')\n           \
    \ rotatedLetter = alphabet[(alphabet.index(of: rotatedLetter) + 2) % alphabet.count]\n\
    \                                               ^\n/tmp/tmp8dnlg878.swift:18:48:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            rotatedLetter = alphabet[(alphabet.index(of: rotatedLetter)\
    \ + 2) % alphabet.count]\n                                               ^\n \
    \                                     (                                 ?? <#default\
    \ value#>)\n/tmp/tmp8dnlg878.swift:18:48: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            rotatedLetter =\
    \ alphabet[(alphabet.index(of: rotatedLetter) + 2) % alphabet.count]\n       \
    \                                        ^\n                                 \
    \                                      !\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character : Character]()\n    alphabet[\"A\"] = \"Z\"\
    \n    alphabet[\"B\"] = \"Y\"\n    alphabet[\"C\"] = \"X\"\n    alphabet[\"D\"\
    ] = \"W\"\n    alphabet[\"E\"] = \"V\"\n    alphabet[\"F\"] = \"U\"\n    alphabet[\"\
    G\"] = \"T\"\n    alphabet[\"H\"] = \"S\"\n    alphabet[\"I\"] = \"R\"\n    alphabet[\"\
    J\"] = \"Q\"\n    alphabet[\"K\"] = \"P\"\n    alphabet[\"L\"] = \"O\"\n    alphabet[\"\
    M\"] = \"N\"\n    alphabet[\"N\"] = \"M\"\n    alphabet[\"O\"] = \"L\"\n    alphabet[\"\
    P\"] = \"K\"\n    alphabet[\"Q\"] = \"J\"\n    alphabet[\"R\"] = \"I\"\n    alphabet[\"\
    S\"] = \"H\"\n    alphabet[\"T\"] = \"G\"\n    alphabet[\"U\"] = \"F\"\n    alphabet[\"\
    V\"] = \"E\"\n    alphabet[\"W\"] = \"D\"\n    alphabet[\"X\"] = \"C\"\n    alphabet[\"\
    Y\"] = \"B\"\n    alphabet[\"Z\"] = \"A\"\n    \n    var encryptedString = \"\"\
    \n    for char in s {\n        encryptedString += alphabet[char]\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_znzudun.swift:38:36: error: cannot convert value of type 'Character?'\
    \ to expected argument type 'String'\n        encryptedString += alphabet[char]\n\
    \                                   ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(4)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(5)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(6)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(7)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(8)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(9)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(10)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(11)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(12)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(13)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(14)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(15)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(16)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(17)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(18)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(19)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(20)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(21)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(22)))!)\n\
    \    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(23)))!)\n\
    \    alphabet.append(Charact\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoz80504e.swift:34:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpoz80504e.swift:33:20: note: to match this opening '('\n    alphabet.append(Charact\n\
    \                   ^\n/tmp/tmpoz80504e.swift:9:33: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:9:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(0)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:10:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(1)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:11:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(2)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:33:\
    \ error: value of type 'String' has no member 'characterAtIndex'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpoz80504e.swift:12:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    alphabet.append(Character(s.characterAtIndex(s.startIndex.advancedBy(3)))!)\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n    alphabet.append(\"\")\n    alphabet.append(\"\")\n    alphabet.append(\"\
    \")\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp259lj5tb.swift:111:1: error: missing return in global function
    expected to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = \"\"\n\
    \    for letter in s {\n        let index = alphabet.index(of: letter)!\n    \
    \    let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n  \
    \      result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt6_rbzho.swift:11:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: letter)!\n    \
    \                         ^\n/tmp/tmpt6_rbzho.swift:11:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: letter)!\n                 \
    \            ^~~~~\n                             firstIndex\n/tmp/tmpt6_rbzho.swift:12:24:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index + 2\n                       ^\n"
  stdout: ''
  timestamp: 1660028457
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetRotated = \"zyxwvutsrqponmlkjihgfedcba\"\n\
    \    var alphabetRotatedLength = alphabetRotated.count\n    var encryptedString\
    \ = \"\"\n    for char in s.characters {\n        var index = alphabet.index(of:\
    \ char)!\n        index = index + 2\n        index = index % alphabetLength\n\
    \        encryptedString += alphabetRotated[index]\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2rhffqaw.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2rhffqaw.swift:14:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        var\
    \ index = alphabet.index(of: char)!\n                             ^\n/tmp/tmp2rhffqaw.swift:14:30:\
    \ note: use 'firstIndex(of:)' instead\n        var index = alphabet.index(of:\
    \ char)!\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmp2rhffqaw.swift:15:23: error: binary operator '+' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n        index = index + 2\n     \
    \           ~~~~~ ^ ~\n/tmp/tmp2rhffqaw.swift:15:23: note: overloads for '+' exist\
    \ with these partially matching parameter lists: (Int, Int)\n        index = index\
    \ + 2\n                      ^\n/tmp/tmp2rhffqaw.swift:16:23: error: binary operator\
    \ '%' cannot be applied to operands of type 'String.Index' and 'Int'\n       \
    \ index = index % alphabetLength\n                ~~~~~ ^ ~~~~~~~~~~~~~~\n/tmp/tmp2rhffqaw.swift:16:23:\
    \ note: overloads for '%' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        index = index % alphabetLength\n                      ^\n\
    /tmp/tmp2rhffqaw.swift:17:43: error: subscript 'subscript(_:)' requires that 'String.Index'\
    \ conform to 'RangeExpression'\n        encryptedString += alphabetRotated[index]\n\
    \                                          ^\nSwift.Collection:2:23: note: where\
    \ 'R' = 'String.Index'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var result = \"\"\n    for c in s.characters {\n        let index = alphabet.indexOf(c)\n\
    \        let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n\
    \        result += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8v_nct70.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8v_nct70.swift:10:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.indexOf(c)\n\
    \                    ^~~~~~~~\n/tmp/tmp8v_nct70.swift:12:23: error: cannot find\
    \ 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n            \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.characters.count\n    var alphabetRotation = alphabet.characters.map\
    \ { $0.unicodeScalars.first }\n    var alphabetRotationLength = alphabetRotation.count\n\
    \    var alphabetRotationIndex = alphabetRotationLength - 1\n    var alphabetRotationIndex2\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex3 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex4 = alphabetRotationIndex - 1\n    var alphabetRotationIndex5\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex6 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex7 = alphabetRotationIndex - 1\n    var alphabetRotationIndex8\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex9 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex10 = alphabetRotationIndex - 1\n    var alphabetRotationIndex11\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex12 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex13 = alphabetRotationIndex - 1\n    var alphabetRotationIndex14\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex15 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex16 = alphabetRotationIndex - 1\n    var alphabetRotationIndex17\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex18 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex19 = alphabetRotationIndex - 1\n    var alphabetRotationIndex20\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex21 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex22 = alphabetRotationIndex - 1\n    var alphabetRotationIndex23\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex24 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex25 = alphabetRotationIndex - 1\n    var alphabetRotationIndex26\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex27 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex28 = alphabetRotationIndex - 1\n    var alphabetRotationIndex29\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex30 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex31 = alphabetRotationIndex - 1\n    var alphabetRotationIndex32\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex33 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex34 = alphabetRotationIndex - 1\n    var alphabetRotationIndex35\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex36 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex37 = alphabetRotationIndex - 1\n    var alphabetRotationIndex38\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex39 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex40 = alphabetRotationIndex - 1\n    var alphabetRotationIndex41\
    \ = alphabetRotationIndex - 1\n    var alphabetRotationIndex42 = alphabetRotationIndex\
    \ - 1\n    var alphabetRotationIndex43 = alphabetRotationIndex - 1\n    var alphabet\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdkso6g8u.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    var alphabetLength = alphabet.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdkso6g8u.swift:10:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    var alphabetRotation = alphabet.characters.map\
    \ { $0.unicodeScalars.first }\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdkso6g8u.swift:55:9:\
    \ error: type annotation missing in pattern\n    var alphabet\n        ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [String]()\n    alphabet.append(s.characters)\n    alphabet.append(s.characters.reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed())\n    alphabet.append(s.characters.reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed())\n\
    \    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx755yfk7.swift:27:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpx755yfk7.swift:26:20: note: to match this opening '('\n    alphabet.append(s.characters.reversed().reversed().reversed().reversed().reversed().reversed().reversed().reversed().reverse\n\
    \                   ^\n/tmp/tmpx755yfk7.swift:9:23: error: 'characters' is unavailable:\
    \ Please use String directly\n    alphabet.append(s.characters)\n            \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpx755yfk7.swift:10:14: error: no exact matches in call to instance method\
    \ 'append'\n    alphabet.append(s.characters.reversed())\n             ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got '[String.Element]'\
    \ (aka 'Array<Character>'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got '[String.Element]'\
    \ (aka 'Array<Character>'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpx755yfk7.swift:10:14:\
    \ note: found candidate with type '(__owned [String.Element]) -> ()' (aka '(__owned\
    \ Array<Character>) -> ()')\n    alphabet.append(s.characters.reversed())\n  \
    \           ^\n/tmp/tmpx755yfk7.swift:11:23: error: 'characters' is unavailable:\
    \ Please use String directly\n    alphabet.append(s.characters.reversed().reversed())\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx755yfk7.swift:12:14: error: no exact matches in call to instance\
    \ method 'append'\n    alphabet.append(s.characters.reversed().reversed().reversed())\n\
    \             ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n "
  stdout: ''
  timestamp: 1660028810
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n\
    \    }\n    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n    alphabet.removeLast()\n    alphabet.removeLast()\n\
    \    alphabet.removeLast()\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m77itbc.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660028458
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ \"\"\n    for letter in alphabet {\n        newAlphabet += String(letter.characters.dropLast())\n\
    \    }\n    var newAlphabetArray = newAlphabet.characters.map { String($0) }\n\
    \    var newAlphabetArrayReversed = newAlphabetArray.reversed()\n    var newAlphabetArrayReversedString\
    \ = \"\"\n    for letter in newAlphabetArrayReversed {\n        newAlphabetArrayReversedString\
    \ += String(letter)\n    }\n    var newAlphabetArrayReversedStringArray = newAlphabetArrayReversedString.characters.map\
    \ { String($0) }\n    var newAlphabetArrayReversedStringArrayReversed = newAlphabetArrayReversedStringArray.reversed()\n\
    \    var newAlphabetArrayReversedStringArrayReversedString = \"\"\n    for letter\
    \ in newAlphabetArrayReversedStringArrayReversed {\n        newAlphabetArrayReversedStringArrayReversedString\
    \ += String(letter)\n    }\n    var newAlphabetArrayReversedStringArrayReversedStringArray\
    \ = newAlphabetArrayReversedStringArrayReversedString.characters.map { String($0)\
    \ }\n    var newAlphabetArrayReversedStringArrayReversedStringArrayReversed =\
    \ newAlphabetArrayReversedStringArrayReversedStringArray.reversed()\n    var newAlphabetArrayReversedStringArrayReversedStringArrayReversedString\
    \ = \"\"\n    for letter in newAlphabetArrayReversedStringArrayReversedStringArrayReversed\
    \ {\n        newAlphabetArrayReversedStringArrayReversedStringArrayReversedString\
    \ += String(letter)\n    }\n    var newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArray\
    \ = newAlphabetArrayReversedStringArrayReversedStringArrayReversedString.characters.map\
    \ { String($0) }\n    var newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArrayReversed\
    \ = newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArray.reversed()\n\
    \    var newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArrayReversedString\
    \ = \"\"\n    for letter in newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArrayReversed\
    \ {\n        newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArrayReversedString\
    \ += String(letter)\n    }\n    var newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArrayReversedStringArray\
    \ = newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArray\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4r4_pf_n.swift:11:38: error: value of type 'Character' has no member\
    \ 'characters'\n        newAlphabet += String(letter.characters.dropLast())\n\
    \                              ~~~~~~ ^~~~~~~~~~\n/tmp/tmp4r4_pf_n.swift:13:40:\
    \ error: 'characters' is unavailable: Please use String directly\n    var newAlphabetArray\
    \ = newAlphabet.characters.map { String($0) }\n                              \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp4r4_pf_n.swift:19:78:\
    \ error: 'characters' is unavailable: Please use String directly\n    var newAlphabetArrayReversedStringArray\
    \ = newAlphabetArrayReversedString.characters.map { String($0) }\n           \
    \                                                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4r4_pf_n.swift:25:116:\
    \ error: 'characters' is unavailable: Please use String directly\n    var newAlphabetArrayReversedStringArrayReversedStringArray\
    \ = newAlphabetArrayReversedStringArrayReversedString.characters.map { String($0)\
    \ }\n                                                                        \
    \                                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp4r4_pf_n.swift:31:154: error: 'characters'\
    \ is unavailable: Please use String directly\n    var newAlphabetArrayReversedStringArrayReversedStringArrayReversedStringArray\
    \ = newAlphabetArrayReversedStringArrayReversedStringArrayReversedString.characters.map\
    \ { String($0) }\n                                                           \
    \                                                                            \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660028459
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var newAlphabet =\
    \ \"\"\n    var newString = \"\"\n    for char in alphabet {\n        newAlphabet\
    \ += char\n    }\n    for char in s {\n        newString += newAlphabet[(alphabet.index(char)\
    \ + 2) % 26]\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsu40zj6b.swift:12:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        newAlphabet += char\n          \
    \             ^\n/tmp/tmpsu40zj6b.swift:15:44: error: cannot convert value of\
    \ type 'String.Index?' to expected argument type 'Int'\n        newString += newAlphabet[(alphabet.index(char)\
    \ + 2) % 26]\n                                           ^\n/tmp/tmpsu40zj6b.swift:15:50:\
    \ error: missing argument label 'of:' in call\n        newString += newAlphabet[(alphabet.index(char)\
    \ + 2) % 26]\n                                                 ^\n           \
    \                                      of: \n/tmp/tmpsu40zj6b.swift:15:33: error:\
    \ no exact matches in call to subscript \n        newString += newAlphabet[(alphabet.index(char)\
    \ + 2) % 26]\n                                ^\n/tmp/tmpsu40zj6b.swift:15:33:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Character')\n        newString += newAlphabet[(alphabet.index(char) +\
    \ 2) % 26]\n                                ^\n/tmp/tmpsu40zj6b.swift:15:33: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Character')\n        newString += newAlphabet[(alphabet.index(char) + 2) %\
    \ 26]\n                                ^\n"
  stdout: ''
  timestamp: 1660028460
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfunc encrypt(s: String) -> String\
    \ {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength\
    \ = alphabet.count\n    var alphabetIndex = 0\n    var encryptedString = \"\"\n\
    \    for letter in s {\n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n\
    \        alphabetIndex++\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0_sz6bf.swift:13:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpc0_sz6bf.swift:14:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660028457
