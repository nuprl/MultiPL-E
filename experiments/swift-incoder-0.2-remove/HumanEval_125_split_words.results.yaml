language: swift
name: HumanEval_125_split_words
results:
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    let splitWords = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n    if splitWords.count == 0 {\n        return Err(25)\n\
    \    }\n    let splitWordsArray = splitWords.map { $0.components(separatedBy:\
    \ \",\") }\n    if splitWordsArray.count == 0 {\n        return Err(25)\n    }\n\
    \    let splitWordsArray2 = splitWordsArray.map { $0.map { $0.lowercased() } }\n\
    \    if splitWordsArray2.count == 0 {\n        return Err(25)\n    }\n    let\
    \ splitWordsArray3 = splitWordsArray2.map { $0.filter { $0.count % 2 == 1 } }\n\
    \    if splitWordsArray3.count == 0 {\n        return Err(25)\n    }\n    let\
    \ splitWordsArray4 = splitWordsArray3.map { $0.filter { $0.count % 2 == 0 } }\n\
    \    if splitWordsArray4.count == 0 {\n        return Err(25)\n    }\n    let\
    \ splitWordsArray5 = splitWordsArray4.map { $0.map { $0.lowercased() } }\n   \
    \ if splitWordsArray5.count == 0 {\n        return Err(25)\n    }\n    let splitWordsArray6\
    \ = splitWordsArray5.map { $0.filter { $0.count % 2 == 1 } }\n    if splitWordsArray6.count\
    \ == 0 {\n        return Err(25)\n    }\n    let splitWordsArray7 = splitWordsArray6.map\
    \ { $0.filter { $0.count % 2 == 0 } }\n    if splitWordsArray7.count == 0 {\n\
    \        return Err(25)\n    }\n    let splitWordsArray8 = splitWordsArray7.map\
    \ { $0.map { $0.lowercased() } }\n    if splitWordsArray8.count == 0 {\n     \
    \   return Err(25)\n    }\n    let splitWordsArray9 = splitWordsArray8.map { $0.filter\
    \ { $0.count % 2 == 1 } }\n    if splitWordsArray9.count == 0 {\n        return\
    \ Err(25)\n    }\n    let splitWordsArray10 = splitWordsArray9.map { $0.filter\
    \ { $0.count % 2 == 0 } }\n    if splitWordsArray10.count == 0 {\n        return\
    \ Err(25)\n    }\n    let splitWordsArray11 = splitWordsArray10.map { $0.map {\
    \ $0.lowercased() } }\n    if splitWordsArray11.count == 0 {\n        return Err(25)\n\
    \    }\n    let splitWordsArray12 = splitWordsArray11.\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5st4jfc_.swift:61:46: error: expected member name following '.'\n\
    \    let splitWordsArray12 = splitWordsArray11.\n                            \
    \                 ^\n/tmp/tmp5st4jfc_.swift:9:21: error: value of type 'String'\
    \ has no member 'components'\n    let words = txt.components(separatedBy: \" \"\
    )\n                ~~~ ^~~~~~~~~~\n/tmp/tmp5st4jfc_.swift:11:16: error: cannot\
    \ find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:13:61:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let splitWords = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                           ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5st4jfc_.swift:15:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:19:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmp5st4jfc_.swift:27:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:31:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:35:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmp5st4jfc_.swift:39:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:43:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:47:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmp5st4jfc_.swift:51:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:55:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp5st4jfc_.swift:59:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else {\n        return\
    \ Err(words.count / 2)\n    }\n    let even = words.count / 2\n    let odd = words.count\
    \ / 2 - 1\n    let evenWords = words.enumerated().filter { $0.element % 2 == 0\
    \ }.map { $0.element }\n    let oddWords = words.enumerated().filter { $0.element\
    \ % 2 != 0 }.map { $0.element }\n    let evenLetters = evenWords.map { $0.characters.count\
    \ }\n    let oddLetters = oddWords.map { $0.characters.count }\n    let letters\
    \ = evenLetters + oddLetters\n    let oddOrder = letters.filter { $0 % 2 == 1\
    \ }\n    let evenOrder = letters.filter { $0 % 2 == 0 }\n    let evenLettersCount\
    \ = evenOrder.count\n    let oddLettersCount = oddOrder.count\n    let evenLettersPercent\
    \ = evenLettersCount / even.count\n    let oddLettersPercent = oddLettersCount\
    \ / odd.count\n    let evenLettersPercentString = String(evenLettersPercent)\n\
    \    let oddLettersPercentString = String(oddLettersPercent)\n    let evenLettersPercentString\
    \ = String(evenLettersPercent)\n    let oddLettersPercentString = String(oddLettersPercent)\n\
    \    let evenLettersPercentString = String(evenLettersPercent)\n    let oddLettersPercentString\
    \ = String(oddLettersPercent)\n    let evenLettersPercentString = String(evenLettersPercent)\n\
    \    let oddLettersPercentString = String(oddLettersPercent)\n    let evenLettersPercentString\
    \ = String(evenLettersPercent)\n    let oddLettersPercentString = String(oddLettersPercent)\n\
    \    let evenLettersPercentString = String(evenLettersPercent)\n    let oddLettersPercentString\
    \ = String(oddLettersPercent)\n    let evenLettersPercentString = String(evenLettersPercent)\n\
    \    let oddLettersPercentString = String(oddLettersPercent)\n    let evenLettersPercentString\
    \ = String(evenLettersPercent)\n    let oddLettersPercentString = String(oddLettersPercent)\n\
    \    let evenLettersPercentString = String(evenLettersPercent)\n    let oddLettersPercentString\
    \ = String(oddLettersPercent)\n    let evenLettersPercentString = String(evenLettersPercent)\n\
    \    let oddLettersPercentString = String(oddLettersPercent)\n    let evenLettersPercentString\
    \ = String(evenLettersPercent)\n    let oddLettersPercentString = String(oddLetters\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcwkuelz1.swift:49:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpcwkuelz1.swift:48:41: note: to match this opening '('\n    let oddLettersPercentString\
    \ = String(oddLetters\n                                        ^\n/tmp/tmpcwkuelz1.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpcwkuelz1.swift:10:41: error:\
    \ cannot find 'Err' in scope\n    guard words.count > 0 else { return Err(0) }\n\
    \                                        ^~~\n/tmp/tmpcwkuelz1.swift:12:16: error:\
    \ cannot find 'Err' in scope\n        return Err(words.count / 2)\n          \
    \     ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n     \
    \   return Ok(words)\n    }\n    if words.count % 2 == 1 {\n        return Err(Int(words.count\
    \ / 2))\n    }\n    let even = words.filter{$0.isUpper}.count\n    let odd = words.filter{$0.isLower}.count\n\
    \    return Ok(words.filter{$0.isUpper}.dropLast(even).dropFirst(odd))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpo7d9gw67.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpo7d9gw67.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpo7d9gw67.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpo7d9gw67.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(words.count / 2))\n               ^~~\n/tmp/tmpo7d9gw67.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.filter{$0.isUpper}.dropLast(even).dropFirst(odd))\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    \n    let letters = words.map { $0.lowercased() }\n    let evenLetters\
    \ = letters.filter { $0 % 2 == 0 }\n    let oddLetters = letters.filter { $0 %\
    \ 2 != 0 }\n    \n    return Ok([evenLetters, oddLetters])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwm7r3aro.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwm7r3aro.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpwm7r3aro.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpwm7r3aro.swift:17:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([evenLetters, oddLetters])\n      \
    \     ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(0))\n    }\n    let letters = words.map { $0.lowercased()\
    \ }\n    let evenLetters = letters.filter { $0.count % 2 == 0 }\n    let oddLetters\
    \ = letters.filter { $0.count % 2 != 0 }\n    let evenLettersCount = evenLetters.count\n\
    \    let oddLettersCount = oddLetters.count\n    if evenLettersCount == 0 {\n\
    \        return Err(Int(0))\n    }\n    if oddLettersCount == 0 {\n        return\
    \ Err(Int(1))\n    }\n    if evenLettersCount > oddLettersCount {\n        return\
    \ Err(Int(evenLettersCount))\n    }\n    return Ok([evenLetters, oddLetters])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb67sa4ch.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpb67sa4ch.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpb67sa4ch.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpb67sa4ch.swift:22:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(1))\n               ^~~\n/tmp/tmpb67sa4ch.swift:25:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(evenLettersCount))\n    \
    \           ^~~\n/tmp/tmpb67sa4ch.swift:27:12: error: cannot find 'Ok' in scope\n\
    \    return Ok([evenLetters, oddLetters])\n           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map(String.init)\n    let evenLetters\
    \ = letters.filter({ $0.count % 2 == 0 })\n    let oddLetters = letters.filter({\
    \ $0.count % 2 != 0 })\n    return Ok(evenLetters + oddLetters)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpchlxdnf3.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpchlxdnf3.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpchlxdnf3.swift:19:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(evenLetters + oddLetters)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(.letters))\n    }\n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    if words.count > 1 {\n        let comma = words.first(where:\
    \ { $0 == \",\" })\n        if comma == nil {\n            return Ok(words)\n\
    \        }\n        return Err(Int(.letters))\n    }\n    return Ok(words.map\
    \ { String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmyxo2u26.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.letters))\n               ^~~\n/tmp/tmpmyxo2u26.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.letters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpmyxo2u26.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpmyxo2u26.swift:19:20: error: cannot find 'Ok' in scope\n            return\
    \ Ok(words)\n                   ^~\n/tmp/tmpmyxo2u26.swift:21:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.letters))\n               ^~~\n\
    /tmp/tmpmyxo2u26.swift:21:24: error: missing argument label 'bitPattern:' in call\n\
    \        return Err(Int(.letters))\n                       ^\n               \
    \        bitPattern: \n/tmp/tmpmyxo2u26.swift:23:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(words.map { String($0) })\n           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ > 0 {\n        return Ok(words)\n    }\n    \n    let commaWords = txt.components(separatedBy:\
    \ \",\")\n    if commaWords.count > 0 {\n        return Ok(commaWords)\n    }\n\
    \    \n    let letters = txt.lowercased().unicodeScalars.filter({ $0.isLetter\
    \ })\n    if letters.count % 2 == 1 {\n        return Ok(letters)\n    }\n   \
    \ \n    return Err(Int(.init(letters.count / 2)))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkqfpry_o.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpkqfpry_o.swift:11:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmpkqfpry_o.swift:14:26:\
    \ error: value of type 'String' has no member 'components'\n    let commaWords\
    \ = txt.components(separatedBy: \",\")\n                     ~~~ ^~~~~~~~~~\n\
    /tmp/tmpkqfpry_o.swift:16:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(commaWords)\n               ^~\n/tmp/tmpkqfpry_o.swift:19:63: error: value\
    \ of type 'Unicode.Scalar' has no member 'isLetter'\n    let letters = txt.lowercased().unicodeScalars.filter({\
    \ $0.isLetter })\n                                                           ~~\
    \ ^~~~~~~~\n/tmp/tmpkqfpry_o.swift:21:16: error: cannot find 'Ok' in scope\n \
    \       return Ok(letters)\n               ^~\n/tmp/tmpkqfpry_o.swift:24:12: error:\
    \ cannot find 'Err' in scope\n    return Err(Int(.init(letters.count / 2)))\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let wordArray = words.map\
    \ { $0.lowercased() }\n    \n    guard wordArray.count > 0 else {\n        return\
    \ Err(25)\n    }\n    \n    let wordArrayCount = wordArray.count\n    \n    guard\
    \ wordArrayCount > 0 else {\n        return Err(25)\n    }\n    \n    let letterArray\
    \ = wordArray.map { $0.unicodeScalars.filter { $0.isLetter}.map { $0.value } }\n\
    \    \n    guard letterArray.count > 0 else {\n        return Err(25)\n    }\n\
    \    \n    let letterArrayCount = letterArray.count\n    \n    guard letterArrayCount\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let letterArrayOdd = letterArray.filter\
    \ { $0.count % 2 == 1 }\n    \n    guard letterArrayOdd.count > 0 else {\n   \
    \     return Err(25)\n    }\n    \n    let letterArrayOddCount = letterArrayOdd.count\n\
    \    \n    guard letterArrayOddCount > 0 else {\n        return Err(25)\n    }\n\
    \    \n    let letterArrayEven = letterArray.filter { $0.count % 2 == 0 }\n  \
    \  \n    guard letterArrayEven.count > 0 else {\n        return Err(25)\n    }\n\
    \    \n    let letterArrayEvenCount = letterArrayEven.count\n    \n    guard letterArrayEvenCount\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let letterArrayOddAndEven\
    \ = letterArrayOdd.append(letterArrayEven)\n    \n    guard letterArrayOddAndEven.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let letterArrayOddAndEvenCount\
    \ = letterArrayOddAndEven.count\n    \n    guard letterArrayOddAndEvenCount >\
    \ 0 else {\n        return Err(25)\n    }\n    \n    let letterArrayOddAndEvenOdd\
    \ = letterArrayOddAndEven.filter { $0.count % 2 == 1 }\n    \n    guard letterArrayOddAndEvenOdd.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let letterArrayOddAndEvenOddCount\
    \ = letterArrayOddAndEvenOdd.count\n    \n    guard letterArrayOddAndEvenOddCount\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjg6f0415.swift:86:8: error: expected pattern\n    let \n      \
    \ ^\n/tmp/tmpjg6f0415.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjg6f0415.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpjg6f0415.swift:23:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:29:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:35:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpjg6f0415.swift:41:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:47:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:53:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpjg6f0415.swift:59:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:65:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:71:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpjg6f0415.swift:77:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpjg6f0415.swift:83:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let mut words: [String] = []\n    for word in words\
    \ {\n        words.append(word.trimmingCharacters(in: .whitespaces))\n    }\n\
    \    let mut chars: [Character] = []\n    for word in words {\n        for char\
    \ in word.unicodeScalars {\n            chars.append(char)\n        }\n    }\n\
    \    let mut charsSet = CharacterSet(chars)\n    charsSet.subtractCharactersInRange(NSCharacterSet.lowercaseLetters)\n\
    \    if charsSet.count % 2 != 0 {\n        return Err(25)\n    }\n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv37_cok5.swift:16:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut words: [String]\
    \ = []\n            ^\n/tmp/tmpv37_cok5.swift:16:13: note: join the identifiers\
    \ together\n    let mut words: [String] = []\n        ~~~~^~~~~\n        mutwords\n\
    /tmp/tmpv37_cok5.swift:16:13: note: join the identifiers together with camel-case\n\
    \    let mut words: [String] = []\n        ~~~~^~~~~\n        mutWords\n/tmp/tmpv37_cok5.swift:20:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut chars: [Character] = []\n            ^\n/tmp/tmpv37_cok5.swift:20:13:\
    \ note: join the identifiers together\n    let mut chars: [Character] = []\n \
    \       ~~~~^~~~~\n        mutchars\n/tmp/tmpv37_cok5.swift:20:13: note: join\
    \ the identifiers together with camel-case\n    let mut chars: [Character] = []\n\
    \        ~~~~^~~~~\n        mutChars\n/tmp/tmpv37_cok5.swift:26:13: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut charsSet = CharacterSet(chars)\n            ^\n/tmp/tmpv37_cok5.swift:26:13:\
    \ note: join the identifiers together\n    let mut charsSet = CharacterSet(chars)\n\
    \        ~~~~^~~~~~~~\n        mutcharsSet\n/tmp/tmpv37_cok5.swift:26:13: note:\
    \ join the identifiers together with camel-case\n    let mut charsSet = CharacterSet(chars)\n\
    \        ~~~~^~~~~~~~\n        mutCharsSet\n/tmp/tmpv37_cok5.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpv37_cok5.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpv37_cok5.swift:18:15: error: no exact matches in call to instance\
    \ method 'append'\n        words.append(word.trimmingCharacters(in: .whitespaces))\n\
    \              ^\n/tmp/tmpv37_cok5.swift:18:15: note: found candidate with type\
    \ '(__owned String.SubSequence) -> ()' (aka '(__owned Substring) -> ()')\n   \
    \     words.append(word.trimmingCharacters(in: .whitespaces))\n              ^\n\
    /tmp/tmpv37_cok5"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    \n    let evenWords = words.filter{ $0.count % 2 == 0 }\n    let evenWordsCount\
    \ = evenWords.count\n    let evenWordsStrings = evenWords.map{ $0.joined(separator:\
    \ \",\") }\n    \n    let oddWords = words.filter{ $0.count % 2 != 0 }\n    let\
    \ oddWordsCount = oddWords.count\n    let oddWordsStrings = oddWords.map{ $0.joined(separator:\
    \ \",\") }\n    \n    return Ok([evenWordsStrings, oddWordsStrings, evenWordsCount,\
    \ oddWordsCount])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmgy1nzb4.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpmgy1nzb4.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpmgy1nzb4.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpmgy1nzb4.swift:21:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([evenWordsStrings, oddWordsStrings,\
    \ evenWordsCount, oddWordsCount])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    if words.count % 2 == 1 {\n        return Ok(words.prefix(words.count\
    \ / 2))\n    }\n    return Ok(words.suffix(words.count / 2))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq0qryhq7.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpq0qryhq7.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpq0qryhq7.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpq0qryhq7.swift:17:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.prefix(words.count / 2))\n               ^~\n/tmp/tmpq0qryhq7.swift:19:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.suffix(words.count / 2))\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    if words.count > 25 {\n        return Err(25)\n    }\n\
    \    let letters = words.map({ $0.lowercased() })\n    let evenLetters = letters.filter({\
    \ $0 % 2 == 0 })\n    let oddLetters = letters.filter({ $0 % 2 != 0 })\n    return\
    \ Ok([evenLetters, oddLetters])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnwimx224.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpnwimx224.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpnwimx224.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpnwimx224.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpnwimx224.swift:22:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok([evenLetters, oddLetters])\n           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if words.count == 1 {\n        return Ok(words)\n    }\n    \n    let\
    \ firstWord = words[0]\n    \n    if firstWord.count == 0 {\n        return Err(0)\n\
    \    }\n    \n    let firstChar = firstWord[0]\n    \n    if firstChar.isUppercase\
    \ {\n        return Err(0)\n    }\n    \n    if firstChar.isLowercase {\n    \
    \    return Ok(words)\n    }\n    \n    let firstCharCode = firstChar.asciiValue\n\
    \    \n    if firstCharCode >= 97 && firstCharCode <= 122 {\n        return Ok(words)\n\
    \    }\n    \n    if firstCharCode >= 65 && firstCharCode <= 90 {\n        return\
    \ Ok(words)\n    }\n    \n    if firstCharCode >= 97 && firstCharCode <= 122 {\n\
    \        return Ok(words)\n    }\n    \n    return Err(0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpstj31rkz.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpstj31rkz.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpstj31rkz.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpstj31rkz.swift:23:16: error: cannot find 'Err' in scope\n        return\
    \ Err(0)\n               ^~~\n/tmp/tmpstj31rkz.swift:29:16: error: cannot find\
    \ 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpstj31rkz.swift:33:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpstj31rkz.swift:39:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpstj31rkz.swift:43:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpstj31rkz.swift:47:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpstj31rkz.swift:50:12: error: cannot find 'Err' in scope\n    return Err(0)\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map(String.init)\n    let letterCount\
    \ = letters.reduce(0) { (sum, letter) -> Int in\n        if let _ = letter.lowercased()\
    \ {\n            return sum + 1\n        }\n        return sum\n    }\n    return\
    \ Ok(letterCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9huwziv9.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmp9huwziv9.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp9huwziv9.swift:18:12:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let _ = letter.lowercased() {\n           ^       ~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9huwziv9.swift:23:12: error: cannot find 'Ok' in scope\n    return Ok(letterCount)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errDomain))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpufznle1_.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errDomain))\n               ^~~\n/tmp/tmpufznle1_.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errDomain))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpufznle1_.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpufznle1_.swift:12:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    \n    if words.count == 2 {\n        return\
    \ Ok(words.map { $0.lowercased() })\n    }\n    \n    if words.count == 3 {\n\
    \        return Ok(words.map { $0.lowercased() })\n    }\n    \n    if words.count\
    \ == 4 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    \n    if\
    \ words.count == 5 {\n        return Ok(words.map { $0.lowercased() })\n    }\n\
    \    \n    if words.count == 6 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 7 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 8 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 9 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 10 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 11 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 12 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 13 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 14 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 15 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 16 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 17 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 18 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 19 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 20 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 21 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 22 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    \n    if words.count == 23 {\n        return Ok(words.map \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1x3gayko.swift:105:1: error: expected ')' in expression list\n\
    }\n^\n/tmp/tmp1x3gayko.swift:104:18: note: to match this opening '('\n       \
    \ return Ok(words.map \n                 ^\n/tmp/tmp1x3gayko.swift:127:44: error:\
    \ expected '}' at end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n\
    \                                           ^\n/tmp/tmp1x3gayko.swift:8:56: note:\
    \ to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmp1x3gayko.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp1x3gayko.swift:12:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp1x3gayko.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1x3gayko.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmp1x3gayko.swift:24:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmp1x3gayko.swift:28:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words.map { $0.lowercased() })\n               ^~\n\
    /tmp/tmp1x3gayko.swift:32:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmp1x3gayko.swift:36:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmp1x3gayko.swift:40:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words.map { $0.lowercased() })\n               ^~\n\
    /tmp/tmp1x3gayko.swift:44:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmp1x3gayko.swift:48:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmp1x3gayko.swift:52:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words.map { $0.lowercase"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errUnknown))\n    }\n    \n    guard let comma = words.first {\n  \
    \      return Err(Int(.errUnknown))\n    }\n    \n    guard let lowercase = words.last\
    \ {\n        return Err(Int(.errUnknown))\n    }\n    \n    guard let count =\
    \ lowercase\n        .unicodeScalars\n        .filter({ $0.isLowerCase })\n  \
    \      .filter({ $0.isOdd })\n        .count else {\n        return Err(Int(.errUnknown))\n\
    \    }\n    \n    return Ok([comma, lowercase])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx9a0_gkd.swift:13:35: error: expected 'else' after 'guard' condition\n\
    \    guard let comma = words.first {\n                                  ^\n  \
    \                                else \n/tmp/tmpx9a0_gkd.swift:17:38: error: expected\
    \ 'else' after 'guard' condition\n    guard let lowercase = words.last {\n   \
    \                                  ^\n                                     else\
    \ \n/tmp/tmpx9a0_gkd.swift:10:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpx9a0_gkd.swift:10:24: error:\
    \ missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpx9a0_gkd.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpx9a0_gkd.swift:14:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n  \
    \             ^~~\n/tmp/tmpx9a0_gkd.swift:14:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n              \
    \         ^\n                       bitPattern: \n/tmp/tmpx9a0_gkd.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n  \
    \             ^~~\n/tmp/tmpx9a0_gkd.swift:18:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n              \
    \         ^\n                       bitPattern: \n/tmp/tmpx9a0_gkd.swift:23:22:\
    \ error: value of type 'Substring.UnicodeScalarView.Element' (aka 'Unicode.Scalar')\
    \ has no member 'isLowerCase'\n        .filter({ $0.isLowerCase })\n         \
    \         ~~ ^~~~~~~~~~~\n/tmp/tmpx9a0_gkd.swift:24:22: error: value of type 'Substring.UnicodeScalarView.Element'\
    \ (aka 'Unicode.Scalar') has no member 'isOdd'\n        .filter({ $0.isOdd })\n\
    \                  ~~ ^~~~~\n/tmp/tmpx9a0_gkd.swift:26:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(.errUnknown))\n        "
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.invalid))\n    }\n    \n    var result: [String] = []\n    \n    for\
    \ word in words {\n        guard let wordWithoutSpaces = word.trimmingCharacters(in:\
    \ .whitespaces) else {\n            return Err(Int(.invalid))\n        }\n   \
    \     \n        if wordWithoutSpaces.isEmpty {\n            continue\n       \
    \ }\n        \n        if let comma = wordWithoutSpaces.range(of: \",\") {\n \
    \           result.append(wordWithoutSpaces[..<comma])\n        } else {\n   \
    \         result.append(wordWithoutSpaces)\n        }\n    }\n    \n    return\
    \ Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpuhamegja.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.invalid))\n               ^~~\n/tmp/tmpuhamegja.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.invalid))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpuhamegja.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuhamegja.swift:16:44:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpuhamegja.swift:16:68:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                                                  ~^~~~~~~~~~~\n\
    /tmp/tmpuhamegja.swift:17:20: error: cannot find 'Err' in scope\n            return\
    \ Err(Int(.invalid))\n                   ^~~\n/tmp/tmpuhamegja.swift:17:28: error:\
    \ missing argument label 'bitPattern:' in call\n            return Err(Int(.invalid))\n\
    \                           ^\n                           bitPattern: \n/tmp/tmpuhamegja.swift:31:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(.zero))\n    }\n    if words.count == 1 {\n \
    \       return Ok(words)\n    }\n    if words.count % 2 == 1 {\n        return\
    \ Err(Int(.zero))\n    }\n    let even = words.filter{$0.isUpper}.count\n    let\
    \ odd = words.filter{$0.isLower}.count\n    return Ok([words[0..<even], words[even..<words.count-1]])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjm27z3hq.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjm27z3hq.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpjm27z3hq.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpjm27z3hq.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.zero))\n               ^~~\n/tmp/tmpjm27z3hq.swift:21:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok([words[0..<even], words[even..<words.count-1]])\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count < 2\
    \ {\n        return Err(Int(1))\n    }\n    \n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { (sum, word) -> Int in\n        let letters\
    \ = word.characters.count\n        return sum + letters + letters % 2\n    }\n\
    \    \n    return Ok([words[0..<wordCount-1], letterCount])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpal8gyavg.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmpal8gyavg.swift:16:28: error:\
    \ 'characters' is unavailable: Please use Substring directly\n        let letters\
    \ = word.characters.count\n                           ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmpal8gyavg.swift:20:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok([words[0..<wordCount-1], letterCount])\n      \
    \     ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let wordCounts = words.reduce(into:\
    \ [String: Int](), { result, word in\n        let count = word.characters.count\n\
    \        result[word] = (result[word] ?? 0) + count\n    })\n    \n    let letterCounts\
    \ = wordCounts.reduce(into: [String: Int](), { result, word in\n        let count\
    \ = word.characters.filter({ $0 >= 'a' && $0 <= 'z' }).count\n        result[word]\
    \ = (result[word] ?? 0) + count\n    })\n    \n    let oddLetterCounts = letterCounts.reduce(into:\
    \ [String: Int](), { result, word in\n        let count = word.characters.filter({\
    \ $0 >= 'a' && $0 <= 'z' }).filter({ $0 % 2 == 1 }).count\n        result[word]\
    \ = (result[word] ?? 0) + count\n    })\n    \n    return Ok([wordCounts, letterCounts,\
    \ oddLetterCounts])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkx63gktm.swift:20:52: error: single-quoted string literal found,\
    \ use '\"'\n        let count = word.characters.filter({ $0 >= 'a' && $0 <= 'z'\
    \ }).count\n                                                   ^~~\n         \
    \                                          \"a\"\n/tmp/tmpkx63gktm.swift:20:65:\
    \ error: single-quoted string literal found, use '\"'\n        let count = word.characters.filter({\
    \ $0 >= 'a' && $0 <= 'z' }).count\n                                          \
    \                      ^~~\n                                                 \
    \               \"z\"\n/tmp/tmpkx63gktm.swift:25:52: error: single-quoted string\
    \ literal found, use '\"'\n        let count = word.characters.filter({ $0 >=\
    \ 'a' && $0 <= 'z' }).filter({ $0 % 2 == 1 }).count\n                        \
    \                           ^~~\n                                            \
    \       \"a\"\n/tmp/tmpkx63gktm.swift:25:65: error: single-quoted string literal\
    \ found, use '\"'\n        let count = word.characters.filter({ $0 >= 'a' && $0\
    \ <= 'z' }).filter({ $0 % 2 == 1 }).count\n                                  \
    \                              ^~~\n                                         \
    \                       \"z\"\n/tmp/tmpkx63gktm.swift:9:21: error: value of type\
    \ 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpkx63gktm.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpkx63gktm.swift:29:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([wordCounts, letterCounts, oddLetterCounts])\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054482
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let letterCount\
    \ = words.reduce(0) { $0 + $1.count }\n    guard letterCount % 2 == 1 else { return\
    \ Err(0) }\n    guard wordCount > 1 else { return Err(0) }\n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9uqtpo8i.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp9uqtpo8i.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp9uqtpo8i.swift:13:46: error: cannot find\
    \ 'Err' in scope\n    guard letterCount % 2 == 1 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmp9uqtpo8i.swift:14:39: error:\
    \ cannot find 'Err' in scope\n    guard wordCount > 1 else { return Err(0) }\n\
    \                                      ^~~\n/tmp/tmp9uqtpo8i.swift:15:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054471
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(0)\n    }\n    if words.count == 1 {\n        return Ok(words)\n\
    \    }\n    if words.count > 1 {\n        let firstWord = words[0]\n        let\
    \ lastWord = words[words.count - 1]\n        let firstLetter = firstWord.characters.first\n\
    \        let lastLetter = lastWord.characters.last\n        let firstLetterUpper\
    \ = firstLetter >= 'A' && firstLetter <= 'Z'\n        let lastLetterUpper = lastLetter\
    \ >= 'A' && lastLetter <= 'Z'\n        if firstLetterUpper && lastLetterUpper\
    \ {\n            return Ok(words)\n        }\n        if firstLetterUpper && !lastLetterUpper\
    \ {\n            return Ok(words.dropFirst())\n        }\n        if !firstLetterUpper\
    \ && lastLetterUpper {\n            return Ok(words.dropLast())\n        }\n \
    \   }\n    return Err(0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3sduyktl.swift:21:47: error: single-quoted string literal found,\
    \ use '\"'\n        let firstLetterUpper = firstLetter >= 'A' && firstLetter <=\
    \ 'Z'\n                                              ^~~\n                   \
    \                           \"A\"\n/tmp/tmp3sduyktl.swift:21:69: error: single-quoted\
    \ string literal found, use '\"'\n        let firstLetterUpper = firstLetter >=\
    \ 'A' && firstLetter <= 'Z'\n                                                \
    \                    ^~~\n                                                   \
    \                 \"Z\"\n/tmp/tmp3sduyktl.swift:22:45: error: single-quoted string\
    \ literal found, use '\"'\n        let lastLetterUpper = lastLetter >= 'A' &&\
    \ lastLetter <= 'Z'\n                                            ^~~\n       \
    \                                     \"A\"\n/tmp/tmp3sduyktl.swift:22:66: error:\
    \ single-quoted string literal found, use '\"'\n        let lastLetterUpper =\
    \ lastLetter >= 'A' && lastLetter <= 'Z'\n                                   \
    \                              ^~~\n                                         \
    \                        \"Z\"\n/tmp/tmp3sduyktl.swift:11:16: error: cannot find\
    \ 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmp3sduyktl.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp3sduyktl.swift:19:37: error: 'characters' is unavailable: Please use Substring\
    \ directly\n        let firstLetter = firstWord.characters.first\n           \
    \                         ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmp3sduyktl.swift:20:35: error: 'characters' is unavailable:\
    \ Please use Substring directly\n        let lastLetter = lastWord.characters.last\n\
    \                                  ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmp3sduyktl.swift:21:32: error: value of optional type\
    \ 'Character?' must be unwrapped to a va"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int(.zero))\n    }\n    \n    let wordCount =\
    \ words.count\n    \n    let wordList: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n    \n    guard wordList.count > 0 else {\n    \
    \    return Err(Int(.zero))\n    }\n    \n    let wordListCount = wordList.count\n\
    \    \n    let alphabet: [Character] = Array(Array(UnicodeScalar.lowercaseLetters))\n\
    \    \n    guard wordListCount == wordCount else {\n        return Err(Int(.zero))\n\
    \    }\n    \n    let alphabetCount = alphabet.count\n    \n    guard alphabetCount\
    \ == 26 else {\n        return Err(Int(.zero))\n    }\n    \n    let evenLetterCount\
    \ = (wordListCount % 2 == 0) ? wordListCount / 2 : wordListCount / 2 + 1\n   \
    \ \n    let oddLetterCount = wordListCount / 2\n    \n    let evenLetterList:\
    \ [String] = wordList.prefix(evenLetterCount)\n    \n    let oddLetterList: [String]\
    \ = wordList.suffix(oddLetterCount)\n    \n    let evenLetterListCount = evenLetterList.count\n\
    \    \n    let oddLetterListCount = oddLetterList.count\n    \n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n    \n    let oddLetterListCountUpper\
    \ = oddLetterListCount.map { $0.uppercased() }\n    \n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n    \n    let oddLetterListCountUpper\
    \ = oddLetterListCount.map { $0.uppercased() }\n    \n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n    \n    let oddLetterListCountUpper\
    \ = oddLetterListCount.map { $0.uppercased() }\n    \n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n    \n    let oddLetterListCountUpper\
    \ = oddLetterListCount.map { $0.uppercased() }\n    \n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n    \n    let oddLetterListCountUpper\
    \ = oddLetterListCount.map { $0.uppercased() }\n    \n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n    \n    let oddLetter\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjft7l38s.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjft7l38s.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpjft7l38s.swift:16:69:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let wordList: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                                   ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjft7l38s.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.zero))\n               ^~~\n/tmp/tmpjft7l38s.swift:24:59: error: type\
    \ 'UnicodeScalar' (aka 'Unicode.Scalar') has no member 'lowercaseLetters'\n  \
    \  let alphabet: [Character] = Array(Array(UnicodeScalar.lowercaseLetters))\n\
    \                                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpjft7l38s.swift:27:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.zero))\n               ^~~\n/tmp/tmpjft7l38s.swift:33:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpjft7l38s.swift:40:45:\
    \ error: cannot convert value of type 'ArraySlice<String>' to specified type '[String]'\n\
    \    let evenLetterList: [String] = wordList.prefix(evenLetterCount)\n       \
    \                            ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjft7l38s.swift:48:56:\
    \ error: value of type 'Int' has no member 'map'\n    let evenLetterListCountUpper\
    \ = evenLetterListCount.map { $0.uppercased() }\n                            \
    \       ~~~~~~~~~~~~~~~~~~~ ^~~\n/tmp/tmpjft7l38s.swift:50:54: error: value of\
    \ type 'Int' has no member 'map'\n    let oddLetterListCountUpper = oddLetterListCount.map\
    \ { $0.uppercased() }\n                                  ~~~~~~~~~~~~~~~~~~ ^~~\n\
    /tmp/tmpjft7l38s.swift:52:56: error: value of type 'Int' has no member 'map'\n\
    \    let evenLetterListCountUpper = evenLetterListCount.map { $0.uppercased()\
    \ }\n                           "
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.lowercased() } }\n    guard splitWords.count == words.count\
    \ else { return Err(0) }\n    let evenOrder = splitWords.map { $0.count }\n  \
    \  let oddOrder = splitWords.map { $0.count / 2 }\n    return Ok([evenOrder, oddOrder])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw7d9wsmf.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpw7d9wsmf.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpw7d9wsmf.swift:12:57: error: cannot find\
    \ 'Err' in scope\n    guard splitWords.count == words.count else { return Err(0)\
    \ }\n                                                        ^~~\n/tmp/tmpw7d9wsmf.swift:15:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([evenOrder, oddOrder])\n   \
    \        ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    guard !words.isEmpty\
    \ else { return Err(0) }\n    guard !words.contains(\",\") else { return Err(1)\
    \ }\n    guard !words.contains(\".\") else { return Err(2) }\n    guard !words.contains(\"\
    ?\") else { return Err(3) }\n    guard !words.contains(\"!\") else { return Err(4)\
    \ }\n    guard !words.contains(\":\") else { return Err(5) }\n    guard !words.contains(\"\
    ;\") else { return Err(6) }\n    guard !words.contains(\":\") else { return Err(7)\
    \ }\n    guard !words.contains(\";\") else { return Err(8) }\n    guard !words.contains(\"\
    :\") else { return Err(9) }\n    guard !words.contains(\";\") else { return Err(10)\
    \ }\n    guard !words.contains(\":\") else { return Err(11) }\n    guard !words.contains(\"\
    ;\") else { return Err(12) }\n    guard !words.contains(\":\") else { return Err(13)\
    \ }\n    guard !words.contains(\";\") else { return Err(14) }\n    guard !words.contains(\"\
    :\") else { return Err(15) }\n    guard !words.contains(\";\") else { return Err(16)\
    \ }\n    guard !words.contains(\":\") else { return Err(17) }\n    guard !words.contains(\"\
    ;\") else { return Err(18) }\n    guard !words.contains(\":\") else { return Err(19)\
    \ }\n    guard !words.contains(\";\") else { return Err(20) }\n    guard !words.contains(\"\
    :\") else { return Err(21) }\n    guard !words.contains(\";\") else { return Err(22)\
    \ }\n    guard !words.contains(\":\") else { return Err(23) }\n    guard !words.contains(\"\
    ;\") else { return Err(24) }\n    guard !words.contains(\":\") else { return Err(25)\
    \ }\n    guard !words.contains(\";\") else { return Err(26) }\n    guard !words.contains(\"\
    :\") else { return Err(27) }\n    guard !words.contains(\";\") else { return Err(28)\
    \ }\n    guard !words.contains(\":\") else { return Err(29) }\n    guard !words.contains(\"\
    ;\") else { return Err(30) }\n    guard !words.contains(\":\") else { return Err(31)\
    \ }\n    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm0vol24a.swift:42:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n/tmp/tmpm0vol24a.swift:10:40:\
    \ error: cannot find 'Err' in scope\n    guard !words.isEmpty else { return Err(0)\
    \ }\n                                       ^~~\n/tmp/tmpm0vol24a.swift:11:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\",\") else { return\
    \ Err(1) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:12:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(2) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:13:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"?\") else { return\
    \ Err(3) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:14:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") else { return\
    \ Err(4) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:15:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(5) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:16:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(6) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:17:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(7) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:18:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(8) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:19:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(9) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:20:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(10) }\n                                             ^~~\n/tmp/tmpm0vol24a.swift:21:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { re"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(.lowercaseLetters))\n    }\n    if words.count ==\
    \ 1 {\n        return Ok(words)\n    }\n    let letters = words.map({ String($0).lowercased()\
    \ })\n    let odd = letters.filter({ $0.count % 2 == 1 })\n    return Ok(odd)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq9gj4qg2.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.lowercaseLetters))\n               ^~~\n/tmp/tmpq9gj4qg2.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lowercaseLetters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpq9gj4qg2.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpq9gj4qg2.swift:18:12: error: cannot find 'Ok' in scope\n    return Ok(odd)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordArray\
    \ = words.map { $0.lowercased() }\n    \n    guard wordArray.count > 0 else {\
    \ return Err(0) }\n    \n    let wordArrayCount = wordArray.count\n    \n    guard\
    \ wordArrayCount % 2 == 1 else {\n        return Err(wordArrayCount / 2)\n   \
    \ }\n    \n    return Ok(wordArray.filter { $0.count % 2 == 1 })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps3y5oiao.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmps3y5oiao.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmps3y5oiao.swift:14:45: error: cannot find\
    \ 'Err' in scope\n    guard wordArray.count > 0 else { return Err(0) }\n     \
    \                                       ^~~\n/tmp/tmps3y5oiao.swift:19:16: error:\
    \ cannot find 'Err' in scope\n        return Err(wordArrayCount / 2)\n       \
    \        ^~~\n/tmp/tmps3y5oiao.swift:22:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(wordArray.filter { $0.count % 2 == 1 })\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(0)\n    }\n    \n    var result = [String]()\n    \n \
    \   for word in words {\n        let splits = word.split(separator: \",\")\n \
    \       if splits.count == 0 {\n            result.append(word)\n        } else\
    \ {\n            for split in splits {\n                result.append(split)\n\
    \            }\n        }\n    }\n    \n    if result.count == 0 {\n        return\
    \ Err(0)\n    }\n    \n    var result2 = [String]()\n    \n    for word in result\
    \ {\n        let splits = word.split(separator: \" \")\n        if splits.count\
    \ == 0 {\n            result2.append(word)\n        } else {\n            for\
    \ split in splits {\n                result2.append(split)\n            }\n  \
    \      }\n    }\n    \n    if result2.count == 0 {\n        return Err(0)\n  \
    \  }\n    \n    var result3 = [String]()\n    \n    for word in result2 {\n  \
    \      let splits = word.split(separator: \"\")\n        if splits.count == 0\
    \ {\n            result3.append(word)\n        } else {\n            for split\
    \ in splits {\n                result3.append(split)\n            }\n        }\n\
    \    }\n    \n    if result3.count == 0 {\n        return Err(0)\n    }\n    \n\
    \    var result4 = [String]()\n    \n    for word in result3 {\n        let splits\
    \ = word.split(separator: \"\")\n        if splits.count == 0 {\n            result4.append(word)\n\
    \        } else {\n            for split in splits {\n                result4.append(split)\n\
    \            }\n        }\n    }\n    \n    if result4.count == 0 {\n        return\
    \ Err(0)\n    }\n    \n    var result5 = [String]()\n    \n    for word in result4\
    \ {\n        let splits = word.split(separator: \"\")\n        if splits.count\
    \ == 0 {\n            result5.append(word)\n        } else {\n            for\
    \ split in splits {\n                result5.append(split)\n            }\n  \
    \      }\n    }\n    \n    if result5.count == 0 {\n        return Err(0)\n  \
    \  }\n    \n    var result6 = [String]()\n    \n    for word in result5 {\n  \
    \      let splits = word.split(separator: \"\")\n        if splits.count == 0\
    \ {\n            result6.append(word)\n        } else {\n            for split\
    \ in splits {\n                result6.append(split)\n            }\n        }\n\
    \    }\n    \n    if result6.count == 0 {\n        return Err(0)\n    }\n    \n\
    \    var result7 = [String]()\n    \n    for word in result6 {\n        let splits\
    \ = word.split(separator: \"\")\n        if splits.count == 0 {\n            result7.append(word)\n\
    \        } else {\n            for split in splits {\n                result7.append(split)\n\
    \            }\n        }\n    }\n    \n    if result7.count == 0 {\n        return\
    \ Err(0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv6jsp3d5.swift:153:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpv6jsp3d5.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpv6jsp3d5.swift:11:16: error: cannot\
    \ find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpv6jsp3d5.swift:19:20:\
    \ error: no exact matches in call to instance method 'append'\n            result.append(word)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n   \
    \ @inlinable public mutating func append(_ newElement: __owned Element)\n    \
    \                                ^\nSwift.RangeReplaceableCollection:4:37: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpv6jsp3d5.swift:19:20:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n            result.append(word)\n                   ^\n\
    /tmp/tmpv6jsp3d5.swift:22:24: error: no exact matches in call to instance method\
    \ 'append'\n                result.append(split)\n                       ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Substring.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Substring.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpv6jsp3d5.swift:22:24:\
    \ note: found candidate with type '(__owned Substring.SubSequence) -> ()' (aka "
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errDomain))\n    }\n    \n    var result = [String]()\n    \n    for\
    \ word in words {\n        if let word = word.trimmingCharacters(in: .whitespaces)\
    \ {\n            result.append(word)\n        }\n    }\n    \n    if result.count\
    \ == 0 {\n        return Err(Int(.errDomain))\n    }\n    \n    if result.count\
    \ == 1 {\n        return result\n    }\n    \n    if result.count % 2 == 1 {\n\
    \        return Err(Int(.errDomain))\n    }\n    \n    let alphabet = Array(\"\
    abcdefghijklmnopqrstuvwxyz\".characters)\n    \n    var result2 = [String]()\n\
    \    \n    for i in 0..<result.count {\n        let word = result[i]\n       \
    \ let letter = alphabet[Int(result[i])]\n        \n        if letter != alphabet[Int(result[i])]\
    \ {\n            result2.append(word)\n        }\n    }\n    \n    if result2.count\
    \ == 0 {\n        return Err(Int(.errDomain))\n    }\n    \n    if result2.count\
    \ % 2 == 1 {\n        return Err(Int(.errDomain))\n    }\n    \n    return Ok(result2)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpi_fbi1da.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errDomain))\n               ^~~\n/tmp/tmpi_fbi1da.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errDomain))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpi_fbi1da.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpi_fbi1da.swift:16:28:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        if let word = word.trimmingCharacters(in: .whitespaces) {\n         \
    \             ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpi_fbi1da.swift:16:52: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n        if let word\
    \ = word.trimmingCharacters(in: .whitespaces) {\n                            \
    \                      ~^~~~~~~~~~~\n/tmp/tmpi_fbi1da.swift:22:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.errDomain))\n               ^~~\n\
    /tmp/tmpi_fbi1da.swift:22:24: error: missing argument label 'bitPattern:' in call\n\
    \        return Err(Int(.errDomain))\n                       ^\n             \
    \          bitPattern: \n/tmp/tmpi_fbi1da.swift:26:16: error: cannot convert return\
    \ expression of type '[String]' to return type 'Result<[String], Int>'\n     \
    \   return result\n               ^~~~~~\n/tmp/tmpi_fbi1da.swift:30:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errDomain))\n          \
    \     ^~~\n/tmp/tmpi_fbi1da.swift:30:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errDomain))\n                       ^\n   \
    \                    bitPattern: \n/tmp/tmpi_fbi1da.swift:33:55: error: 'characters'\
    \ is unavailable: Please use String directly\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    .characters)\n                                                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters'"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    let words = words.map { $0.lowercased()\
    \ }\n    let wordCount = words.count\n    let evenWordCount = wordCount % 2 ==\
    \ 0\n    if evenWordCount {\n        return Ok(words)\n    }\n    let oddWordCount\
    \ = wordCount % 2 == 1\n    if oddWordCount {\n        return Ok(words.suffix(1))\n\
    \    }\n    return Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpc9c0a2nz.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpc9c0a2nz.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpc9c0a2nz.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpc9c0a2nz.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.suffix(1))\n               ^~\n/tmp/tmpc9c0a2nz.swift:23:12: error:\
    \ cannot find 'Err' in scope\n    return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let letters = words.map { $0.lowercased() }\n    if\
    \ letters.count % 2 == 1 {\n        return Ok(letters)\n    }\n    return Err(letters.count\
    \ / 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2a2d_utk.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmp2a2d_utk.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmp2a2d_utk.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(letters)\n             \
    \  ^~\n/tmp/tmp2a2d_utk.swift:20:12: error: cannot find 'Err' in scope\n    return\
    \ Err(letters.count / 2)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(.zero))\n    }\n    let wordCount = words.count\n\
    \    let wordCountWithCommas = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder\
    \ = wordCountWithCommas + words.count - 1\n    let wordCountWithCommasWithOddOrderAndLowercaseLetters\
    \ = wordCountWithCommasWithOddOrder + words.count - 1\n    if wordCountWithCommasWithOddOrderAndLowercaseLetters\
    \ % 2 == 1 {\n        return Err(Int(.zero))\n    }\n    return Ok(words.map {\
    \ $0.trimmingCharacters(in: .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp97cq388c.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp97cq388c.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmp97cq388c.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmp97cq388c.swift:20:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n      \
    \     ^~\n/tmp/tmp97cq388c.swift:20:54: error: cannot infer contextual base in\
    \ reference to member 'whitespaces'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words.first!)\n    }\n    let letters = words.map { $0.lowercased() }\n \
    \   if letters.count % 2 == 1 {\n        return Ok(letters.first!)\n    }\n  \
    \  return Err(letters.first!)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprd2tbbpv.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmprd2tbbpv.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words.first!)\n               ^~\n/tmp/tmprd2tbbpv.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(letters.first!)\n      \
    \         ^~\n/tmp/tmprd2tbbpv.swift:20:12: error: cannot find 'Err' in scope\n\
    \    return Err(letters.first!)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let letters = words.map(String.init)\n    let letterCount\
    \ = letters.reduce(0) { (result, letter) -> Int in\n        let index = letter.index(of:\
    \ letter)\n        if index == nil {\n            return result + 1\n        }\
    \ else {\n            return result + 1\n        }\n    }\n    if letterCount\
    \ % 2 == 1 {\n        return Ok(letters.map(String.init))\n    } else {\n    \
    \    return Err(letterCount)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpix8sgvo1.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpix8sgvo1.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpix8sgvo1.swift:18:38:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = letter.index(of: letter)\n          \
    \                           ^\n/tmp/tmpix8sgvo1.swift:26:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(letters.map(String.init))\n               ^~\n\
    /tmp/tmpix8sgvo1.swift:28:16: error: cannot find 'Err' in scope\n        return\
    \ Err(letterCount)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    )\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    }\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ;\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ;\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    =\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ;\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    )\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    }\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ;\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    =\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ;\") {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdavinmin.swift:109:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpdavinmin.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpdavinmin.swift:9:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpdavinmin.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpdavinmin.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpdavinmin.swift:18:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropFirst())\n               ^~\n/tmp/tmpdavinmin.swift:21:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n          \
    \     ^~\n/tmp/tmpdavinmin.swift:24:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.dropFirst())\n               ^~\n/tmp/tmpdavinmin.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpdavinmin.swift:30:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpdavinmin.swift:33:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpdavinmin.swift:36:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpdavinmin.swift:39:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpdavinmin.swift:42:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpdavinmin.swift:45:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpdavinmin.swift:48:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpdavinmin.swift:51:16:\
    \ e"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    let letters = words.map(String.init)\n    let letterCount\
    \ = letters.reduce(0) { (acc, letter) -> Int in\n        guard let letter = letter,\
    \ let letterCount = Int(letter) else { return acc }\n        return acc + letterCount\n\
    \    }\n    if letterCount % 2 == 1 {\n        return Ok(letters.map { $0.lowercased()\
    \ })\n    }\n    return Ok(letters.map { $0.lowercased() })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwuofmc88.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwuofmc88.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpwuofmc88.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpwuofmc88.swift:22:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(letters.map { $0.lowercased() })\n               ^~\n/tmp/tmpwuofmc88.swift:24:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(letters.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(.lowercaseLetters))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let letters = words.map({ $0.lowercased()\
    \ })\n    let oddLetters = letters.filter { $0 % 2 == 1 }\n    if oddLetters.count\
    \ == 0 {\n        return Ok(words)\n    }\n    return Err(Int(.lowercaseLetters))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz2eeya2l.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpz2eeya2l.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.lowercaseLetters))\n               ^~~\n/tmp/tmpz2eeya2l.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lowercaseLetters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpz2eeya2l.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpz2eeya2l.swift:19:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpz2eeya2l.swift:21:12: error: cannot find\
    \ 'Err' in scope\n    return Err(Int(.lowercaseLetters))\n           ^~~\n/tmp/tmpz2eeya2l.swift:21:20:\
    \ error: missing argument label 'bitPattern:' in call\n    return Err(Int(.lowercaseLetters))\n\
    \                   ^\n                   bitPattern: \n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    let firstLetter = firstWord.characters.first!\n\
    \    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'A' && firstLetter <= 'Z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= '0' && firstLetter <= '9' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'A' && firstLetter <= 'Z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= '0' && firstLetter <= '9' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'A' && firstLetter <= 'Z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= '0' && firstLetter <= '9' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'A' && firstLetter <= 'Z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= '0' && firstLetter <= '9' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'A' && firstLetter <= 'Z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= '0' && firstLetter <= '9' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'A' && firstLetter <= 'Z' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= '0' && firstLetter <= '9' {\n        return Ok(words)\n\
    \    }\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n        return Ok(words)\n\
    \    }\n    if first\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5hvgwksf.swift:18:23: error: single-quoted string literal found,\
    \ use '\"'\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n              \
    \        ^~~\n                      \"a\"\n/tmp/tmp5hvgwksf.swift:18:45: error:\
    \ single-quoted string literal found, use '\"'\n    if firstLetter >= 'a' && firstLetter\
    \ <= 'z' {\n                                            ^~~\n                \
    \                            \"z\"\n/tmp/tmp5hvgwksf.swift:21:23: error: single-quoted\
    \ string literal found, use '\"'\n    if firstLetter >= 'A' && firstLetter <=\
    \ 'Z' {\n                      ^~~\n                      \"A\"\n/tmp/tmp5hvgwksf.swift:21:45:\
    \ error: single-quoted string literal found, use '\"'\n    if firstLetter >= 'A'\
    \ && firstLetter <= 'Z' {\n                                            ^~~\n \
    \                                           \"Z\"\n/tmp/tmp5hvgwksf.swift:24:23:\
    \ error: single-quoted string literal found, use '\"'\n    if firstLetter >= '0'\
    \ && firstLetter <= '9' {\n                      ^~~\n                      \"\
    0\"\n/tmp/tmp5hvgwksf.swift:24:45: error: single-quoted string literal found,\
    \ use '\"'\n    if firstLetter >= '0' && firstLetter <= '9' {\n              \
    \                              ^~~\n                                         \
    \   \"9\"\n/tmp/tmp5hvgwksf.swift:27:23: error: single-quoted string literal found,\
    \ use '\"'\n    if firstLetter >= 'a' && firstLetter <= 'z' {\n              \
    \        ^~~\n                      \"a\"\n/tmp/tmp5hvgwksf.swift:27:45: error:\
    \ single-quoted string literal found, use '\"'\n    if firstLetter >= 'a' && firstLetter\
    \ <= 'z' {\n                                            ^~~\n                \
    \                            \"z\"\n/tmp/tmp5hvgwksf.swift:30:23: error: single-quoted\
    \ string literal found, use '\"'\n    if firstLetter >= 'A' && firstLetter <=\
    \ 'Z' {\n                      ^~~\n                      \"A\"\n/tmp/tmp5hvgwksf.swift:30:45:\
    \ error: single-quoted string literal found, use '\"'\n    if firstLetter >= 'A'\
    \ && firstLetter <= 'Z' {\n                                            ^~~\n \
    \                                           \"Z"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.letters))\n    }\n    \n    var result: [String] = []\n    \n    for\
    \ word in words {\n        guard let letters = word.split(separator: \",\") else\
    \ {\n            return Err(Int(.letters))\n        }\n        \n        for letter\
    \ in letters {\n            if let num = Int(letter) {\n                if num\
    \ % 2 == 1 {\n                    return Err(Int(.letters))\n                }\n\
    \            }\n        }\n        \n        result.append(word)\n    }\n    \n\
    \    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm5x42vxy.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.letters))\n               ^~~\n/tmp/tmpm5x42vxy.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.letters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpm5x42vxy.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm5x42vxy.swift:17:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.letters))\n \
    \                  ^~~\n/tmp/tmpm5x42vxy.swift:17:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.letters))\n       \
    \                    ^\n                           bitPattern: \n/tmp/tmpm5x42vxy.swift:16:15:\
    \ error: initializer for conditional binding must have Optional type, not '[Substring.SubSequence]'\
    \ (aka 'Array<Substring>')\n        guard let letters = word.split(separator:\
    \ \",\") else {\n              ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm5x42vxy.swift:23:28:\
    \ error: cannot find 'Err' in scope\n                    return Err(Int(.letters))\n\
    \                           ^~~\n/tmp/tmpm5x42vxy.swift:23:36: error: missing\
    \ argument label 'bitPattern:' in call\n                    return Err(Int(.letters))\n\
    \                                   ^\n                                   bitPattern:\
    \ \n/tmp/tmpm5x42vxy.swift:28:16: error: no exact matches in call to instance\
    \ method 'append'\n        result.append(word)\n               ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    )\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    }\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    )\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    }\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnmadb8h4.swift:109:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpnmadb8h4.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpnmadb8h4.swift:9:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpnmadb8h4.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpnmadb8h4.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpnmadb8h4.swift:18:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropFirst())\n               ^~\n/tmp/tmpnmadb8h4.swift:21:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n          \
    \     ^~\n/tmp/tmpnmadb8h4.swift:24:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.dropFirst())\n               ^~\n/tmp/tmpnmadb8h4.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpnmadb8h4.swift:30:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpnmadb8h4.swift:33:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpnmadb8h4.swift:36:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpnmadb8h4.swift:39:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpnmadb8h4.swift:42:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpnmadb8h4.swift:45:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpnmadb8h4.swift:48:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpnmadb8h4.swift:51:16:\
    \ e"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int(.notFound))\n    }\n    \n    var result:\
    \ [String] = []\n    for word in words {\n        let splitWord = word.components(separatedBy:\
    \ \",\")\n        guard splitWord.count > 0 else {\n            return Err(Int(.notFound))\n\
    \        }\n        \n        for word in splitWord {\n            let lowercase\
    \ = word.lowercased()\n            if let index = result.index(of: lowercase)\
    \ {\n                result[index] = result[index] + \" \" + word\n          \
    \  } else {\n                result.append(word)\n            }\n        }\n \
    \   }\n    \n    if result.count % 2 == 1 {\n        return Err(Int(.notFound))\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgt1e3al_.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpgt1e3al_.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.notFound))\n               ^~~\n/tmp/tmpgt1e3al_.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.notFound))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpgt1e3al_.swift:32:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.notFound))\n    \
    \           ^~~\n/tmp/tmpgt1e3al_.swift:32:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.notFound))\n                       ^\n    \
    \                   bitPattern: \n/tmp/tmpgt1e3al_.swift:35:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let letters = words.map(String.init)\n    let letterCount\
    \ = letters.reduce(0) { $0 + $1.count }\n    if letterCount % 2 == 1 {\n     \
    \   return Ok(letters.map { $0.lowercased() })\n    }\n    return Ok(letters.map\
    \ { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp28d64zfe.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmp28d64zfe.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmp28d64zfe.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(letters.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmp28d64zfe.swift:21:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(letters.map { $0.lowercased() })\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordList:\
    \ [String] = words.map { $0.lowercased() }\n    let wordListCount = wordList.count\n\
    \    guard wordListCount > 0 else { return Err(0) }\n    guard wordListCount %\
    \ 2 == 0 else { return Err(0) }\n    let evenWordListCount = wordListCount / 2\n\
    \    let evenWordList: [String] = wordList.prefix(evenWordListCount)\n    let\
    \ oddWordListCount = wordListCount - evenWordListCount\n    let oddWordList: [String]\
    \ = wordList.suffix(oddWordListCount)\n    return Ok(evenWordList + oddWordList)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0he9tqp_.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp0he9tqp_.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp0he9tqp_.swift:14:43: error: cannot find\
    \ 'Err' in scope\n    guard wordListCount > 0 else { return Err(0) }\n       \
    \                                   ^~~\n/tmp/tmp0he9tqp_.swift:15:48: error:\
    \ cannot find 'Err' in scope\n    guard wordListCount % 2 == 0 else { return Err(0)\
    \ }\n                                               ^~~\n/tmp/tmp0he9tqp_.swift:17:43:\
    \ error: cannot convert value of type 'ArraySlice<String>' to specified type '[String]'\n\
    \    let evenWordList: [String] = wordList.prefix(evenWordListCount)\n       \
    \                          ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0he9tqp_.swift:20:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(evenWordList + oddWordList)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    let letters = words.map({ $0.lowercased() })\n  \
    \  let evenLetters = letters.filter({ $0.count % 2 == 0 })\n    let oddLetters\
    \ = letters.filter({ $0.count % 2 != 0 })\n    return Ok([evenLetters, oddLetters])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoiognxrt.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpoiognxrt.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpoiognxrt.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpoiognxrt.swift:19:12: error: cannot find 'Ok' in scope\n   \
    \ return Ok([evenLetters, oddLetters])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    let lastWord = words[words.count\
    \ - 1]\n    if firstWord.count != lastWord.count {\n        return Err(25)\n \
    \   }\n    let firstWordChars = firstWord.characters\n    let lastWordChars =\
    \ lastWord.characters\n    if firstWordChars.count != lastWordChars.count {\n\
    \        return Err(25)\n    }\n    let firstWordCharsLowercase = firstWordChars.filter\
    \ {\n        Character.isLowercase($0)\n    }\n    let lastWordCharsLowercase\
    \ = lastWordChars.filter {\n        Character.isLowercase($0)\n    }\n    if firstWordCharsLowercase.count\
    \ != lastWordCharsLowercase.count {\n        return Err(25)\n    }\n    if firstWordCharsLowercase.count\
    \ == lastWordCharsLowercase.count {\n        return Ok(words)\n    }\n    if firstWordCharsLowercase.count\
    \ > lastWordCharsLowercase.count {\n        return Ok(firstWordCharsLowercase.prefix(lastWordCharsLowercase.count))\n\
    \    }\n    return Ok(firstWordCharsLowercase.suffix(lastWordCharsLowercase.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz4uu30u8.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpz4uu30u8.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpz4uu30u8.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpz4uu30u8.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpz4uu30u8.swift:24:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpz4uu30u8.swift:27:9:\
    \ error: instance member 'isLowercase' cannot be used on type 'Character'; did\
    \ you mean to use a value of this type instead?\n        Character.isLowercase($0)\n\
    \        ^~~~~~~~~\n/tmp/tmpz4uu30u8.swift:27:19: error: cannot call value of\
    \ non-function type 'Bool'\n        Character.isLowercase($0)\n              \
    \    ^\n/tmp/tmpz4uu30u8.swift:30:9: error: instance member 'isLowercase' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \        Character.isLowercase($0)\n        ^~~~~~~~~\n/tmp/tmpz4uu30u8.swift:30:19:\
    \ error: cannot call value of non-function type 'Bool'\n        Character.isLowercase($0)\n\
    \                  ^\n/tmp/tmpz4uu30u8.swift:33:16: error: cannot find 'Err' in\
    \ scope\n        return Err(25)\n               ^~~\n/tmp/tmpz4uu30u8.swift:36:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpz4uu30u8.swift:39:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(firstWordCharsLowercase.prefix(lastWordCharsLowercase.count))\n         \
    \      ^~\n/tmp/tmpz4uu30u8.swift:41:12: error: cannot find 'Ok' in scope\n  \
    \  return Ok(firstWordCharsLowercase.suffix(lastWordCharsLowercase.count))\n \
    \          ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    \n    if words.count % 2 == 1 {\n        return\
    \ Ok(words.map { $0.lowercased() })\n    }\n    \n    return Ok(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpemobwc0m.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpemobwc0m.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpemobwc0m.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpemobwc0m.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpemobwc0m.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errUnknown))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl0myi10r.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpl0myi10r.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpl0myi10r.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl0myi10r.swift:12:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordArray = words.map { $0.lowercased() }\n    let\
    \ evenWords = wordArray.filter { (word: String) -> Bool in\n        return word.count\
    \ % 2 == 0\n    }\n    let oddWords = wordArray.filter { (word: String) -> Bool\
    \ in\n        return word.count % 2 != 0\n    }\n    return Ok([evenWords, oddWords])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpukypphme.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpukypphme.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpukypphme.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpukypphme.swift:23:12: error: cannot find 'Ok' in scope\n    return Ok([evenWords,\
    \ oddWords])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.init(rawValue: 1))) // no spaces found\n    }\n    \n    var words:\
    \ [String] = []\n    \n    for word in words {\n        if let wordWithoutSpaces\
    \ = word.trimmingCharacters(in: .whitespaces) {\n            words.append(wordWithoutSpaces)\n\
    \        } else {\n            words.append(word)\n        }\n    }\n    \n  \
    \  return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpi0zhyfy9.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(rawValue: 1))) // no spaces found\n               ^~~\n\
    /tmp/tmpi0zhyfy9.swift:10:25: error: reference to member 'init' cannot be resolved\
    \ without a contextual type\n        return Err(Int(.init(rawValue: 1))) // no\
    \ spaces found\n                        ^\n/tmp/tmpi0zhyfy9.swift:9:11: error:\
    \ initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpi0zhyfy9.swift:13:9:\
    \ error: invalid redeclaration of 'words'\n    var words: [String] = []\n    \
    \    ^\n/tmp/tmpi0zhyfy9.swift:9:15: note: 'words' previously declared here\n\
    \    guard let words = txt.split(separator: \" \") else {\n              ^\n/tmp/tmpi0zhyfy9.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n/tmp/tmpi0zhyfy9.swift:16:65:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       if let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces) {\n\
    \                                                               ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    \n    if words.count % 2 == 1 {\n        return\
    \ Ok(words.prefix(words.count / 2))\n    }\n    \n    return Ok(words.suffix(words.count\
    \ / 2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3r3uqvh6.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp3r3uqvh6.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp3r3uqvh6.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp3r3uqvh6.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.prefix(words.count / 2))\n               ^~\n/tmp/tmp3r3uqvh6.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.suffix(words.count / 2))\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let comma = words.last!.components(separatedBy: \",\"\
    )\n    if comma.count == 0 {\n        return Ok(words)\n    }\n    return Ok(words\
    \ + comma)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz6j1p91q.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpz6j1p91q.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpz6j1p91q.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpz6j1p91q.swift:18:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpz6j1p91q.swift:20:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words + comma)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int((txt.characters.count - 1) / 2))\n    }\n    \n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp74vcc9em.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp74vcc9em.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int((txt.characters.count - 1)\
    \ / 2))\n               ^~~\n/tmp/tmp74vcc9em.swift:13:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.errUnknown))\n    }\n    \n    return Ok(words)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_o8_bik5.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp_o8_bik5.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n         \
    \      ^~~\n/tmp/tmp_o8_bik5.swift:10:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errUnknown))\n                       ^\n  \
    \                     bitPattern: \n/tmp/tmp_o8_bik5.swift:13:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(rawValue: 1))\n    }\n    \n    var result = [String]()\n    \n    for\
    \ word in words {\n        if let word = word.lowercased() {\n            result.append(word)\n\
    \        }\n    }\n    \n    if result.count == 0 {\n        return Err(Int(rawValue:\
    \ 2))\n    }\n    \n    if result.count == 1 {\n        return Ok(result[0])\n\
    \    }\n    \n    if result.count % 2 == 1 {\n        return Ok(result[result.count\
    \ / 2])\n    }\n    \n    return Ok(result[result.count / 2 - 1])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpj7xw4hby.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmpj7xw4hby.swift:10:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpj7xw4hby.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpj7xw4hby.swift:16:12:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let word = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpj7xw4hby.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(rawValue: 2))\n               ^~~\n/tmp/tmpj7xw4hby.swift:22:23: error:\
    \ extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 2))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpj7xw4hby.swift:26:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(result[0])\n           \
    \    ^~\n/tmp/tmpj7xw4hby.swift:30:16: error: cannot find 'Ok' in scope\n    \
    \    return Ok(result[result.count / 2])\n               ^~\n/tmp/tmpj7xw4hby.swift:33:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result[result.count / 2 - 1])\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else { return Err(0) }\n    let words = words.map { $0.lowercased() }\n    guard\
    \ !words.isEmpty else { return Err(0) }\n    let wordCount = words.count\n   \
    \ guard wordCount % 2 == 1 else { return Err(0) }\n    return Ok(words)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5054fe3u.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp5054fe3u.swift:10:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmp5054fe3u.swift:12:40: error: cannot find\
    \ 'Err' in scope\n    guard !words.isEmpty else { return Err(0) }\n          \
    \                             ^~~\n/tmp/tmp5054fe3u.swift:14:44: error: cannot\
    \ find 'Err' in scope\n    guard wordCount % 2 == 1 else { return Err(0) }\n \
    \                                          ^~~\n/tmp/tmp5054fe3u.swift:15:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    var result = [String]()\n\
    \    \n    for word in words {\n        let splitted = word.components(separatedBy:\
    \ \",\")\n        guard splitted.count > 0 else {\n            return Err(25)\n\
    \        }\n        \n        for split in splitted {\n            let lowercase\
    \ = split.lowercased()\n            if let index = result.index(where: { $0 ==\
    \ lowercase }) {\n                result[index] = split\n            } else {\n\
    \                result.append(split)\n            }\n        }\n    }\n    \n\
    \    guard result.count > 0 else {\n        return Err(25)\n    }\n    \n    return\
    \ Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphhf91x6y.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmphhf91x6y.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmphhf91x6y.swift:33:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmphhf91x6y.swift:36:12: error: cannot find 'Ok' in scope\n    return Ok(result)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordList\
    \ = [String]()\n    \n    for word in words {\n        guard let wordCount = word.characters.count\
    \ else { return Err(0) }\n        \n        if wordCount == 1 {\n            wordList.append(word)\n\
    \        } else {\n            let wordArray = word.characters.split(separator:\
    \ \",\")\n            \n            guard wordArray.count > 0 else { return Err(0)\
    \ }\n            \n            let wordArrayCount = wordArray.count\n        \
    \    \n            if wordArrayCount % 2 == 1 {\n                wordList.append(word)\n\
    \            } else {\n                let wordArrayCount = wordArray.count\n\
    \                \n                for index in 0..<wordArrayCount {\n       \
    \             if index == wordArrayCount - 1 {\n                        wordList.append(wordArray[index])\n\
    \                    } else {\n                        wordList.append(wordArray[index])\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return Ok(wordList)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa69zq5zv.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpa69zq5zv.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpa69zq5zv.swift:42:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(wordList)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let wordArray = words.map { String($0) }\n    let letters\
    \ = wordArray.map { String($0).lowercased() }\n    let oddLetters = letters.filter\
    \ { $0.count % 2 == 1 }\n    return Ok(oddLetters)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9ycfkuso.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmp9ycfkuso.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmp9ycfkuso.swift:19:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(oddLetters)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 1 {\n        return Ok(words)\n    }\n    \n    let\
    \ firstWord = words[0]\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces)\
    \ != nil {\n        return Ok(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.decimalDigits) != nil {\n        return Ok(words)\n    }\n    \n\
    \    if firstWord.rangeOfCharacter(from: CharacterSet.letters) != nil {\n    \
    \    return Ok(words)\n    }\n    \n    if firstWord.rangeOfCharacter(from: CharacterSet.symbols)\
    \ != nil {\n        return Ok(words)\n    }\n    \n    return Ok(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv_wy1w47.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpv_wy1w47.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpv_wy1w47.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv_wy1w47.swift:22:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) != nil {\n   \
    \                                     ^~~~~~~~~~~~\n/tmp/tmpv_wy1w47.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv_wy1w47.swift:26:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.decimalDigits) != nil {\n \
    \                                       ^~~~~~~~~~~~\n/tmp/tmpv_wy1w47.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv_wy1w47.swift:30:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.letters) != nil {\n       \
    \                                 ^~~~~~~~~~~~\n/tmp/tmpv_wy1w47.swift:31:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv_wy1w47.swift:34:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.symbols) != nil {\n       \
    \                                 ^~~~~~~~~~~~\n/tmp/tmpv_wy1w47.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv_wy1w47.swift:38:12: error: cannot find 'Ok' in scope\n    return Ok(words.map\
    \ { $0.lowercased() })\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int(.zero))\n    }\n    let wordCount = words.count\n\
    \    guard wordCount > 1 else {\n        return Err(Int(.zero))\n    }\n    let\
    \ wordCount2 = wordCount.filter{$0.isWhiteSpace}.count\n    guard wordCount2 >\
    \ 0 else {\n        return Err(Int(.zero))\n    }\n    let wordCount3 = wordCount.filter{$0.isComma}.count\n\
    \    guard wordCount3 > 0 else {\n        return Err(Int(.zero))\n    }\n    let\
    \ wordCount4 = wordCount.filter{$0.isLower}.filter{$0.isOdd}.count\n    guard\
    \ wordCount4 > 0 else {\n        return Err(Int(.zero))\n    }\n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpetof3fuc.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpetof3fuc.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpetof3fuc.swift:15:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmpetof3fuc.swift:19:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(.zero))\n               ^~~\n/tmp/tmpetof3fuc.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmpetof3fuc.swift:27:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(.zero))\n               ^~~\n/tmp/tmpetof3fuc.swift:29:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    let wordCount = words.count\n   \
    \ let letterCount = words.reduce(0) { (acc, word) -> Int in\n        let letterCount\
    \ = word.characters.count\n        if letterCount % 2 == 1 {\n            return\
    \ acc + letterCount\n        } else {\n            return acc\n        }\n   \
    \ }\n    return Ok([words]) // return an array of words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpguaa5yp1.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpguaa5yp1.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpguaa5yp1.swift:17:24:\
    \ error: cannot convert return expression of type 'String' to return type 'Int'\n\
    \            return acc + letterCount\n                   ~~~~^~~~~~~~~~~~~\n\
    /tmp/tmpguaa5yp1.swift:22:12: error: cannot find 'Ok' in scope\n    return Ok([words])\
    \ // return an array of words\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count < 2\
    \ { return Err(0) }\n    let word0 = words[0]\n    let word1 = words[1]\n    if\
    \ word0.isEmpty || word1.isEmpty { return Err(0) }\n    if word0.isEmpty { return\
    \ Ok(word1.split(separator: \",\")) }\n    if word1.isEmpty { return Ok(word0.split(separator:\
    \ \",\")) }\n    let letters = word0.characters.map { String($0) }\n    let letters1\
    \ = word1.characters.map { String($0) }\n    let letters2 = letters.filter { !letters1.contains($0)\
    \ }\n    let letters3 = letters1.filter { !letters2.contains($0) }\n    if letters3.count\
    \ % 2 == 1 { return Ok(letters3.map { String($0) }) }\n    return Ok(letters3.map\
    \ { String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_41la7t4.swift:10:33: error: cannot find 'Err' in scope\n    if\
    \ words.count < 2 { return Err(0) }\n                                ^~~\n/tmp/tmp_41la7t4.swift:13:48:\
    \ error: cannot find 'Err' in scope\n    if word0.isEmpty || word1.isEmpty { return\
    \ Err(0) }\n                                               ^~~\n/tmp/tmp_41la7t4.swift:14:31:\
    \ error: cannot find 'Ok' in scope\n    if word0.isEmpty { return Ok(word1.split(separator:\
    \ \",\")) }\n                              ^~\n/tmp/tmp_41la7t4.swift:15:31: error:\
    \ cannot find 'Ok' in scope\n    if word1.isEmpty { return Ok(word0.split(separator:\
    \ \",\")) }\n                              ^~\n/tmp/tmp_41la7t4.swift:16:25: error:\
    \ 'characters' is unavailable: Please use Substring directly\n    let letters\
    \ = word0.characters.map { String($0) }\n                        ^~~~~~~~~~\n\
    Swift.Substring:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public\
    \ var characters: Substring { get set }\n               ^\n/tmp/tmp_41la7t4.swift:17:26:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    let letters1\
    \ = word1.characters.map { String($0) }\n                         ^~~~~~~~~~\n\
    Swift.Substring:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public\
    \ var characters: Substring { get set }\n               ^\n/tmp/tmp_41la7t4.swift:20:41:\
    \ error: cannot find 'Ok' in scope\n    if letters3.count % 2 == 1 { return Ok(letters3.map\
    \ { String($0) }) }\n                                        ^~\n/tmp/tmp_41la7t4.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(letters3.map { String($0) })\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.map { $0.lowercased() }\n    let even\
    \ = words.filter { $0.count % 2 == 0 }\n    let odd = words.filter { $0.count\
    \ % 2 != 0 }\n    return Ok(even.count + odd.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6kgvtq_w.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp6kgvtq_w.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp6kgvtq_w.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp6kgvtq_w.swift:19:12: error: cannot find 'Ok' in scope\n    return Ok(even.count\
    \ + odd.count)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.init(rawValue: 10)))\n    }\n    \n    var result: [String]\
    \ = []\n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.init(rawValue: 10)))\n        }\n\
    \        \n        for letter in letters {\n            guard let number = Int(letter,\
    \ radix: 16) else {\n                return Err(Int(.init(rawValue: 10)))\n  \
    \          }\n            \n            if number % 2 == 1 {\n               \
    \ result.append(letter)\n            }\n        }\n    }\n    \n    if result.count\
    \ == 0 {\n        return Err(Int(.init(rawValue: 10)))\n    }\n    \n    return\
    \ Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbkmc_wiy.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpbkmc_wiy.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n \
    \              ^~~\n/tmp/tmpbkmc_wiy.swift:10:25: error: reference to member 'init'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpbkmc_wiy.swift:31:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n        \
    \       ^~~\n/tmp/tmpbkmc_wiy.swift:31:25: error: reference to member 'init' cannot\
    \ be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpbkmc_wiy.swift:34:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.lowercased() } }\n    let evenOrder = splitWords.filter { $0.count\
    \ % 2 == 0 }\n    let oddOrder = splitWords.filter { $0.count % 2 != 0 }\n   \
    \ return evenOrder.count > oddOrder.count ? Err(evenOrder.count) : Ok(evenOrder)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb27wl25_.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpb27wl25_.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpb27wl25_.swift:14:47: error: cannot find\
    \ 'Err' in scope\n    return evenOrder.count > oddOrder.count ? Err(evenOrder.count)\
    \ : Ok(evenOrder)\n                                              ^~~\n/tmp/tmpb27wl25_.swift:14:70:\
    \ error: cannot find 'Ok' in scope\n    return evenOrder.count > oddOrder.count\
    \ ? Err(evenOrder.count) : Ok(evenOrder)\n                                   \
    \                                  ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count < 2\
    \ {\n        return Err(25)\n    }\n    if words.count > 2 {\n        return Err(25)\n\
    \    }\n    if words.count == 2 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    return\
    \ Ok(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphr_49eh2.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmphr_49eh2.swift:14:16: error: cannot\
    \ find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmphr_49eh2.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmphr_49eh2.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmphr_49eh2.swift:22:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.Failure))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkrneij0f.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.Failure))\n               ^~~\n/tmp/tmpkrneij0f.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpkrneij0f.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkrneij0f.swift:12:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map { $0.lowercased() }\n    let odd_letters\
    \ = letters.filter { $0.count % 2 == 1 }\n    if odd_letters.count == 0 {\n  \
    \      return Ok(words)\n    }\n    return Ok(odd_letters)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeiylsp3e.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpeiylsp3e.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpeiylsp3e.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpeiylsp3e.swift:21:12: error: cannot find 'Ok' in scope\n    return Ok(odd_letters)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    let wordArray = words.map { $0.lowercased()\
    \ }\n    let wordArrayCount = wordArray.count\n    let evenWordArrayCount = wordArrayCount\
    \ / 2\n    let oddWordArrayCount = wordArrayCount - evenWordArrayCount\n    let\
    \ evenWordArray = wordArray.filter { (word: String) -> Bool in\n        return\
    \ word % 2 == 0\n    }\n    let oddWordArray = wordArray.filter { (word: String)\
    \ -> Bool in\n        return word % 2 != 0\n    }\n    return Ok([evenWordArray,\
    \ oddWordArray])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1wyecdxm.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp1wyecdxm.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp1wyecdxm.swift:18:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return word % 2 == 0\n               ^\n/tmp/tmp1wyecdxm.swift:21:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return word % 2 != 0\n               ^\n/tmp/tmp1wyecdxm.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([evenWordArray, oddWordArray])\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(.zero))\n    }\n    \n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    \n    if wordArray.count\
    \ % 2 == 1 {\n        return Err(Int(.zero))\n    }\n    \n    let evenWords =\
    \ wordArray.filter { $0 % 2 == 0 }\n    let oddWords = wordArray.filter { $0 %\
    \ 2 == 1 }\n    \n    return Ok([evenWords, oddWords])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpy3flawtj.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpy3flawtj.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpy3flawtj.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmpy3flawtj.swift:24:12: error: cannot find 'Ok' in scope\n\
    \    return Ok([evenWords, oddWords])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordArray\
    \ = words.map { $0.lowercased() }\n    guard wordArray.count > 0 else { return\
    \ Err(0) }\n    let evenWordCount = wordArray.filter { $0.count % 2 == 0 }.count\n\
    \    let oddWordCount = wordArray.filter { $0.count % 2 != 0 }.count\n    guard\
    \ evenWordCount > 0 && oddWordCount > 0 else { return Err(0) }\n    guard evenWordCount\
    \ > oddWordCount else { return Err(0) }\n    guard evenWordCount > wordCount else\
    \ { return Err(0) }\n    guard oddWordCount > wordCount else { return Err(0) }\n\
    \    guard evenWordCount == wordCount else { return Err(0) }\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n    guard evenWordCount > wordCount else\
    \ { return Err(0) }\n    guard oddWordCount > wordCount else { return Err(0) }\n\
    \    guard evenWordCount == wordCount else { return Err(0) }\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n    guard evenWordCount > wordCount else\
    \ { return Err(0) }\n    guard oddWordCount > wordCount else { return Err(0) }\n\
    \    guard evenWordCount == wordCount else { return Err(0) }\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n    guard evenWordCount > wordCount else\
    \ { return Err(0) }\n    guard oddWordCount > wordCount else { return Err(0) }\n\
    \    guard evenWordCount == wordCount else { return Err(0) }\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n    guard evenWordCount > wordCount else\
    \ { return Err(0) }\n    guard oddWordCount > wordCount else { return Err(0) }\n\
    \    guard evenWordCount == wordCount else { return Err(0) }\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n    guard evenWordCount > wordCount else\
    \ { return Err(0) }\n    guard oddWordCount > wordCount else { return Err(0) }\n\
    \    guard evenWordCount == wordCount else { return Err(0) }\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp1xkfsdu.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpp1xkfsdu.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpp1xkfsdu.swift:13:45: error: cannot find\
    \ 'Err' in scope\n    guard wordArray.count > 0 else { return Err(0) }\n     \
    \                                       ^~~\n/tmp/tmpp1xkfsdu.swift:16:63: error:\
    \ cannot find 'Err' in scope\n    guard evenWordCount > 0 && oddWordCount > 0\
    \ else { return Err(0) }\n                                                   \
    \           ^~~\n/tmp/tmpp1xkfsdu.swift:17:54: error: cannot find 'Err' in scope\n\
    \    guard evenWordCount > oddWordCount else { return Err(0) }\n             \
    \                                        ^~~\n/tmp/tmpp1xkfsdu.swift:18:51: error:\
    \ cannot find 'Err' in scope\n    guard evenWordCount > wordCount else { return\
    \ Err(0) }\n                                                  ^~~\n/tmp/tmpp1xkfsdu.swift:19:50:\
    \ error: cannot find 'Err' in scope\n    guard oddWordCount > wordCount else {\
    \ return Err(0) }\n                                                 ^~~\n/tmp/tmpp1xkfsdu.swift:20:52:\
    \ error: cannot find 'Err' in scope\n    guard evenWordCount == wordCount else\
    \ { return Err(0) }\n                                                   ^~~\n\
    /tmp/tmpp1xkfsdu.swift:21:51: error: cannot find 'Err' in scope\n    guard oddWordCount\
    \ == wordCount else { return Err(0) }\n                                      \
    \            ^~~\n/tmp/tmpp1xkfsdu.swift:22:51: error: cannot find 'Err' in scope\n\
    \    guard evenWordCount > wordCount else { return Err(0) }\n                \
    \                                  ^~~\n/tmp/tmpp1xkfsdu.swift:23:50: error: cannot\
    \ find 'Err' in scope\n    guard oddWordCount > wordCount else { return Err(0)\
    \ }\n                                                 ^~~\n/tmp/tmpp1xkfsdu.swift:24:52:\
    \ error: cannot find 'Err' in scope\n    guard evenWordCount == wordCount else\
    \ { return E"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNotEmpty })\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.filter({ $0.isNot\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv0j6hrgy.swift:111:1: error: expected ')' in expression list\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpv0j6hrgy.swift:107:29:\
    \ note: to match this opening '('\n    let words = words.filter({ $0.isNot\n \
    \                           ^\n/tmp/tmpv0j6hrgy.swift:130:44: error: expected\
    \ '}' at end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n\
    \                                           ^\n/tmp/tmpv0j6hrgy.swift:8:56: note:\
    \ to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpv0j6hrgy.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpv0j6hrgy.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpv0j6hrgy.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv0j6hrgy.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpv0j6hrgy.swift:21:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpv0j6hrgy.swift:25:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpv0j6hrgy.swift:28:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpv0j6hrgy.swift:32:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpv0j6hrgy.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv0j6hrgy.swift:39:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpv0j6hrgy.swift:42:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpv0j6hrgy.swift:46:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpv0j6hrgy.swift:49:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/t"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let letterCount = words.reduce(0)\
    \ { (sum, word) -> Int in\n        let letterCount = word.characters.count\n \
    \       if letterCount % 2 == 1 {\n            return letterCount + sum\n    \
    \    } else {\n            return sum + letterCount\n        }\n    }\n    if\
    \ letterCount > 26 {\n        return Err(25)\n    }\n    return Ok(words.map {\
    \ $0.trimmingCharacters(in: .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkf75i68t.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpkf75i68t.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpkf75i68t.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpkf75i68t.swift:20:32: error: cannot convert return expression of type\
    \ 'String' to return type 'Int'\n            return letterCount + sum\n      \
    \             ~~~~~~~~~~~~^~~~~\n/tmp/tmpkf75i68t.swift:26:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpkf75i68t.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n           ^~\n/tmp/tmpkf75i68t.swift:28:54: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespaces) })\n                             \
    \                       ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map { $0.lowercased() }\n    if letters.count\
    \ == 0 {\n        return Err(25)\n    }\n    if letters.count == 1 {\n       \
    \ return Ok(words)\n    }\n    let odd = letters.filter { $0.count % 2 == 1 }\n\
    \    if odd.count == 0 {\n        return Ok(words)\n    }\n    return Err(25)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpglt63ceh.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpglt63ceh.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpglt63ceh.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpglt63ceh.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpglt63ceh.swift:21:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpglt63ceh.swift:25:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpglt63ceh.swift:27:12: error: cannot find 'Err' in scope\n    return Err(25)\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    let letters = words.map { $0.lowercased() }\n    let evenLetters = letters.filter\
    \ { $0 % 2 == 0 }\n    let oddLetters = letters.filter { $0 % 2 != 0 }\n    let\
    \ evenLettersCount = evenLetters.count\n    let oddLettersCount = oddLetters.count\n\
    \    return Ok([evenLetters, oddLetters, evenLettersCount, oddLettersCount])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprsx5txre.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmprsx5txre.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmprsx5txre.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmprsx5txre.swift:17:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([evenLetters, oddLetters, evenLettersCount,\
    \ oddLettersCount])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ { return Err(0) }\n    let comma = words.last!.split(separator: \",\")\n   \
    \ if comma.count == 0 { return Err(0) }\n    let letters = words.map { $0.lowercased().count\
    \ }\n    let odd = letters.filter { $0 % 2 == 1 }\n    if odd.count == 0 { return\
    \ Err(0) }\n    return Ok(odd)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpobi0kwji.swift:10:34: error: cannot find 'Err' in scope\n    if\
    \ words.count == 0 { return Err(0) }\n                                 ^~~\n/tmp/tmpobi0kwji.swift:12:34:\
    \ error: cannot find 'Err' in scope\n    if comma.count == 0 { return Err(0) }\n\
    \                                 ^~~\n/tmp/tmpobi0kwji.swift:15:32: error: cannot\
    \ find 'Err' in scope\n    if odd.count == 0 { return Err(0) }\n             \
    \                  ^~~\n/tmp/tmpobi0kwji.swift:16:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(odd)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words[0])\n    }\n    \n    if words.count > 25 {\n        return\
    \ Err(25)\n    }\n    \n    return Ok(words.map(String.init))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt5d2rs98.swift:12:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpt5d2rs98.swift:16:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpt5d2rs98.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpt5d2rs98.swift:23:12: error: cannot find 'Ok' in scope\n    return Ok(words.map(String.init))\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n     \
    \   return Ok(words)\n    }\n    let letters = words.map { $0.lowercased() }\n\
    \    let odd = letters.filter { $0.count % 2 == 1 }\n    let even = letters.filter\
    \ { $0.count % 2 == 0 }\n    return Ok([even, odd])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp0fqg0qf.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpp0fqg0qf.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpp0fqg0qf.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpp0fqg0qf.swift:19:12: error: cannot find 'Ok' in scope\n    return Ok([even,\
    \ odd])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let letterCount = words.map({\
    \ $0.characters.count }).reduce(0)\n    if letterCount % 2 == 1 {\n        return\
    \ Ok(words)\n    }\n    return Err(letterCount)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp28gg5fp5.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp28gg5fp5.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp28gg5fp5.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp28gg5fp5.swift:19:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp28gg5fp5.swift:21:12: error: cannot find\
    \ 'Err' in scope\n    return Err(letterCount)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count < 2\
    \ {\n        return Err(25)\n    }\n    if words.count == 2 {\n        return\
    \ Ok(words)\n    }\n    if words.count == 3 {\n        return Ok(words + [\"and\"\
    ])\n    }\n    if words.count == 4 {\n        return Ok(words + [\"and\", \"the\"\
    ])\n    }\n    if words.count == 5 {\n        return Ok(words + [\"and\", \"the\"\
    , \"and\"])\n    }\n    if words.count == 6 {\n        return Ok(words + [\"and\"\
    , \"the\", \"and\", \"the\"])\n    }\n    if words.count == 7 {\n        return\
    \ Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\"])\n    }\n    if words.count\
    \ == 8 {\n        return Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\"\
    , \"the\"])\n    }\n    if words.count == 9 {\n        return Ok(words + [\"and\"\
    , \"the\", \"and\", \"the\", \"and\", \"the\", \"and\"])\n    }\n    if words.count\
    \ == 10 {\n        return Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\"\
    , \"the\", \"and\", \"the\"])\n    }\n    if words.count == 11 {\n        return\
    \ Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"\
    the\", \"and\"])\n    }\n    if words.count == 12 {\n        return Ok(words +\
    \ [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"\
    and\", \"the\"])\n    }\n    if words.count == 13 {\n        return Ok(words +\
    \ [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"\
    and\", \"the\", \"and\"])\n    }\n    if words.count == 14 {\n        return Ok(words\
    \ + [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"\
    and\", \"the\", \"and\", \"the\"])\n    }\n    if words.count == 15 {\n      \
    \  return Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"\
    and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\"])\n    }\n\
    \    if words.count == 16 {\n        return Ok(words + [\"and\", \"the\", \"and\"\
    , \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\"\
    , \"and\", \"the\", \"and\"])\n    }\n    if words.count == 17 {\n        return\
    \ Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"\
    the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\"\
    , \"and\"])\n    }\n    if words.count == 18 {\n        return \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmph96vd03x.swift:85:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmph96vd03x.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmph96vd03x.swift:11:16: error: cannot\
    \ find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmph96vd03x.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmph96vd03x.swift:17:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words + [\"and\"])\n               ^~\n/tmp/tmph96vd03x.swift:20:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\"])\n \
    \              ^~\n/tmp/tmph96vd03x.swift:23:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words + [\"and\", \"the\", \"and\"])\n               ^~\n/tmp/tmph96vd03x.swift:26:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\"\
    , \"and\", \"the\"])\n               ^~\n/tmp/tmph96vd03x.swift:29:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\", \"and\"\
    , \"the\", \"and\"])\n               ^~\n/tmp/tmph96vd03x.swift:32:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\", \"and\"\
    , \"the\", \"and\", \"the\"])\n               ^~\n/tmp/tmph96vd03x.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\"\
    , \"and\", \"the\", \"and\", \"the\", \"and\"])\n               ^~\n/tmp/tmph96vd03x.swift:38:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\"\
    , \"and\", \"the\", \"and\", \"the\", \"and\", \"the\"])\n               ^~\n\
    /tmp/tmph96vd03x.swift:41:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words + [\"and\", \"the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"\
    the\", \"and\"])\n               ^~\n/tmp/tmph96vd03x.swift:44:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words + [\"and\", \"the\", \"and\", \"\
    the\", \"and\", \"the\", \"and\", \"the\", \"and\", \"the\"])\n              \
    \ ^~\n/tmp/tmph96vd03x.swif"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordCountWithCommas\
    \ = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder = wordCountWithCommas\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrder + words.count - 1\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_up19lhi.swift:24:90: error: expected 'else' after 'guard' condition\n\
    \    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\n\
    \                                                                            \
    \             ^\n/tmp/tmp_up19lhi.swift:9:21: error: value of type 'String' has\
    \ no member 'components'\n    let words = txt.components(separatedBy: \" \")\n\
    \                ~~~ ^~~~~~~~~~\n/tmp/tmp_up19lhi.swift:10:41: error: cannot find\
    \ 'Err' in scope\n    guard words.count > 0 else { return Err(0) }\n         \
    \                               ^~~\n/tmp/tmp_up19lhi.swift:16:94: error: cannot\
    \ find 'Err' in scope\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n                                      \
    \                                                       ^~~\n/tmp/tmp_up19lhi.swift:17:11:\
    \ error: cannot find 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ in scope\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_up19lhi.swift:17:106: error: cannot find 'Err' in scope\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n                                      \
    \                                                                   ^~~\n/tmp/tmp_up19lhi.swift:18:11:\
    \ error: cannot find 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ in scope\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_up19lhi.swift:18:118: error: cannot find 'Err' in scope\n    guard wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ == wordCount else { return Err(0) }\n                                      \
    \           "
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int(.letters))\n    }\n    \n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { $0 + $1.count }\n   \
    \ \n    guard letterCount % 2 == 1 else {\n        return Err(Int(.letters))\n\
    \    }\n    \n    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk144h2m4.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpk144h2m4.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.letters))\n               ^~~\n/tmp/tmpk144h2m4.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.letters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpk144h2m4.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.letters))\n     \
    \          ^~~\n/tmp/tmpk144h2m4.swift:18:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.letters))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmpk144h2m4.swift:21:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces)\
    \ })\n           ^~\n/tmp/tmpk144h2m4.swift:21:54: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let firstWord = words[0]\n\
    \    let firstChar = firstWord.characters.first\n    let firstCharUpper = firstChar.uppercased()\n\
    \    let firstCharLower = firstChar.lowercased()\n    let firstCharUpperCount\
    \ = firstCharUpper.count\n    let firstCharLowerCount = firstCharLower.count\n\
    \    let firstCharUpperOdd = firstCharUpperCount % 2\n    let firstCharLowerOdd\
    \ = firstCharLowerCount % 2\n    if firstCharUpperOdd != firstCharLowerOdd {\n\
    \        return Err(Int(1))\n    }\n    if firstCharUpperOdd {\n        return\
    \ Ok(words)\n    }\n    if firstCharLowerOdd {\n        return Ok(words.dropFirst())\n\
    \    }\n    return Err(Int(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp870nngtz.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmp870nngtz.swift:14:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp870nngtz.swift:18:31:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    let firstChar\
    \ = firstWord.characters.first\n                              ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmp870nngtz.swift:19:26: error: value of\
    \ optional type 'Character?' must be unwrapped to refer to member 'uppercased'\
    \ of wrapped base type 'Character'\n    let firstCharUpper = firstChar.uppercased()\n\
    \                         ^\n/tmp/tmp870nngtz.swift:19:26: note: chain the optional\
    \ using '?' to access member 'uppercased' only for non-'nil' base values\n   \
    \ let firstCharUpper = firstChar.uppercased()\n                         ^\n  \
    \                                ?\n/tmp/tmp870nngtz.swift:19:26: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let firstCharUpper\
    \ = firstChar.uppercased()\n                         ^\n                     \
    \             !\n/tmp/tmp870nngtz.swift:20:26: error: value of optional type 'Character?'\
    \ must be unwrapped to refer to member 'lowercased' of wrapped base type 'Character'\n\
    \    let firstCharLower = firstChar.lowercased()\n                         ^\n\
    /tmp/tmp870nngtz.swift:20:26: note: chain the optional using '?' to access member\
    \ 'lowercased' only for non-'nil' base values\n    let firstCharLower = firstChar.lowercased()\n\
    \                         ^\n                                  ?\n/tmp/tmp870nngtz.swift:20:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let firstCharLower = firstChar.lowercased()\n                   \
    \      ^\n                                  !\n/tmp/tmp870nngtz.swift:26:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmp870nngtz"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else {\n        return Err(Int(.errDomain))\n    }\n    \n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\").map { $0.lowercased() } }\n\
    \    \n    guard splitWords.count == words.count else {\n        return Err(Int(.errDomain))\n\
    \    }\n    \n    let evenOrder = splitWords.map { $0.count }\n    \n    guard\
    \ evenOrder.count == words.count else {\n        return Err(Int(.errDomain))\n\
    \    }\n    \n    let oddOrder = evenOrder.filter { $0 % 2 == 1 }\n    \n    guard\
    \ oddOrder.count == words.count else {\n        return Err(Int(.errDomain))\n\
    \    }\n    \n    return Ok(splitWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8hn6l3u6.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8hn6l3u6.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.errDomain))\n               ^~~\n/tmp/tmp8hn6l3u6.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errDomain))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp8hn6l3u6.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errDomain))\n   \
    \            ^~~\n/tmp/tmp8hn6l3u6.swift:17:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errDomain))\n               \
    \        ^\n                       bitPattern: \n/tmp/tmp8hn6l3u6.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errDomain))\n   \
    \            ^~~\n/tmp/tmp8hn6l3u6.swift:23:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errDomain))\n               \
    \        ^\n                       bitPattern: \n/tmp/tmp8hn6l3u6.swift:29:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errDomain))\n   \
    \            ^~~\n/tmp/tmp8hn6l3u6.swift:29:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errDomain))\n               \
    \        ^\n                       bitPattern: \n/tmp/tmp8hn6l3u6.swift:32:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(splitWords)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordArray\
    \ = words.map { $0.lowercased() }\n    \n    guard wordArray.count > 0 else {\
    \ return Err(0) }\n    \n    let wordArrayCount = wordArray.count\n    \n    guard\
    \ wordArrayCount % 2 == 1 else {\n        return Err(wordArrayCount)\n    }\n\
    \    \n    let evenWordArray = wordArray.filter { $0 % 2 == 0 }\n    \n    guard\
    \ evenWordArray.count > 0 else { return Err(0) }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n    guard evenWordArrayCount % 2 == 1 else {\n\
    \        return Err(evenWordArrayCount)\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpder99r5p.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpder99r5p.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpder99r5p.swift:14:45: error: cannot find\
    \ 'Err' in scope\n    guard wordArray.count > 0 else { return Err(0) }\n     \
    \                                       ^~~\n/tmp/tmpder99r5p.swift:19:16: error:\
    \ cannot find 'Err' in scope\n        return Err(wordArrayCount)\n           \
    \    ^~~\n/tmp/tmpder99r5p.swift:24:49: error: cannot find 'Err' in scope\n  \
    \  guard evenWordArray.count > 0 else { return Err(0) }\n                    \
    \                            ^~~\n/tmp/tmpder99r5p.swift:29:16: error: cannot\
    \ find 'Err' in scope\n        return Err(evenWordArrayCount)\n              \
    \ ^~~\n/tmp/tmpder99r5p.swift:35:16: error: cannot find 'Err' in scope\n     \
    \   return Err(evenWordArrayCount)\n               ^~~\n/tmp/tmpder99r5p.swift:41:16:\
    \ error: cannot find 'Err' in scope\n        return Err(evenWordArrayCount)\n\
    \               ^~~\n/tmp/tmpder99r5p.swift:47:16: error: cannot find 'Err' in\
    \ scope\n        return Err(evenWordArrayCount)\n               ^~~\n/tmp/tmpder99r5p.swift:53:16:\
    \ error: cannot find 'Err' in scope\n        return Err(evenWordArrayCount)\n\
    \               ^~~\n/tmp/tmpder99r5p.swift:59:16: error: cannot find 'Err' in\
    \ scope\n        return Err(evenWordArrayCount)\n               ^~~\n/tmp/tmpder99r5p.swift:65:16:\
    \ error: cannot find 'Err' in scope\n        return Err(evenWordArrayCount)\n\
    \               ^~~\n/tmp/tmpder99r5p.swift:71:16: error: cannot find 'Err' in\
    \ scope\n        return Err(evenWordArrayCount)\n               ^~~\n/tmp/tmpder99r5p.swift:77:16:\
    \ error: cannot find 'Err' in scope\n        return Err(evenWordArrayCount)\n\
    \               ^~~\n/tmp/tmpder99r5p.swift:83:16: error: cannot find 'Err' in\
    \ scope\n        return Err(evenWordArrayCount)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.invalidInput))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdkezpp8q.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.invalidInput))\n               ^~~\n/tmp/tmpdkezpp8q.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.invalidInput))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpdkezpp8q.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdkezpp8q.swift:12:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int((txt.characters.count + txt.characters.count - 1) / 2))\n    }\n   \
    \ return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpihohi26q.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int((txt.characters.count + txt.characters.count - 1) / 2))\n \
    \              ^~~\n/tmp/tmpihohi26q.swift:9:11: error: initializer for conditional\
    \ binding must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let words = txt.split(separator: \" \") else {\n          ^       \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpihohi26q.swift:12:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    let firstLetter = firstWord.characters.first\n\
    \    let firstLetterUppercase = firstLetter == firstWord.characters.first && firstLetter\
    \ >= ord(\"A\") && firstLetter <= ord(\"Z\")\n    if firstLetterUppercase {\n\
    \        return Ok(words)\n    }\n    if firstLetter >= ord(\"a\") && firstLetter\
    \ <= ord(\"z\") {\n        return Ok(words)\n    }\n    if firstLetter >= ord(\"\
    A\") && firstLetter <= ord(\"Z\") {\n        return Ok(words)\n    }\n    return\
    \ Err(Int(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmposy63lkd.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmposy63lkd.swift:14:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmposy63lkd.swift:17:33:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    let firstLetter\
    \ = firstWord.characters.first\n                                ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmposy63lkd.swift:18:92: error: cannot find\
    \ 'ord' in scope\n    let firstLetterUppercase = firstLetter == firstWord.characters.first\
    \ && firstLetter >= ord(\"A\") && firstLetter <= ord(\"Z\")\n                \
    \                                                                           ^~~\n\
    /tmp/tmposy63lkd.swift:18:119: error: cannot find 'ord' in scope\n    let firstLetterUppercase\
    \ = firstLetter == firstWord.characters.first && firstLetter >= ord(\"A\") &&\
    \ firstLetter <= ord(\"Z\")\n                                                \
    \                                                                      ^~~\n/tmp/tmposy63lkd.swift:18:77:\
    \ error: value of optional type 'Character?' must be unwrapped to a value of type\
    \ 'Character'\n    let firstLetterUppercase = firstLetter == firstWord.characters.first\
    \ && firstLetter >= ord(\"A\") && firstLetter <= ord(\"Z\")\n                \
    \                                                            ^\n/tmp/tmposy63lkd.swift:18:77:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let firstLetterUppercase = firstLetter == firstWord.characters.first\
    \ && firstLetter >= ord(\"A\") && firstLetter <= ord(\"Z\")\n                \
    \                                                            ^\n             \
    \                                                                           ??\
    \ <#default value#>\n/tmp/tmposy63lkd.swift:18:77: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n    let firstLetterUppercase\
    \ = firstLe"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errDomain))\n    }\n    \n    var result = [String]()\n    \n    for\
    \ word in words {\n        if let wordCount = word.split(separator: \",\").count\
    \ {\n            if wordCount % 2 == 1 {\n                result.append(word)\n\
    \            }\n        } else {\n            result.append(word)\n        }\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprtiamn7w.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errDomain))\n               ^~~\n/tmp/tmprtiamn7w.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errDomain))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmprtiamn7w.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprtiamn7w.swift:18:24:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \  result.append(word)\n                       ^\nSwift.Array:6:37: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.SubSequence' (aka\
    \ 'Substring'))\n    @inlinable public mutating func append(_ newElement: __owned\
    \ Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmprtiamn7w.swift:18:24:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n                result.append(word)\n                  \
    \     ^\n/tmp/tmprtiamn7w.swift:21:20: error: no exact matches in call to instance\
    \ method 'append'\n            result.append(word)\n                   ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/t"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    \n    let wordCount = words.count\n    \n \
    \   if wordCount == 2 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 3 {\n        return Ok(words)\n    }\n    \n    if wordCount == 4 {\n   \
    \     return Ok(words)\n    }\n    \n    if wordCount == 5 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 6 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 7 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 8 {\n        return Ok(words)\n    }\n    \n    if wordCount == 9 {\n   \
    \     return Ok(words)\n    }\n    \n    if wordCount == 10 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 11 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 12 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 13 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 14 {\n        return Ok(words)\n    }\n    \n    if wordCount == 15 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 16 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 17 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 18 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 19 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 20 {\n        return Ok(words)\n    }\n    \n    if wordCount == 21 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 22 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 23 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 24 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 25 {\n        return Ok(words)\n    }\n    \n    return Err(25)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplk78u03m.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmplk78u03m.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmplk78u03m.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplk78u03m.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:26:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:30:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplk78u03m.swift:34:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:38:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:42:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplk78u03m.swift:46:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:50:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:54:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplk78u03m.swift:58:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:62:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:66:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplk78u03m.swift:70:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:74:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmplk78u03m.swift:78:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplk78u03m.swift:82:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int(.zero))\n    }\n    let wordCount = words.count\n\
    \    guard wordCount > 1 else {\n        return Err(Int(.zero))\n    }\n    let\
    \ lowercaseCount = words.map({ $0.lowercased().count }).reduce(0,+)\n    guard\
    \ lowercaseCount % 2 == 1 else {\n        return Err(Int(.zero))\n    }\n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpts330628.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpts330628.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpts330628.swift:15:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmpts330628.swift:19:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(.zero))\n               ^~~\n/tmp/tmpts330628.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.trimmingCharacters(in: .whitespaces) } }\n    guard splitWords.count\
    \ > 0 else { return Err(0) }\n    let splitWordsCount = splitWords.count\n   \
    \ let alphabet = splitWords.map { $0.count }\n    let alphabetCount = alphabet.count\n\
    \    let alphabetLetters = alphabet.map { $0.count }\n    let alphabetLettersCount\
    \ = alphabetLetters.count\n    let alphabetLettersOdd = alphabetLetters.filter\
    \ { $0 % 2 == 1 }\n    let alphabetLettersEven = alphabetLetters.filter { $0 %\
    \ 2 == 0 }\n    let alphabetLettersOddCount = alphabetLettersOdd.count\n    let\
    \ alphabetLettersEvenCount = alphabetLettersEven.count\n    let alphabetLettersOddAndEven\
    \ = alphabetLettersOdd.map { $0 + $1 }\n    let alphabetLettersOddAndEvenCount\
    \ = alphabetLettersOddAndEven.count\n    let alphabetLettersOddAndEvenAndOdd =\
    \ alphabetLettersOddAndEven.map { $0 + $1 }\n    let alphabetLettersOddAndEvenAndOddCount\
    \ = alphabetLettersOddAndEvenAndOdd.count\n    let alphabetLettersOddAndEvenAndOddAndEven\
    \ = alphabetLettersOddAndEvenAndOdd.map { $0 + $1 }\n    let alphabetLettersOddAndEvenAndOddAndEvenCount\
    \ = alphabetLettersOddAndEvenAndOddAndEven.count\n    let alphabetLettersOddAndEvenAndOddAndEvenAndOdd\
    \ = alphabetLettersOddAndEvenAndOddAndEvenAndOdd.map { $0 + $1 }\n    let alphabetLettersOddAndEvenAndOddAndEvenAndOddCount\
    \ = alphabetLettersOddAndEvenAndOddAndEvenAndOdd.count\n    let alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven.map { $0 + $1 }\n    let\
    \ alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEvenCount = alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven.count\n\
    \    let alphabetLetters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpts8a_1pj.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpts8a_1pj.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpts8a_1pj.swift:11:99: error: cannot infer\
    \ contextual base in reference to member 'whitespaces'\n    let splitWords = words.map\
    \ { $0.components(separatedBy: \",\").map { $0.trimmingCharacters(in: .whitespaces)\
    \ } }\n                                                                      \
    \                           ~^~~~~~~~~~~\n/tmp/tmpts8a_1pj.swift:12:46: error:\
    \ cannot find 'Err' in scope\n    guard splitWords.count > 0 else { return Err(0)\
    \ }\n                                             ^~~\n/tmp/tmpts8a_1pj.swift:28:56:\
    \ error: use of local variable 'alphabetLettersOddAndEvenAndOddAndEvenAndOdd'\
    \ before its declaration\n    let alphabetLettersOddAndEvenAndOddAndEvenAndOdd\
    \ = alphabetLettersOddAndEvenAndOddAndEvenAndOdd.map { $0 + $1 }\n           \
    \                                            ^\n/tmp/tmpts8a_1pj.swift:28:9: note:\
    \ 'alphabetLettersOddAndEvenAndOddAndEvenAndOdd' declared here\n    let alphabetLettersOddAndEvenAndOddAndEvenAndOdd\
    \ = alphabetLettersOddAndEvenAndOddAndEvenAndOdd.map { $0 + $1 }\n        ^\n\
    /tmp/tmpts8a_1pj.swift:30:63: error: use of local variable 'alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven'\
    \ before its declaration\n    let alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven.map { $0 + $1 }\n    \
    \                                                          ^\n/tmp/tmpts8a_1pj.swift:30:9:\
    \ note: 'alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven' declared here\n\
    \    let alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven = alphabetLettersOddAndEvenAndOddAndEvenAndOddAndEven.map\
    \ { $0 + $1 }\n        ^\n/tmp/tmpts8a_1pj.swift:32:9: error: type annotation\
    \ missing in pattern\n    let alphabetLetters\n        ^\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(0)\n    }\n    if words.count == 1 {\n        return Ok(words)\n\
    \    }\n    let wordCount = words.count\n    let letterCount = words[0].characters.count\n\
    \    if letterCount == 0 {\n        return Err(letterCount)\n    }\n    if letterCount\
    \ % 2 == 1 {\n        return Err(letterCount)\n    }\n    let letterCount = letterCount\
    \ / 2\n    let wordCount = wordCount - 1\n    let letterCount = letterCount -\
    \ 1\n    let letters = Array(words[0].characters)\n    let letters = letters.filter\
    \ {\n        letters.count > letterCount\n    }\n    let letters = letters.filter\
    \ {\n        letters.count % 2 == 1\n    }\n    let letters = letters.filter {\n\
    \        letters.count < letterCount\n    }\n    return Ok([String](letters))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5tsng6hm.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(0)\n               ^~~\n/tmp/tmp5tsng6hm.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp5tsng6hm.swift:17:32:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    let letterCount\
    \ = words[0].characters.count\n                               ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmp5tsng6hm.swift:19:16: error: cannot find\
    \ 'Err' in scope\n        return Err(letterCount)\n               ^~~\n/tmp/tmp5tsng6hm.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCount)\n       \
    \        ^~~\n/tmp/tmp5tsng6hm.swift:24:9: error: invalid redeclaration of 'letterCount'\n\
    \    let letterCount = letterCount / 2\n        ^\n/tmp/tmp5tsng6hm.swift:17:9:\
    \ note: 'letterCount' previously declared here\n    let letterCount = words[0].characters.count\n\
    \        ^\n/tmp/tmp5tsng6hm.swift:25:9: error: invalid redeclaration of 'wordCount'\n\
    \    let wordCount = wordCount - 1\n        ^\n/tmp/tmp5tsng6hm.swift:16:9: note:\
    \ 'wordCount' previously declared here\n    let wordCount = words.count\n    \
    \    ^\n/tmp/tmp5tsng6hm.swift:27:34: error: 'characters' is unavailable: Please\
    \ use Substring directly\n    let letters = Array(words[0].characters)\n     \
    \                            ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmp5tsng6hm.swift:28:34: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ letters = letters.filter {\n                                 ^\n           \
    \                       _ in \n/tmp/tmp5tsng6hm.swift:37:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok([String](letters))\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int(.zero))\n    }\n    \n    var result = [String]()\n\
    \    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\"), letters.count > 0 else {\n            return Err(Int(.zero))\n     \
    \   }\n        \n        let letterCount = letters.reduce(0) { $0 + $1.count }\n\
    \        \n        if letterCount % 2 == 1 {\n            result.append(word)\n\
    \        }\n    }\n    \n    guard result.count > 0 else {\n        return Err(Int(.zero))\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9gs5vt34.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp9gs5vt34.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmp9gs5vt34.swift:29:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmp9gs5vt34.swift:32:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let mut words: [String] = []\n    for word in words\
    \ {\n        words.append(word.trimmingCharacters(in: .whitespaces))\n    }\n\
    \    if words.count % 2 != 0 {\n        return Err(25)\n    }\n    let mut chars:\
    \ [Character] = []\n    for char in words[words.count - 1] {\n        if char.lowercased()\
    \ != char {\n            chars.append(char)\n        }\n    }\n    if chars.count\
    \ % 2 != 0 {\n        return Err(25)\n    }\n    return Ok(words)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyjlvfgw5.swift:16:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut words: [String]\
    \ = []\n            ^\n/tmp/tmpyjlvfgw5.swift:16:13: note: join the identifiers\
    \ together\n    let mut words: [String] = []\n        ~~~~^~~~~\n        mutwords\n\
    /tmp/tmpyjlvfgw5.swift:16:13: note: join the identifiers together with camel-case\n\
    \    let mut words: [String] = []\n        ~~~~^~~~~\n        mutWords\n/tmp/tmpyjlvfgw5.swift:23:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut chars: [Character] = []\n            ^\n/tmp/tmpyjlvfgw5.swift:23:13:\
    \ note: join the identifiers together\n    let mut chars: [Character] = []\n \
    \       ~~~~^~~~~\n        mutchars\n/tmp/tmpyjlvfgw5.swift:23:13: note: join\
    \ the identifiers together with camel-case\n    let mut chars: [Character] = []\n\
    \        ~~~~^~~~~\n        mutChars\n/tmp/tmpyjlvfgw5.swift:11:16: error: cannot\
    \ find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpyjlvfgw5.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpyjlvfgw5.swift:18:15: error: no exact matches in call to instance\
    \ method 'append'\n        words.append(word.trimmingCharacters(in: .whitespaces))\n\
    \              ^\n/tmp/tmpyjlvfgw5.swift:18:15: note: found candidate with type\
    \ '(__owned String.SubSequence) -> ()' (aka '(__owned Substring) -> ()')\n   \
    \     words.append(word.trimmingCharacters(in: .whitespaces))\n              ^\n\
    /tmp/tmpyjlvfgw5.swift:18:27: error: value of type 'String.SubSequence' (aka 'Substring')\
    \ has no member 'trimmingCharacters'\n        words.append(word.trimmingCharacters(in:\
    \ .whitespaces))\n                     ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpyjlvfgw5.swift:18:51:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       words.append(word.trimmingCharacters(in: .whitespaces))\n            \
    \                                     ~^~~~~~~~~~~\n/tmp/tmpyjlvfgw5.swift:21:16:\
    \ error: cannot find 'Err' i"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    if words.count % 2 != 0 {\n        return Err(25)\n  \
    \  }\n    let even = words.filter{$0.isUpper}.count\n    let odd = words.filter{$0.isLower}.count\n\
    \    if even % 2 == 0 {\n        return Ok(words.filter{$0.isUpper})\n    }\n\
    \    if odd % 2 == 0 {\n        return Ok(words.filter{$0.isLower})\n    }\n \
    \   return Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz2ke_p6u.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpz2ke_p6u.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpz2ke_p6u.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpz2ke_p6u.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpz2ke_p6u.swift:22:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words.filter{$0.isUpper})\n               ^~\n\
    /tmp/tmpz2ke_p6u.swift:25:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.filter{$0.isLower})\n               ^~\n/tmp/tmpz2ke_p6u.swift:27:12:\
    \ error: cannot find 'Err' in scope\n    return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { (result, word) -> Int in\n        let\
    \ letterCount = word.characters.count\n        return result + letterCount\n \
    \   }\n    if letterCount % 2 == 1 {\n        return Err(Int(1))\n    }\n    return\
    \ Ok(words.map { $0.trimmingCharacters(in: .whitespaces)})\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoomgkzz4.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpoomgkzz4.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpoomgkzz4.swift:16:23:\
    \ error: cannot convert return expression of type 'String' to return type 'Int'\n\
    \        return result + letterCount\n               ~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpoomgkzz4.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmpoomgkzz4.swift:21:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(words.map { $0.trimmingCharacters(in: .whitespaces)})\n           ^~\n/tmp/tmpoomgkzz4.swift:21:54:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   return Ok(words.map { $0.trimmingCharacters(in: .whitespaces)})\n        \
    \                                            ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(0)\n    }\n    if words.count == 1 {\n        return Ok(words)\n\
    \    }\n    let words = words.map(String.init)\n    let letters = words.map(String.init).map({\
    \ String($0.lowercased()) })\n    let letters = letters.reduce(\"\", combine:\
    \ { (acc, letter) -> String in\n        if letter.isEmpty {\n            return\
    \ acc\n        }\n        return acc + letter\n    })\n    let letters = letters.split(separator:\
    \ \",\")\n    if letters.count == 0 {\n        return Err(0)\n    }\n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    let letters = letters.map(String.init)\n\
    \    let letters = letters.reduce(\"\", combine: { (acc, letter) -> String in\n\
    \        if letter.isEmpty {\n            return acc\n        }\n        return\
    \ acc + letter\n    })\n    let letters = letters.split(separator: \" \")\n  \
    \  if letters.count == 0 {\n        return Err(0)\n    }\n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    let letters = letters.map(String.init)\n\
    \    let letters = letters.reduce(\"\", combine: { (acc, letter) -> String in\n\
    \        if letter.isEmpty {\n            return acc\n        }\n        return\
    \ acc + letter\n    })\n    let letters = letters.split(separator: \",\")\n  \
    \  if letters.count == 0 {\n        return Err(0)\n    }\n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    let letters = letters.map(String.init)\n\
    \    let letters = letters.reduce(\"\", combine: { (acc, letter) -> String in\n\
    \        if letter.isEmpty {\n            return acc\n        }\n        return\
    \ acc + letter\n    })\n    let letters = letters.split(separator: \" \")\n  \
    \  if letters.count == 0 {\n        return Err(0)\n    }\n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    let letters = letters.map(String.init)\n\
    \    let letters = letters.reduce(\"\", combine: { (acc, letter) -> String in\n\
    \        if letter.isEmpty {\n            return acc\n        }\n        return\
    \ acc + letter\n    })\n    let letters = letters.split(separator: \",\")\n  \
    \  if letters.count == 0 {\n        return Err(0)\n    }\n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    let letters = letters.map(String.init)\n\
    \    let letters = letters.reduce(\"\", combine: { (acc, letter) -> String in\n\
    \        if letter.isEmpty {\n            return acc\n        }\n        return\
    \ acc + letter\n    })\n    let letters = letters.split(separator: \" \")\n  \
    \  if letters.count == 0 {\n        return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1ndo_51c.swift:119:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmp1ndo_51c.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmp1ndo_51c.swift:11:16: error: cannot\
    \ find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmp1ndo_51c.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1ndo_51c.swift:16:9: error: invalid redeclaration of 'words'\n    let\
    \ words = words.map(String.init)\n        ^\n/tmp/tmp1ndo_51c.swift:9:9: note:\
    \ 'words' previously declared here\n    let words = txt.split(separator: \" \"\
    )\n        ^\n/tmp/tmp1ndo_51c.swift:26:16: error: cannot find 'Err' in scope\n\
    \        return Err(0)\n               ^~~\n/tmp/tmp1ndo_51c.swift:29:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(letters)\n               ^~\n/tmp/tmp1ndo_51c.swift:40:16:\
    \ error: cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n\
    /tmp/tmp1ndo_51c.swift:43:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(letters)\n               ^~\n/tmp/tmp1ndo_51c.swift:54:16: error: cannot\
    \ find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmp1ndo_51c.swift:57:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(letters)\n             \
    \  ^~\n/tmp/tmp1ndo_51c.swift:68:16: error: cannot find 'Err' in scope\n     \
    \   return Err(0)\n               ^~~\n/tmp/tmp1ndo_51c.swift:71:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(letters)\n               ^~\n/tmp/tmp1ndo_51c.swift:82:16:\
    \ error: cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n\
    /tmp/tmp1ndo_51c.swift:85:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(letters)\n               ^~\n/tmp/tmp1ndo_51c.swift:96:9: error: non-void\
    \ function should return a value\n        return \n        ^\n/tmp/tmp1ndo_51c.swift:100:6:\
    \ error: operator functions can only be declared at global or in"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    guard let letters = words.map({ String($0).lowercased() }).joined(separator:\
    \ \",\").lowercased() else {\n        return Err(0)\n    }\n    let letterCount\
    \ = letters.count\n    return letterCount == letters.count ? Ok([letters]) : Err(letterCount)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwtdw0_5_.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwtdw0_5_.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpwtdw0_5_.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpwtdw0_5_.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpwtdw0_5_.swift:16:43:\
    \ error: cannot find 'Ok' in scope\n    return letterCount == letters.count ?\
    \ Ok([letters]) : Err(letterCount)\n                                         \
    \ ^~\n/tmp/tmpwtdw0_5_.swift:16:59: error: cannot find 'Err' in scope\n    return\
    \ letterCount == letters.count ? Ok([letters]) : Err(letterCount)\n          \
    \                                                ^~~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let letterCount = words.reduce(0)\
    \ { (result, word) -> Int in\n        let letters = word.components(separatedBy:\
    \ \",\")\n        if letters.count == 1 {\n            return result + 1\n   \
    \     }\n        return result + letters.count\n    }\n    return Ok([words[0..<wordCount-1],\
    \ letterCount])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpf0phs1y3.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpf0phs1y3.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpf0phs1y3.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpf0phs1y3.swift:24:12: error: cannot find 'Ok' in scope\n    return Ok([words[0..<wordCount-1],\
    \ letterCount])\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ < 2 {\n        return Err(25)\n    }\n    \n    if words.count > 2 {\n     \
    \   return Err(25)\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphn4gl9s1.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmphn4gl9s1.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmphn4gl9s1.swift:16:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmphn4gl9s1.swift:19:12: error: cannot find 'Ok' in scope\n    return Ok(words)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    \n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.lowercased() } }\n    \n    if splitWords.count == 1 {\n   \
    \     return Ok(splitWords)\n    }\n    \n    let evenOrder = splitWords.filter\
    \ { $0.count % 2 == 0 }\n    let oddOrder = splitWords.filter { $0.count % 2 !=\
    \ 0 }\n    \n    return Ok(evenOrder.count + oddOrder.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp633zmab3.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp633zmab3.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp633zmab3.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp633zmab3.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(splitWords)\n               ^~\n/tmp/tmp633zmab3.swift:28:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(evenOrder.count + oddOrder.count)\n      \
    \     ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(0)\n    }\n    let wordCount = words.count\n    let letterCount\
    \ = words.reduce(0) { (sum, word) -> Int in\n        let letterCount = word.characters.count\n\
    \        return letterCount + sum\n    }\n    if letterCount % 2 == 1 {\n    \
    \    return Err(letterCount)\n    }\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxldiebea.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(0)\n               ^~~\n/tmp/tmpxldiebea.swift:15:32: error: 'characters'\
    \ is unavailable: Please use Substring directly\n        let letterCount = word.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmpxldiebea.swift:19:16: error: cannot find 'Err' in scope\n\
    \        return Err(letterCount)\n               ^~~\n/tmp/tmpxldiebea.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n           ^~\n/tmp/tmpxldiebea.swift:21:30: error: value\
    \ of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n      \
    \                    ~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpxldiebea.swift:21:54: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    return\
    \ Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n                \
    \                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    guard words.count >\
    \ 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    \n    var result = [String]()\n    \n    for word in words {\n      \
    \  guard let word = word.trimmingCharacters(in: .whitespaces) else { return Err(0)\
    \ }\n        guard let word = word.split(separator: \",\") else { return Err(0)\
    \ }\n        guard let word = word.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmpm98f4i4t.swift:19:1: error: expected ')' in expression list\n}\n^\n/tmp/tmpm98f4i4t.swift:18:1785:\
    \ note: to match this opening '('\n        guard let word = word.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init\n\
    \                                         "
  stdout: ''
  timestamp: 1660054517
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    \n    if words.count == 1 {\n    \
    \    return Ok(words)\n    }\n    \n    if words.count == 2 {\n        return\
    \ Ok(words)\n    }\n    \n    if words.count == 3 {\n        return Ok(words)\n\
    \    }\n    \n    if words.count == 4 {\n        return Ok(words)\n    }\n   \
    \ \n    if words.count == 5 {\n        return Ok(words)\n    }\n    \n    if words.count\
    \ == 6 {\n        return Ok(words)\n    }\n    \n    if words.count == 7 {\n \
    \       return Ok(words)\n    }\n    \n    if words.count == 8 {\n        return\
    \ Ok(words)\n    }\n    \n    if words.count == 9 {\n        return Ok(words)\n\
    \    }\n    \n    if words.count == 10 {\n        return Ok(words)\n    }\n  \
    \  \n    if words.count == 11 {\n        return Ok(words)\n    }\n    \n    if\
    \ words.count == 12 {\n        return Ok(words)\n    }\n    \n    if words.count\
    \ == 13 {\n        return Ok(words)\n    }\n    \n    if words.count == 14 {\n\
    \        return Ok(words)\n    }\n    \n    if words.count == 15 {\n        return\
    \ Ok(words)\n    }\n    \n    if words.count == 16 {\n        return Ok(words)\n\
    \    }\n    \n    if words.count == 17 {\n        return Ok(words)\n    }\n  \
    \  \n    if words.count == 18 {\n        return Ok(words)\n    }\n    \n    if\
    \ words.count == 19 {\n        return Ok(words)\n    }\n    \n    if words.count\
    \ == 20 {\n        return Ok(words)\n    }\n    \n    if words.count == 21 {\n\
    \        return Ok(words)\n    }\n    \n    if words.count == 22 {\n        return\
    \ Ok(words)\n    }\n    \n    if words.count == 23 {\n        return Ok(words)\n\
    \    }\n    \n    if words.count == 24 {\n        return Ok(words)\n    }\n  \
    \  \n    if words.count == 25 {\n        return Ok(words)\n    }\n    \n    if\
    \ words.count == 26 {\n        return Ok(words)\n    }\n    \n    if words.count\
    \ == 27 {\n        return Ok(words)\n    }\n    \n    if words.count == 28 {\n\
    \        return Ok(words)\n    }\n    \n    if words.count == 29 {\n        return\
    \ Ok(words)\n    }\n    \n    if words.count == 30 {\n        return Ok(words)\n\
    \    }\n    \n    if words.count == 31 {\n        return Ok(words)\n    }\n  \
    \  \n    if words.count == 32 {\n        return Ok(words)\n    }\n    \n    if\
    \ words.count == 33 {\n        return Ok(words)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbgy9fj97.swift:12:16: error: cannot find 'Err' in scope\n     \
    \   return Err(0)\n               ^~~\n/tmp/tmpbgy9fj97.swift:16:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:20:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpbgy9fj97.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:28:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:32:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpbgy9fj97.swift:36:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:40:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:44:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpbgy9fj97.swift:48:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:52:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:56:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpbgy9fj97.swift:60:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:64:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:68:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpbgy9fj97.swift:72:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:76:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:80:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpbgy9fj97.swift:84:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpbgy9fj97.swift:88:16: error"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.errUnknown))\n    }\n    \n    var result = [String]()\n\
    \    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.errUnknown))\n        }\n       \
    \ \n        for letter in letters {\n            if let num = Int(letter) {\n\
    \                if num % 2 == 1 {\n                    result.append(String(num))\n\
    \                }\n            }\n        }\n    }\n    \n    if result.count\
    \ == 0 {\n        return Err(Int(.errUnknown))\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx5gxm_uo.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpx5gxm_uo.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n         \
    \      ^~~\n/tmp/tmpx5gxm_uo.swift:10:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errUnknown))\n                       ^\n  \
    \                     bitPattern: \n/tmp/tmpx5gxm_uo.swift:30:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.errUnknown))\n               ^~~\n\
    /tmp/tmpx5gxm_uo.swift:30:24: error: missing argument label 'bitPattern:' in call\n\
    \        return Err(Int(.errUnknown))\n                       ^\n            \
    \           bitPattern: \n/tmp/tmpx5gxm_uo.swift:33:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    guard words.count < 26 && words.count > 0 else { return Err(0) }\n  \
    \  \n    let result: [String] = []\n    for i in 0..<words.count {\n        if\
    \ let word = words[i], let letter = word.lowercased() {\n            result.append(letter)\n\
    \        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpu9s1uzn3.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpu9s1uzn3.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpu9s1uzn3.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpu9s1uzn3.swift:12:61: error:\
    \ cannot find 'Err' in scope\n    guard words.count < 26 && words.count > 0 else\
    \ { return Err(0) }\n                                                        \
    \    ^~~\n/tmp/tmpu9s1uzn3.swift:21:12: error: cannot find 'Ok' in scope\n   \
    \ return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let words = words.map { $0.lowercased() }\n    let even\
    \ = words.filter { $0.count % 2 == 0 }\n    let odd = words.filter { $0.count\
    \ % 2 != 0 }\n    return Ok([even, odd])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv_vwx1np.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpv_vwx1np.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpv_vwx1np.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpv_vwx1np.swift:19:12: error: cannot find 'Ok' in scope\n    return Ok([even,\
    \ odd])\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map { $0.lowercased() }\n    let odd\
    \ = letters.filter { $0 % 2 != 0 }\n    return Ok(odd)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpohptx4_l.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpohptx4_l.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpohptx4_l.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpohptx4_l.swift:18:12: error: cannot find 'Ok' in scope\n    return Ok(odd)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else {\n        return Err(Int(.notAnInteger))\n    }\n    \n    let wordCount\
    \ = words.count\n    guard wordCount > 0 else {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    let wordArray = words.map { $0.lowercased() }\n    \n    let\
    \ evenWords = wordArray.filter { $0.count % 2 == 0 }\n    guard evenWords.count\
    \ > 0 else {\n        return Err(Int(.notAnInteger))\n    }\n    \n    let oddWords\
    \ = wordArray.filter { $0.count % 2 != 0 }\n    guard oddWords.count > 0 else\
    \ {\n        return Err(Int(.notAnInteger))\n    }\n    \n    let evenWordCount\
    \ = evenWords.count\n    guard evenWordCount > 0 else {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    let oddWordCount = oddWords.count\n    guard oddWordCount >\
    \ 0 else {\n        return Err(Int(.notAnInteger))\n    }\n    \n    let evenWordArray\
    \ = evenWords.map { $0.lowercased() }\n    \n    let oddWordArray = oddWords.map\
    \ { $0.lowercased() }\n    \n    let evenWordArrayCount = evenWordArray.count\n\
    \    guard evenWordArrayCount > 0 else {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    let oddWordArrayCount = oddWordArray.count\n    guard oddWordArrayCount\
    \ > 0 else {\n        return Err(Int(.notAnInteger))\n    }\n    \n    let evenWordArrayCount\
    \ = evenWordArray.count\n    guard evenWordArrayCount > 0 else {\n        return\
    \ Err(Int(.notAnInteger))\n    }\n    \n    let oddWordArrayCount = oddWordArray.count\n\
    \    guard oddWordArrayCount > 0 else {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    let evenWordArrayCount = evenWordArray.count\n    guard evenWordArrayCount\
    \ > 0 else {\n        return Err(Int(.notAnInteger))\n    }\n    \n    let oddWordArrayCount\
    \ = oddWordArray.count\n    guard oddWordArrayCount > 0 else {\n        return\
    \ Err(Int(.notAnInteger))\n    }\n    \n    let evenWordArrayCount = evenWordArray.count\n\
    \    guard evenWordArrayCount > 0 else {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    let oddWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq3i9hktu.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpq3i9hktu.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.notAnInteger))\n               ^~~\n/tmp/tmpq3i9hktu.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.notAnInteger))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpq3i9hktu.swift:16:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.notAnInteger))\n\
    \               ^~~\n/tmp/tmpq3i9hktu.swift:16:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.notAnInteger))\n            \
    \           ^\n                       bitPattern: \n/tmp/tmpq3i9hktu.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.notAnInteger))\n\
    \               ^~~\n/tmp/tmpq3i9hktu.swift:23:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.notAnInteger))\n            \
    \           ^\n                       bitPattern: \n/tmp/tmpq3i9hktu.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.notAnInteger))\n\
    \               ^~~\n/tmp/tmpq3i9hktu.swift:28:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.notAnInteger))\n            \
    \           ^\n                       bitPattern: \n/tmp/tmpq3i9hktu.swift:33:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.notAnInteger))\n\
    \               ^~~\n/tmp/tmpq3i9hktu.swift:33:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.notAnInteger))\n            \
    \           ^\n                       bitPattern: \n/tmp/tmpq3i9hktu.swift:38:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.notAnInteger))\n\
    \               ^~~\n/tmp/tmpq3i9hktu.swift:38:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.notAnInteger))\n            \
    \           ^\n                       bitPattern: \n/tmp/tmpq3i9hktu.swift:47:16:\
    \ error: cannot find 'Err' in "
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let wordCountWithCommas\
    \ = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder = wordCountWithCommas\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetters = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9], words[10], words[11], words[12],\
    \ words[13], words[14], words[15], words[16], words[17], words[18], words[19],\
    \ words[20], words[21], words[22], words[23], words[24], words[25]])\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpemit4_93.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmpemit4_93.swift:14:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpemit4_93.swift:20:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8], words[9], words[10],\
    \ words[11], words[12], words[13], words[14], words[15], words[16], words[17],\
    \ words[18], words[19], words[20], words[21], words[22], words[23], words[24],\
    \ words[25]])\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    guard let letters = words.map({ $0.lowercased() }).reduce(0) { $0 + $1.count\
    \ }\n    return Ok([words[0..<words.count / 2], letters])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9uhmp5zs.swift:12:66: error: expected 'else' after 'guard' condition\n\
    \    guard let letters = words.map({ $0.lowercased() }).reduce(0) { $0 + $1.count\
    \ }\n                                                                 ^\n    \
    \                                                             else \n/tmp/tmp9uhmp5zs.swift:12:68:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ letters = words.map({ $0.lowercased() }).reduce(0) { $0 + $1.count }\n     \
    \                                                              ^\n/tmp/tmp9uhmp5zs.swift:12:73:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ letters = words.map({ $0.lowercased() }).reduce(0) { $0 + $1.count }\n     \
    \                                                                   ^\n/tmp/tmp9uhmp5zs.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp9uhmp5zs.swift:10:41: error:\
    \ cannot find 'Err' in scope\n    guard words.count > 0 else { return Err(0) }\n\
    \                                        ^~~\n/tmp/tmp9uhmp5zs.swift:11:46: error:\
    \ cannot find 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n                                             ^~~\n/tmp/tmp9uhmp5zs.swift:13:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words[0..<words.count / 2],\
    \ letters])\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n    if words.count ==\
    \ 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \",\") }\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n   \
    \ let words = words.compactMap { $0.components(separatedBy: \" \") }\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ Err(Int(1))\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \" \") }\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n   \
    \ let words = words.compactMap { $0.components(separatedBy: \",\") }\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ Err(Int(1))\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \",\") }\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n   \
    \ let words = words.compactMap { $0.components(separatedBy: \" \") }\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ Err(Int(1))\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \" \") }\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n   \
    \ let words = words.compactMap { $0.components(separatedBy: \",\") }\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    if words.count == 0 {\n        return\
    \ Err(Int(1))\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \",\") }\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n   \
    \ let words = words.compactMap { $0.components(separatedBy: \" \") }\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\") }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcvoxkykm.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpcvoxkykm.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:13:63:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words = words.compactMap { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                             ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcvoxkykm.swift:15:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:19:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmpcvoxkykm.swift:27:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:31:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpcvoxkykm.swift:35:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:39:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:43:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmpcvoxkykm.swift:47:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:51:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpcvoxkykm.swift:55:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:59:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpcvoxkykm.swift:63:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmpcvoxkykm.swift:67:16: error: cannot find 'Err' "
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if words.count == 1 {\n        return Ok(words)\n    }\n    \n    let\
    \ firstWord = words.first!\n    \n    if firstWord.hasPrefix(\",\") {\n      \
    \  return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\\\"\
    \") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    '\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    (\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    )\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    }\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ;\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    '\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    (\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    )\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    [\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ]\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    {\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    }\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ;\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpr28iw96g.swift:103:24: error: expected member name following '.'\n\
    \        return Ok(words.\n                       ^\n/tmp/tmpr28iw96g.swift:104:1:\
    \ error: expected ')' in expression list\n}\n^\n/tmp/tmpr28iw96g.swift:103:18:\
    \ note: to match this opening '('\n        return Ok(words.\n                \
    \ ^\n/tmp/tmpr28iw96g.swift:126:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpr28iw96g.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpr28iw96g.swift:9:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpr28iw96g.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpr28iw96g.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpr28iw96g.swift:23:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropFirst())\n               ^~\n/tmp/tmpr28iw96g.swift:27:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n          \
    \     ^~\n/tmp/tmpr28iw96g.swift:31:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.dropFirst())\n               ^~\n/tmp/tmpr28iw96g.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpr28iw96g.swift:39:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpr28iw96g.swift:43:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpr28iw96g.swift:47:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpr28iw96g.swift:51:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpr28iw96g.swift:55:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(w"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errUnknown))\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpe2s43w4a.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpe2s43w4a.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpe2s43w4a.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe2s43w4a.swift:13:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map({ $0.lowercased() })\n    let\
    \ odd = letters.filter({ $0.count % 2 == 1 })\n    if odd.count == 0 {\n     \
    \   return Ok(words)\n    }\n    return Ok(odd)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp03tubv1z.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp03tubv1z.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp03tubv1z.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp03tubv1z.swift:19:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp03tubv1z.swift:21:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(odd)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    \n    if words.count == 1 {\n\
    \        return Ok(words)\n    }\n    \n    if words.count % 2 == 1 {\n      \
    \  return Err(Int(words.count))\n    }\n    \n    let even = words.filter{ $0.count\
    \ % 2 == 0 }\n    let odd = words.filter{ $0.count % 2 != 0 }\n    \n    let evenCount\
    \ = even.count\n    let oddCount = odd.count\n    \n    if evenCount == 0 {\n\
    \        return Ok(even)\n    }\n    \n    if oddCount == 0 {\n        return\
    \ Ok(odd)\n    }\n    \n    let evenLetters = even.map{ $0.lowercased() }\n  \
    \  let oddLetters = odd.map{ $0.lowercased() }\n    \n    if evenLetters.count\
    \ > oddLetters.count {\n        return Ok(evenLetters)\n    }\n    \n    return\
    \ Ok(oddLetters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpitwknr2x.swift:12:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmpitwknr2x.swift:16:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpitwknr2x.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(words.count))\n  \
    \             ^~~\n/tmp/tmpitwknr2x.swift:30:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(even)\n               ^~\n/tmp/tmpitwknr2x.swift:34:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(odd)\n               ^~\n/tmp/tmpitwknr2x.swift:41:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(evenLetters)\n         \
    \      ^~\n/tmp/tmpitwknr2x.swift:44:12: error: cannot find 'Ok' in scope\n  \
    \  return Ok(oddLetters)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let comma = words.last?.components(separatedBy: \",\"\
    )\n    if comma == nil {\n        return Ok(words.dropLast())\n    }\n    return\
    \ Ok(words.dropLast().append(comma))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeb4gkbgc.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpeb4gkbgc.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpeb4gkbgc.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpeb4gkbgc.swift:18:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropLast())\n               ^~\n/tmp/tmpeb4gkbgc.swift:20:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.dropLast().append(comma))\n \
    \          ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    if words.count > 1 {\n        let comma = words.last\n\
    \        let commaWords = comma.split(separator: \",\")\n        if commaWords.count\
    \ == 1 {\n            return Ok(words)\n        }\n        if commaWords.count\
    \ > 1 {\n            let letters = commaWords.last\n            let letterWords\
    \ = letters.split(separator: \"\")\n            if letterWords.count == 1 {\n\
    \                return Ok(words)\n            }\n            if letterWords.count\
    \ > 1 {\n                return Err(Int(letterWords.count))\n            }\n \
    \       }\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1hkamkvu.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmp1hkamkvu.swift:14:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1hkamkvu.swift:18:26:\
    \ error: value of optional type 'String.SubSequence?' (aka 'Optional<Substring>')\
    \ must be unwrapped to refer to member 'split' of wrapped base type 'String.SubSequence'\
    \ (aka 'Substring')\n        let commaWords = comma.split(separator: \",\")\n\
    \                         ^\n/tmp/tmp1hkamkvu.swift:18:26: note: chain the optional\
    \ using '?' to access member 'split' only for non-'nil' base values\n        let\
    \ commaWords = comma.split(separator: \",\")\n                         ^\n   \
    \                           ?\n/tmp/tmp1hkamkvu.swift:18:26: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ commaWords = comma.split(separator: \",\")\n                         ^\n   \
    \                           !\n/tmp/tmp1hkamkvu.swift:20:20: error: cannot find\
    \ 'Ok' in scope\n            return Ok(words)\n                   ^~\n/tmp/tmp1hkamkvu.swift:26:24:\
    \ error: cannot find 'Ok' in scope\n                return Ok(words)\n       \
    \                ^~\n/tmp/tmp1hkamkvu.swift:29:24: error: cannot find 'Err' in\
    \ scope\n                return Err(Int(letterWords.count))\n                \
    \       ^~~\n/tmp/tmp1hkamkvu.swift:33:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    let letters = words.count / 2\n    let letters_odd = letters.filter {\
    \ $0 % 2 != 0 }\n    let letters_even = letters.filter { $0 % 2 == 0 }\n    let\
    \ letters_odd_sorted = letters_odd.sorted()\n    let letters_even_sorted = letters_even.sorted()\n\
    \    let letters_odd_sorted_string = letters_odd_sorted.map { String($0) }\n \
    \   let letters_even_sorted_string = letters_even_sorted.map { String($0) }\n\
    \    return Ok([letters_odd_sorted_string, letters_even_sorted_string])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfl14zx3m.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpfl14zx3m.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpfl14zx3m.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpfl14zx3m.swift:19:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([letters_odd_sorted_string, letters_even_sorted_string])\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.init(\"0\")).init)\n    }\n    \n    var result: [String] = []\n  \
    \  \n    for word in words {\n        if let word = word.trimmingCharacters(in:\
    \ .whitespacesAndNewlines), !word.isEmpty {\n            result.append(word)\n\
    \        }\n    }\n    \n    if result.count == 0 {\n        return Err(Int(.init(\"\
    0\")).init)\n    }\n    \n    if result.count == 1 {\n        return Ok(result[0])\n\
    \    }\n    \n    if result.count % 2 == 1 {\n        return Err(Int(.init(\"\
    0\")).init)\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpg4ibz16k.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(\"0\")).init)\n               ^~~\n/tmp/tmpg4ibz16k.swift:10:36:\
    \ error: no exact matches in reference to initializer \n        return Err(Int(.init(\"\
    0\")).init)\n                                   ^\n/tmp/tmpg4ibz16k.swift:10:36:\
    \ note: found candidate with type '(Int) -> Optional<Int>'\n        return Err(Int(.init(\"\
    0\")).init)\n                                   ^\n/tmp/tmpg4ibz16k.swift:10:36:\
    \ note: found candidate with type '(()) -> Optional<Int>'\n        return Err(Int(.init(\"\
    0\")).init)\n                                   ^\n/tmp/tmpg4ibz16k.swift:10:36:\
    \ note: found candidate with type '(any Decoder) throws -> Optional<Int>'\n  \
    \      return Err(Int(.init(\"0\")).init)\n                                  \
    \ ^\n/tmp/tmpg4ibz16k.swift:9:11: error: initializer for conditional binding must\
    \ have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n  \
    \  guard let words = txt.split(separator: \" \") else {\n          ^         \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg4ibz16k.swift:16:28: error: value of type\
    \ 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        if let word = word.trimmingCharacters(in: .whitespacesAndNewlines), !word.isEmpty\
    \ {\n                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpg4ibz16k.swift:16:52:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \        if let word = word.trimmingCharacters(in: .whitespacesAndNewlines), !word.isEmpty\
    \ {\n                                                  ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpg4ibz16k.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.init(\"0\")).init)\n               ^~~\n/tmp/tmpg4ibz16k.swift:22:36:\
    \ error: no exact matches in reference to initializer \n        return Err(Int(.init(\"\
    0\")).init)\n                                   ^\n/tmp/tmpg4ibz16k.swift:22:36:\
    \ note: found candidate with type '(Int) -> Optional<Int>'\n        return Err(Int(.init(\"\
    0\")).init)\n                                   ^\n/tmp/tmpg"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.errUnknown))\n    }\n    return Ok(words)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyrd6yzou.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpyrd6yzou.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n         \
    \      ^~~\n/tmp/tmpyrd6yzou.swift:10:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errUnknown))\n                       ^\n  \
    \                     bitPattern: \n/tmp/tmpyrd6yzou.swift:12:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordArray\
    \ = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    guard wordArrayCount % 2 == 1 else {\n        return Err(wordArrayCount)\n\
    \    }\n    return Ok(wordArray.filter { $0.count % 2 == 1 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpww70ga4s.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpww70ga4s.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpww70ga4s.swift:15:16: error: cannot find\
    \ 'Err' in scope\n        return Err(wordArrayCount)\n               ^~~\n/tmp/tmpww70ga4s.swift:17:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(wordArray.filter { $0.count\
    \ % 2 == 1 })\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) == nil {\n        return Ok(words)\n    }\n    if\
    \ firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) != nil {\n      \
    \  return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces)\
    \ != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) != nil {\n        return Err(25)\n    }\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.white\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqvaw8z63.swift:75:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpqvaw8z63.swift:74:34: note: to match this opening '('\n    if firstWord.rangeOfCharacter(from:\
    \ CharacterSet.white\n                                 ^\n/tmp/tmpqvaw8z63.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpqvaw8z63.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpqvaw8z63.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpqvaw8z63.swift:17:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) == nil {\n   \
    \                                     ^~~~~~~~~~~~\n/tmp/tmpqvaw8z63.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpqvaw8z63.swift:20:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) != nil {\n   \
    \                                     ^~~~~~~~~~~~\n/tmp/tmpqvaw8z63.swift:21:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpqvaw8z63.swift:23:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) != nil {\n   \
    \                                     ^~~~~~~~~~~~\n/tmp/tmpqvaw8z63.swift:24:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpqvaw8z63.swift:26:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) != nil {\n   \
    \                                     ^~~~~~~~~~~~\n/tmp/tmpqvaw8z63.swift:27:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpqvaw8z63.swift:29:41: error: cannot find 'CharacterSet' in scope\n   \
    \ if firstWord.rangeOfCharacter(from: CharacterSet.whitespaces) != nil {\n   \
    \                                     ^~~~~~~~~~~~\n/tmp/tmpqvaw8"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n     \
    \   return Ok(words)\n    }\n    let words = words.map { $0.lowercased() }\n \
    \   let even = words.filter { $0.count % 2 == 0 }\n    let odd = words.filter\
    \ { $0.count % 2 != 0 }\n    if even.count == 0 {\n        return Ok(even)\n \
    \   }\n    if odd.count == 0 {\n        return Ok(odd)\n    }\n    let even =\
    \ even.map { $0.lowercased() }\n    let odd = odd.map { $0.lowercased() }\n  \
    \  return Ok(even.count + odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1ohz16n4.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp1ohz16n4.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp1ohz16n4.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1ohz16n4.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(even)\n               ^~\n/tmp/tmp1ohz16n4.swift:23:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(odd)\n               ^~\n/tmp/tmp1ohz16n4.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(even.count + odd.count)\n  \
    \         ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    let evenWords = words.filter{ $0.count % 2 == 0 }\n    let evenWordsCount\
    \ = evenWords.count\n    let evenWordsArray = evenWords.map { $0.lowercased()\
    \ }\n    let evenWordsArrayCount = evenWordsArray.count\n    let evenWordsArraySortedCount\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount2\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount3\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount4\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount5\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount6\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount7\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount8\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount9\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount10\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount11\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount12\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount13\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount14\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount15\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount16\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount17\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n    let evenWordsArraySortedCount18\
    \ = evenWordsArray.reduce(0, combine: { $0 + $1.count })\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmwyj6cs3.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpmwyj6cs3.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpmwyj6cs3.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\") }\n    if splitWords.count == 0 {\n        return Err(25)\n    }\n  \
    \  if splitWords.count == 1 {\n        return Ok(splitWords)\n    }\n    let letters\
    \ = splitWords.map { $0.map(String.init) }\n    if letters.count == 0 {\n    \
    \    return Err(25)\n    }\n    if letters.count == 1 {\n        return Ok(letters)\n\
    \    }\n    let letterCount = letters.map { $0.count }\n    if letterCount.count\
    \ == 0 {\n        return Err(25)\n    }\n    if letterCount.count == 1 {\n   \
    \     return Ok(letterCount)\n    }\n    let letterCountOdd = letterCount.filter\
    \ { $0 % 2 == 1 }\n    if letterCountOdd.count == 0 {\n        return Err(25)\n\
    \    }\n    if letterCountOdd.count == 1 {\n        return Ok(letterCountOdd)\n\
    \    }\n    return Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7inh3caw.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp7inh3caw.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp7inh3caw.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp7inh3caw.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmp7inh3caw.swift:21:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(splitWords)\n               ^~\n/tmp/tmp7inh3caw.swift:25:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmp7inh3caw.swift:28:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(letters)\n               ^~\n/tmp/tmp7inh3caw.swift:32:16: error: cannot\
    \ find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp7inh3caw.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(letterCount)\n         \
    \      ^~\n/tmp/tmp7inh3caw.swift:39:16: error: cannot find 'Err' in scope\n \
    \       return Err(25)\n               ^~~\n/tmp/tmp7inh3caw.swift:42:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(letterCountOdd)\n             \
    \  ^~\n/tmp/tmp7inh3caw.swift:44:12: error: cannot find 'Err' in scope\n    return\
    \ Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    guard words.count >\
    \ 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    \n    var result = [String]()\n    \n    for word in words {\n      \
    \  guard let word = word.trimmingCharacters(in: .whitespaces) else {\n       \
    \     return Err(0)\n        }\n        \n        if word.count > 0 {\n      \
    \      result.append(word)\n        }\n    }\n    \n    return Ok(result)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq838j619.swift:10:41: error: cannot find 'Err' in scope\n    guard\
    \ words.count > 0 else { return Err(0) }\n                                   \
    \     ^~~\n/tmp/tmpq838j619.swift:11:46: error: cannot find 'Err' in scope\n \
    \   guard words.count % 2 == 0 else { return Err(0) }\n                      \
    \                       ^~~\n/tmp/tmpq838j619.swift:16:31: error: value of type\
    \ 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let word = word.trimmingCharacters(in: .whitespaces) else {\n \
    \                        ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpq838j619.swift:16:55:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let word = word.trimmingCharacters(in: .whitespaces) else {\n  \
    \                                                   ~^~~~~~~~~~~\n/tmp/tmpq838j619.swift:17:20:\
    \ error: cannot find 'Err' in scope\n            return Err(0)\n             \
    \      ^~~\n/tmp/tmpq838j619.swift:25:12: error: cannot find 'Ok' in scope\n \
    \   return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok([words[0]])\n    }\n    \n    let splitWords = words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n    \n    if splitWords.count == 0 {\n        return Err(25)\n\
    \    }\n    \n    if splitWords.count == 1 {\n        return Ok([splitWords[0]])\n\
    \    }\n    \n    let splitWordsCount = splitWords.count\n    let splitWordsCountOdd\
    \ = splitWordsCount % 2 == 1\n    \n    if splitWordsCountOdd {\n        return\
    \ Ok(splitWords.map { $0.lowercased() })\n    } else {\n        return Ok(splitWords.map\
    \ { $0.lowercased() })\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjmri2fip.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjmri2fip.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpjmri2fip.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpjmri2fip.swift:19:61: error: cannot infer contextual base in\
    \ reference to member 'whitespaces'\n    let splitWords = words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n                                                          \
    \ ~^~~~~~~~~~~\n/tmp/tmpjmri2fip.swift:22:16: error: cannot find 'Err' in scope\n\
    \        return Err(25)\n               ^~~\n/tmp/tmpjmri2fip.swift:26:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok([splitWords[0]])\n            \
    \   ^~\n/tmp/tmpjmri2fip.swift:33:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(splitWords.map { $0.lowercased() })\n               ^~\n/tmp/tmpjmri2fip.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(splitWords.map { $0.lowercased()\
    \ })\n               ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(rawValue: 1))\n    }\n    \n    guard let comma = words.first else {\n\
    \        return Err(Int(rawValue: 2))\n    }\n    \n    guard let lowercase =\
    \ words.last else {\n        return Err(Int(rawValue: 3))\n    }\n    \n    guard\
    \ let count = lowercase..<alphabet.count else {\n        return Err(Int(rawValue:\
    \ 4))\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmph7ww9eu2.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmph7ww9eu2.swift:10:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmph7ww9eu2.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph7ww9eu2.swift:14:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 2))\n  \
    \             ^~~\n/tmp/tmph7ww9eu2.swift:14:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 2))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmph7ww9eu2.swift:18:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 3))\n         \
    \      ^~~\n/tmp/tmph7ww9eu2.swift:18:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 3))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmph7ww9eu2.swift:21:35: error: cannot find 'alphabet'\
    \ in scope\n    guard let count = lowercase..<alphabet.count else {\n        \
    \                          ^~~~~~~~\n/tmp/tmph7ww9eu2.swift:22:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(rawValue: 4))\n               ^~~\n\
    /tmp/tmph7ww9eu2.swift:22:23: error: extraneous argument label 'rawValue:' in\
    \ call\n        return Err(Int(rawValue: 4))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmph7ww9eu2.swift:25:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errUnknown))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl0myi10r.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpl0myi10r.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpl0myi10r.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl0myi10r.swift:12:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054472
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    guard words.count >\
    \ 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    \n    var result = [String]()\n    for i in 0..<words.count {\n     \
    \   let word = words[i]\n        if let word = word.lowercased() {\n         \
    \   result.append(word)\n        }\n    }\n    \n    return Ok(result)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv8m5ke7l.swift:10:41: error: cannot find 'Err' in scope\n    guard\
    \ words.count > 0 else { return Err(0) }\n                                   \
    \     ^~~\n/tmp/tmpv8m5ke7l.swift:11:46: error: cannot find 'Err' in scope\n \
    \   guard words.count % 2 == 0 else { return Err(0) }\n                      \
    \                       ^~~\n/tmp/tmpv8m5ke7l.swift:16:12: error: initializer\
    \ for conditional binding must have Optional type, not 'String'\n        if let\
    \ word = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n/tmp/tmpv8m5ke7l.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let words = words.map { $0.lowercased()\
    \ }\n    \n    let wordCount = words.count\n    \n    if wordCount == 0 {\n  \
    \      return Err(25)\n    }\n    \n    let wordCountEven = wordCount % 2 == 0\n\
    \    \n    if wordCountEven {\n        let evenWords = words.suffix(wordCount\
    \ / 2)\n        let oddWords = words.prefix(wordCount / 2)\n        return Ok([evenWords,\
    \ oddWords])\n    } else {\n        return Ok(words)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjpjp2g1r.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpjpjp2g1r.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpjpjp2g1r.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpjpjp2g1r.swift:27:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([evenWords, oddWords])\n               ^~\n/tmp/tmpjpjp2g1r.swift:29:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let mut splitted = [String]()\n    for word in words\
    \ {\n        let splitted = word.split(separator: \",\")\n        if splitted.count\
    \ == 0 {\n            return Err(25)\n        }\n        if splitted.count ==\
    \ 1 {\n            splitted.append(\"\")\n        }\n        for s in splitted\
    \ {\n            splitted.append(s.lowercased())\n        }\n        splitted.removeFirst()\n\
    \        splitted.removeLast()\n        splitted.removeFirst()\n        splitted.removeLast()\n\
    \        if splitted.count % 2 == 1 {\n            return Err(25)\n        }\n\
    \    }\n    return Ok(splitted)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpsghwo3ce.swift:16:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut splitted\
    \ = [String]()\n            ^\n/tmp/tmpsghwo3ce.swift:16:13: note: join the identifiers\
    \ together\n    let mut splitted = [String]()\n        ~~~~^~~~~~~~\n        mutsplitted\n\
    /tmp/tmpsghwo3ce.swift:16:13: note: join the identifiers together with camel-case\n\
    \    let mut splitted = [String]()\n        ~~~~^~~~~~~~\n        mutSplitted\n\
    /tmp/tmpsghwo3ce.swift:11:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpsghwo3ce.swift:14:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpsghwo3ce.swift:20:20:\
    \ error: cannot find 'Err' in scope\n            return Err(25)\n            \
    \       ^~~\n/tmp/tmpsghwo3ce.swift:23:22: error: cannot use mutating member on\
    \ immutable value: 'splitted' is a 'let' constant\n            splitted.append(\"\
    \")\n            ~~~~~~~~ ^\n/tmp/tmpsghwo3ce.swift:18:9: note: change 'let' to\
    \ 'var' to make it mutable\n        let splitted = word.split(separator: \",\"\
    )\n        ^~~\n        var\n/tmp/tmpsghwo3ce.swift:26:22: error: no exact matches\
    \ in call to instance method 'append'\n            splitted.append(s.lowercased())\n\
    \                     ^\n/tmp/tmpsghwo3ce.swift:26:22: note: found candidate with\
    \ type '(__owned Substring.SubSequence) -> ()' (aka '(__owned Substring) -> ()')\n\
    \            splitted.append(s.lowercased())\n                     ^\n/tmp/tmpsghwo3ce.swift:26:22:\
    \ note: found candidate with type '(__owned String) -> ()'\n            splitted.append(s.lowercased())\n\
    \                     ^\n/tmp/tmpsghwo3ce.swift:28:18: error: cannot use mutating\
    \ member on immutable value: 'splitted' is a 'let' constant\n        splitted.removeFirst()\n\
    \        ~~~~~~~~ ^\n/tmp/tmpsghwo3ce.swift:18:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let splitted = word.split(separator: \",\")\n  \
    \      ^~~\n        var\n/tmp/tmpsghwo3ce.swift:29:18: error: cannot use mutating\
    \ member on immutable value: 'splitted'"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let letters = words.map { $0.lowercased() }\n\
    \    let odd = letters.filter { $0.count % 2 == 1 }\n    let even = letters.filter\
    \ { $0.count % 2 == 0 }\n    return odd.count > 0 ? odd.map(String.init) : even.map(String.init)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppu8xq3sk.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmppu8xq3sk.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count < 2\
    \ {\n        return Err(25)\n    }\n    let words: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n    if words.count < 2 {\n        return Err(25)\n\
    \    }\n    let words: [String] = words.map { $0.split(separator: \",\").map {\
    \ $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if words.count <\
    \ 2 {\n        return Err(25)\n    }\n    let words: [String] = words.map { $0.map\
    \ { $0.lowercased() } }\n    if words.count < 2 {\n        return Err(25)\n  \
    \  }\n    let words: [String] = words.map { $0.filter { $0.count % 2 == 1 } }\n\
    \    if words.count < 2 {\n        return Err(25)\n    }\n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbfenu7zm.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpbfenu7zm.swift:13:42: error: value\
    \ of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \    let words: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                      ~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpbfenu7zm.swift:13:66:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                                ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbfenu7zm.swift:13:9: error: invalid redeclaration of 'words'\n    let\
    \ words: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n        ^\n/tmp/tmpbfenu7zm.swift:9:9: note: 'words' previously declared\
    \ here\n    let words = txt.split(separator: \" \")\n        ^\n/tmp/tmpbfenu7zm.swift:15:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpbfenu7zm.swift:17:97: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlines'\n    let words: [String] = words.map { $0.split(separator:\
    \ \",\").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n      \
    \                                                                            \
    \             ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbfenu7zm.swift:17:9: error: invalid\
    \ redeclaration of 'words'\n    let words: [String] = words.map { $0.split(separator:\
    \ \",\").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n      \
    \  ^\n/tmp/tmpbfenu7zm.swift:9:9: note: 'words' previously declared here\n   \
    \ let words = txt.split(separator: \" \")\n        ^\n/tmp/tmpbfenu7zm.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpbfenu7zm.swift:21:9: error: invalid redeclaration of 'words'\n    let\
    \ words: [String] = words.map { $0.map { $0.lowercased() } }\n        ^\n/tmp/tmpbfenu7zm.swift:9:9:\
    \ note: 'words' previ"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.errUnknown))\n    }\n    \n    var words: [String] = []\n\
    \    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.errUnknown))\n        }\n       \
    \ \n        for letter in letters {\n            guard let letter = letter.lowercased()\
    \ else {\n                return Err(Int(.errUnknown))\n            }\n      \
    \      \n            if letter != letter {\n                return Err(Int(.errUnknown))\n\
    \            }\n            \n            if letter != letter {\n            \
    \    return Err(Int(.errUnknown))\n            }\n            \n            if\
    \ letter != letter {\n                return Err(Int(.errUnknown))\n         \
    \   }\n            \n            if letter != letter {\n                return\
    \ Err(Int(.errUnknown))\n            }\n            \n            if letter !=\
    \ letter {\n                return Err(Int(.errUnknown))\n            }\n    \
    \        \n            if letter != letter {\n                return Err(Int(.errUnknown))\n\
    \            }\n            \n            if letter != letter {\n            \
    \    return Err(Int(.errUnknown))\n            }\n            \n            if\
    \ letter != letter {\n                return Err(Int(.errUnknown))\n         \
    \   }\n            \n            if letter != letter {\n                return\
    \ Err(Int(.errUnknown))\n            }\n            \n            if letter !=\
    \ letter {\n                return Err(Int(.errUnknown))\n            }\n    \
    \        \n            if letter != letter {\n                return Err(Int(.errUnknown))\n\
    \            }\n            \n            if letter != letter {\n            \
    \    return Err(Int(.errUnknown))\n            }\n            \n            if\
    \ letter != letter {\n                return Err(Int(.errUnknown))\n         \
    \   }\n            \n            if letter != letter {\n                return\
    \ Err(Int(.errUnknown))\n            }\n            \n            if letter !=\
    \ letter {\n                return Err(Int(.errUnknown))\n            }\n    \
    \        \n            if letter != letter {\n                return Err(Int(.errUnknown))\n\
    \            }\n            \n            if letter != letter {\n            \
    \    return Err(Int(.errUnknown))\n            }\n            \n            if\
    \ letter != letter {\n                return Err(Int(.errUnknown))\n         \
    \   }\n            \n            if letter != letter {\n                return\
    \ Err(Int(.errUnknown))\n            }\n            \n            if letter !=\
    \ letter {\n                return Err(Int(.errUnknown))\n            }\n    \
    \        \n            if letter != letter {\n                return Err(Int(.errUnknown))\n\
    \            }\n            \n            if letter != letter {\n            \
    \    return Err(Int(.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk9pkk825.swift:110:1: error: expected identifier after '.' expression\n\
    }\n^\n/tmp/tmpk9pkk825.swift:132:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpk9pkk825.swift:19:31: note: to match this opening '{'\n\
    \        for letter in letters {\n                              ^\n/tmp/tmpk9pkk825.swift:132:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpk9pkk825.swift:14:23:\
    \ note: to match this opening '{'\n    for word in words {\n                 \
    \     ^\n/tmp/tmpk9pkk825.swift:132:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpk9pkk825.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpk9pkk825.swift:9:27: error: value\
    \ of type 'String' has no member 'components'\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpk9pkk825.swift:10:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n  \
    \             ^~~\n/tmp/tmpk9pkk825.swift:10:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n              \
    \         ^\n                       bitPattern: \n/tmp/tmpk9pkk825.swift:15:34:\
    \ error: value of type 'String' has no member 'components'\n        guard let\
    \ letters = word.components(separatedBy: \",\") else {\n                     \
    \       ~~~~ ^~~~~~~~~~\n/tmp/tmpk9pkk825.swift:16:20: error: cannot find 'Err'\
    \ in scope\n            return Err(Int(.errUnknown))\n                   ^~~\n\
    /tmp/tmpk9pkk825.swift:16:28: error: missing argument label 'bitPattern:' in call\n\
    \            return Err(Int(.errUnknown))\n                           ^\n    \
    \                       bitPattern: \n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    let wordArray = words.map { $0.lowercased() }\n    \n    if wordArray.count\
    \ % 2 == 1 {\n        return Err(25)\n    }\n    \n    return Ok(wordArray)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvw64sj04.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpvw64sj04.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpvw64sj04.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpvw64sj04.swift:22:12: error: cannot find 'Ok' in scope\n    return Ok(wordArray)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    let wordCount = words.count\n    let letterCount\
    \ = words.reduce(0) { $0 + $1.count }\n    if letterCount % 2 == 1 {\n       \
    \ return Ok(words.map { $0.lowercased() })\n    }\n    return Ok(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfaqqyq8e.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpfaqqyq8e.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpfaqqyq8e.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpfaqqyq8e.swift:19:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpfaqqyq8e.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let mut words = words.map(String.init)\n    let mut letters\
    \ = words.count\n    let mut evenLetters = 0\n    let mut oddLetters = 0\n   \
    \ for word in words {\n        let letter = word.characters.count\n        if\
    \ letter % 2 == 0 {\n            evenLetters += letter\n        } else {\n   \
    \         oddLetters += letter\n        }\n    }\n    if evenLetters == words.count\
    \ {\n        return Ok(words)\n    }\n    if oddLetters == words.count {\n   \
    \     return Ok(words.map { $0.lowercased() })\n    }\n    return Err(25)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkoygauq9.swift:16:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut words =\
    \ words.map(String.init)\n            ^\n/tmp/tmpkoygauq9.swift:16:13: note: join\
    \ the identifiers together\n    let mut words = words.map(String.init)\n     \
    \   ~~~~^~~~~\n        mutwords\n/tmp/tmpkoygauq9.swift:16:13: note: join the\
    \ identifiers together with camel-case\n    let mut words = words.map(String.init)\n\
    \        ~~~~^~~~~\n        mutWords\n/tmp/tmpkoygauq9.swift:17:13: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut letters = words.count\n            ^\n/tmp/tmpkoygauq9.swift:17:13:\
    \ note: join the identifiers together\n    let mut letters = words.count\n   \
    \     ~~~~^~~~~~~\n        mutletters\n/tmp/tmpkoygauq9.swift:17:13: note: join\
    \ the identifiers together with camel-case\n    let mut letters = words.count\n\
    \        ~~~~^~~~~~~\n        mutLetters\n/tmp/tmpkoygauq9.swift:18:13: error:\
    \ found an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut evenLetters = 0\n            ^\n/tmp/tmpkoygauq9.swift:18:13:\
    \ note: join the identifiers together\n    let mut evenLetters = 0\n        ~~~~^~~~~~~~~~~\n\
    \        mutevenLetters\n/tmp/tmpkoygauq9.swift:18:13: note: join the identifiers\
    \ together with camel-case\n    let mut evenLetters = 0\n        ~~~~^~~~~~~~~~~\n\
    \        mutEvenLetters\n/tmp/tmpkoygauq9.swift:19:13: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \   let mut oddLetters = 0\n            ^\n/tmp/tmpkoygauq9.swift:19:13: note:\
    \ join the identifiers together\n    let mut oddLetters = 0\n        ~~~~^~~~~~~~~~\n\
    \        mutoddLetters\n/tmp/tmpkoygauq9.swift:19:13: note: join the identifiers\
    \ together with camel-case\n    let mut oddLetters = 0\n        ~~~~^~~~~~~~~~\n\
    \        mutOddLetters\n/tmp/tmpkoygauq9.swift:9:21: error: value of type 'String'\
    \ has no member 'components'\n    let words = txt.components(separatedBy: \" \"\
    )\n                ~"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n     \
    \   return Ok(words)\n    }\n    let wordCount = words.count\n    let letterCount\
    \ = words.reduce(0) { (acc, word) -> Int in\n        if let letter = word.unicodeScalars.first\
    \ {\n            return acc + Int(letter)\n        }\n        return acc\n   \
    \ }\n    if letterCount % 2 == 1 {\n        return Ok(words)\n    }\n    return\
    \ Err(Int(letterCount / 2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpipp7__m5.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpipp7__m5.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpipp7__m5.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpipp7__m5.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpipp7__m5.swift:26:12: error: cannot find\
    \ 'Err' in scope\n    return Err(Int(letterCount / 2))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    let wordCount = words.count\n    let charCount =\
    \ txt.characters.count\n    \n    if charCount % wordCount != 0 {\n        return\
    \ Err(25)\n    }\n    \n    let chars = Array(txt.characters)\n    \n    var words:\
    \ [String] = []\n    for i in 0..<wordCount {\n        let start = chars.index(after:\
    \ chars.startIndex, offsetBy: i * charCount)\n        let end = chars.index(after:\
    \ start, offsetBy: charCount)\n        words.append(String(chars[start..<end]))\n\
    \    }\n    \n    if words.count % 2 == 1 {\n        return Ok(words)\n    }\n\
    \    \n    return Ok(words.filter { (word) -> Bool in\n        return word.lowercaseString.characters.count\
    \ % 2 == 1\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl5rqudk0.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpl5rqudk0.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpl5rqudk0.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpl5rqudk0.swift:17:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let charCount = txt.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpl5rqudk0.swift:20:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpl5rqudk0.swift:23:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    let chars = Array(txt.characters)\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpl5rqudk0.swift:33:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words)\n               ^~\n/tmp/tmpl5rqudk0.swift:36:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.filter { (word) -> Bool in\n\
    \           ^~\n/tmp/tmpl5rqudk0.swift:37:21: error: value of type 'String' has\
    \ no member 'lowercaseString'\n        return word.lowercaseString.characters.count\
    \ % 2 == 1\n               ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpl5rqudk0.swift:27:27:\
    \ error: no exact matches in call to instance method 'index'\n        let start\
    \ = chars.index(after: chars.startIndex, offsetBy: i * charCount)\n          \
    \                ^\n/tmp/tmpl5rqudk0.swift:27:27: note: found candidate with type\
    \ '(Int, Int) -> Int'\n        let start = chars.index(after: chars.startIndex,\
    \ offsetBy: i * charCount)\n                          ^\n/tmp/tmpl5rqudk0.swift:28:25:\
    \ error: no exact matches in call to instance method 'index'\n        let end\
    \ = chars.index(after: start, offsetBy: charCount)\n "
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else {\n        return\
    \ Err(words.count / 2)\n    }\n    \n    let letters = words.map { $0.lowercased()\
    \ }\n    \n    return Ok(letters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7en9oox1.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp7en9oox1.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp7en9oox1.swift:12:16: error: cannot find\
    \ 'Err' in scope\n        return Err(words.count / 2)\n               ^~~\n/tmp/tmp7en9oox1.swift:17:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(letters)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let words: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n    let wordCount = words.count\n    let letterCount\
    \ = words.map { $0.characters.count }.reduce(0, +)\n    if letterCount % 2 ==\
    \ 1 {\n        return Ok(words)\n    }\n    return Err(letterCount)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3_5vjxbo.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmp3_5vjxbo.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmp3_5vjxbo.swift:16:42:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \    let words: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                      ~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3_5vjxbo.swift:16:66:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                                ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3_5vjxbo.swift:16:9: error: invalid redeclaration of 'words'\n    let\
    \ words: [String] = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n        ^\n/tmp/tmp3_5vjxbo.swift:9:9: note: 'words' previously declared\
    \ here\n    let words = txt.split(separator: \" \")\n        ^\n/tmp/tmp3_5vjxbo.swift:20:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp3_5vjxbo.swift:22:12: error: cannot find 'Err' in scope\n    return Err(letterCount)\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    guard words.count >\
    \ 0 else { return Err(0) }\n    guard words.count % 2 == 0 else {\n        return\
    \ Err(words.count / 2)\n    }\n    \n    var result = [String]()\n    for word\
    \ in words {\n        let letters = word.split(separator: \",\")\n        guard\
    \ letters.count > 0 else { return Err(0) }\n        guard letters.count % 2 ==\
    \ 0 else {\n            return Err(letters.count / 2)\n        }\n        \n \
    \       for letter in letters {\n            let lowercase = String(letter).lowercased()\n\
    \            if let index = result.index(of: lowercase) {\n                result[index]\
    \ = result[index] + letter\n            } else {\n                result.append(lowercase)\n\
    \            }\n        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp40zzop88.swift:10:41: error: cannot find 'Err' in scope\n    guard\
    \ words.count > 0 else { return Err(0) }\n                                   \
    \     ^~~\n/tmp/tmp40zzop88.swift:12:16: error: cannot find 'Err' in scope\n \
    \       return Err(words.count / 2)\n               ^~~\n/tmp/tmp40zzop88.swift:18:47:\
    \ error: cannot find 'Err' in scope\n        guard letters.count > 0 else { return\
    \ Err(0) }\n                                              ^~~\n/tmp/tmp40zzop88.swift:20:20:\
    \ error: cannot find 'Err' in scope\n            return Err(letters.count / 2)\n\
    \                   ^~~\n/tmp/tmp40zzop88.swift:25:35: warning: 'index(of:)' is\
    \ deprecated: renamed to 'firstIndex(of:)'\n            if let index = result.index(of:\
    \ lowercase) {\n                                  ^\n/tmp/tmp40zzop88.swift:25:35:\
    \ note: use 'firstIndex(of:)' instead\n            if let index = result.index(of:\
    \ lowercase) {\n                                  ^~~~~\n                    \
    \              firstIndex\n/tmp/tmp40zzop88.swift:33:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    let wordArray = words.map { $0.lowercased() }\n    \n    if wordArray.count\
    \ % 2 == 1 {\n        return Err(25)\n    }\n    \n    let evenWordArray = wordArray.filter\
    \ { (word: String) -> Bool in\n        return word % 2 == 0\n    }\n    \n   \
    \ let evenWordCount = evenWordArray.count\n    \n    let evenWordArraySorted =\
    \ evenWordArray\n        .sorted()\n        .map { $0.lowercased() }\n    \n \
    \   if evenWordArraySorted.count % 2 == 1 {\n        return Err(25)\n    }\n \
    \   \n    let evenWordArraySortedCount = evenWordArraySorted.count\n    \n   \
    \ let evenWordArraySortedSortedCount = evenWordArraySorted\n        .sorted()\n\
    \        .map { $0.lowercased() }\n    \n    if evenWordArraySortedSortedCount\
    \ == wordCount {\n        return evenWordArraySortedSortedCount\n    }\n    \n\
    \    return evenWordArraySortedCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4979yr68.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp4979yr68.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp4979yr68.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmp4979yr68.swift:23:16: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n        return word % 2 == 0\n               ^\n\
    /tmp/tmp4979yr68.swift:33:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errDomain))\n    }\n    \n    var result = [String]()\n    \n    for\
    \ word in words {\n        if let wordCount = word.split(separator: \",\").count\
    \ {\n            result.append(word)\n        } else {\n            result.append(word.lowercased())\n\
    \        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpaxdkhfix.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errDomain))\n               ^~~\n/tmp/tmpaxdkhfix.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errDomain))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpaxdkhfix.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaxdkhfix.swift:17:20:\
    \ error: no exact matches in call to instance method 'append'\n            result.append(word)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n   \
    \ @inlinable public mutating func append(_ newElement: __owned Element)\n    \
    \                                ^\nSwift.RangeReplaceableCollection:4:37: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpaxdkhfix.swift:17:20:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n            result.append(word)\n                   ^\n\
    /tmp/tmpaxdkhfix.swift:16:12: error: initializer for conditional binding must\
    \ have Optional type, not 'Int'\n        if let wordCount = word.split(separator:\
    \ \",\").count {\n           ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpaxdkhfix.swift:23:12: error: cannot find 'Ok' in scope\n    return Ok(result)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(Int((txt.characters.count / 2) - 1))\n    }\n\
    \    guard words.count % 2 == 0 else {\n        return Err(Int((txt.characters.count\
    \ / 2) - 1))\n    }\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbmumwycc.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpbmumwycc.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count / 2) - 1))\n        \
    \       ^~~\n/tmp/tmpbmumwycc.swift:14:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int((txt.characters.count / 2) - 1))\n               ^~~\n\
    /tmp/tmpbmumwycc.swift:16:12: error: cannot find 'Ok' in scope\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n           ^~\n/tmp/tmpbmumwycc.swift:16:54:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n                                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    let letterCount = words.map { $0.characters.count }.reduce(0, +)\n\
    \    \n    return Ok(wordCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqc5bsqo0.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpqc5bsqo0.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpqc5bsqo0.swift:18:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(wordCount)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    var result = [String]()\n \
    \   for word in words {\n        let wordArray = word.components(separatedBy:\
    \ \",\")\n        if wordArray.count == 0 {\n            return Err(25)\n    \
    \    }\n        \n        for word in wordArray {\n            let lowercaseLetters\
    \ = word.characters.filter({ $0 >= 'a' && $0 <= 'z' }).count\n            if lowercaseLetters\
    \ % 2 == 1 {\n                result.append(word)\n            }\n        }\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp773lvtlv.swift:22:67: error: single-quoted string literal found,\
    \ use '\"'\n            let lowercaseLetters = word.characters.filter({ $0 >=\
    \ 'a' && $0 <= 'z' }).count\n                                                \
    \                  ^~~\n                                                     \
    \             \"a\"\n/tmp/tmp773lvtlv.swift:22:80: error: single-quoted string\
    \ literal found, use '\"'\n            let lowercaseLetters = word.characters.filter({\
    \ $0 >= 'a' && $0 <= 'z' }).count\n                                          \
    \                                     ^~~\n                                  \
    \                                             \"z\"\n/tmp/tmp773lvtlv.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp773lvtlv.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmp773lvtlv.swift:29:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 1 {\n        return Ok([words[0]])\n    }\n    \n \
    \   let wordCount2 = wordCount.filter { (word: String) -> Bool in\n        return\
    \ !word.isEmpty\n    }\n    \n    if wordCount2 == 0 {\n        return Err(25)\n\
    \    }\n    \n    let wordCount3 = wordCount2.filter { (word: String) -> Bool\
    \ in\n        return !word.isEmpty\n    }\n    \n    if wordCount3 == 0 {\n  \
    \      return Err(25)\n    }\n    \n    let wordCount4 = wordCount3.filter { (word:\
    \ String) -> Bool in\n        return !word.isEmpty\n    }\n    \n    if wordCount4\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount5 = wordCount4.filter\
    \ { (word: String) -> Bool in\n        return !word.isEmpty\n    }\n    \n   \
    \ if wordCount5 == 0 {\n        return Err(25)\n    }\n    \n    let wordCount6\
    \ = wordCount5.filter { (word: String) -> Bool in\n        return !word.isEmpty\n\
    \    }\n    \n    if wordCount6 == 0 {\n        return Err(25)\n    }\n    \n\
    \    let wordCount7 = wordCount6.filter { (word: String) -> Bool in\n        return\
    \ !word.isEmpty\n    }\n    \n    if wordCount7 == 0 {\n        return Err(25)\n\
    \    }\n    \n    let wordCount8 = wordCount7.filter { (word: String) -> Bool\
    \ in\n        return !word.isEmpty\n    }\n    \n    if wordCount8 == 0 {\n  \
    \      return Err(25)\n    }\n    \n    let wordCount9 = wordCount8.filter { (word:\
    \ String) -> Bool in\n        return !word.isEmpty\n    }\n    \n    if wordCount9\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount10 = wordCount9.filter\
    \ { (word: String) -> Bool in\n        return !word.isEmpty\n    }\n    \n   \
    \ if wordCount10 == 0 {\n        return Err(25)\n    }\n    \n    let wordCount11\
    \ = wordCount10.filter { (word: String) -> Bool in\n        return !word.isEmpty\n\
    \    }\n    \n    if wordCount11 == 0 {\n        return Err(25)\n    }\n    \n\
    \    let wordCount12 = wordCount11.filter { (word: String) -> Bool in\n      \
    \  return !word.isEmpty\n    }\n    \n    if wordCount12\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp75j_vy6.swift:105:19: error: expected '{' after 'if' condition\n\
    \    if wordCount12\n                  ^\n/tmp/tmpp75j_vy6.swift:9:21: error:\
    \ value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpp75j_vy6.swift:12:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpp75j_vy6.swift:26:16: error: cannot find 'Err' in scope\n  \
    \      return Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:34:16: error:\
    \ cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:42:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpp75j_vy6.swift:50:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:58:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:66:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpp75j_vy6.swift:74:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:82:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpp75j_vy6.swift:90:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpp75j_vy6.swift:98:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let comma = words.last\n    if comma == \"\" {\n     \
    \   return Ok(words)\n    }\n    if comma == \",\" {\n        return Ok(words.dropLast())\n\
    \    }\n    return Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2x9sfbny.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmp2x9sfbny.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp2x9sfbny.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp2x9sfbny.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropLast())\n               ^~\n/tmp/tmp2x9sfbny.swift:23:12: error:\
    \ cannot find 'Err' in scope\n    return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    let wordArray = words.map { $0.lowercased()\
    \ }\n    if wordArray.count == 0 {\n        return Err(25)\n    }\n    let wordArrayCount\
    \ = wordArray.count\n    let evenArray = wordArray.filter { $0 % 2 == 0 }\n  \
    \  let oddArray = wordArray.filter { $0 % 2 != 0 }\n    let evenArrayCount = evenArray.count\n\
    \    let oddArrayCount = oddArray.count\n    if evenArrayCount == wordArrayCount\
    \ {\n        return Ok([evenArray])\n    }\n    if oddArrayCount == wordArrayCount\
    \ {\n        return Ok([oddArray])\n    }\n    return Err(25)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk3srpczg.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpk3srpczg.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpk3srpczg.swift:15:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpk3srpczg.swift:23:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([evenArray])\n               ^~\n/tmp/tmpk3srpczg.swift:26:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok([oddArray])\n               ^~\n/tmp/tmpk3srpczg.swift:28:12:\
    \ error: cannot find 'Err' in scope\n    return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errUnknown))\n    }\n    \n    var result: [String] = []\n    \n  \
    \  for word in words {\n        guard let wordWithoutSpaces = word.trimmingCharacters(in:\
    \ .whitespaces) else {\n            return Err(Int(.errUnknown))\n        }\n\
    \        \n        guard let wordWithoutCommas = wordWithoutSpaces.split(separator:\
    \ \",\") else {\n            return Err(Int(.errUnknown))\n        }\n       \
    \ \n        for wordWithoutComma in wordWithoutCommas {\n            guard let\
    \ wordWithoutLowercaseLetters = wordWithoutComma.lowercased() else {\n       \
    \         return Err(Int(.errUnknown))\n            }\n            \n        \
    \    if wordWithoutLowercaseLetters.count % 2 == 1 {\n                result.append(wordWithoutLowercaseLetters)\n\
    \            }\n        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfkg1mpn8.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpfkg1mpn8.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpfkg1mpn8.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfkg1mpn8.swift:16:44:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpfkg1mpn8.swift:16:68:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                                                  ~^~~~~~~~~~~\n\
    /tmp/tmpfkg1mpn8.swift:17:20: error: cannot find 'Err' in scope\n            return\
    \ Err(Int(.errUnknown))\n                   ^~~\n/tmp/tmpfkg1mpn8.swift:17:28:\
    \ error: missing argument label 'bitPattern:' in call\n            return Err(Int(.errUnknown))\n\
    \                           ^\n                           bitPattern: \n/tmp/tmpfkg1mpn8.swift:21:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.errUnknown))\n\
    \                   ^~~\n/tmp/tmpfkg1mpn8.swift:21:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.errUnknown))\n    \
    \                       ^\n                           bitPattern: \n/tmp/tmpfkg1mpn8.swift:35:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let letterCount = words.reduce(0)\
    \ { (result, word) -> Int in\n        let letterCount = word.characters.count\n\
    \        return result + letterCount\n    }\n    if letterCount % 2 == 1 {\n \
    \       return Ok(words)\n    }\n    return Err(letterCount)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpr6t6tjtv.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpr6t6tjtv.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpr6t6tjtv.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpr6t6tjtv.swift:19:23: error: cannot convert return expression of type\
    \ 'String' to return type 'Int'\n        return result + letterCount\n       \
    \        ~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpr6t6tjtv.swift:22:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpr6t6tjtv.swift:24:12:\
    \ error: cannot find 'Err' in scope\n    return Err(letterCount)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map { $0.lowercased() }\n    let odd\
    \ = letters.filter { $0 % 2 == 1 }\n    if odd.count == 0 {\n        return Ok(words)\n\
    \    }\n    return Err(odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpunpaqpt3.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpunpaqpt3.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpunpaqpt3.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpunpaqpt3.swift:19:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpunpaqpt3.swift:21:12: error: cannot find\
    \ 'Err' in scope\n    return Err(odd.count)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    guard wordCount > 1 else {\n        return Err(25)\n    }\n    \n \
    \   let wordCountUpper = wordCount.filter { $0.isUppercase }\n    guard wordCountUpper.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    let wordCountLower = wordCount.filter\
    \ { $0.isLowercase }\n    guard wordCountLower.count > 0 else {\n        return\
    \ Err(25)\n    }\n    \n    let wordCountOdd = wordCount.filter { $0.isOdd }\n\
    \    guard wordCountOdd.count > 0 else {\n        return Err(25)\n    }\n    \n\
    \    let wordCountEven = wordCount.filter { $0.isEven }\n    guard wordCountEven.count\
    \ > 0 else {\n        return Err(25)\n    }\n    \n    return Ok(words)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpj370c_fi.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpj370c_fi.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpj370c_fi.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpj370c_fi.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpj370c_fi.swift:27:16: error: cannot find\
    \ 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpj370c_fi.swift:32:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpj370c_fi.swift:37:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpj370c_fi.swift:40:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    \n    let wordCount = words.count\n    \n  \
    \  let wordCountWithCommas = wordCount.map { $0.count }.reduce(0, +)\n    \n \
    \   let letterCount = txt.characters.reduce(0) { $0 + $1.count }\n    \n    let\
    \ letterCountWithCommas = letterCount.map { $0.count }.reduce(0, +)\n    \n  \
    \  let letterCountWithCommasWithOddOrder = letterCountWithCommas.map { $0 + $1\
    \ }.reduce(0, +)\n    \n    return Ok([words[0], wordCountWithCommas, letterCountWithCommas,\
    \ letterCountWithCommasWithOddOrder])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5hqbmqcd.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp5hqbmqcd.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp5hqbmqcd.swift:16:44: error: missing argument\
    \ label 'into:' in call\n    let letterCount = txt.characters.reduce(0) { $0 +\
    \ $1.count }\n                                           ^\n                 \
    \                           into: \n/tmp/tmp5hqbmqcd.swift:22:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok([words[0], wordCountWithCommas, letterCountWithCommas,\
    \ letterCountWithCommasWithOddOrder])\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map(String.init)\n    let letterCount\
    \ = letters.reduce(0) { (result, letter) -> Int in\n        if let _ = letter,\
    \ let _ = result {\n            return 1\n        }\n        return result + 1\n\
    \    }\n    if letterCount % 2 == 1 {\n        return Ok(words)\n    }\n    return\
    \ Err(letterCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_um7cydn.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_um7cydn.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp_um7cydn.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp_um7cydn.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp_um7cydn.swift:26:12: error: cannot find\
    \ 'Err' in scope\n    return Err(letterCount)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    if words.count == 2 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    if words.count % 2 == 1 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    if words.count % 2 == 0 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    return Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplmk139ml.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmplmk139ml.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmplmk139ml.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmplmk139ml.swift:17:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmplmk139ml.swift:20:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmplmk139ml.swift:23:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words.map { $0.lowercased() })\n               ^~\n\
    /tmp/tmplmk139ml.swift:25:12: error: cannot find 'Err' in scope\n    return Err(25)\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.lettersWithDigitsOnly))\n    }\n    \n    var result = [String]()\n\
    \    \n    for word in words {\n        guard let letters = word.split(separator:\
    \ \",\") else {\n            return Err(Int(.lettersWithDigitsOnly))\n       \
    \ }\n        \n        for letter in letters {\n            guard let letter =\
    \ letter.trimmingCharacters(in: .whitespaces) else {\n                return Err(Int(.lettersWithDigitsOnly))\n\
    \            }\n            \n            if let index = alphabet.index(of: letter)\
    \ {\n                result.append(String(letter))\n            } else {\n   \
    \             return Err(Int(.lettersWithDigitsOnly))\n            }\n       \
    \ }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphdkhhfed.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.lettersWithDigitsOnly))\n               ^~~\n/tmp/tmphdkhhfed.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lettersWithDigitsOnly))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmphdkhhfed.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphdkhhfed.swift:17:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.lettersWithDigitsOnly))\n\
    \                   ^~~\n/tmp/tmphdkhhfed.swift:17:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.lettersWithDigitsOnly))\n\
    \                           ^\n                           bitPattern: \n/tmp/tmphdkhhfed.swift:16:15:\
    \ error: initializer for conditional binding must have Optional type, not '[Substring.SubSequence]'\
    \ (aka 'Array<Substring>')\n        guard let letters = word.split(separator:\
    \ \",\") else {\n              ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphdkhhfed.swift:21:39:\
    \ error: value of type 'Substring.SubSequence' (aka 'Substring') has no member\
    \ 'trimmingCharacters'\n            guard let letter = letter.trimmingCharacters(in:\
    \ .whitespaces) else {\n                               ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphdkhhfed.swift:21:63: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n            guard let letter = letter.trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \        ~^~~~~~~~~~~\n/tmp/tmphdkhhfed.swift:22:24: error: cannot find 'Err'\
    \ in scope\n                return Err(Int(.lettersWithDigitsOnly))\n        \
    \               ^~~\n/tmp/tmphdkhhfed.swift:22:32: error: missing argument label\
    \ 'bitPattern:' in call\n                return Err(Int(.lettersWithDigitsOnly))\n\
    \                               ^\n                  "
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.letters))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_p7ooht9.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.letters))\n               ^~~\n/tmp/tmp_p7ooht9.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.letters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp_p7ooht9.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_p7ooht9.swift:12:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    guard let letters = words.map({ $0.lowercased() }).reduce(into: []) {\n\
    \        letters.append(contentsOf: [\"\"])\n        letters.indices.forEach {\
    \ letters[$0].append($1) }\n    }\n    return Ok(letters)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3s6ekmdi.swift:12:73: error: expected 'else' after 'guard' condition\n\
    \    guard let letters = words.map({ $0.lowercased() }).reduce(into: []) {\n \
    \                                                                       ^\n  \
    \                                                                      else \n\
    /tmp/tmp3s6ekmdi.swift:9:21: error: value of type 'String' has no member 'components'\n\
    \    let words = txt.components(separatedBy: \" \")\n                ~~~ ^~~~~~~~~~\n\
    /tmp/tmp3s6ekmdi.swift:10:41: error: cannot find 'Err' in scope\n    guard words.count\
    \ > 0 else { return Err(0) }\n                                        ^~~\n/tmp/tmp3s6ekmdi.swift:11:46:\
    \ error: cannot find 'Err' in scope\n    guard words.count % 2 == 0 else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmp3s6ekmdi.swift:13:9:\
    \ error: cannot find 'letters' in scope\n        letters.append(contentsOf: [\"\
    \"])\n        ^~~~~~~\n/tmp/tmp3s6ekmdi.swift:14:9: error: cannot find 'letters'\
    \ in scope\n        letters.indices.forEach { letters[$0].append($1) }\n     \
    \   ^~~~~~~\n/tmp/tmp3s6ekmdi.swift:14:35: error: cannot find 'letters' in scope\n\
    \        letters.indices.forEach { letters[$0].append($1) }\n                \
    \                  ^~~~~~~\n/tmp/tmp3s6ekmdi.swift:16:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(letters)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.trimmingCharacters(in: .whitespaces) } }\n    guard splitWords.count\
    \ > 0 else { return Err(0) }\n    let letters = splitWords.map { $0.count }\n\
    \    guard letters.count > 0 else { return Err(0) }\n    let oddLetters = letters.filter\
    \ { $0 % 2 == 1 }\n    guard oddLetters.count > 0 else { return Err(0) }\n   \
    \ return Ok(oddLetters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpayt778a8.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpayt778a8.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpayt778a8.swift:11:99: error: cannot infer\
    \ contextual base in reference to member 'whitespaces'\n    let splitWords = words.map\
    \ { $0.components(separatedBy: \",\").map { $0.trimmingCharacters(in: .whitespaces)\
    \ } }\n                                                                      \
    \                           ~^~~~~~~~~~~\n/tmp/tmpayt778a8.swift:12:46: error:\
    \ cannot find 'Err' in scope\n    guard splitWords.count > 0 else { return Err(0)\
    \ }\n                                             ^~~\n/tmp/tmpayt778a8.swift:14:43:\
    \ error: cannot find 'Err' in scope\n    guard letters.count > 0 else { return\
    \ Err(0) }\n                                          ^~~\n/tmp/tmpayt778a8.swift:16:46:\
    \ error: cannot find 'Err' in scope\n    guard oddLetters.count > 0 else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpayt778a8.swift:17:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(oddLetters)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else { return Err(0) }\n    guard !words.contains(\",\") else { return Err(1)\
    \ }\n    guard !words.contains(\".\") else { return Err(2) }\n    guard !words.contains(\"\
    !\") else { return Err(3) }\n    guard !words.contains(\"?\") else { return Err(4)\
    \ }\n    guard !words.contains(\":\") else { return Err(5) }\n    guard !words.contains(\"\
    ;\") else { return Err(6) }\n    guard !words.contains(\",\") else { return Err(7)\
    \ }\n    guard !words.contains(\".\") else { return Err(8) }\n    guard !words.contains(\"\
    !\") else { return Err(9) }\n    guard !words.contains(\"?\") else { return Err(10)\
    \ }\n    guard !words.contains(\":\") else { return Err(11) }\n    guard !words.contains(\"\
    ;\") else { return Err(12) }\n    guard !words.contains(\",\") else { return Err(13)\
    \ }\n    guard !words.contains(\".\") else { return Err(14) }\n    guard !words.contains(\"\
    !\") else { return Err(15) }\n    guard !words.contains(\"?\") else { return Err(16)\
    \ }\n    guard !words.contains(\":\") else { return Err(17) }\n    guard !words.contains(\"\
    ;\") else { return Err(18) }\n    guard !words.contains(\",\") else { return Err(19)\
    \ }\n    guard !words.contains(\".\") else { return Err(20) }\n    guard !words.contains(\"\
    !\") else { return Err(21) }\n    guard !words.contains(\"?\") else { return Err(22)\
    \ }\n    guard !words.contains(\":\") else { return Err(23) }\n    guard !words.contains(\"\
    ;\") else { return Err(24) }\n    guard !words.contains(\",\") else { return Err(25)\
    \ }\n    guard !words.contains(\".\") else { return Err(26) }\n    guard !words.contains(\"\
    !\") else { return Err(27) }\n    guard !words.contains(\"?\") else { return Err(28)\
    \ }\n    guard !words.contains(\":\") else { return Err(29) }\n    guard !words.contains(\"\
    ;\") else { return Err(30) }\n    guard !words.contains(\",\") else { return Err(31)\
    \ }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp74lsp377.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp74lsp377.swift:10:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmp74lsp377.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard !words.contains(\",\") else { return Err(1) }\n  \
    \                                           ^~~\n/tmp/tmp74lsp377.swift:12:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(2) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:13:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") else { return\
    \ Err(3) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:14:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"?\") else { return\
    \ Err(4) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:15:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(5) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:16:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(6) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:17:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\",\") else { return\
    \ Err(7) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:18:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(8) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:19:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") else { return\
    \ Err(9) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:20:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"?\") else { return\
    \ Err(10) }\n                                             ^~~\n/tmp/tmp74lsp377.swift:21:46:\
    \ error: cannot find 'Err' i"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    guard words.count % 2 == 0 else { return Err(0)\
    \ }\n    let letters = words.map { String($0).lowercased() }\n    let evenLetters\
    \ = letters.filter { $0.count % 2 == 0 }\n    let oddLetters = letters.filter\
    \ { $0.count % 2 != 0 }\n    return Ok(evenLetters + oddLetters)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmwvzic8g.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpmwvzic8g.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpmwvzic8g.swift:11:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpmwvzic8g.swift:15:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(evenLetters + oddLetters)\n       \
    \    ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let letters = words.map { $0.lowercased() }\n    if letters.count\
    \ == 0 {\n        return Err(25)\n    }\n    if letters.count == 1 {\n       \
    \ return Ok(words)\n    }\n    let odd = letters.filter { $0 % 2 == 1 }\n    if\
    \ odd.count == 0 {\n        return Ok(words)\n    }\n    if odd.count == 1 {\n\
    \        return Ok(odd)\n    }\n    return Err(25)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa0ftcpbn.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpa0ftcpbn.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpa0ftcpbn.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpa0ftcpbn.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpa0ftcpbn.swift:21:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpa0ftcpbn.swift:25:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpa0ftcpbn.swift:28:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(odd)\n               ^~\n/tmp/tmpa0ftcpbn.swift:30:12: error: cannot find\
    \ 'Err' in scope\n    return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else { return Err(0) }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\") }\n    guard !splitWords.isEmpty else { return Err(0) }\n    let letters\
    \ = splitWords.map { $0.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmpb4djdvkv.swift:14:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpb4djdvkv.swift:36:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpb4djdvkv.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpb4djdvkv.swift:9:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpb4djdvkv.swift:10:40: error:\
    \ cannot find 'Err' in scope\n    guard !words.isEmpty else { return Err(0) }\n\
    \                                       ^~~\n/tmp/tmpb4djdvkv.swift:12:45: error:\
    \ cannot find 'Err' in scope\n    guard !splitWords.isEmpty else { return Err(0)\
    \ }\n                                            ^~~\n"
  stdout: ''
  timestamp: 1660054523
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    let wordCount = words.count\n   \
    \ let wordArray = words.map { $0.lowercased() }\n    if wordArray.count % 2 ==\
    \ 1 {\n        return Ok(wordArray)\n    }\n    return Ok(wordArray.filter { $0.count\
    \ % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwulbb48d.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwulbb48d.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpwulbb48d.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(wordArray)\n           \
    \    ^~\n/tmp/tmpwulbb48d.swift:18:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(wordArray.filter { $0.count % 2 == 1 })\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.errUnknown))\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 0 {\n        return Err(Int(.errUnknown))\n    }\n\
    \    \n    if wordCount == 1 {\n        return Ok([words[0]])\n    }\n    \n \
    \   let wordArray = words.map { $0.lowercased() }\n    \n    let evenWords = wordArray.filter\
    \ { $0.count % 2 == 0 }\n    let oddWords = wordArray.filter { $0.count % 2 !=\
    \ 0 }\n    \n    return Ok([evenWords, oddWords])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpejq89f9k.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpejq89f9k.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n         \
    \      ^~~\n/tmp/tmpejq89f9k.swift:10:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errUnknown))\n                       ^\n  \
    \                     bitPattern: \n/tmp/tmpejq89f9k.swift:16:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.errUnknown))\n               ^~~\n\
    /tmp/tmpejq89f9k.swift:16:24: error: missing argument label 'bitPattern:' in call\n\
    \        return Err(Int(.errUnknown))\n                       ^\n            \
    \           bitPattern: \n/tmp/tmpejq89f9k.swift:20:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok([words[0]])\n               ^~\n/tmp/tmpejq89f9k.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([evenWords, oddWords])\n   \
    \        ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n    if wordArray.count == 0 {\n        return Err(Int(1))\n    }\n    let\
    \ wordArrayCount = wordArray.count\n    let letterCount = wordArray.reduce(0)\
    \ { $0 + $1.count }\n    if letterCount % 2 == 1 {\n        return Err(Int(1))\n\
    \    }\n    if wordArrayCount != wordCount {\n        return Err(Int(1))\n   \
    \ }\n    return Ok(wordArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptwto0trj.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptwto0trj.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmptwto0trj.swift:14:60:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let wordArray = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                          ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptwto0trj.swift:16:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(1))\n               ^~~\n/tmp/tmptwto0trj.swift:21:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmptwto0trj.swift:24:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmptwto0trj.swift:26:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(wordArray)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if words.count % 2 == 1 {\n        return Err(25)\n    }\n    \n  \
    \  let wordArray = words.enumerated().map { (index, word) -> String in\n     \
    \   if index == wordCount / 2 {\n            return word\n        } else {\n \
    \           return word\n        }\n    }\n    \n    return Ok(wordArray)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm5xx4svi.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpm5xx4svi.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpm5xx4svi.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpm5xx4svi.swift:28:12: error: cannot find 'Ok' in scope\n    return Ok(wordArray)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    \n    let wordCount = [String: Int]()\n    for word\
    \ in words {\n        let wordCount = word.split(separator: \",\").count\n   \
    \     if wordCount == 1 {\n            wordCount[word] = wordCount\n        }\
    \ else {\n            let letterCount = [String: Int]()\n            for letter\
    \ in word {\n                let letterCount = letter.split(separator: \"\").count\n\
    \                letterCount[letter] = letterCount\n            }\n          \
    \  wordCount[word] = letterCount\n        }\n    }\n    \n    let letterCount\
    \ = [String: Int]()\n    for letter in \"abcdefghijklmnopqrstuvwxyz\".characters\
    \ {\n        let letterCount = txt.split(separator: \"\").count\n        letterCount[String(letter)]\
    \ = letterCount\n    }\n    \n    return Ok(wordCount)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa3ojv068.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpa3ojv068.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpa3ojv068.swift:21:22:\
    \ error: value of type 'Int' has no subscripts\n            wordCount[word] =\
    \ wordCount\n            ~~~~~~~~~^\n/tmp/tmpa3ojv068.swift:25:42: error: value\
    \ of type 'Character' has no member 'split'\n                let letterCount =\
    \ letter.split(separator: \"\").count\n                                  ~~~~~~\
    \ ^~~~~\n/tmp/tmpa3ojv068.swift:28:22: error: value of type 'Int' has no subscripts\n\
    \            wordCount[word] = letterCount\n            ~~~~~~~~~^\n/tmp/tmpa3ojv068.swift:33:48:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in \"abcdefghijklmnopqrstuvwxyz\".characters {\n                           \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpa3ojv068.swift:35:20: error: value of type 'Int' has no subscripts\n\
    \        letterCount[String(letter)] = letterCount\n        ~~~~~~~~~~~^\n/tmp/tmpa3ojv068.swift:38:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(wordCount)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n     \
    \   return Ok(words)\n    }\n    if words.count % 2 == 1 {\n        return Err(Int(words.count))\n\
    \    }\n    let even = words.filter{ $0.isEmpty == false }\n    let odd = words.filter{\
    \ $0.isEmpty == false && $0.lowercased() != $0.lowercased().reversed().lowercased()\
    \ }\n    return Ok([even, odd])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7vdh56ua.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp7vdh56ua.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp7vdh56ua.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp7vdh56ua.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(words.count))\n               ^~~\n/tmp/tmp7vdh56ua.swift:21:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([even, odd])\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    \n    let words: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n    \n    if words.count == 0 {\n        return\
    \ Err(25)\n    }\n    \n    if words.count == 1 {\n        return Ok(words)\n\
    \    }\n    \n    let letters: [String] = words.map { $0.lowercased() }\n    \n\
    \    if letters.count == 0 {\n        return Err(25)\n    }\n    \n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    \n    let letters: [String] =\
    \ letters.map { $0.lowercased() }\n    \n    if letters.count == 0 {\n       \
    \ return Err(25)\n    }\n    \n    if letters.count == 1 {\n        return Ok(letters)\n\
    \    }\n    \n    let letters: [String] = letters.map { $0.lowercased() }\n  \
    \  \n    if letters.count == 0 {\n        return Err(25)\n    }\n    \n    if\
    \ letters.count == 1 {\n        return Ok(letters)\n    }\n    \n    let letters:\
    \ [String] = letters.map { $0.lowercased() }\n    \n    if letters.count == 0\
    \ {\n        return Err(25)\n    }\n    \n    if letters.count == 1 {\n      \
    \  return Ok(letters)\n    }\n    \n    let letters: [String] = letters.map {\
    \ $0.lowercased() }\n    \n    if letters.count == 0 {\n        return Err(25)\n\
    \    }\n    \n    if letters.count == 1 {\n        return Ok(letters)\n    }\n\
    \    \n    let letters: [String] = letters.map { $0.lowercased() }\n    \n   \
    \ if letters.count == 0 {\n        return Err(25)\n    }\n    \n    if letters.count\
    \ == 1 {\n        return Ok(letters)\n    }\n    \n    let letters: [String] =\
    \ letters.map { $0.lowercased() }\n    \n    if letters.count == 0 {\n       \
    \ return Err(25)\n    }\n    \n    if letters.count == 1 {\n        return Ok(letters)\n\
    \    }\n    \n    let letters: [String] = letters.map { $0.lowercased() }\n  \
    \  \n    if letters.count == 0 {\n        return Err(25)\n    }\n    \n    if\
    \ letters.count == 1 {\n        return Ok(letters)\n    }\n    \n    let letters:\
    \ [String] = letters.map { $0.lowercased() }\n    \n    if letters.count == 0\
    \ {\n        return Err(25)\n    }\n    \n    if letters.count == 1 {\n      \
    \  return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzjghuqpe.swift:137:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpzjghuqpe.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpzjghuqpe.swift:11:16: error: cannot\
    \ find 'Err' in scope\n        return Err(25)\n               ^~~\n/tmp/tmpzjghuqpe.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpzjghuqpe.swift:17:42: error: value of type 'String.SubSequence' (aka 'Substring')\
    \ has no member 'trimmingCharacters'\n    let words: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n                                      ~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzjghuqpe.swift:17:66: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlines'\n    let words: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n                                               \
    \                 ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzjghuqpe.swift:17:9: error:\
    \ invalid redeclaration of 'words'\n    let words: [String] = words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n        ^\n/tmp/tmpzjghuqpe.swift:9:9: note: 'words'\
    \ previously declared here\n    let words = txt.split(separator: \" \")\n    \
    \    ^\n/tmp/tmpzjghuqpe.swift:20:16: error: cannot find 'Err' in scope\n    \
    \    return Err(25)\n               ^~~\n/tmp/tmpzjghuqpe.swift:24:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpzjghuqpe.swift:30:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpzjghuqpe.swift:34:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(letters)\n               ^~\n/tmp/tmpzjghuqpe.swift:37:9: error: invalid\
    \ redeclaration of 'letters'\n    let letters: [String] = letters.map { $0.lowercased()\
    \ }\n        ^\n/tmp/tmpzjghuqpe.swift:27:9: note: 'letters' previously declared\
    \ here\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.map { $0.count }.max()\n    return Ok([words]) \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3mdmgcnr.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp3mdmgcnr.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp3mdmgcnr.swift:15:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words]) \n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let wordArray\
    \ = words.map { $0.lowercased() }\n    guard wordArray.count > 0 else { return\
    \ Err(0) }\n    let wordArrayCount = wordArray.count\n    guard wordArrayCount\
    \ % 2 == 1 else {\n        return Err(wordArrayCount / 2)\n    }\n    let evenWordArrayCount\
    \ = wordArrayCount / 2\n    let evenWordArray = wordArray.prefix(evenWordArrayCount)\n\
    \    let oddWordArrayCount = wordArrayCount - evenWordArrayCount\n    let oddWordArray\
    \ = wordArray.suffix(oddWordArrayCount)\n    return Ok([evenWordArray, oddWordArray])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptvlfz3ce.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptvlfz3ce.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmptvlfz3ce.swift:13:45: error: cannot find\
    \ 'Err' in scope\n    guard wordArray.count > 0 else { return Err(0) }\n     \
    \                                       ^~~\n/tmp/tmptvlfz3ce.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(wordArrayCount / 2)\n       \
    \        ^~~\n/tmp/tmptvlfz3ce.swift:22:12: error: cannot find 'Ok' in scope\n\
    \    return Ok([evenWordArray, oddWordArray])\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.letters))\n    }\n    \n    var words: [String] = []\n\
    \    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.letters))\n        }\n        \n\
    \        for letter in letters {\n            guard let letter = letter.trimmingCharacters(in:\
    \ .whitespaces) else {\n                return Err(Int(.letters))\n          \
    \  }\n            \n            guard let letter = letter.lowercased() else {\n\
    \                return Err(Int(.letters))\n            }\n            \n    \
    \        if letter != letter {\n                return Err(Int(.letters))\n  \
    \          }\n            \n            if letters.count % 2 == 1 {\n        \
    \        words.append(letter)\n            }\n        }\n    }\n    \n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmr9_8o01.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpmr9_8o01.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.letters))\n            \
    \   ^~~\n/tmp/tmpmr9_8o01.swift:10:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.letters))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmpmr9_8o01.swift:15:34: error: value of\
    \ type 'String' has no member 'components'\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n                            ~~~~ ^~~~~~~~~~\n/tmp/tmpmr9_8o01.swift:16:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.letters))\n \
    \                  ^~~\n/tmp/tmpmr9_8o01.swift:16:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.letters))\n       \
    \                    ^\n                           bitPattern: \n/tmp/tmpmr9_8o01.swift:38:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n/tmp/tmpmr9_8o01.swift:20:63:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \           guard let letter = letter.trimmingCharacters(in: .whitespaces) else\
    \ {\n                                                             ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.Failure))\n    }\n    \n    var words: [String] = []\n    \n    for\
    \ word in words {\n        if let word2 = word.split(separator: \",\") {\n   \
    \         words.append(contentsOf: word2)\n        } else {\n            words.append(word)\n\
    \        }\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeoympucn.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.Failure))\n               ^~~\n/tmp/tmpeoympucn.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpeoympucn.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpeoympucn.swift:13:9:\
    \ error: invalid redeclaration of 'words'\n    var words: [String] = []\n    \
    \    ^\n/tmp/tmpeoympucn.swift:9:15: note: 'words' previously declared here\n\
    \    guard let words = txt.split(separator: \" \") else {\n              ^\n/tmp/tmpeoympucn.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if words.count % 2 == 1 {\n        return Err(Int(wordCount))\n   \
    \ }\n    \n    let evenWords = words.filter{$0.isUpper}\n    \n    if evenWords.count\
    \ % 2 == 1 {\n        return Err(Int(wordCount))\n    }\n    \n    let evenWordCount\
    \ = evenWords.count\n    \n    if evenWordCount > wordCount {\n        return\
    \ Err(Int(wordCount))\n    }\n    \n    let evenWordsArray = evenWords.map { String($0)\
    \ }\n    \n    let evenWordsArrayCount = evenWordsArray.count\n    \n    if evenWordsArrayCount\
    \ > wordCount {\n        return Err(Int(wordCount))\n    }\n    \n    let evenWordsArrayCount\
    \ = evenWordsArray.count\n    \n    if evenWordsArrayCount % 2 == 1 {\n      \
    \  return Err(Int(wordCount))\n    }\n    \n    let evenWordsArrayCount = evenWordsArray.count\n\
    \    \n    if evenWordsArrayCount > wordCount {\n        return Err(Int(wordCount))\n\
    \    }\n    \n    let evenWordsArrayCount = evenWordsArray.count\n    \n    if\
    \ evenWordsArrayCount % 2 == 1 {\n        return Err(Int(wordCount))\n    }\n\
    \    \n    let evenWordsArrayCount = evenWordsArray.count\n    \n    if evenWordsArrayCount\
    \ > wordCount {\n        return Err(Int(wordCount))\n    }\n    \n    let evenWordsArrayCount\
    \ = evenWordsArray.count\n    \n    if evenWordsArrayCount % 2 == 1 {\n      \
    \  return Err(Int(wordCount))\n    }\n    \n    let evenWordsArrayCount = evenWordsArray.count\n\
    \    \n    if evenWordsArrayCount > wordCount {\n        return Err(Int(wordCount))\n\
    \    }\n    \n    let evenWordsArrayCount = evenWordsArray.count\n    \n    if\
    \ evenWordsArrayCount % 2 == 1 {\n        return Err(Int(wordCount))\n    }\n\
    \    \n    let evenWordsArrayCount = evenWordsArray.count\n    \n    if evenWordsArrayCount\
    \ > wordCount {\n        return Err(Int(wordCount))\n    }\n    \n    let evenWordsArrayCount\
    \ = evenWordsArray.count\n    \n    if evenWordsArrayCount % 2 == 1 {\n      \
    \  return Err(Int(wordCount))\n    }\n    \n    let evenWordsArrayCount = \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxrcitmp9.swift:95:30: error: expected initial value after '='\n\
    \    let evenWordsArrayCount = \n                             ^\n/tmp/tmpxrcitmp9.swift:9:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpxrcitmp9.swift:12:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpxrcitmp9.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(wordCount))\n               ^~~\n/tmp/tmpxrcitmp9.swift:24:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(wordCount))\n           \
    \    ^~~\n/tmp/tmpxrcitmp9.swift:30:16: error: cannot find 'Err' in scope\n  \
    \      return Err(Int(wordCount))\n               ^~~\n/tmp/tmpxrcitmp9.swift:38:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(wordCount))\n    \
    \           ^~~\n/tmp/tmpxrcitmp9.swift:44:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(wordCount))\n               ^~~\n/tmp/tmpxrcitmp9.swift:50:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(wordCount))\n    \
    \           ^~~\n/tmp/tmpxrcitmp9.swift:56:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(wordCount))\n               ^~~\n/tmp/tmpxrcitmp9.swift:62:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(wordCount))\n    \
    \           ^~~\n/tmp/tmpxrcitmp9.swift:68:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(wordCount))\n               ^~~\n/tmp/tmpxrcitmp9.swift:74:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(wordCount))\n    \
    \           ^~~\n/tmp/tmpxrcitmp9.swift:80:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(wordCount))\n               ^~~\n/tmp/tmpxrcitmp9.swift:86:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(wordCount))\n    \
    \           ^~~\n/tmp/tmpxrcitmp9.swift:92:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(wordCount))\n               ^~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    if words.count == 2 {\n        return Ok(words[0])\n\
    \    }\n    if words.count == 3 {\n        return Ok(words[0])\n    }\n    if\
    \ words.count == 4 {\n        return Ok(words[0])\n    }\n    if words.count ==\
    \ 5 {\n        return Ok(words[0])\n    }\n    if words.count == 6 {\n       \
    \ return Ok(words[0])\n    }\n    if words.count == 7 {\n        return Ok(words[0])\n\
    \    }\n    if words.count == 8 {\n        return Ok(words[0])\n    }\n    if\
    \ words.count == 9 {\n        return Ok(words[0])\n    }\n    if words.count ==\
    \ 10 {\n        return Ok(words[0])\n    }\n    if words.count == 11 {\n     \
    \   return Ok(words[0])\n    }\n    if words.count == 12 {\n        return Ok(words[0])\n\
    \    }\n    if words.count == 13 {\n        return Ok(words[0])\n    }\n    if\
    \ words.count == 14 {\n        return Ok(words[0])\n    }\n    if words.count\
    \ == 15 {\n        return Ok(words[0])\n    }\n    if words.count == 16 {\n  \
    \      return Ok(words[0])\n    }\n    if words.count == 17 {\n        return\
    \ Ok(words[0])\n    }\n    if words.count == 18 {\n        return Ok(words[0])\n\
    \    }\n    if words.count == 19 {\n        return Ok(words[0])\n    }\n    if\
    \ words.count == 20 {\n        return Ok(words[0])\n    }\n    if words.count\
    \ == 21 {\n        return Ok(words[0])\n    }\n    if words.count == 22 {\n  \
    \      return Ok(words[0])\n    }\n    if words.count == 23 {\n        return\
    \ Ok(words[0])\n    }\n    if words.count == 24 {\n        return Ok(words[0])\n\
    \    }\n    if words.count == 25 {\n        return Ok(words[0])\n    }\n    return\
    \ Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpawiac84r.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpawiac84r.swift:14:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpawiac84r.swift:20:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:23:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n\
    /tmp/tmpawiac84r.swift:26:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:29:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:32:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpawiac84r.swift:35:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:38:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n\
    /tmp/tmpawiac84r.swift:41:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:44:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:47:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpawiac84r.swift:50:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:53:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n\
    /tmp/tmpawiac84r.swift:56:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:59:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpawiac84r.swift:62:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpawiac84r.swift:65:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0]"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Err(Int(.errString))\n    }\n    \n    var result = [String]()\n    \n    for\
    \ word in words {\n        guard let wordWithoutSpaces = word.trimmingCharacters(in:\
    \ .whitespaces) else {\n            return Err(Int(.errString))\n        }\n \
    \       \n        if wordWithoutSpaces.count > 0 {\n            result.append(wordWithoutSpaces)\n\
    \        }\n    }\n    \n    if result.count > 0 {\n        return Ok(result)\n\
    \    }\n    \n    if result.count == 0 {\n        return Err(Int(.errString))\n\
    \    }\n    \n    if result.count > 1 {\n        return Err(Int(.errString))\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplch2lf42.swift:10:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.errString))\n               ^~~\n/tmp/tmplch2lf42.swift:10:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errString))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmplch2lf42.swift:9:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplch2lf42.swift:16:44:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmplch2lf42.swift:16:68:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                                                  ~^~~~~~~~~~~\n\
    /tmp/tmplch2lf42.swift:17:20: error: cannot find 'Err' in scope\n            return\
    \ Err(Int(.errString))\n                   ^~~\n/tmp/tmplch2lf42.swift:17:28:\
    \ error: missing argument label 'bitPattern:' in call\n            return Err(Int(.errString))\n\
    \                           ^\n                           bitPattern: \n/tmp/tmplch2lf42.swift:26:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(result)\n              \
    \ ^~\n/tmp/tmplch2lf42.swift:30:16: error: cannot find 'Err' in scope\n      \
    \  return Err(Int(.errString))\n               ^~~\n/tmp/tmplch2lf42.swift:30:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errString))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmplch2lf42.swift:34:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errString))\n   \
    \            ^~~\n/tmp/tmplch2lf42.swift:34:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errStri"
  stdout: ''
  timestamp: 1660054473
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(0))\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    let firstWordSplit = firstWord.split(separator:\
    \ \",\")\n    if firstWordSplit.count == 0 {\n        return Ok(words)\n    }\n\
    \    if firstWordSplit.count == 1 {\n        return Ok(firstWordSplit)\n    }\n\
    \    let firstWordSplitCount = firstWordSplit[0].characters.count\n    let firstWordSplitCountInt\
    \ = Int(firstWordSplitCount)\n    if firstWordSplitCountInt % 2 == 1 {\n     \
    \   return Ok(firstWordSplit)\n    }\n    return Err(Int(firstWordSplitCountInt))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp97ztnj9b.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(0))\n               ^~~\n/tmp/tmp97ztnj9b.swift:14:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp97ztnj9b.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp97ztnj9b.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(firstWordSplit)\n               ^~\n/tmp/tmp97ztnj9b.swift:24:49: error:\
    \ 'characters' is unavailable: Please use Substring directly\n    let firstWordSplitCount\
    \ = firstWordSplit[0].characters.count\n                                     \
    \           ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: Substring { get set }\n           \
    \    ^\n/tmp/tmp97ztnj9b.swift:27:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(firstWordSplit)\n               ^~\n/tmp/tmp97ztnj9b.swift:29:12:\
    \ error: cannot find 'Err' in scope\n    return Err(Int(firstWordSplitCountInt))\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words[0])\n    }\n    \n    if words.count > 25 {\n        return\
    \ Err(25)\n    }\n    \n    if words.count < 2 {\n        return Ok(words.map\
    \ { $0.lowercased() })\n    }\n    \n    return Ok(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpduhx_4or.swift:12:16: error: cannot find 'Err' in scope\n     \
    \   return Err(25)\n               ^~~\n/tmp/tmpduhx_4or.swift:16:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpduhx_4or.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmpduhx_4or.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpduhx_4or.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.lowercased() } }\n    let evenOrderWords = splitWords.filter\
    \ { $0.count % 2 == 0 }\n    let oddOrderWords = splitWords.filter { $0.count\
    \ % 2 != 0 }\n    return evenOrderWords.count > 0 ? Ok(evenOrderWords) : oddOrderWords.count\
    \ > 0 ? Ok(oddOrderWords) : Err(0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpckutiy8n.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpckutiy8n.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpckutiy8n.swift:14:39: error: cannot find\
    \ 'Ok' in scope\n    return evenOrderWords.count > 0 ? Ok(evenOrderWords) : oddOrderWords.count\
    \ > 0 ? Ok(oddOrderWords) : Err(0)\n                                      ^~\n\
    /tmp/tmpckutiy8n.swift:14:86: error: cannot find 'Ok' in scope\n    return evenOrderWords.count\
    \ > 0 ? Ok(evenOrderWords) : oddOrderWords.count > 0 ? Ok(oddOrderWords) : Err(0)\n\
    \                                                                            \
    \         ^~\n/tmp/tmpckutiy8n.swift:14:106: error: cannot find 'Err' in scope\n\
    \    return evenOrderWords.count > 0 ? Ok(evenOrderWords) : oddOrderWords.count\
    \ > 0 ? Ok(oddOrderWords) : Err(0)\n                                         \
    \                                                                ^~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else {\n        return Err(25)\n    }\n    let wordCount = words.count\n\
    \    guard wordCount > 1 else {\n        return Err(25)\n    }\n    let lowercaseLetterCount\
    \ = words.map { $0.lowercased().count }.reduce(0, +)\n    guard lowercaseLetterCount\
    \ % 2 == 1 else {\n        return Err(25)\n    }\n    return Ok(words)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprcln6c66.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmprcln6c66.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmprcln6c66.swift:15:16:\
    \ error: cannot find 'Err' in scope\n        return Err(25)\n               ^~~\n\
    /tmp/tmprcln6c66.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmprcln6c66.swift:21:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    \n    if words.count == 1 {\n   \
    \     return Ok(words)\n    }\n    \n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.lowercased() } }\n    \n    if splitWords.count == 0 {\n   \
    \     return Err(25)\n    }\n    \n    if splitWords.count == 1 {\n        return\
    \ Ok(splitWords)\n    }\n    \n    let oddOrderWords = splitWords.filter { $0.count\
    \ % 2 == 1 }\n    \n    if oddOrderWords.count == 0 {\n        return Ok(splitWords)\n\
    \    }\n    \n    return Err(25)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpo5rd7gfy.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpo5rd7gfy.swift:12:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmpo5rd7gfy.swift:16:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpo5rd7gfy.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(25)\n               ^~~\n/tmp/tmpo5rd7gfy.swift:26:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(splitWords)\n               ^~\n/tmp/tmpo5rd7gfy.swift:32:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(splitWords)\n          \
    \     ^~\n/tmp/tmpo5rd7gfy.swift:35:12: error: cannot find 'Err' in scope\n  \
    \  return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words[0])\n    }\n    let mut words = words.map(String.init)\n    let mut\
    \ letters = words.map(|s| s.characters.filter(|c| c.isLetter).count)\n    let\
    \ mut odd_letters = letters.filter(|c| c % 2 == 1)\n    let mut even = letters.filter(|c|\
    \ c % 2 == 0)\n    if odd_letters.count > 0 {\n        return Err(odd_letters.count)\n\
    \    }\n    if even.count > 0 {\n        return Ok(even.count)\n    }\n    return\
    \ Ok(letters.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp15sk0h3a.swift:16:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut words =\
    \ words.map(String.init)\n            ^\n/tmp/tmp15sk0h3a.swift:16:13: note: join\
    \ the identifiers together\n    let mut words = words.map(String.init)\n     \
    \   ~~~~^~~~~\n        mutwords\n/tmp/tmp15sk0h3a.swift:16:13: note: join the\
    \ identifiers together with camel-case\n    let mut words = words.map(String.init)\n\
    \        ~~~~^~~~~\n        mutWords\n/tmp/tmp15sk0h3a.swift:17:13: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut letters = words.map(|s| s.characters.filter(|c| c.isLetter).count)\n\
    \            ^\n/tmp/tmp15sk0h3a.swift:17:13: note: join the identifiers together\n\
    \    let mut letters = words.map(|s| s.characters.filter(|c| c.isLetter).count)\n\
    \        ~~~~^~~~~~~\n        mutletters\n/tmp/tmp15sk0h3a.swift:17:13: note:\
    \ join the identifiers together with camel-case\n    let mut letters = words.map(|s|\
    \ s.characters.filter(|c| c.isLetter).count)\n        ~~~~^~~~~~~\n        mutLetters\n\
    /tmp/tmp15sk0h3a.swift:17:37: error: expected ',' separator\n    let mut letters\
    \ = words.map(|s| s.characters.filter(|c| c.isLetter).count)\n               \
    \                     ^\n                                   ,\n/tmp/tmp15sk0h3a.swift:17:61:\
    \ error: expected ',' separator\n    let mut letters = words.map(|s| s.characters.filter(|c|\
    \ c.isLetter).count)\n                                                       \
    \     ^\n                                                           ,\n/tmp/tmp15sk0h3a.swift:18:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut odd_letters = letters.filter(|c| c % 2 ==\
    \ 1)\n            ^\n/tmp/tmp15sk0h3a.swift:18:13: note: join the identifiers\
    \ together\n    let mut odd_letters = letters.filter(|c| c % 2 == 1)\n       \
    \ ~~~~^~~~~~~~~~~\n        mutodd_letters\n/tmp/tmp15sk0h3a.swift:18:13: note:\
    \ join the identifiers together with camel-case\n    let mut odd_lette"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else { return Err(0) }\n    guard words.count == 2 else { return Err(1) }\n\
    \    return Ok(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzb3w8thq.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpzb3w8thq.swift:10:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmpzb3w8thq.swift:11:42: error: cannot find\
    \ 'Err' in scope\n    guard words.count == 2 else { return Err(1) }\n        \
    \                                 ^~~\n/tmp/tmpzb3w8thq.swift:12:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(words.map { $0.lowercased() })\n         \
    \  ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    let words = words.compactMap { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n    if words.count == 0 {\n        return Err(0)\n\
    \    }\n    let words = words.compactMap { $0.components(separatedBy: \",\").map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \" \").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if\
    \ words.count == 0 {\n        return Err(0)\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\").map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ } }\n    if words.count == 0 {\n        return Err(0)\n    }\n    let words\
    \ = words.compactMap { $0.components(separatedBy: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) } }\n    if words.count == 0 {\n        return Err(0)\n\
    \    }\n    let words = words.compactMap { $0.components(separatedBy: \",\").map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \" \").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if\
    \ words.count == 0 {\n        return Err(0)\n    }\n    let words = words.compactMap\
    \ { $0.components(separatedBy: \",\").map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ } }\n    if words.count == 0 {\n        return Err(0)\n    }\n    let words\
    \ = words.compactMap { $0.components(separatedBy: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) } }\n    if words.count == 0 {\n        return Err(0)\n\
    \    }\n    let words = words.compactMap { $0.components(separatedBy: \",\").map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    let words = words.compactMap { $0.components(separatedBy:\
    \ \" \").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) } }\n    if\
    \ words.count == 0 {\n        return \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp24vonro.swift:78:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpp24vonro.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpp24vonro.swift:9:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpp24vonro.swift:11:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpp24vonro.swift:13:63:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words = words.compactMap { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                             ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp24vonro.swift:15:16: error: cannot find 'Err' in scope\n        return\
    \ Err(0)\n               ^~~\n/tmp/tmpp24vonro.swift:17:101: error: cannot infer\
    \ contextual base in reference to member 'whitespacesAndNewlines'\n    let words\
    \ = words.compactMap { $0.components(separatedBy: \",\").map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) } }\n                                             \
    \                                                      ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp24vonro.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(0)\n               ^~~\n/tmp/tmpp24vonro.swift:21:101: error: cannot infer\
    \ contextual base in reference to member 'whitespacesAndNewlines'\n    let words\
    \ = words.compactMap { $0.components(separatedBy: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) } }\n                                             \
    \                                                      ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp24vonro.swift:23:16: error: cannot find 'Err' in scope\n        return\
    \ Err(0)\n               ^~~\n/tmp/tmpp24vonro.swift:25:101: error: cannot infer\
    \ contextual base in reference to member 'whitespacesA"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(Int(.lowercaseLetter))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { (sum, word) -> Int in\n\
    \        if let letter = word.unicodeScalars.first {\n            return sum +\
    \ Int(letter)\n        }\n        return sum\n    }\n    if letterCount % 2 ==\
    \ 1 {\n        return Err(Int(.lowercaseLetter))\n    }\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprqkn6abp.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmprqkn6abp.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.lowercaseLetter))\n               ^~~\n/tmp/tmprqkn6abp.swift:11:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lowercaseLetter))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmprqkn6abp.swift:21:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.lowercaseLetter))\n\
    \               ^~~\n/tmp/tmprqkn6abp.swift:21:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.lowercaseLetter))\n         \
    \              ^\n                       bitPattern: \n/tmp/tmprqkn6abp.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n           ^~\n/tmp/tmprqkn6abp.swift:23:54: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespaces) })\n                             \
    \                       ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    \n    if words.count\
    \ == 0 {\n        return Err(0)\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 1 {\n        return Ok(words[0])\n    }\n    \n   \
    \ if wordCount == 2 {\n        return Ok(words[0])\n    }\n    \n    if wordCount\
    \ == 3 {\n        return Ok(words[0])\n    }\n    \n    if wordCount == 4 {\n\
    \        return Ok(words[0])\n    }\n    \n    if wordCount == 5 {\n        return\
    \ Ok(words[0])\n    }\n    \n    if wordCount == 6 {\n        return Ok(words[0])\n\
    \    }\n    \n    if wordCount == 7 {\n        return Ok(words[0])\n    }\n  \
    \  \n    if wordCount == 8 {\n        return Ok(words[0])\n    }\n    \n    if\
    \ wordCount == 9 {\n        return Ok(words[0])\n    }\n    \n    if wordCount\
    \ == 10 {\n        return Ok(words[0])\n    }\n    \n    if wordCount == 11 {\n\
    \        return Ok(words[0])\n    }\n    \n    if wordCount == 12 {\n        return\
    \ Ok(words[0])\n    }\n    \n    if wordCount == 13 {\n        return Ok(words[0])\n\
    \    }\n    \n    if wordCount == 14 {\n        return Ok(words[0])\n    }\n \
    \   \n    if wordCount == 15 {\n        return Ok(words[0])\n    }\n    \n   \
    \ if wordCount == 16 {\n        return Ok(words[0])\n    }\n    \n    if wordCount\
    \ == 17 {\n        return Ok(words[0])\n    }\n    \n    if wordCount == 18 {\n\
    \        return Ok(words[0])\n    }\n    \n    if wordCount == 19 {\n        return\
    \ Ok(words[0])\n    }\n    \n    if wordCount == 20 {\n        return Ok(words[0])\n\
    \    }\n    \n    if wordCount == 21 {\n        return Ok(words[0])\n    }\n \
    \   \n    if wordCount == 22 {\n        return Ok(words[0])\n    }\n    \n   \
    \ if wordCount == 23 {\n        return Ok(words[0])\n    }\n    \n    if wordCount\
    \ == 24 {\n        return Ok(words[0])\n    }\n    \n    if wordCount == 25 {\n\
    \        return Ok(words[0])\n    }\n    \n    if wordCount == 26 {\n        return\
    \ Ok(words[0])\n    }\n    \n    if wordCount == 27 {\n        return Ok(words[0])\n\
    \    }\n    \n    if wordCount == 28 {\n        return Ok(words[0])\n    }\n \
    \   \n    if wordCount == 29 {\n        return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd_303gg2.swift:153:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpd_303gg2.swift:8:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpd_303gg2.swift:12:16: error: cannot\
    \ find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpd_303gg2.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpd_303gg2.swift:22:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:26:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n\
    /tmp/tmpd_303gg2.swift:30:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:34:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:38:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpd_303gg2.swift:42:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:46:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n\
    /tmp/tmpd_303gg2.swift:50:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:54:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:58:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words[0])\n            \
    \   ^~\n/tmp/tmpd_303gg2.swift:62:16: error: cannot find 'Ok' in scope\n     \
    \   return Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:66:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words[0])\n               ^~\n\
    /tmp/tmpd_303gg2.swift:70:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words[0])\n               ^~\n/tmp/tmpd_303gg2.swift:74:16: error: cannot\
    \ find 'Ok' in scope\n        retur"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(.invalidInput))\n    }\n    \n    var words: [String] =\
    \ []\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.invalidInput))\n        }\n     \
    \   \n        for letter in letters {\n            if let letter = letter.lowercased()\
    \ {\n                words.append(letter)\n            }\n        }\n    }\n \
    \   \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpf72xyas5.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpf72xyas5.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.invalidInput))\n       \
    \        ^~~\n/tmp/tmpf72xyas5.swift:10:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.invalidInput))\n                       ^\n\
    \                       bitPattern: \n/tmp/tmpf72xyas5.swift:16:34: error: value\
    \ of type 'String' has no member 'components'\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n                            ~~~~ ^~~~~~~~~~\n/tmp/tmpf72xyas5.swift:17:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.invalidInput))\n\
    \                   ^~~\n/tmp/tmpf72xyas5.swift:17:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.invalidInput))\n  \
    \                         ^\n                           bitPattern: \n/tmp/tmpf72xyas5.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(1))\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = words.count\n    let letterCount = words.reduce(0)\
    \ { $0 + $1.count }\n    if letterCount % 2 != 0 {\n        return Err(Int(letterCount))\n\
    \    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpve_gp085.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(1))\n               ^~~\n/tmp/tmpve_gp085.swift:14:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpve_gp085.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(letterCount))\n  \
    \             ^~~\n/tmp/tmpve_gp085.swift:21:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ == 0 {\n        return Err(25)\n    }\n    if words.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let firstWord = words[0]\n    let firstLetter = firstWord.characters.first!\n\
    \    let firstLetterUppercase = firstLetter.isUppercase\n    let firstLetterLowercase\
    \ = firstLetter.isLowercase\n    let firstLetterUppercaseOrOdd = firstLetterUppercase\
    \ || firstLetterLowercase && firstLetter.asciiValue % 2 == 1\n    if firstLetterUppercaseOrOdd\
    \ {\n        return Ok(words)\n    }\n    return Err(25)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5rjs4vxa.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp5rjs4vxa.swift:11:16: error: cannot find 'Err'\
    \ in scope\n        return Err(25)\n               ^~~\n/tmp/tmp5rjs4vxa.swift:14:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp5rjs4vxa.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp5rjs4vxa.swift:24:12: error: cannot find\
    \ 'Err' in scope\n    return Err(25)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return Err(Int(0))\n    }\n    if words.count == 1 {\n        return\
    \ Err(Int(1))\n    }\n    if words.count > 25 {\n        return Err(Int(25))\n\
    \    }\n    let letters = words.map({ $0.lowercased() })\n    let odd = letters.filter({\
    \ $0.count % 2 == 1 })\n    return Ok(odd)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptrkjze3f.swift:11:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(0))\n               ^~~\n/tmp/tmptrkjze3f.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmptrkjze3f.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(25))\n               ^~~\n/tmp/tmptrkjze3f.swift:21:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(odd)\n           ^~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard words.count\
    \ > 0 else { return Err(0) }\n    let wordCount = words.count\n    let letterCount\
    \ = words.reduce(0) { $0 + $1.count }\n    guard letterCount % 2 == 1 else { return\
    \ Err(0) }\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmple2pwi2z.swift:9:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmple2pwi2z.swift:10:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmple2pwi2z.swift:13:46: error: cannot find\
    \ 'Err' in scope\n    guard letterCount % 2 == 1 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmple2pwi2z.swift:14:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n           ^~\n/tmp/tmple2pwi2z.swift:14:54: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n                                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054474
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(rawValue: 1))\n    }\n    \n    return Ok(words.filter {\
    \ $0.isEmpty || $0.isEmpty == false })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgv2ldq3w.swift:9:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpgv2ldq3w.swift:10:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmpgv2ldq3w.swift:10:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpgv2ldq3w.swift:13:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(words.filter { $0.isEmpty || $0.isEmpty == false })\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054474
