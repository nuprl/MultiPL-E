language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpunrjp3he.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpunrjp3he.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpunrjp3he.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpunrjp3he.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpunrjp3he.swift:24:42:\
    \ error: expected '{' in extension\n            strongest_extension_strength =\
    \ extension_strength\n                                         ^\n/tmp/tmpunrjp3he.swift:23:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmpunrjp3he.swift:24:13:\
    \ error: cannot find type 'strongest_extension_strength' in scope\n          \
    \  strongest_extension_strength = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpunrjp3he.swift:21:45: error: 'characters' is unavailable: Please use String\
    \ directly\n        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpunrjp3he.swift:21:102: error: 'characters' is unavailable:\
    \ Please use String directly\n        let extension_strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo5ixzt4f.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo5ixzt4f.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmpo5ixzt4f.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmpo5ixzt4f.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n  \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmpo5ixzt4f.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmpo5ixzt4f.swift:20:81: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:81: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:72: error:\
    \ declaration is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuabxz7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpatuabxz7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpatuabxz7.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpatuabxz7.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpatuabxz7.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpatuabxz7.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpatuabxz7.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpcz4v6pst/tmpcz4v6pst.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b059669bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0596392b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0596392988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05963917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcz4v6pst                        0x0000562ac0eef4fd <unavailable> + 5373

    5    libc.so.6                          0x00002b0596887460 __libc_start_main +
    245

    6    tmpcz4v6pst                        0x0000562ac0eef089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest\
    \ = extensions[0]\n    for extension in extensions {\n        var strongestStrength\
    \ = extension.count\n        for letter in extension {\n            if letter.isUppercase\
    \ {\n                strongestStrength -= 1\n            }\n        }\n      \
    \  if strongestStrength > strongest.count {\n            strongest = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpioejscjo.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpioejscjo.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpioejscjo.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpioejscjo.swift:20:33:\
    \ error: expected initial value after '='\n        var strongestStrength = extension.count\n\
    \                                ^\n/tmp/tmpioejscjo.swift:20:32: error: consecutive\
    \ statements on a line must be separated by ';'\n        var strongestStrength\
    \ = extension.count\n                               ^\n                      \
    \         ;\n/tmp/tmpioejscjo.swift:20:42: error: expected type name in extension\
    \ declaration\n        var strongestStrength = extension.count\n             \
    \                            ^\n/tmp/tmpioejscjo.swift:20:42: error: expected\
    \ '{' in extension\n        var strongestStrength = extension.count\n        \
    \                                 ^\n/tmp/tmpioejscjo.swift:20:33: error: declaration\
    \ is only valid at file scope\n        var strongestStrength = extension.count\n\
    \                                ^\n/tmp/tmpioejscjo.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpioejscjo.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpioejscjo.swift:27:25: error: expected expression in\
    \ assignment\n            strongest = extension\n                        ^\n/tmp/tmpioejscjo.swift:28:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpioejscjo.swift:27:34:\
    \ error: expected '{' in extension\n            strongest = extension\n      \
    \                           ^\n/tmp/tmpioejscjo.swift:27:25: error: declaration\
    \ is only valid at file scope\n            strongest = extension\n           \
    \             ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_lowercase = class_name.lowercased()\n\
    \    for extension in extensions {\n        var extension_lowercase = extension.lowercased()\n\
    \        var class_name_extension_lowercase = class_name_lowercase + extension_lowercase\n\
    \        var extension_strength = class_name_extension_lowercase.characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = class_name_extension_lowercase\n            strongest_extension_strength =\
    \ extension_strength\n        }\n    }\n    return strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsnj84csn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpsnj84csn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpsnj84csn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpsnj84csn.swift:21:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpsnj84csn.swift:21:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpsnj84csn.swift:21:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpsnj84csn.swift:21:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpsnj84csn.swift:21:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmp9mvwlz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmp9mvwlz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmp9mvwlz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpmp9mvwlz.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmp9mvwlz.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmp9mvwlz.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmp9mvwlz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3o3wciy.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3o3wciy.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpr3o3wciy.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpr3o3wciy.swift:20:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpr3o3wciy.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:7"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpxc89db.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpxc89db.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpxc89db.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpxc89db.swift:20:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmpmpxc89db.swift:20:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmpmpxc89db.swift:20:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmpmpxc89db.swift:20:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmpmpxc89db.swift:20:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmpmpxc89db.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpmpxc8"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_components = class_name.components(separatedBy: \".\"\
    )\n        let extension_components = extension.components(separatedBy: \".\"\
    )\n        let class_name_components_count = class_name_components.count\n   \
    \     let extension_components_count = extension_components.count\n        let\
    \ class_name_components_count_cap = class_name_components.count - class_name_components.map\
    \ { $0.isUppercase }.count\n        let extension_components_count_cap = extension_components.count\
    \ - extension_components.map { $0.isUppercase }.count\n        let class_name_components_count_sm\
    \ = class_name_components.count - class_name_components.map { $0.isLowercase }.count\n\
    \        let extension_components_count_sm = extension_components.count - extension_components.map\
    \ { $0.isLowercase }.count\n        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ - class_name_components_count_sm)\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap - extension_components_count_sm)\n       \
    \ let class_name_components_count_cap_sm_ratio = class_name_components_count_cap_sm\
    \ / class_name_components_count_sm\n        let extension_components_count_cap_sm_ratio\
    \ = extension_components_count_cap_sm / extension_components_count_sm\n      \
    \  let class_name_components_count_cap_sm_ratio_power = class_name_components_count_cap_sm_ratio\
    \ * class_name_components_count_cap\n        let extension_components_count_cap_sm_ratio_power\
    \ = extension_components_count_cap_sm_ratio * extension_components_count_cap\n\
    \        let class_name_components_count_cap_sm_ratio_power_extension_components_count\
    \ = class_name_components_count_cap_sm_ratio_power * extension_components_count\n\
    \        let extension_components_count_cap_sm_ratio_power_extension_components_count\
    \ = extension_components_count_cap_sm_ratio_power * class_name_components_count\n\
    \        let extension_components_count_cap_sm_ratio_power_extension_components_count_power\
    \ = extension_components_count_cap_sm_ratio_power_extension_components_count *\
    \ extension_components_count_cap_sm_ratio_power\n        let extension_components_count_cap_sm_ratio_power_extension_components_count_power_extension_components_count\
    \ = extension_components_count_cap_sm_ratio_power_extension_components_count *\
    \ extension_components_count_cap_sm_ratio_power_extension_components_count\n \
    \       let extension_components_count_cap_sm_ratio_power_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpicppsi8t.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpicppsi8t.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpicppsi8t.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpicppsi8t.swift:21:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpicppsi8t.swift:21:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpicppsi8t.swift:21:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpicppsi8t.swift:21:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpicppsi8t.swift:21:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpicppsi8t.swift:62:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpicppsi8t.swift:16:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpicppsi8t.swift:42:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpicppsi8t.swift:20:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var max_strength = -1\n    for extension in extensions {\n     \
    \   let cap = extension.count\n        let sm = class_name.count\n        let\
    \ strength = cap - sm\n        if strength > max_strength {\n            max_strength\
    \ = strength\n            strongest_extension = extension\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl29kmrcq.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpl29kmrcq.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpl29kmrcq.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpl29kmrcq.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpl29kmrcq.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpl29kmrcq.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpl29kmrcq.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpl29kmrcq.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpl29kmrcq.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpl29kmrcq.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpl29kmrcq.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpl29kmrcq.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpxc89db.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpxc89db.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpxc89db.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpxc89db.swift:20:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmpmpxc89db.swift:20:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmpmpxc89db.swift:20:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmpmpxc89db.swift:20:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmpmpxc89db.swift:20:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmpmpxc89db.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpmpxc8"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpchkbv284.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpchkbv284.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpchkbv284.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpchkbv284.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpchkbv284.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpchkbv284.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpchkbv284.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpchkbv284.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpchkbv284.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpchkbv284.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpchkbv284.swift:31:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpchkbv284.swift:32:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpchkbv284.swift:31:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpchkbv284.swift:31:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvcrp2j40.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvcrp2j40.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvcrp2j40.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvcrp2j40.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvcrp2j40.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpvcrp2j40.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvcrp2j40.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvcrp2j40.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvcrp2j40.swift:22:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpvcrp2j40.swift:23:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpvcrp2j40.swift:22:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpvcrp2j40.swift:23:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp86dnqjxz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp86dnqjxz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp86dnqjxz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp86dnqjxz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp86dnqjxz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp86dnqjxz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp86dnqjxz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp86dnqjxz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp86dnqjxz.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp86dnqjxz.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp86dnqjxz.swift:28:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp86dnqjxz.swift:29:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp86dnqjxz.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp86dnqjxz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongest_extension = \"\"\n    var strongest_extension_strength = -1\n    \n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    \n    if strongest_extension_strength == -1 {\n        return class_name\n\
    \    }\n    \n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplvgdyvou.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplvgdyvou.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplvgdyvou.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplvgdyvou.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmplvgdyvou.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmplvgdyvou.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmplvgdyvou.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmplvgdyvou.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmplvgdyvou.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmplvgdyvou.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmplvgdyvou.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmplvgdyvou.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_lowercase = class_name.lowercased()\n\
    \    \n    for extension in extensions {\n        var extension_lowercase = extension.lowercased()\n\
    \        var extension_strength = class_name_lowercase.count-extension_lowercase.count\n\
    \        \n        if extension_strength > strongest_extension_strength {\n  \
    \          strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    \n    return class_name + \".\"\
    \ + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9cvzpb8x.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp9cvzpb8x.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp9cvzpb8x.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp9cvzpb8x.swift:22:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmp9cvzpb8x.swift:22:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp9cvzpb8x.swift:22:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp9cvzpb8x.swift:22:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp9cvzpb8x.swift:22:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmp9cvzpb8x.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp9cvzpb8x.swift:27:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmp9cvzpb8x.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmp9cvzpb8x.swift:27:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_lowercase = class_name.lowercased()\n\
    \    var extension_lowercase = extensions[0].lowercased()\n    var extension_strength\
    \ = extensions[0].count\n    for extension in extensions {\n        var extension_lowercase\
    \ = extension.lowercased()\n        var extension_strength = extension.count\n\
    \        if class_name_lowercase.hasSuffix(extension_lowercase) {\n          \
    \  extension_strength -= 1\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpphxc0kvi.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpphxc0kvi.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpphxc0kvi.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpphxc0kvi.swift:23:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpphxc0kvi.swift:23:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpphxc0kvi.swift:23:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpphxc0kvi.swift:23:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpphxc0kvi.swift:23:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpphxc0kvi.swift:24:34: error: expected\
    \ initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpphxc0kvi.swift:24:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpphxc0kvi.swift:24:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpphxc0kvi.swift:24:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpphxc0kvi.swift:24:34: error: declaration\
    \ is only valid at file scope\n        var extensio"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    var max_extension = \"\"\n    for extension in\
    \ extensions {\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n        if extension_strength\
    \ > max_strength {\n            max_strength = extension_strength\n          \
    \  max_extension = extension\n        }\n    }\n    return class_name + \".\"\
    \ + max_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzpx3uyht.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpzpx3uyht.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpzpx3uyht.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpzpx3uyht.swift:21:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmpzpx3uyht.swift:21:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmpzpx3uyht.swift:21:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmpzpx3uyht.swift:21:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmpzpx3uyht.swift:21:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmpzpx3uyht.swift:24:29:\
    \ error: expected expression in assignment\n            max_extension = extension\n\
    \                            ^\n/tmp/tmpzpx3uyht.swift:25"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuabxz7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpatuabxz7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpatuabxz7.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpatuabxz7.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpatuabxz7.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpatuabxz7.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpatuabxz7.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0orjd655.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp0orjd655.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp0orjd655.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp0orjd655.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmp0orjd655.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmp0orjd655.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n  \
    \                                        ^\n/tmp/tmp0orjd655.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmp0orjd655.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmp0orjd655.swift:20:81: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmp0orjd655.swift:20:81: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmp0orjd655.swift:20:72: error:\
    \ declaration is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuabxz7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpatuabxz7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpatuabxz7.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpatuabxz7.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpatuabxz7.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpatuabxz7.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpatuabxz7.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptn6lnq42.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptn6lnq42.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptn6lnq42.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptn6lnq42.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmptn6lnq42.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmptn6lnq42.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmptn6lnq42.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmptn6lnq42.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmptn6lnq42.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmptn6lnq42.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmptn6lnq42.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowerLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwpup67lu.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpwpup67lu.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpwpup67lu.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpwpup67lu.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowerLetters()\n                                 ^\n/tmp/tmpwpup67lu.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowerLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpwpup67lu.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters() - extension.countUpToLowerLetters()\n\
    \                                          ^\n/tmp/tmpwpup67lu.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowerLetters()\n                                      \
    \    ^\n/tmp/tmpwpup67lu.swift:20:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowerLetters()\n                                 ^\n/tmp/tmpwpup67lu.swift:20:81:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters() - extension.countUpToLowerLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmpwpup67lu.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowerLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmpwpup67lu.swift:20:72: error: decl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, character) -> Int in\n            return\
    \ sum + Int(character.isUppercase)\n        }\n        if extension_strength >\
    \ max_strength {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_hjo0gyz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_hjo0gyz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_hjo0gyz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_hjo0gyz.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                 ^\n/tmp/tmp_hjo0gyz.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, character) -> Int\
    \ in\n                                ^\n                                ;\n/tmp/tmp_hjo0gyz.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, character) -> Int in\n            \
    \                              ^\n/tmp/tmp_hjo0gyz.swift:20:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                          ^\n\
    /tmp/tmp_hjo0gyz.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n                                 ^\n/tmp/tmp_hjo0gyz.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp_hjo0gyz.swift:26:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp_hjo0gyz.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_hjo0gyz.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm5tsu2h1.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm5tsu2h1.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm5tsu2h1.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm5tsu2h1.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpm5tsu2h1.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpm5tsu2h1.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpm5tsu2h1.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpm5tsu2h1.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpm5tsu2h1.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpm5tsu2h1.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpm5tsu2h1.swift:32:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpm5tsu2h1.swift:33:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpm5tsu2h1.swift:32:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpm5tsu2h1.swift:32:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n            let character = Character(character)\n            return\
    \ sum + Int(character.isUppercase)\n        }\n        if extension_strength >\
    \ strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = extension_strength\n        }\n  \
    \  }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmsswbkv7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmsswbkv7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmsswbkv7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmsswbkv7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                 ^\n/tmp/tmpmsswbkv7.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, character) -> Int\
    \ in\n                                ^\n                                ;\n/tmp/tmpmsswbkv7.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, character) -> Int in\n            \
    \                              ^\n/tmp/tmpmsswbkv7.swift:20:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                          ^\n\
    /tmp/tmpmsswbkv7.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n                                 ^\n/tmp/tmpmsswbkv7.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpmsswbkv7.swift:26:42:\
    \ error: expected '{' in extension\n            strongest_extension_strength =\
    \ extension_strength\n                                         ^\n/tmp/tmpmsswbkv7.swift:25:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmpmsswbkv7.swift:26:13:\
    \ error: cannot find type 'strongest_extension_strength' in scope\n          \
    \  strongest_extension_strength = extens"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3o3wciy.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3o3wciy.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpr3o3wciy.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpr3o3wciy.swift:20:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpr3o3wciy.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:7"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = extensions[0]\n\
    \    for extension in extensions {\n        let cap = extension.count\n      \
    \  let sm = extension.lowercased().count\n        let strength = cap - sm\n  \
    \      if strength > strongest.count {\n            strongest = extension\n  \
    \      }\n    }\n    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1fjo3trg.swift:18:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1fjo3trg.swift:18:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1fjo3trg.swift:18:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1fjo3trg.swift:19:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp1fjo3trg.swift:19:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp1fjo3trg.swift:19:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp1fjo3trg.swift:19:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp1fjo3trg.swift:19:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp1fjo3trg.swift:20:18:\
    \ error: expected initial value after '='\n        let sm = extension.lowercased().count\n\
    \                 ^\n/tmp/tmp1fjo3trg.swift:20:17: error: consecutive statements\
    \ on a line must be separated by ';'\n        let sm = extension.lowercased().count\n\
    \                ^\n                ;\n/tmp/tmp1fjo3trg.swift:20:27: error: expected\
    \ type name in extension declaration\n        let sm = extension.lowercased().count\n\
    \                          ^\n/tmp/tmp1fjo3trg.swift:20:27: error: expected '{'\
    \ in extension\n        let sm = extension.lowercased().count\n              \
    \            ^\n/tmp/tmp1fjo3trg.swift:20:18: error: declaration is only valid\
    \ at file scope\n        let sm = extension.lowercased().count\n             \
    \    ^\n/tmp/tmp1fjo3trg.swift:23:25: error: expected expression in assignment\n\
    \            strongest = extension\n                        ^\n/tmp/tmp1fjo3trg.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp1fjo3trg.swift:23:3"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3o3wciy.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3o3wciy.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpr3o3wciy.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpr3o3wciy.swift:20:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpr3o3wciy.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:7"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1 // default value\n    for extension in extensions {\n\
    \        let cap = extension.count\n        let sm = class_name.count\n      \
    \  let strength = cap - sm\n        if strength > strongest_extension.count {\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3etpj8is.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3etpj8is.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3etpj8is.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3etpj8is.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp3etpj8is.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp3etpj8is.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp3etpj8is.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp3etpj8is.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp3etpj8is.swift:24:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp3etpj8is.swift:25:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp3etpj8is.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3etpj8is.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var strongest_extension_class_name\
    \ = \"\"\n    \n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        \n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        \n        if class_name_components_count == extension_components_count\
    \ {\n            let class_name_components_lowercase = class_name_components.lowercased()\n\
    \            let extension_components_lowercase = extension_components.lowercased()\n\
    \            \n            let class_name_components_lowercase_index = class_name_components_lowercase.index(of:\
    \ extension_components_lowercase)\n            let extension_components_lowercase_index\
    \ = extension_components_lowercase.index(of: class_name_components_lowercase)\n\
    \            \n            if class_name_components_lowercase_index < extension_components_lowercase_index\
    \ {\n                strongest_extension_strength = class_name_components_lowercase_index\
    \ - extension_components_lowercase_index\n                strongest_extension_class_name\
    \ = class_name_components_lowercase\n            }\n        }\n    }\n    \n \
    \   if strongest_extension_strength > 0 {\n        strongest_extension = class_name\
    \ + \".\" + strongest_extension_class_name\n    }\n    \n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm9dvy995.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm9dvy995.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm9dvy995.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm9dvy995.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpm9dvy995.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpm9dvy995.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpm9dvy995.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpm9dvy995.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpm9dvy995.swift:22:48: error: value of type 'String' has no member\
    \ 'components'\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n                                    ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo5ixzt4f.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo5ixzt4f.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmpo5ixzt4f.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmpo5ixzt4f.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n  \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmpo5ixzt4f.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmpo5ixzt4f.swift:20:81: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:81: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:72: error:\
    \ declaration is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuabxz7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpatuabxz7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpatuabxz7.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpatuabxz7.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpatuabxz7.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpatuabxz7.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpatuabxz7.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuabxz7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpatuabxz7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpatuabxz7.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpatuabxz7.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpatuabxz7.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpatuabxz7.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpatuabxz7.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpcz4v6pst/tmpcz4v6pst.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b059669bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0596392b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0596392988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05963917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcz4v6pst                        0x0000562ac0eef4fd <unavailable> + 5373

    5    libc.so.6                          0x00002b0596887460 __libc_start_main +
    245

    6    tmpcz4v6pst                        0x0000562ac0eef089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvh28y94q.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvh28y94q.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvh28y94q.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvh28y94q.swift:22:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpvh28y94q.swift:23:42:\
    \ error: expected '{' in extension\n            strongest_extension_strength =\
    \ extension_strength\n                                         ^\n/tmp/tmpvh28y94q.swift:22:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmpvh28y94q.swift:23:13:\
    \ error: cannot find type 'strongest_extension_strength' in scope\n          \
    \  strongest_extension_strength = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvh28y94q.swift:20:45: error: 'characters' is unavailable: Please use String\
    \ directly\n        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvh28y94q.swift:20:102: error: 'characters' is unavailable:\
    \ Please use String directly\n        let extension_strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptn6lnq42.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptn6lnq42.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptn6lnq42.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptn6lnq42.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmptn6lnq42.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmptn6lnq42.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmptn6lnq42.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmptn6lnq42.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmptn6lnq42.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmptn6lnq42.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmptn6lnq42.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    \n    for extension in extensions {\n        let\
    \ class_name_components = class_name.components(separatedBy: \".\")\n        let\
    \ extension_components = extension.components(separatedBy: \".\")\n        \n\
    \        let class_name_components_count = class_name_components.count\n     \
    \   let extension_components_count = extension_components.count\n        \n  \
    \      if class_name_components_count == extension_components_count {\n      \
    \      let class_name_components_lowercase = class_name_components.map { $0.lowercased()\
    \ }\n            let extension_components_lowercase = extension_components.map\
    \ { $0.lowercased() }\n            \n            let class_name_components_uppercase\
    \ = class_name_components.map { $0.uppercased() }\n            let extension_components_uppercase\
    \ = extension_components.map { $0.uppercased() }\n            \n            let\
    \ class_name_components_lowercase_index = class_name_components_lowercase.index(of:\
    \ extension_components_lowercase[0])\n            let extension_components_lowercase_index\
    \ = extension_components_lowercase.index(of: class_name_components_lowercase[0])\n\
    \            \n            if class_name_components_lowercase_index < extension_components_lowercase_index\
    \ {\n                strongest_extension = class_name + \".\" + extension\n  \
    \              strength = class_name_components_lowercase_index - extension_components_lowercase_index\n\
    \            }\n        }\n    }\n    \n    if strength == -1 {\n        return\
    \ class_name\n    }\n    \n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpq8pwccz5.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpq8pwccz5.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpq8pwccz5.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpq8pwccz5.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpq8pwccz5.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpq8pwccz5.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpq8pwccz5.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpq8pwccz5.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpq8pwccz5.swift:38:58: error: expected expression after operator\n\
    \                strongest_extension = class_name + \".\" + extension\n      \
    \                                                   ^\n/tmp/tmpq8pwccz5.swift:39:26:\
    \ error: expected '{' in extension\n                strength = class_name_components_lowercase_index\
    \ - extension_components_lowercase_index\n                         ^\n/tmp/tmpq8pwccz5.swift:38:58:\
    \ error: declaration is only valid at file scope\n                strongest_extension\
    \ = class_name + \".\" + extension\n                                         \
    \                ^\n/tmp/tmpq8pwccz5.swift:39:17: error: cannot find type 'strength'\
    \ in scope\n                strength = class_"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_components = class_name.components(separatedBy: \".\"\
    )\n        let extension_components = extension.components(separatedBy: \".\"\
    )\n        let class_name_components_count = class_name_components.count\n   \
    \     let extension_components_count = extension_components.count\n        let\
    \ class_name_components_extension_strength = class_name_components_count - extension_components_count\n\
    \        if class_name_components_extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = class_name_components_extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgwqcp5q_.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpgwqcp5q_.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpgwqcp5q_.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpgwqcp5q_.swift:21:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpgwqcp5q_.swift:21:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpgwqcp5q_.swift:21:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpgwqcp5q_.swift:21:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpgwqcp5q_.swift:21:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpgwqcp5q_.swift:27:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpgwqcp5q_.swift:28:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpgwqcp5q_.swift:27:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpgwqcp5q_.swift:27:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpgwqcp5q_.swift:20:48: error: value of type 'String'\
    \ has no member 'components'\n        let class_name_components = class_name.componen"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.components(separatedBy: extension.lowercased()).count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppp2gas84.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmppp2gas84.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmppp2gas84.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmppp2gas84.swift:20:69:\
    \ error: expected expression in list of expressions\n        let extension_strength\
    \ = class_name.components(separatedBy: extension.lowercased()).count\n       \
    \                                                             ^\n/tmp/tmppp2gas84.swift:20:68:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = class_name.components(separatedBy: extension.lowercased()).count\n\
    \                                                                   ^\n      \
    \                                                             ;\n/tmp/tmppp2gas84.swift:20:78:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = class_name.components(separatedBy: extension.lowercased()).count\n       \
    \                                                                      ^\n/tmp/tmppp2gas84.swift:20:78:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \                                 ^\n/tmp/tmppp2gas84.swift:20:69: error: declaration\
    \ is only valid at file scope\n        let extension_strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \                        ^\n/tmp/tmppp2gas84.swift:22:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmppp2gas84.swift:23:42: error: expected '{' in extension\n\
    \            strongest_extension_strength = extension_strength\n             \
    \                            ^\n/tmp/tmppp2gas84.swift:22:35: error: declaration\
    \ is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strength = Int()\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength_frac = cap - sm\n   \
    \     if strength_frac > strength {\n            strongest = extension\n     \
    \       strength = strength_frac\n        }\n    }\n    return strongest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_tdgo91t.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_tdgo91t.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_tdgo91t.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_tdgo91t.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp_tdgo91t.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp_tdgo91t.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp_tdgo91t.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp_tdgo91t.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp_tdgo91t.swift:24:25:\
    \ error: expected expression in assignment\n            strongest = extension\n\
    \                        ^\n/tmp/tmp_tdgo91t.swift:25:22: error: expected '{'\
    \ in extension\n            strength = strength_frac\n                     ^\n\
    /tmp/tmp_tdgo91t.swift:24:25: error: declaration is only valid at file scope\n\
    \            strongest = extension\n                        ^\n/tmp/tmp_tdgo91t.swift:25:13:\
    \ error: cannot find type 'strength' in scope\n            strength = strength_frac\n\
    \            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongest_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > strongest_strength\
    \ {\n            strongest = class_name\n            strongest_strength = extension_strength\n\
    \        }\n    }\n    return strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxr94s0ri.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxr94s0ri.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxr94s0ri.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxr94s0ri.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpxr94s0ri.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpxr94s0ri.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpxr94s0ri.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpxr94s0ri.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_lowercase = class_name.lowercased()\n\
    \    \n    for extension in extensions {\n        var extension_lowercase = extension.lowercased()\n\
    \        var extension_strength = class_name_lowercase.count{\n            char\
    \ in\n            extension_lowercase.contains(char)\n        }\n        \n  \
    \      if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    \n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo6uahj2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjo6uahj2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjo6uahj2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjo6uahj2.swift:22:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpjo6uahj2.swift:22:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpjo6uahj2.swift:22:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpjo6uahj2.swift:22:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpjo6uahj2.swift:22:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpjo6uahj2.swift:30:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjo6uahj2.swift:31:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpjo6uahj2.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpjo6uahj2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpjo6uahj2.swift:23:55: error: cannot\
    \ call value of non-function type 'Int'\n        var extension_strength = class_name_lowercase.count{\n\
    \                                                      ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    \n    for extension in\
    \ extensions {\n        let extension_strength = extension.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    \n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphlz80ry0.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphlz80ry0.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphlz80ry0.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphlz80ry0.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmphlz80ry0.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmphlz80ry0.swift:22:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmphlz80ry0.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmphlz80ry0.swift:22:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmphlz80ry0.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmphlz80ry0.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmphlz80ry0.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmphlz80ry0.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsitte7v6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpsitte7v6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpsitte7v6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpsitte7v6.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpsitte7v6.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpsitte7v6.swift:21:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpsitte7v6.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpsitte7v6.swift:21:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpsitte7v6.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpsitte7v6.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpsitte7v6.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpsitte7v6.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smallerCapitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smallerCapitalizedToUppercase\
    \ = extension_counter_string_smallerCapitalized.uppercased()\n        let extension_counter_string_smallerCapitalizedToLowercase\
    \ = extension_counter_string_smallerCapitalized.lowercased()\n        let extension_counter_string_smallerCapitalizedToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercase.uppercased()\n    \
    \    let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpj_1yrglo.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpj_1yrglo.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpj_1yrglo.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpj_1yrglo.swift:58:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpj_1yrglo.swift:16:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmpj_1yrglo.swift:38:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpj_1yrglo.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        var extension_strength = extension.count\n        for c in extension\
    \ {\n            if c.isUppercase {\n                extension_strength -= 1\n\
    \            }\n            if c.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3sk34ukt.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3sk34ukt.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3sk34ukt.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3sk34ukt.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp3sk34ukt.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp3sk34ukt.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp3sk34ukt.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp3sk34ukt.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp3sk34ukt.swift:22:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmp3sk34ukt.swift:22:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmp3sk34ukt.swift:32:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp3sk34ukt.swift:33:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp3sk34ukt.swift:32:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3sk34ukt.swift:32:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smallerCapitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smallerCapitalizedToUppercase\
    \ = extension_counter_string_smallerCapitalized.uppercased()\n        let extension_counter_string_smallerCapitalizedToLowercase\
    \ = extension_counter_string_smallerCapitalized.lowercased()\n        let extension_counter_string_smallerCapitalizedToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercase.uppercased()\n    \
    \    let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpj_1yrglo.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpj_1yrglo.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpj_1yrglo.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpj_1yrglo.swift:58:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpj_1yrglo.swift:16:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmpj_1yrglo.swift:38:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpj_1yrglo.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_components = class_name.components(separatedBy: \".\"\
    )\n        let extension_components = extension.components(separatedBy: \".\"\
    )\n        let class_name_components_count = class_name_components.count\n   \
    \     let extension_components_count = extension_components.count\n        let\
    \ class_name_components_extension_strength = class_name_components_count - extension_components_count\n\
    \        let extension_components_extension_strength = extension_components_count\
    \ - class_name_components_count\n        if class_name_components_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ class_name_components_extension_strength\n            strongest_extension =\
    \ extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpayn9_sza.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpayn9_sza.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpayn9_sza.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpayn9_sza.swift:21:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpayn9_sza.swift:21:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpayn9_sza.swift:21:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpayn9_sza.swift:21:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpayn9_sza.swift:21:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpayn9_sza.swift:28:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpayn9_sza.swift:29:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpayn9_sza.swift:28:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpayn9_sza.swift:28:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpayn9_sza.swift:20:48: error: value of type 'String'\
    \ has no member 'components'\n        let class_name_components = class_name.componen"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmp9mvwlz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmp9mvwlz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmp9mvwlz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpmp9mvwlz.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmp9mvwlz.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmp9mvwlz.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmp9mvwlz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpchkbv284.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpchkbv284.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpchkbv284.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpchkbv284.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpchkbv284.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpchkbv284.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpchkbv284.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpchkbv284.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpchkbv284.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpchkbv284.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpchkbv284.swift:31:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpchkbv284.swift:32:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpchkbv284.swift:31:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpchkbv284.swift:31:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    \n    for extension in\
    \ extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    \n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpguvwm9vj.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpguvwm9vj.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpguvwm9vj.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpguvwm9vj.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpguvwm9vj.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpguvwm9vj.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpguvwm9vj.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpguvwm9vj.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpguvwm9vj.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpguvwm9vj.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpguvwm9vj.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpguvwm9vj.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = extensions[0]\n\
    \    for extension in extensions {\n        let cap = extension.count\n      \
    \  let sm = extension.lowercased().count\n        let strength = cap - sm\n  \
    \      if strength > 0 {\n            strongest = extension\n        }\n    }\n\
    \    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7j78fsgz.swift:18:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7j78fsgz.swift:18:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7j78fsgz.swift:18:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7j78fsgz.swift:19:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp7j78fsgz.swift:19:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp7j78fsgz.swift:19:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp7j78fsgz.swift:19:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp7j78fsgz.swift:19:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp7j78fsgz.swift:20:18:\
    \ error: expected initial value after '='\n        let sm = extension.lowercased().count\n\
    \                 ^\n/tmp/tmp7j78fsgz.swift:20:17: error: consecutive statements\
    \ on a line must be separated by ';'\n        let sm = extension.lowercased().count\n\
    \                ^\n                ;\n/tmp/tmp7j78fsgz.swift:20:27: error: expected\
    \ type name in extension declaration\n        let sm = extension.lowercased().count\n\
    \                          ^\n/tmp/tmp7j78fsgz.swift:20:27: error: expected '{'\
    \ in extension\n        let sm = extension.lowercased().count\n              \
    \            ^\n/tmp/tmp7j78fsgz.swift:20:18: error: declaration is only valid\
    \ at file scope\n        let sm = extension.lowercased().count\n             \
    \    ^\n/tmp/tmp7j78fsgz.swift:23:25: error: expected expression in assignment\n\
    \            strongest = extension\n                        ^\n/tmp/tmp7j78fsgz.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp7j78fsgz.swift:23:3"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsitte7v6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpsitte7v6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpsitte7v6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpsitte7v6.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpsitte7v6.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpsitte7v6.swift:21:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpsitte7v6.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpsitte7v6.swift:21:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpsitte7v6.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpsitte7v6.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpsitte7v6.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpsitte7v6.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpoy6q3oxu.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpoy6q3oxu.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpoy6q3oxu.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpoy6q3oxu.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpoy6q3oxu.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpoy6q3oxu.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpoy6q3oxu.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpoy6q3oxu.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpoy6q3oxu.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpoy6q3oxu.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpoy6q3oxu.swift:27:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpoy6q3oxu.swift:28:42: error: expected '{' in extension\n\
    \            strongest_extension_strength = extension_strength\n             \
    \                            ^\n/tmp/tmpoy6q3oxu.swift:27:35: error: declaration\
    \ is only valid at file scope\n            strongest_extension = extension\n \
    \                                 ^\n/tmp/tmpoy6q3oxu.swift:28:13: error: cannot\
    \ find type 'strongest_e"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = extension.lowercased().count\n        let\
    \ strength = cap - sm\n        if strength > strength {\n            strongest_extension\
    \ = extension\n            strength = cap - sm\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxzzprh3q.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxzzprh3q.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxzzprh3q.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxzzprh3q.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpxzzprh3q.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpxzzprh3q.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpxzzprh3q.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpxzzprh3q.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpxzzprh3q.swift:21:18:\
    \ error: expected initial value after '='\n        let sm = extension.lowercased().count\n\
    \                 ^\n/tmp/tmpxzzprh3q.swift:21:17: error: consecutive statements\
    \ on a line must be separated by ';'\n        let sm = extension.lowercased().count\n\
    \                ^\n                ;\n/tmp/tmpxzzprh3q.swift:21:27: error: expected\
    \ type name in extension declaration\n        let sm = extension.lowercased().count\n\
    \                          ^\n/tmp/tmpxzzprh3q.swift:21:27: error: expected '{'\
    \ in extension\n        let sm = extension.lowercased().count\n              \
    \            ^\n/tmp/tmpxzzprh3q.swift:21:18: error: declaration is only valid\
    \ at file scope\n        let sm = extension.lowercased().count\n             \
    \    ^\n/tmp/tmpxzzprh3q.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpxzzprh3q.swift:25:22: error: expected '{' in extension\n      \
    \      strength = cap - sm\n            "
  stdout: ''
  timestamp: 1660009599
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        var extension_strength = extension.count\n        for character in\
    \ extension {\n            if character == character.lowercased() {\n        \
    \        extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3d1kekfq.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3d1kekfq.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3d1kekfq.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3d1kekfq.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp3d1kekfq.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp3d1kekfq.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp3d1kekfq.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp3d1kekfq.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp3d1kekfq.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp3d1kekfq.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp3d1kekfq.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp3d1kekfq.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp3d1kekfq.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3d1kekfq.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smaller_capitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smaller_capitalized_extension\
    \ = extension_counter_string_smaller_capitalized.components(separatedBy: \".\"\
    )\n        let extension_counter_string_smaller_capitalized_extension_strength\
    \ = extension_counter_string_smaller_capitalized_extension.count\n        if extension_counter_string_smaller_capitalized_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = class_name\n\
    \            strongest_extension_strength = extension_counter_string_smaller_capitalized_extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpznb4fr_5.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpznb4fr_5.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpznb4fr_5.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpznb4fr_5.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character >= 'A' && character <= 'Z' {\n                extension_strength\
    \ -= 1\n            }\n            if character >= 'a' && character <= 'z' {\n\
    \                extension_strength -= 1\n            }\n        }\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp44in7v_o.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp44in7v_o.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp44in7v_o.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp44in7v_o.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp44in7v_o.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp44in7v_o.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp44in7v_o.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp44in7v_o.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp44in7v_o.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp44in7v_o.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp44in7v_o.swift:22:29: error: single-quoted\
    \ string literal found, use '\"'\n            if character >= 'A' && character\
    \ <= 'Z' {\n                            ^~~\n                            \"A\"\
    \n/tmp/tmp44in7v_o.swift:22:49: error: single-quoted string literal found, use\
    \ '\"'\n            if character >= 'A' && character <= 'Z' {\n              \
    \                                  ^~~\n                                     \
    \           \"Z\"\n/tmp/tmp44in7v_o.swift:25:29: error: single-quoted string literal\
    \ found, use '\"'\n            if characte"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpf0818ij8.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpf0818ij8.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpf0818ij8.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpf0818ij8.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpf0818ij8.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpf0818ij8.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpf0818ij8.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpf0818ij8.swift:20:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpf0818ij8.swift:20:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpf0818ij8.swift:20:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpf0818ij8.swift:20:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongest_extension = \"\"\n    var strongest_extension_strength = -1\n    \n\
    \    for extension in extensions {\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n        \n  \
    \      if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    \n    if strongest_extension_strength != -1 {\n        strongest =\
    \ class_name + \".\" + strongest_extension\n    }\n    \n    return strongest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp745tobul.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp745tobul.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp745tobul.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp745tobul.swift:22:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmp745tobul.swift:22:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmp745tobul.swift:22:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmp745tobul.swift:22:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmp745tobul.swift:22:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmp745tobul.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp745to"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpxc89db.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmpxc89db.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmpxc89db.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmpxc89db.swift:20:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmpmpxc89db.swift:20:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmpmpxc89db.swift:20:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmpmpxc89db.swift:20:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmpmpxc89db.swift:20:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmpmpxc89db.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpmpxc8"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var strongest_extension_class_name\
    \ = \"\"\n    \n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        \n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        \n        let class_name_components_count_cap = class_name_components.count\
    \ - class_name_components_count + 1\n        let extension_components_count_cap\
    \ = extension_components.count - extension_components_count + 1\n        \n  \
    \      let class_name_components_count_sm = class_name_components_count - class_name_components_count_cap\n\
    \        let extension_components_count_sm = extension_components_count - extension_components_count_cap\n\
    \        \n        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ - class_name_components_count_sm) / 2\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap - extension_components_count_sm) / 2\n   \
    \     \n        let class_name_components_count_cap_sm_sum = class_name_components_count_cap_sm\
    \ + class_name_components_count_sm\n        let extension_components_count_cap_sm_sum\
    \ = extension_components_count_cap_sm + extension_components_count_sm\n      \
    \  \n        let class_name_components_count_cap_sm_product = class_name_components_count_cap_sm\
    \ * extension_components_count_cap_sm\n        let extension_components_count_cap_sm_product\
    \ = class_name_components_count_cap_sm * extension_components_count_sm\n     \
    \   \n        let class_name_components_count_cap_sm_product_sum = class_name_components_count_cap_sm_product\
    \ + class_name_components_count_cap_sm_sum\n        let extension_components_count_cap_sm_product_sum\
    \ = extension_components_count_cap_sm_product + extension_components_count_cap_sm_sum\n\
    \        \n        let class_name_components_count_cap_sm_product_product = class_name_components_count_cap_sm_product_sum\
    \ * extension_components_count_cap_sm_product_sum\n        let extension_components_count_cap_sm_product_product\
    \ = class_name_components_count_cap_sm_product_sum * extension_components_count_cap_sm_sum\n\
    \        \n        let strength = class_name_components_count_cap_sm_product_product\
    \ / extension_components_count_cap_sm_product_product\n        \n        if strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqjhsbx2j.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpqjhsbx2j.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpqjhsbx2j.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpqjhsbx2j.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpqjhsbx2j.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpqjhsbx2j.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpqjhsbx2j.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpqjhsbx2j.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpqjhsbx2j.swift:53:1: error: expected expression in assignment\n\
    }\n^\n/tmp/tmpqjhsbx2j.swift:76:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpqjhsbx2j.swift:21:33: note: to\
    \ match this opening '{'\n    for extension in extensions {\n                \
    \                ^\n/tmp/tmpqjhsbx2j.swift:76:91: error: expected '}' at end of\
    \ brace statement\nassert(Strongest_Extension(class_name: \"Sp\", extensions:\
    \ [\"671235\", \"Bb\"]) == \"Sp.671235\")\n                                  \
    \                                      "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_length = class_name.characters.count\n\
    \    var extension_length = extensions.count\n    for i in 0..<class_name_length\
    \ {\n        for j in 0..<extension_length {\n            let class_name_character\
    \ = class_name.characters[i]\n            let extension_character = extensions[j].characters[i]\n\
    \            if class_name_character == extension_character {\n              \
    \  if class_name_character == class_name_character.lowercased() {\n          \
    \          strongest_extension_strength = class_name_character.characters.count\
    \ - extension_character.characters.count\n                } else {\n         \
    \           strongest_extension_strength = class_name_character.characters.count\
    \ + extension_character.characters.count\n                }\n                if\
    \ strongest_extension_strength > strongest_extension_strength {\n            \
    \        strongest_extension = class_name\n                    strongest_extension_strength\
    \ = strongest_extension_strength\n                }\n            }\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr2f2hxqm.swift:19:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    var class_name_length = class_name.characters.count\n\
    \                                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpr2f2hxqm.swift:23:40: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   let class_name_character = class_name.characters[i]\n                    \
    \                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpr2f2hxqm.swift:23:51: error: 'characters'\
    \ is unavailable: Please use String directly\n            let class_name_character\
    \ = class_name.characters[i]\n                                               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpr2f2hxqm.swift:24:39:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            let extension_character = extensions[j].characters[i]\n\
    \                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpr2f2hxqm.swift:24:53:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ let extension_character = extensions[j].characters[i]\n                    \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpr2f2hxqm.swift:26:41: error: binary operator '==' cannot\
    \ be applied to operands of type 'Character' and 'String'\n                if\
    \ class_name_character == class_name_character.lowercased() {\n "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countElements() / class_name.countElements()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5tawjny.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw5tawjny.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw5tawjny.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw5tawjny.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countElements()\
    \ / class_name.countElements()\n                                 ^\n/tmp/tmpw5tawjny.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countElements() / class_name.countElements()\n\
    \                                ^\n                                ;\n/tmp/tmpw5tawjny.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countElements() / class_name.countElements()\n                 \
    \                         ^\n/tmp/tmpw5tawjny.swift:20:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.countElements() / class_name.countElements()\n\
    \                                          ^\n/tmp/tmpw5tawjny.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countElements()\
    \ / class_name.countElements()\n                                 ^\n/tmp/tmpw5tawjny.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpw5tawjny.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpw5tawjny.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw5tawjny.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string.lowercased()\n        let extension_counter_string_smaller_capitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smaller_capitalized_extension\
    \ = extension_counter_string_smaller_capitalized.components(separatedBy: \".\"\
    )\n        let extension_counter_string_smaller_capitalized_extension_counter\
    \ = extension_counter_string_smaller_capitalized_extension.count\n        let\
    \ extension_counter_string_smaller_capitalized_extension_counter_capitalized =\
    \ extension_counter_string_smaller_capitalized_extension_counter.capitalized\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller\
    \ = extension_counter_string_smaller_capitalized_extension_counter.lowercased()\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized\
    \ = extension_counter_string_smaller_capitalized_extension_counter_smaller.capitalized\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension\
    \ = extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized.components(separatedBy:\
    \ \".\")\n        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter\
    \ = extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension.count\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter_capitalized\
    \ = extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter.capitalized\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter_smaller\
    \ = extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter.lowercased()\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter_smaller_capitalized\
    \ = extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter_smaller.capitalized\n\
    \        let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm99jxzo8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm99jxzo8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm99jxzo8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm99jxzo8.swift:60:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpm99jxzo8.swift:16:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmpm99jxzo8.swift:40:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpm99jxzo8.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpm99jxzo8.swift:25:93:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_smaller_capitalized\
    \ = extension_counter_string_smaller.capitalized\n                           \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmpm99jxzo8.swift:36:13: error: type annotation missing in pattern\n    \
    \    let extension_counter_string_smaller_capitalized_extension_counter_smaller_capitalized_extension_counter\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvqvva6co.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvqvva6co.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvqvva6co.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvqvva6co.swift:20:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmpvqvva6co.swift:20:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmpvqvva6co.swift:20:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmpvqvva6co.swift:20:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmpvqvva6co.swift:20:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmpvqvva6co.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpvqvva"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for c in extension\
    \ {\n            if c.isUppercase {\n                extension_strength -= 1\n\
    \            }\n            if c.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5292wq9c.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5292wq9c.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5292wq9c.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5292wq9c.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5292wq9c.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp5292wq9c.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp5292wq9c.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp5292wq9c.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5292wq9c.swift:21:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmp5292wq9c.swift:21:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmp5292wq9c.swift:31:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp5292wq9c.swift:32:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp5292wq9c.swift:31:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp5292wq9c.swift:31:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smallerCapitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smallerCapitalizedToUppercase\
    \ = extension_counter_string_smallerCapitalized.uppercased()\n        let extension_counter_string_smallerCapitalizedToLowercase\
    \ = extension_counter_string_smallerCapitalized.lowercased()\n        let extension_counter_string_smallerCapitalizedToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToUppercase.lowercased()\n    \
    \    let extension_counter_string_smallerCapitalizedToLowercaseToUppercase = extension_counter_string_smallerCapitalizedToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercaseToLowercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseToUppercase.lowercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseTo\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5jupxab7.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5jupxab7.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5jupxab7.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5jupxab7.swift:59:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp5jupxab7.swift:16:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmp5jupxab7.swift:39:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp5jupxab7.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp5jupxab7.swift:35:13:\
    \ error: type annotation missing in pattern\n        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToLowercaseToUppercaseToLowercaseTo\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp86dnqjxz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp86dnqjxz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp86dnqjxz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp86dnqjxz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp86dnqjxz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp86dnqjxz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp86dnqjxz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp86dnqjxz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp86dnqjxz.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp86dnqjxz.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp86dnqjxz.swift:28:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp86dnqjxz.swift:29:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp86dnqjxz.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp86dnqjxz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_components = class_name.components(separatedBy: \".\"\
    )\n        let extension_components = extension.components(separatedBy: \".\"\
    )\n        let class_name_components_count = class_name_components.count\n   \
    \     let extension_components_count = extension_components.count\n        let\
    \ class_name_components_count_cap = class_name_components.count - class_name_components_count\
    \ + 1\n        let extension_components_count_cap = extension_components.count\
    \ - extension_components_count + 1\n        let class_name_components_count_sm\
    \ = class_name_components_count - class_name_components_count_cap\n        let\
    \ extension_components_count_sm = extension_components_count - extension_components_count_cap\n\
    \        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ - class_name_components_count_sm) / 2\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap - extension_components_count_sm) / 2\n   \
    \     let class_name_components_count_cap_sm_extension_components_count_cap_sm\
    \ = class_name_components_count_cap_sm + extension_components_count_cap_sm\n \
    \       let extension_components_count_cap_sm_extension_components_count_cap_sm\
    \ = extension_components_count_cap_sm + extension_components_count_cap_sm\n  \
    \      let class_name_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm\
    \ = class_name_components_count_cap_sm_extension_components_count_cap_sm + extension_components_count_cap_sm_extension_components_count_cap_sm\n\
    \        let extension_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm\
    \ = extension_components_count_cap_sm_extension_components_count_cap_sm + extension_components_count_cap_sm_extension_components_count_cap_sm\n\
    \        let class_name_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm\
    \ = class_name_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm\
    \ + extension_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm\n\
    \        let extension_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm_extension_components_count_cap_sm\
    \ = extension_components_count_cap_sm_extension_components_count_cap\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppkn3p3ft.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmppkn3p3ft.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmppkn3p3ft.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmppkn3p3ft.swift:21:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmppkn3p3ft.swift:21:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmppkn3p3ft.swift:21:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmppkn3p3ft.swift:21:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmppkn3p3ft.swift:21:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmppkn3p3ft.swift:59:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmppkn3p3ft.swift:16:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmppkn3p3ft.swift:39:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmppkn3p3ft.swift:20:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.characters.filter({ $0.isUppercase\
    \ }).count - extension.characters.filter({ $0.isLowercase }).count\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpay_mfpbs.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpay_mfpbs.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpay_mfpbs.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpay_mfpbs.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                 ^\n/tmp/tmpay_mfpbs.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.filter({ $0.isUppercase }).count - extension.characters.filter({\
    \ $0.isLowercase }).count\n                                ^\n               \
    \                 ;\n/tmp/tmpay_mfpbs.swift:21:43: error: expected type name in\
    \ extension declaration\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                          ^\n/tmp/tmpay_mfpbs.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                          ^\n/tmp/tmpay_mfpbs.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                 ^\n/tmp/tmpay_mfpbs.swift:21:99: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \                      ^\n/tmp/tmpay_mfpbs.swift:21:99: error: expected"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp86dnqjxz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp86dnqjxz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp86dnqjxz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp86dnqjxz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp86dnqjxz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp86dnqjxz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp86dnqjxz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp86dnqjxz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp86dnqjxz.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp86dnqjxz.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp86dnqjxz.swift:28:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp86dnqjxz.swift:29:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp86dnqjxz.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp86dnqjxz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmp9mvwlz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmp9mvwlz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmp9mvwlz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpmp9mvwlz.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmp9mvwlz.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmp9mvwlz.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmp9mvwlz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = Int()\n    for extension in extensions {\n        let cap\
    \ = extension.count\n        let sm = class_name.count\n        let strength_fraction\
    \ = cap - sm\n        if strength_fraction > strength {\n            strongest_extension\
    \ = extension\n            strength = strength_fraction\n        }\n    }\n  \
    \  return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpq19oifjc.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpq19oifjc.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpq19oifjc.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpq19oifjc.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpq19oifjc.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpq19oifjc.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpq19oifjc.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpq19oifjc.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpq19oifjc.swift:24:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpq19oifjc.swift:25:22:\
    \ error: expected '{' in extension\n            strength = strength_fraction\n\
    \                     ^\n/tmp/tmpq19oifjc.swift:24:35: error: declaration is only\
    \ valid at file scope\n            strongest_extension = extension\n         \
    \                         ^\n/tmp/tmpq19oifjc.swift:25:13: error: cannot find\
    \ type 'strength' in scope\n            strength = strength_fraction\n       \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmp9mvwlz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmp9mvwlz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmp9mvwlz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpmp9mvwlz.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmp9mvwlz.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmp9mvwlz.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmp9mvwlz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, letter)\
    \ -> Int in\n            let letter_int = letter.unicodeScalars.reduce(0) { (sum,\
    \ scalar) -> Int in\n                let letter = Character(scalar)\n        \
    \        return sum + letter.uppercased().asciiValue - letter.lowercased().asciiValue\n\
    \            }\n            return sum + letter_int\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpe2_qv44o.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpe2_qv44o.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpe2_qv44o.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpe2_qv44o.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, letter) -> Int in\n                                 ^\n/tmp/tmpe2_qv44o.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, letter) -> Int in\n\
    \                                ^\n                                ;\n/tmp/tmpe2_qv44o.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n               \
    \                           ^\n/tmp/tmpe2_qv44o.swift:20:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, letter) -> Int in\n                                          ^\n/tmp/tmpe2_qv44o.swift:20:34:\
    \ error: declaration is only valid at file scope\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n               \
    \                  ^\n/tmp/tmpe2_qv44o.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpe2_qv44o.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpe2_qv44o.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpe2_qv44o.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongestStrength = -1\n    for extension in extensions {\n        var extensionStrength\
    \ = extension.count\n        for letter in extension {\n            if letter.isUppercase\
    \ {\n                extensionStrength -= 1\n            }\n            if letter.isLowercase\
    \ {\n                extensionStrength += 1\n            }\n        }\n      \
    \  if extensionStrength > strongestStrength {\n            strongestStrength =\
    \ extensionStrength\n            strongest = class_name\n        }\n    }\n  \
    \  return strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_p5ka9sg.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_p5ka9sg.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_p5ka9sg.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_p5ka9sg.swift:20:33:\
    \ error: expected initial value after '='\n        var extensionStrength = extension.count\n\
    \                                ^\n/tmp/tmp_p5ka9sg.swift:20:32: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extensionStrength\
    \ = extension.count\n                               ^\n                      \
    \         ;\n/tmp/tmp_p5ka9sg.swift:20:42: error: expected type name in extension\
    \ declaration\n        var extensionStrength = extension.count\n             \
    \                            ^\n/tmp/tmp_p5ka9sg.swift:20:42: error: expected\
    \ '{' in extension\n        var extensionStrength = extension.count\n        \
    \                                 ^\n/tmp/tmp_p5ka9sg.swift:20:33: error: declaration\
    \ is only valid at file scope\n        var extensionStrength = extension.count\n\
    \                                ^\n/tmp/tmp_p5ka9sg.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp_p5ka9sg.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, letter)\
    \ -> Int in\n            let letter_upper = letter.uppercased()\n            return\
    \ sum + Int(letter_upper)\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplgq9pqq7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplgq9pqq7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplgq9pqq7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplgq9pqq7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, letter) -> Int in\n                                 ^\n/tmp/tmplgq9pqq7.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, letter) -> Int in\n\
    \                                ^\n                                ;\n/tmp/tmplgq9pqq7.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n               \
    \                           ^\n/tmp/tmplgq9pqq7.swift:20:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, letter) -> Int in\n                                          ^\n/tmp/tmplgq9pqq7.swift:20:34:\
    \ error: declaration is only valid at file scope\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n               \
    \                  ^\n/tmp/tmplgq9pqq7.swift:26:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmplgq9pqq7.swift:27:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmplgq9pqq7.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmplgq9pqq7.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    var max_extension = \"\"\n    for extension in\
    \ extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            max_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + max_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpn14jmbva.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpn14jmbva.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpn14jmbva.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpn14jmbva.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpn14jmbva.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpn14jmbva.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpn14jmbva.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpn14jmbva.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpn14jmbva.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpn14jmbva.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpn14jmbva.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_extension = class_name + extension\n        let class_name_extension_strength\
    \ = class_name_extension.countUppercaseLetters() - class_name_extension.countLowercaseLetters()\n\
    \        if class_name_extension_strength > strongest_extension_strength {\n \
    \           strongest_extension = class_name_extension\n            strongest_extension_strength\
    \ = class_name_extension_strength\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpb8ra9397.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpb8ra9397.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpb8ra9397.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpb8ra9397.swift:20:49:\
    \ error: expected expression after operator\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmpb8ra9397.swift:20:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        let class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmpb8ra9397.swift:21:9: error: expected type name\
    \ in extension declaration\n        let class_name_extension_strength = class_name_extension.countUppercaseLetters()\
    \ - class_name_extension.countLowercaseLetters()\n        ^\n/tmp/tmpb8ra9397.swift:20:58:\
    \ error: expected '{' in extension\n        let class_name_extension = class_name\
    \ + extension\n                                                         ^\n/tmp/tmpb8ra9397.swift:20:49:\
    \ error: declaration is only valid at file scope\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_components = class_name.components(separatedBy:\
    \ \".\")\n    var extension_components = extensions.components(separatedBy: \"\
    .\")\n    for i in 0..<class_name_components.count {\n        let class_name_component\
    \ = class_name_components[i]\n        for j in 0..<extension_components.count\
    \ {\n            let extension_component = extension_components[j]\n         \
    \   let class_name_component = class_name_component\n            let extension_component\
    \ = extension_component\n            let class_name_component = class_name_component\n\
    \            let extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_component = extension_component\n            let class_name_component\
    \ = class_name_component\n            let extension_component = extension_component\n\
    \            let class_name_component = class_name_component\n            let\
    \ extension_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3h6ceqzk.swift:96:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp3h6ceqzk.swift:21:46: note: to\
    \ match this opening '{'\n    for i in 0..<class_name_components.count {\n   \
    \                                          ^\n/tmp/tmp3h6ceqzk.swift:96:91: error:\
    \ expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp3h6ceqzk.swift:16:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmp3h6ceqzk.swift:19:44:\
    \ error: value of type 'String' has no member 'components'\n    var class_name_components\
    \ = class_name.components(separatedBy: \".\")\n                              \
    \  ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp3h6ceqzk.swift:20:43: error: value of type '[String]'\
    \ has no member 'components'\n    var extension_components = extensions.components(separatedBy:\
    \ \".\")\n                               ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp3h6ceqzk.swift:72:17:\
    \ error: type annotation missing in pattern\n            let extension_\n    \
    \            ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for char in extension\
    \ {\n            if char.uppercased() != char {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwpydf_5t.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpwpydf_5t.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpwpydf_5t.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpwpydf_5t.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpwpydf_5t.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpwpydf_5t.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpwpydf_5t.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpwpydf_5t.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpwpydf_5t.swift:21:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmpwpydf_5t.swift:21:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmpwpydf_5t.swift:28:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpwpydf_5t.swift:29:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpwpydf_5t.swift:28:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpwpydf_5t.swift:28:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo5ixzt4f.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo5ixzt4f.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmpo5ixzt4f.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmpo5ixzt4f.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n  \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmpo5ixzt4f.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmpo5ixzt4f.swift:20:81: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:81: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:72: error:\
    \ declaration is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1\n    for extension in extensions {\n        let cap =\
    \ extension.count\n        let sm = class_name.count\n        let frac = cap -\
    \ sm\n        if frac > strength {\n            strength = frac\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxl5_d36p.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxl5_d36p.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxl5_d36p.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxl5_d36p.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpxl5_d36p.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpxl5_d36p.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpxl5_d36p.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpxl5_d36p.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpxl5_d36p.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpxl5_d36p.swift:26:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpxl5_d36p.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpxl5_d36p.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongest_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n        if extension_strength > strongest_strength\
    \ {\n            strongest = class_name\n            strongest_strength = extension_strength\n\
    \        }\n    }\n    return strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpahe4bwpb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpahe4bwpb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpahe4bwpb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpahe4bwpb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpahe4bwpb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpahe4bwpb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpahe4bwpb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpahe4bwpb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    \n    for extension in\
    \ extensions {\n        let extension_strength = extension.characters.count\n\
    \        \n        if extension_strength > strongest_extension_strength {\n  \
    \          strongest_extension_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpfqyp14q0.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpfqyp14q0.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpfqyp14q0.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpfqyp14q0.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpfqyp14q0.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpfqyp14q0.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpfqyp14q0.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpfqyp14q0.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpfqyp14q0.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpfqyp14q0.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpfqyp14q0.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpfqyp14q0.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character >= 'A' && character <= 'Z' {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpy50wgfdk.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpy50wgfdk.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpy50wgfdk.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpy50wgfdk.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpy50wgfdk.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpy50wgfdk.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpy50wgfdk.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpy50wgfdk.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpy50wgfdk.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpy50wgfdk.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpy50wgfdk.swift:22:29: error: single-quoted\
    \ string literal found, use '\"'\n            if character >= 'A' && character\
    \ <= 'Z' {\n                            ^~~\n                            \"A\"\
    \n/tmp/tmpy50wgfdk.swift:22:49: error: single-quoted string literal found, use\
    \ '\"'\n            if character >= 'A' && character <= 'Z' {\n              \
    \                                  ^~~\n                                     \
    \           \"Z\"\n/tmp/tmpy50wgfdk.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension ="
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo5ixzt4f.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo5ixzt4f.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo5ixzt4f.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmpo5ixzt4f.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmpo5ixzt4f.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n  \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmpo5ixzt4f.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToLowercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmpo5ixzt4f.swift:20:81: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:81: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmpo5ixzt4f.swift:20:72: error:\
    \ declaration is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > 0 {\n            if strongest_extension == \"\" {\n             \
    \   strongest_extension = class_name + extension\n            } else {\n     \
    \           if strength < strongest_extension.count {\n                    strongest_extension\
    \ = class_name + extension\n                }\n            }\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2gzo3x5_.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2gzo3x5_.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2gzo3x5_.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2gzo3x5_.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp2gzo3x5_.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp2gzo3x5_.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp2gzo3x5_.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp2gzo3x5_.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp2gzo3x5_.swift:25:52:\
    \ error: expected expression after operator\n                strongest_extension\
    \ = class_name + extension\n                                                 \
    \  ^\n/tmp/tmp2gzo3x5_.swift:26:13: error: expected type name in extension declaration\n\
    \            } else {\n            ^\n/tmp/tmp2gzo3x5_.swift:25:61: error: expected\
    \ '{' in extension\n                strongest_extension = class_name + extension\n\
    \                                                            ^\n/tmp/tmp2gzo3x5_.swift:25:52:\
    \ error: declaration is only valid at file scope\n                strongest_extension\
    \ = class_name + extension\n                                                 \
    \  ^\n/tmp/tmp2gzo3x5_.swift:28:56: error: expected expression after operator\n\
    \                    strongest_extension = class_name + extension\n          \
    \                                             ^\n/tmp/tmp2gzo3x5_.swift:29:17:\
    \ error: expected type name in extension declaration\n                }\n    \
    \            ^\n/tmp/tmp2gzo3x"
  stdout: ''
  timestamp: 1660009599
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpchkbv284.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpchkbv284.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpchkbv284.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpchkbv284.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpchkbv284.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpchkbv284.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpchkbv284.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpchkbv284.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpchkbv284.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpchkbv284.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpchkbv284.swift:31:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpchkbv284.swift:32:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpchkbv284.swift:31:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpchkbv284.swift:31:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, char)\
    \ -> Int in\n            let char_upper = char.uppercased()\n            let char_lower\
    \ = char.lowercased()\n            return sum + char_upper.characters.count -\
    \ char_lower.characters.count\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp37fj05rq.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp37fj05rq.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp37fj05rq.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp37fj05rq.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, char) -> Int in\n                                 ^\n/tmp/tmp37fj05rq.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, char) -> Int in\n\
    \                                ^\n                                ;\n/tmp/tmp37fj05rq.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, char) -> Int in\n                 \
    \                         ^\n/tmp/tmp37fj05rq.swift:20:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, char) -> Int in\n                                          ^\n/tmp/tmp37fj05rq.swift:20:34:\
    \ error: declaration is only valid at file scope\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, char) -> Int in\n                 \
    \                ^\n/tmp/tmp37fj05rq.swift:27:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp37fj05rq.swift:28:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp37fj05rq.swift:27:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp37fj05rq.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_components = class_name.components(separatedBy: \".\"\
    )\n        let extension_components = extension.components(separatedBy: \".\"\
    )\n        let class_name_components_count = class_name_components.count\n   \
    \     let extension_components_count = extension_components.count\n        let\
    \ class_name_components_count_cap = class_name_components.count - class_name_components_count\
    \ + 1\n        let extension_components_count_cap = extension_components.count\
    \ - extension_components_count + 1\n        let class_name_components_count_sm\
    \ = class_name_components_count - class_name_components_count_cap\n        let\
    \ extension_components_count_sm = extension_components_count - extension_components_count_cap\n\
    \        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ - class_name_components_count_sm) / 2\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap - extension_components_count_sm) / 2\n   \
    \     let class_name_components_count_cap_sm_strength = class_name_components_count_cap_sm\
    \ - class_name_components_count_sm\n        let extension_components_count_cap_sm_strength\
    \ = extension_components_count_cap_sm - extension_components_count_sm\n      \
    \  if class_name_components_count_cap_sm_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = class_name_components_count_cap_sm_strength\n        }\n    }\n    return\
    \ strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2rs43cp0.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2rs43cp0.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2rs43cp0.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2rs43cp0.swift:21:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp2rs43cp0.swift:21:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp2rs43cp0.swift:21:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp2rs43cp0.swift:21:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp2rs43cp0.swift:21:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp2rs43cp0.swift:33:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp2rs43cp0.swift:34:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_count_cap_sm_strength\n\
    \                                         ^\n/tmp/tmp2rs43cp0.swift:33:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmp2rs43cp0.swift:34:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = class_name_components_count_cap_sm_strength\n            ^~~~~~~~"
  stdout: ''
  timestamp: 1660009599
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = extensions[0]\n\
    \    for extension in extensions {\n        let cap = extension.count\n      \
    \  let sm = extension.lowercased().count\n        let strength = cap - sm\n  \
    \      if strength > strongest.count {\n            strongest = extension\n  \
    \      }\n    }\n    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1fjo3trg.swift:18:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1fjo3trg.swift:18:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1fjo3trg.swift:18:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1fjo3trg.swift:19:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp1fjo3trg.swift:19:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp1fjo3trg.swift:19:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp1fjo3trg.swift:19:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp1fjo3trg.swift:19:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp1fjo3trg.swift:20:18:\
    \ error: expected initial value after '='\n        let sm = extension.lowercased().count\n\
    \                 ^\n/tmp/tmp1fjo3trg.swift:20:17: error: consecutive statements\
    \ on a line must be separated by ';'\n        let sm = extension.lowercased().count\n\
    \                ^\n                ;\n/tmp/tmp1fjo3trg.swift:20:27: error: expected\
    \ type name in extension declaration\n        let sm = extension.lowercased().count\n\
    \                          ^\n/tmp/tmp1fjo3trg.swift:20:27: error: expected '{'\
    \ in extension\n        let sm = extension.lowercased().count\n              \
    \            ^\n/tmp/tmp1fjo3trg.swift:20:18: error: declaration is only valid\
    \ at file scope\n        let sm = extension.lowercased().count\n             \
    \    ^\n/tmp/tmp1fjo3trg.swift:23:25: error: expected expression in assignment\n\
    \            strongest = extension\n                        ^\n/tmp/tmp1fjo3trg.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp1fjo3trg.swift:23:3"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmp9mvwlz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmp9mvwlz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmp9mvwlz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpmp9mvwlz.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmp9mvwlz.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmp9mvwlz.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmp9mvwlz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n            if character == character.lowercaseString {\n       \
    \         return sum + 1\n            } else {\n                return sum\n \
    \           }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp382bjhm2.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp382bjhm2.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp382bjhm2.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp382bjhm2.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                 ^\n/tmp/tmp382bjhm2.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, character) -> Int\
    \ in\n                                ^\n                                ;\n/tmp/tmp382bjhm2.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, character) -> Int in\n            \
    \                              ^\n/tmp/tmp382bjhm2.swift:20:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                          ^\n\
    /tmp/tmp382bjhm2.swift:20:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n                                 ^\n/tmp/tmp382bjhm2.swift:28:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp382bjhm2.swift:29:42:\
    \ error: expected '{' in extension\n            strongest_extension_strength =\
    \ extension_strength\n                                         ^\n/tmp/tmp382bjhm2.swift:28:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmp382bjhm2.swift:29:13:\
    \ error: cannot find type 'strongest_extension_strength' in scope\n          \
    \  strongest_extension_strength = extens"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppkg0l_ln.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmppkg0l_ln.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmppkg0l_ln.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmppkg0l_ln.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmppkg0l_ln.swift:20:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmppkg0l_ln.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \        ^\n/tmp/tmppkg0l_ln.swift:20:43: error: expected '{' in extension\n \
    \       let extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmppkg0l_ln.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmppkg0l_ln.swift:20:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmppkg0l_ln.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToCapitalLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmppkg0l"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphhrxax4s.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphhrxax4s.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphhrxax4s.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphhrxax4s.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmphhrxax4s.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmphhrxax4s.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmphhrxax4s.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmphhrxax4s.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmphhrxax4s.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmphhrxax4s.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmphhrxax4s.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmphhrxax4s.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countElements() / class_name.countElements()\n        if extension_strength\
    \ > max_strength {\n            max_strength = extension_strength\n          \
    \  strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8m9v7kqo.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8m9v7kqo.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8m9v7kqo.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8m9v7kqo.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countElements()\
    \ / class_name.countElements()\n                                 ^\n/tmp/tmp8m9v7kqo.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countElements() / class_name.countElements()\n\
    \                                ^\n                                ;\n/tmp/tmp8m9v7kqo.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countElements() / class_name.countElements()\n                 \
    \                         ^\n/tmp/tmp8m9v7kqo.swift:20:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.countElements() / class_name.countElements()\n\
    \                                          ^\n/tmp/tmp8m9v7kqo.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countElements()\
    \ / class_name.countElements()\n                                 ^\n/tmp/tmp8m9v7kqo.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp8m9v7kqo.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp8m9v7kqo.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp8m9v7kqo.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmp9mvwlz.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmp9mvwlz.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmp9mvwlz.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmp9mvwlz.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmp9mvwlz.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpmp9mvwlz.swift:21:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpmp9mvwlz.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmp9mvwlz.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmp9mvwlz.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmp9mvwlz.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        var strength\
    \ = class_name.countUpToIndex(extension.lowercased())\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2c0zfjg_.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2c0zfjg_.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2c0zfjg_.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2c0zfjg_.swift:20:50:\
    \ error: expected expression in list of expressions\n        var strength = class_name.countUpToIndex(extension.lowercased())\n\
    \                                                 ^\n/tmp/tmp2c0zfjg_.swift:20:50:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ strength = class_name.countUpToIndex(extension.lowercased())\n             \
    \                                    ^\n                                     \
    \            ;\n/tmp/tmp2c0zfjg_.swift:20:59: error: expected type name in extension\
    \ declaration\n        var strength = class_name.countUpToIndex(extension.lowercased())\n\
    \                                                          ^\n/tmp/tmp2c0zfjg_.swift:20:59:\
    \ error: expected '{' in extension\n        var strength = class_name.countUpToIndex(extension.lowercased())\n\
    \                                                          ^\n/tmp/tmp2c0zfjg_.swift:20:50:\
    \ error: declaration is only valid at file scope\n        var strength = class_name.countUpToIndex(extension.lowercased())\n\
    \                                                 ^\n/tmp/tmp2c0zfjg_.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp2c0zfjg_.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp2c0zfjg_.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp2c0zfjg_.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmp2c0zfjg_.swift:20:35: error: value\
    \ of type "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n        if extension_strength > max_strength {\n            max_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5nw_y738.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5nw_y738.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5nw_y738.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5nw_y738.swift:20:82:\
    \ error: expected expression after operator\n        let extension_strength =\
    \ class_name.components(separatedBy: \".\").count - extension.components(separatedBy:\
    \ \".\").count\n                                                             \
    \                    ^\n/tmp/tmp5nw_y738.swift:20:81: error: consecutive statements\
    \ on a line must be separated by ';'\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                    ^\n     \
    \                                                                           ;\n\
    /tmp/tmp5nw_y738.swift:20:91: error: expected type name in extension declaration\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                                 ^\n/tmp/tmp5nw_y738.swift:20:91:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ \".\").count - extension.components(separatedBy: \".\").count\n            \
    \                                                                            \
    \  ^\n/tmp/tmp5nw_y738.swift:20:82: error: declaration is only valid at file scope\n\
    \        let extension_strength = class_name.components(separatedBy: \".\").count\
    \ - extension.components(separatedBy: \".\").count\n                         \
    \                                                        ^\n/tmp/tmp5nw_y738.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp5nw_y"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvcrp2j40.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvcrp2j40.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvcrp2j40.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvcrp2j40.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvcrp2j40.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpvcrp2j40.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvcrp2j40.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvcrp2j40.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvcrp2j40.swift:22:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpvcrp2j40.swift:23:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpvcrp2j40.swift:22:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpvcrp2j40.swift:23:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp04oq72sx.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvkx146kq.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvkx146kq.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvkx146kq.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvkx146kq.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvkx146kq.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpvkx146kq.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvkx146kq.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvkx146kq.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvkx146kq.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpvkx146kq.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpvkx146kq.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpvkx146kq.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuabxz7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpatuabxz7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpatuabxz7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpatuabxz7.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpatuabxz7.swift:20:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpatuabxz7.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpatuabxz7.swift:20:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpatuabxz7.swift:20:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpatuabxz7.swift:20:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countElements() / class_name.countElements()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5tawjny.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw5tawjny.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw5tawjny.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw5tawjny.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countElements()\
    \ / class_name.countElements()\n                                 ^\n/tmp/tmpw5tawjny.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countElements() / class_name.countElements()\n\
    \                                ^\n                                ;\n/tmp/tmpw5tawjny.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countElements() / class_name.countElements()\n                 \
    \                         ^\n/tmp/tmpw5tawjny.swift:20:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.countElements() / class_name.countElements()\n\
    \                                          ^\n/tmp/tmpw5tawjny.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countElements()\
    \ / class_name.countElements()\n                                 ^\n/tmp/tmpw5tawjny.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpw5tawjny.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpw5tawjny.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw5tawjny.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let class_name_extension = class_name + extension\n        let class_name_extension_strength\
    \ = class_name_extension.characters.count\n        if class_name_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = class_name_extension\n\
    \            strongest_extension_strength = class_name_extension_strength\n  \
    \      }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqi0celt5.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpqi0celt5.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpqi0celt5.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpqi0celt5.swift:20:49:\
    \ error: expected expression after operator\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmpqi0celt5.swift:20:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        let class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmpqi0celt5.swift:21:9: error: expected type name\
    \ in extension declaration\n        let class_name_extension_strength = class_name_extension.characters.count\n\
    \        ^\n/tmp/tmpqi0celt5.swift:20:58: error: expected '{' in extension\n \
    \       let class_name_extension = class_name + extension\n                  \
    \                                       ^\n/tmp/tmpqi0celt5.swift:20:49: error:\
    \ declaration is only valid at file scope\n        let class_name_extension =\
    \ class_name + extension\n                                                ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongest_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n        if extension_strength > strongest_strength\
    \ {\n            strongest = class_name\n            strongest_strength = extension_strength\n\
    \        }\n    }\n    return strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpahe4bwpb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpahe4bwpb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpahe4bwpb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpahe4bwpb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpahe4bwpb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpahe4bwpb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpahe4bwpb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpahe4bwpb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvh28y94q.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvh28y94q.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvh28y94q.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvh28y94q.swift:22:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpvh28y94q.swift:23:42:\
    \ error: expected '{' in extension\n            strongest_extension_strength =\
    \ extension_strength\n                                         ^\n/tmp/tmpvh28y94q.swift:22:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmpvh28y94q.swift:23:13:\
    \ error: cannot find type 'strongest_extension_strength' in scope\n          \
    \  strongest_extension_strength = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvh28y94q.swift:20:45: error: 'characters' is unavailable: Please use String\
    \ directly\n        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvh28y94q.swift:20:102: error: 'characters' is unavailable:\
    \ Please use String directly\n        let extension_strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strength = Int()\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength_fraction = cap - sm\n\
    \        strength = strength * strength_fraction + strength_fraction\n       \
    \ if strength > strongest.count {\n            strongest = extension\n       \
    \ }\n    }\n    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpauc9euzj.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpauc9euzj.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpauc9euzj.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpauc9euzj.swift:20:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpauc9euzj.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpauc9euzj.swift:20:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpauc9euzj.swift:20:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpauc9euzj.swift:20:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpauc9euzj.swift:25:25:\
    \ error: expected expression in assignment\n            strongest = extension\n\
    \                        ^\n/tmp/tmpauc9euzj.swift:26:9: error: expected type\
    \ name in extension declaration\n        }\n        ^\n/tmp/tmpauc9euzj.swift:25:34:\
    \ error: expected '{' in extension\n            strongest = extension\n      \
    \                           ^\n/tmp/tmpauc9euzj.swift:25:25: error: declaration\
    \ is only valid at file scope\n            strongest = extension\n           \
    \             ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smaller_capitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smaller_capitalized_extension\
    \ = extension_counter_string_smaller_capitalized.components(separatedBy: \".\"\
    )\n        let extension_counter_string_smaller_capitalized_extension_strength\
    \ = extension_counter_string_smaller_capitalized_extension.count\n        if extension_counter_string_smaller_capitalized_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = class_name\n\
    \            strongest_extension_strength = extension_counter_string_smaller_capitalized_extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpznb4fr_5.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpznb4fr_5.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpznb4fr_5.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpznb4fr_5.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3o3wciy.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3o3wciy.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpr3o3wciy.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpr3o3wciy.swift:20:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpr3o3wciy.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:7"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvcrp2j40.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvcrp2j40.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvcrp2j40.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvcrp2j40.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvcrp2j40.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpvcrp2j40.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvcrp2j40.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvcrp2j40.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpvcrp2j40.swift:22:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpvcrp2j40.swift:23:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpvcrp2j40.swift:22:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpvcrp2j40.swift:23:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strength = -1 // default strength is -1\n    for extension in extensions\
    \ {\n        var cap = extension.count\n        var sm = extension.lowercased().count\n\
    \        strength = cap - sm\n        if strength > 0 {\n            strongest_extension\
    \ = class_name + extension\n            break\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdjud43dm.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdjud43dm.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdjud43dm.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdjud43dm.swift:20:19:\
    \ error: expected initial value after '='\n        var cap = extension.count\n\
    \                  ^\n/tmp/tmpdjud43dm.swift:20:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        var cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpdjud43dm.swift:20:28: error: expected\
    \ type name in extension declaration\n        var cap = extension.count\n    \
    \                       ^\n/tmp/tmpdjud43dm.swift:20:28: error: expected '{' in\
    \ extension\n        var cap = extension.count\n                           ^\n\
    /tmp/tmpdjud43dm.swift:20:19: error: declaration is only valid at file scope\n\
    \        var cap = extension.count\n                  ^\n/tmp/tmpdjud43dm.swift:21:18:\
    \ error: expected initial value after '='\n        var sm = extension.lowercased().count\n\
    \                 ^\n/tmp/tmpdjud43dm.swift:21:17: error: consecutive statements\
    \ on a line must be separated by ';'\n        var sm = extension.lowercased().count\n\
    \                ^\n                ;\n/tmp/tmpdjud43dm.swift:21:27: error: expected\
    \ type name in extension declaration\n        var sm = extension.lowercased().count\n\
    \                          ^\n/tmp/tmpdjud43dm.swift:21:27: error: expected '{'\
    \ in extension\n        var sm = extension.lowercased().count\n              \
    \            ^\n/tmp/tmpdjud43dm.swift:21:18: error: declaration is only valid\
    \ at file scope\n        var sm = extension.lowercased().count\n             \
    \    ^\n/tmp/tmpdjud43dm.swift:24:48: error: expected expression after operator\n\
    \            strongest_extension = class_name + extension\n                  \
    \                             ^\n/tmp/tmpdjud43dm.swift:25:13: error: expected\
    \ type name in extension declaration"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character >= 'A' && character <= 'Z' {\n                extension_strength\
    \ -= 1\n            }\n            if character >= 'a' && character <= 'z' {\n\
    \                extension_strength += 1\n            }\n        }\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprzvu95a3.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmprzvu95a3.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmprzvu95a3.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmprzvu95a3.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmprzvu95a3.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmprzvu95a3.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmprzvu95a3.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmprzvu95a3.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmprzvu95a3.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmprzvu95a3.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmprzvu95a3.swift:22:29: error: single-quoted\
    \ string literal found, use '\"'\n            if character >= 'A' && character\
    \ <= 'Z' {\n                            ^~~\n                            \"A\"\
    \n/tmp/tmprzvu95a3.swift:22:49: error: single-quoted string literal found, use\
    \ '\"'\n            if character >= 'A' && character <= 'Z' {\n              \
    \                                  ^~~\n                                     \
    \           \"Z\"\n/tmp/tmprzvu95a3.swift:25:29: error: single-quoted string literal\
    \ found, use '\"'\n            if characte"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpf0818ij8.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpf0818ij8.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpf0818ij8.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpf0818ij8.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpf0818ij8.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpf0818ij8.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpf0818ij8.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpf0818ij8.swift:20:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpf0818ij8.swift:20:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpf0818ij8.swift:20:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpf0818ij8.swift:20:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3o3wciy.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3o3wciy.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3o3wciy.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpr3o3wciy.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpr3o3wciy.swift:20:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpr3o3wciy.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpr3o3wciy.swift:20:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpr3o3wciy.swift:20:7"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters()\n    \
    \    if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6faq0shb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6faq0shb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6faq0shb.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6faq0shb.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6faq0shb.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6faq0shb.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6faq0shb.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6faq0shb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6faq0shb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmph5kvkc05.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmph5kvkc05.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmph5kvkc05.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmph5kvkc05.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmph5kvkc05.swift:22:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmph5kvkc05.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmph5kvkc05.swift:22:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmph5kvkc05.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmph5kvkc05.swift:22:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmph5kvkc05.swift:22:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmph5kvkc05.swift:22:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpoy6q3oxu.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpoy6q3oxu.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpoy6q3oxu.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpoy6q3oxu.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpoy6q3oxu.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpoy6q3oxu.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpoy6q3oxu.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpoy6q3oxu.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpoy6q3oxu.swift:21:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpoy6q3oxu.swift:21:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpoy6q3oxu.swift:27:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpoy6q3oxu.swift:28:42: error: expected '{' in extension\n\
    \            strongest_extension_strength = extension_strength\n             \
    \                            ^\n/tmp/tmpoy6q3oxu.swift:27:35: error: declaration\
    \ is only valid at file scope\n            strongest_extension = extension\n \
    \                                 ^\n/tmp/tmpoy6q3oxu.swift:28:13: error: cannot\
    \ find type 'strongest_e"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1d_26wv7.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1d_26wv7.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1d_26wv7.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1d_26wv7.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmp1d_26wv7.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmp1d_26wv7.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp1d_26wv7.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmp1d_26wv7.swift:20:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUpToLowercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmp1d_26wv7.swift:20:83:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmp1d_26wv7.swift:20:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmp1d_26wv7.swift:"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmphgskkc1y.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.characters.filter({ $0.isUppercase\
    \ }).count - class_name.characters.filter({ $0.isLowercase }).count\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpp0yhpmwb.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpp0yhpmwb.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpp0yhpmwb.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpp0yhpmwb.swift:23:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpp0yhpmwb.swift:24:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpp0yhpmwb.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpp0yhpmwb.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpp0yhpmwb.swift:20:45: error: 'characters'\
    \ is unavailable: Please use String directly\n        let extension_strength =\
    \ class_name.characters.filter({ $0.isUppercase }).count - class_name.characters.filter({\
    \ $0.isLowercase }).count\n                                            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpp0yhpmwb.swift:20:102:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ extension_strength = class_name.characters.filter({ $0.isUppercase }).count\
    \ - class_name.characters.filter({ $0.isLowercase }).count\n                 \
    \                                                                            \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = class_name.components(separatedBy: extension.lowercased()).count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppp2gas84.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmppp2gas84.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmppp2gas84.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmppp2gas84.swift:20:69:\
    \ error: expected expression in list of expressions\n        let extension_strength\
    \ = class_name.components(separatedBy: extension.lowercased()).count\n       \
    \                                                             ^\n/tmp/tmppp2gas84.swift:20:68:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = class_name.components(separatedBy: extension.lowercased()).count\n\
    \                                                                   ^\n      \
    \                                                             ;\n/tmp/tmppp2gas84.swift:20:78:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = class_name.components(separatedBy: extension.lowercased()).count\n       \
    \                                                                      ^\n/tmp/tmppp2gas84.swift:20:78:\
    \ error: expected '{' in extension\n        let extension_strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \                                 ^\n/tmp/tmppp2gas84.swift:20:69: error: declaration\
    \ is only valid at file scope\n        let extension_strength = class_name.components(separatedBy:\
    \ extension.lowercased()).count\n                                            \
    \                        ^\n/tmp/tmppp2gas84.swift:22:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmppp2gas84.swift:23:42: error: expected '{' in extension\n\
    \            strongest_extension_strength = extension_strength\n             \
    \                            ^\n/tmp/tmppp2gas84.swift:22:35: error: declaration\
    \ is onl"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        var extension_strength = extension.count\n        for c in extension\
    \ {\n            if c >= 'A' && c <= 'Z' {\n                extension_strength\
    \ = extension_strength * 26 + c - 'A' + 1\n            } else if c >= 'a' && c\
    \ <= 'z' {\n                extension_strength = extension_strength * 26 + c -\
    \ 'a' + 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzihrdg18.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpzihrdg18.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpzihrdg18.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpzihrdg18.swift:20:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpzihrdg18.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpzihrdg18.swift:20:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpzihrdg18.swift:20:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpzihrdg18.swift:20:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpzihrdg18.swift:21:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpzihrdg18.swift:21:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpzihrdg18.swift:22:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpzihrdg18.swift:22:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpzihrdg18.swift:23:68: error: single-quoted string literal\
    \ found, use '\"'\n                extension_strength = extension_strength * 26\
    \ + c - 'A' + 1\n                                                            "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5t8mgumd.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5t8mgumd.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5t8mgumd.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5t8mgumd.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp5t8mgumd.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp5t8mgumd.swift:20:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp5t8mgumd.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp5t8mgumd.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp5t8mgumd.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp5t8mgumd.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp5t8mgumd.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp5t8mgumd.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    // Your code here\n   \
    \ \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmprd7p9u68/tmprd7p9u68.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac97fa5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac97f756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac97f756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac97f7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd7p9u68                        0x000055e0bda444fd <unavailable> + 5373

    5    libc.so.6                          0x00002ac97fc4b460 __libc_start_main +
    245

    6    tmprd7p9u68                        0x000055e0bda44089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    for extension in extensions {\n\
    \        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9g15oen.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo9g15oen.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo9g15oen.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:20:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpo9g15oen.swift:20:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpo9g15oen.swift:20:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpo9g15oen.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpo9g15oen.swift:24:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpo9g15oen.swift:23:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpo9g15oen.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    \n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    \n    for extension in\
    \ extensions {\n        var extension_strength = extension.count\n        for\
    \ letter in extension {\n            if letter.isUppercase {\n               \
    \ extension_strength -= 1\n            }\n            if letter.isLowercase {\n\
    \                extension_strength += 1\n            }\n        }\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    \n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0tns9rpb.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp0tns9rpb.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp0tns9rpb.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp0tns9rpb.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp0tns9rpb.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp0tns9rpb.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp0tns9rpb.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp0tns9rpb.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp0tns9rpb.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp0tns9rpb.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp0tns9rpb.swift:33:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp0tns9rpb.swift:34:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp0tns9rpb.swift:33:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp0tns9rpb.swift:33:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var class_name_uppercase = class_name.uppercased()\n\
    \    var class_name_lowercase = class_name.lowercased()\n    for extension in\
    \ extensions {\n        var extension_uppercase = extension.uppercased()\n   \
    \     var extension_lowercase = extension.lowercased()\n        var extension_strength\
    \ = class_name_uppercase.distance(class_name_lowercase)\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvirxfik2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvirxfik2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvirxfik2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvirxfik2.swift:22:35:\
    \ error: expected initial value after '='\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmpvirxfik2.swift:22:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_uppercase\
    \ = extension.uppercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpvirxfik2.swift:22:44: error: expected type name\
    \ in extension declaration\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmpvirxfik2.swift:22:44: error:\
    \ expected '{' in extension\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmpvirxfik2.swift:22:35: error:\
    \ declaration is only valid at file scope\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmpvirxfik2.swift:23:35: error: expected\
    \ initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpvirxfik2.swift:23:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpvirxfik2.swift:23:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpvirxfik2.swift:23:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpvirxfik2.swift:23:35: error:\
    \ declaration is only val"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = -1\n    var extension_counter = 0\n \
    \   for extension in extensions {\n        extension_counter += 1\n        let\
    \ extension_counter_string = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smallerCapitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smallerCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalized.capitalizedAndCapitalized()\n\
    \        let extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalizedAndCapitalized.capitalizedAndCapitalizedAndCapitalized()\n\
    \        let extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalized.capitalizedAndCapitalizedAndCapitalizedAndCapitalized()\n\
    \        let extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalized.capitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized()\n\
    \        let extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized.capitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized()\n\
    \        let extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp903y8nrt.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp903y8nrt.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp903y8nrt.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp903y8nrt.swift:55:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp903y8nrt.swift:16:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmp903y8nrt.swift:35:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp903y8nrt.swift:23:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp903y8nrt.swift:30:129:\
    \ error: use of local variable 'extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized'\
    \ before its declaration\n        let extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized\
    \ = extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized.capitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapitalized()\n\
    \                                                                            \
    \                                                    ^\n/tmp/tmp903y8nrt.swift:30:13:\
    \ note: 'extension_counter_string_smallerCapitalizedAndCapitalizedAndCapitalizedAndCapitalizedAndCapi"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4wyf1xa.swift:19:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4wyf1xa.swift:19:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4wyf1xa.swift:19:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4wyf1xa.swift:20:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpw4wyf1xa.swift:20:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpw4wyf1xa.swift:20:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4wyf1xa.swift:20:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpw4wyf1xa.swift:20:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUpToLowercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpw4wyf1xa.swift:20:83:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpw4wyf1xa.swift:20:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToLowercaseLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpw4wyf1xa.swift:"
  stdout: ''
  timestamp: 1660009599
