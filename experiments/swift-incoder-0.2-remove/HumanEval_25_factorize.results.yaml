language: swift
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization: Bool = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorization: Bool = false\n    var isPrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphtj6dvnm.swift:21:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n        ^\n/tmp/tmphtj6dvnm.swift:19:9:\
    \ note: 'isPrimePrimePrimePrimePrimeFactorization' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n        ^\n/tmp/tmphtj6dvnm.swift:33:9:\
    \ error: type annotation missing in pattern\n    var isPrimePrimePrimePrimePrimePrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationCount = [Int]()\n    var primeFactorizationCountMax\
    \ = Int()\n    var primeFactorizationCountMaxIndex = -1\n    var primeFactorizationCountMaxValue\
    \ = Int()\n    var primeFactorizationCountMaxValueIndex = -1\n    var primeFactorizationCountMaxValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1tyasmvr.swift:19:9: error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp1tyasmvr.swift:17:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp1tyasmvr.swift:20:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueValue'\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp1tyasmvr.swift:18:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueValue' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp1tyasmvr.swift:21:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp1tyasmvr.swift:17:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp1tyasmvr.swift:22:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueValue'\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp1tyasmvr.swift:18:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueValue' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp1tyasmvr.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp1tyasmvr.swift:17:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp1tyasmvr.swift:24:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueValue'\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp1tyasmvr.swift:18:9:\
    \ note: 'primeFactorizationCoun"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var primeFactorizationIndex = [Int]()\n\
    \    var primeFactorizationIndexCount = [Int]()\n    var primeFactorizationIndexCountMax\
    \ = Int()\n    var primeFactorizationIndexCountMin = Int()\n    var primeFactorizationIndexCountSum\
    \ = Int()\n    var primeFactorizationIndexSum = Int()\n    var primeFactorizationIndexSumMax\
    \ = Int()\n    var primeFactorizationIndexSumMin = Int()\n    var primeFactorizationIndexSumSum\
    \ = Int()\n    var primeFactorizationIndexSumSumMax = Int()\n    var primeFactorizationIndexSumSumMin\
    \ = Int()\n    var primeFactorizationIndexSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumMax\
    \ = Int()\n    var primeFactorizationIndexSumSumSumMin = Int()\n    var primeFactorizationIndexSumSumSumSum\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumMax = Int()\n    var primeFactorizationIndexSumSumSumSumMin\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumSumSumMax\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumSumMin = Int()\n    var\
    \ primeFactorizationIndexSumSumSumSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumMax\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumMin = Int()\n    var\
    \ primeFactorizationIndexSumSumSumSumSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumMax\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumMin = Int()\n \
    \   var primeFactorizationIndexSumSumSumSumSumSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumMax\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumMin = Int()\n \
    \   var primeFactorizationIndexSumSumSumSumSumSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumSumMax\
    \ = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumSumMin = Int()\n\
    \    var primeFactorizationIndexSumSumSumSumSumSumSumSumSum = Int()\n    var primeFactorizationIndexSumSumSumSumSumSumSumSumSumMax\
    \ = Int()\n    var primeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxzgj50ag.swift:36:9: error: invalid redeclaration of 'primeFactorizationIndexSumSumSumSumSumSumSumMax'\n\
    \    var primeFactorizationIndexSumSumSumSumSumSumSumMax = Int()\n        ^\n\
    /tmp/tmpxzgj50ag.swift:33:9: note: 'primeFactorizationIndexSumSumSumSumSumSumSumMax'\
    \ previously declared here\n    var primeFactorizationIndexSumSumSumSumSumSumSumMax\
    \ = Int()\n        ^\n/tmp/tmpxzgj50ag.swift:37:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexSumSumSumSumSumSumSumMin'\n    var primeFactorizationIndexSumSumSumSumSumSumSumMin\
    \ = Int()\n        ^\n/tmp/tmpxzgj50ag.swift:34:9: note: 'primeFactorizationIndexSumSumSumSumSumSumSumMin'\
    \ previously declared here\n    var primeFactorizationIndexSumSumSumSumSumSumSumMin\
    \ = Int()\n        ^\n/tmp/tmpxzgj50ag.swift:38:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexSumSumSumSumSumSumSumSum'\n    var primeFactorizationIndexSumSumSumSumSumSumSumSum\
    \ = Int()\n        ^\n/tmp/tmpxzgj50ag.swift:35:9: note: 'primeFactorizationIndexSumSumSumSumSumSumSumSum'\
    \ previously declared here\n    var primeFactorizationIndexSumSumSumSumSumSumSumSum\
    \ = Int()\n        ^\n/tmp/tmpxzgj50ag.swift:43:9: error: type annotation missing\
    \ in pattern\n    var primeFactor\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n  \
    \  var primeFactorizationCount = 0\n    var primeFactorization = [Int]()\n   \
    \ var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n    var\
    \ primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n  \
    \  var factorizationCount = 0\n    var primeFactorization = [Int]()\n    var primeFactorizationCount\
    \ = [Int]()\n    var factorizationCount = 0\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var factorizationCount = 0\n    var primeFactorization = [Int]()\n    var\
    \ primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationCount = [Int]()\n    var factorizationCount\
    \ = 0\n    var primeFactorization = [Int]()\n    var primeFactorizationCount =\
    \ [Int]()\n    var factorizationCount = 0\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var factorizationCount = 0\n    var primeFactorization = [Int]()\n    var\
    \ primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationCount = [Int]()\n    var factorizationCount\
    \ = 0\n    var primeFactorization = [Int]()\n    var primeFactorizationCount =\
    \ [Int]()\n    var factorizationCount = 0\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var factorizationCount = 0\n    var primeFactorization = [Int]()\n    var\
    \ primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationCount = [Int]()\n    var factorizationCount\
    \ = 0\n    var primeFactorization = [Int]()\n    var primeFactorizationCount =\
    \ [Int]()\n    var factorizationCount = 0\n    var primeFactorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorization\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp562fu4nn.swift:10:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmp562fu4nn.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:11:9: error: invalid redeclaration\
    \ of 'primeFactorization'\n    var primeFactorization = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:7:9:\
    \ note: 'primeFactorization' previously declared here\n    var primeFactorization\
    \ = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:12:9: error: invalid redeclaration\
    \ of 'primeFactorizationCount'\n    var primeFactorizationCount = [Int]()\n  \
    \      ^\n/tmp/tmp562fu4nn.swift:8:9: note: 'primeFactorizationCount' previously\
    \ declared here\n    var primeFactorizationCount = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:13:9:\
    \ error: invalid redeclaration of 'factorizationCount'\n    var factorizationCount\
    \ = 0\n        ^\n/tmp/tmp562fu4nn.swift:9:9: note: 'factorizationCount' previously\
    \ declared here\n    var factorizationCount = 0\n        ^\n/tmp/tmp562fu4nn.swift:14:9:\
    \ error: invalid redeclaration of 'primeFactorization'\n    var primeFactorization\
    \ = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:7:9: note: 'primeFactorization'\
    \ previously declared here\n    var primeFactorization = [Int]()\n        ^\n\
    /tmp/tmp562fu4nn.swift:15:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:8:9:\
    \ note: 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:16:9: error: invalid redeclaration\
    \ of 'factorizationCount'\n    var factorizationCount = 0\n        ^\n/tmp/tmp562fu4nn.swift:9:9:\
    \ note: 'factorizationCount' previously declared here\n    var factorizationCount\
    \ = 0\n        ^\n/tmp/tmp562fu4nn.swift:17:9: error: invalid redeclaration of\
    \ 'primeFactorization'\n    var primeFactorization = [Int]()\n        ^\n/tmp/tmp562fu4nn.swift:7:9:\
    \ note: 'primeFactorization' previously declared here\n    var primeFact"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var primeFactorizationCountMax\
    \ = Int()\n    var primeFactorizationCountMin = Int()\n    var primeFactorizationCountSum\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorizationCountSumMin\
    \ = Int()\n    var primeFactorizationCountSumMax = Int()\n    var primeFactorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_plpoj5j.swift:14:9: error: invalid redeclaration of 'primeFactorizationCountSumMax'\n\
    \    var primeFactorizationCountSumMax = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:12:9:\
    \ note: 'primeFactorizationCountSumMax' previously declared here\n    var primeFactorizationCountSumMax\
    \ = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:15:9: error: invalid redeclaration\
    \ of 'primeFactorizationCountSumMin'\n    var primeFactorizationCountSumMin =\
    \ Int()\n        ^\n/tmp/tmp_plpoj5j.swift:13:9: note: 'primeFactorizationCountSumMin'\
    \ previously declared here\n    var primeFactorizationCountSumMin = Int()\n  \
    \      ^\n/tmp/tmp_plpoj5j.swift:16:9: error: invalid redeclaration of 'primeFactorizationCountSumMax'\n\
    \    var primeFactorizationCountSumMax = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:12:9:\
    \ note: 'primeFactorizationCountSumMax' previously declared here\n    var primeFactorizationCountSumMax\
    \ = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:17:9: error: invalid redeclaration\
    \ of 'primeFactorizationCountSumMin'\n    var primeFactorizationCountSumMin =\
    \ Int()\n        ^\n/tmp/tmp_plpoj5j.swift:13:9: note: 'primeFactorizationCountSumMin'\
    \ previously declared here\n    var primeFactorizationCountSumMin = Int()\n  \
    \      ^\n/tmp/tmp_plpoj5j.swift:18:9: error: invalid redeclaration of 'primeFactorizationCountSumMax'\n\
    \    var primeFactorizationCountSumMax = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:12:9:\
    \ note: 'primeFactorizationCountSumMax' previously declared here\n    var primeFactorizationCountSumMax\
    \ = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:19:9: error: invalid redeclaration\
    \ of 'primeFactorizationCountSumMin'\n    var primeFactorizationCountSumMin =\
    \ Int()\n        ^\n/tmp/tmp_plpoj5j.swift:13:9: note: 'primeFactorizationCountSumMin'\
    \ previously declared here\n    var primeFactorizationCountSumMin = Int()\n  \
    \      ^\n/tmp/tmp_plpoj5j.swift:20:9: error: invalid redeclaration of 'primeFactorizationCountSumMax'\n\
    \    var primeFactorizationCountSumMax = Int()\n        ^\n/tmp/tmp_plpoj5j.swift:12:9:\
    \ note: 'primeFactorizationCountSumMax' previously declared here\n    var primeFactorizatio"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    var j = 1\n    var factorization\
    \ = factorizationOf(n)\n    for factor in factorization {\n        while i < factor\
    \ {\n            i += 1\n            j += 1\n        }\n        factors.append(j)\n\
    \        j = 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc5512urg.swift:9:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var factor:\
    \ Int = 0\n    var factorCount = 0\n    var isPrimeFactorization: Bool = false\n\
    \    var isPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrime: Bool\
    \ = false\n    var isPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimePrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimePrimeCount = 0\n    var isPrimeFactorizationPrimePrimePrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimePrimePrimeCount = 0\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrime: Bool = false\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimeCount = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimeFactorizationPrimePrimePrimePrimePrimeCount = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime: Bool =\
    \ false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime: Bool\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime: Bool\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz7ahu3ig.swift:37:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpz7ahu3ig.swift:22:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpz7ahu3ig.swift:20:9:\
    \ note: 'isPrimeFactorizationPrimePrimePrimePrime' previously declared here\n\
    \    var isPrimeFactorizationPrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpz7ahu3ig.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimeCount'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz7ahu3ig.swift:21:9:\
    \ note: 'isPrimeFactorizationPrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz7ahu3ig.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz7ahu3ig.swift:25:9:\
    \ note: 'isPrimeFactorizationPrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimeCount = 0\n     \
    \   ^\n/tmp/tmpz7ahu3ig.swift:28:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \      ^\n/tmp/tmpz7ahu3ig.swift:26:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz7ahu3ig.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz7ahu3ig.swift:32:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz7ahu3ig.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeFac"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    var factorizationSize = factorization.count\n    var factorizationIndex =\
    \ 0\n    var factorizationNumber = 0\n    var factorizationNumberIndex = 0\n \
    \   var factorizationNumberIndex2 = 0\n    var factorizationNumberIndex3 = 0\n\
    \    var factorizationNumberIndex4 = 0\n    var factorizationNumberIndex5 = 0\n\
    \    var factorizationNumberIndex6 = 0\n    var factorizationNumberIndex7 = 0\n\
    \    var factorizationNumberIndex8 = 0\n    var factorizationNumberIndex9 = 0\n\
    \    var factorizationNumberIndex10 = 0\n    var factorizationNumberIndex11 =\
    \ 0\n    var factorizationNumberIndex12 = 0\n    var factorizationNumberIndex13\
    \ = 0\n    var factorizationNumberIndex14 = 0\n    var factorizationNumberIndex15\
    \ = 0\n    var factorizationNumberIndex16 = 0\n    var factorizationNumberIndex17\
    \ = 0\n    var factorizationNumberIndex18 = 0\n    var factorizationNumberIndex19\
    \ = 0\n    var factorizationNumberIndex20 = 0\n    var factorizationNumberIndex21\
    \ = 0\n    var factorizationNumberIndex22 = 0\n    var factorizationNumberIndex23\
    \ = 0\n    var factorizationNumberIndex24 = 0\n    var factorizationNumberIndex25\
    \ = 0\n    var factorizationNumberIndex26 = 0\n    var factorizationNumberIndex27\
    \ = 0\n    var factorizationNumberIndex28 = 0\n    var factorizationNumberIndex29\
    \ = 0\n    var factorizationNumberIndex30 = 0\n    var factorizationNumberIndex31\
    \ = 0\n    var factorizationNumberIndex32 = 0\n    var factorizationNumberIndex33\
    \ = 0\n    var factorizationNumberIndex34 = 0\n    var factorizationNumberIndex35\
    \ = 0\n    var factorizationNumberIndex36 = 0\n    var factorizationNumberIndex37\
    \ = 0\n    var factorizationNumberIndex38 = 0\n    var factorizationNumberIndex39\
    \ = 0\n    var factorizationNumberIndex40 = 0\n    var factorizationNumberIndex41\
    \ = 0\n    var factorizationNumberIndex42 = 0\n    var factorizationNumberIndex43\
    \ = 0\n    var factorizationNumberIndex44 = 0\n    var factorizationNumberIndex45\
    \ = 0\n    var factorizationNumberIndex46 = 0\n    var factorizationNumberIndex47\
    \ = 0\n    var factorizationNumberIndex48 = 0\n    var factorizationNumberIndex49\
    \ = 0\n    var factorizationNumberIndex50 = 0\n    var factorizationNumberIndex51\
    \ = 0\n    var factorizationNumberIndex52 = 0\n    var factorizationNumberIndex53\
    \ = 0\n    var factorizationNumberIndex54 = 0\n    var factorizationNumberIndex55\
    \ = 0\n    var factorizationNumberIndex56 = 0\n    var factorizationNumberIndex57\
    \ = 0\n    var factorizationNumberIndex58 = 0\n    var factorizationNumberIndex59\
    \ = 0\n    var factorizationNumber\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4sjfez3c.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4sjfez3c.swift:70:9: error: type annotation\
    \ missing in pattern\n    var factorizationNumber\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: -1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ factorizationIndex = 0\n    var currentFactorizationIndex = 0\n    var currentFactorization\
    \ = factorization[currentFactorizationIndex]\n    while currentFactorizationIndex\
    \ < factorization.count {\n        if n % currentFactorization == 0 {\n      \
    \      factors.append(currentFactorization)\n            factorizationIndex +=\
    \ 1\n            factorization[currentFactorizationIndex] = factorization[currentFactorizationIndex]\
    \ * currentFactorization\n        } else {\n            currentFactorizationIndex\
    \ += 1\n            currentFactorization = factorization[currentFactorizationIndex]\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationNumber: Int = 0\n    var factorizationNumbers: [Int] = []\n   \
    \ var factorizationNumbersCount = 0\n    var factorizationNumbersSum = 0\n   \
    \ var factorizationNumbersSum2 = 0\n    var factorizationNumbersSum3 = 0\n   \
    \ var factorizationNumbersSum4 = 0\n    var factorizationNumbersSum5 = 0\n   \
    \ var factorizationNumbersSum6 = 0\n    var factorizationNumbersSum7 = 0\n   \
    \ var factorizationNumbersSum8 = 0\n    var factorizationNumbersSum9 = 0\n   \
    \ var factorizationNumbersSum10 = 0\n    var factorizationNumbersSum11 = 0\n \
    \   var factorizationNumbersSum12 = 0\n    var factorizationNumbersSum13 = 0\n\
    \    var factorizationNumbersSum14 = 0\n    var factorizationNumbersSum15 = 0\n\
    \    var factorizationNumbersSum16 = 0\n    var factorizationNumbersSum17 = 0\n\
    \    var factorizationNumbersSum18 = 0\n    var factorizationNumbersSum19 = 0\n\
    \    var factorizationNumbersSum20 = 0\n    var factorizationNumbersSum21 = 0\n\
    \    var factorizationNumbersSum22 = 0\n    var factorizationNumbersSum23 = 0\n\
    \    var factorizationNumbersSum24 = 0\n    var factorizationNumbersSum25 = 0\n\
    \    var factorizationNumbersSum26 = 0\n    var factorizationNumbersSum27 = 0\n\
    \    var factorizationNumbersSum28 = 0\n    var factorizationNumbersSum29 = 0\n\
    \    var factorizationNumbersSum30 = 0\n    var factorizationNumbersSum31 = 0\n\
    \    var factorizationNumbersSum32 = 0\n    var factorizationNumbersSum33 = 0\n\
    \    var factorizationNumbersSum34 = 0\n    var factorizationNumbersSum35 = 0\n\
    \    var factorizationNumbersSum36 = 0\n    var factorizationNumbersSum37 = 0\n\
    \    var factorizationNumbersSum38 = 0\n    var factorizationNumbersSum39 = 0\n\
    \    var factorizationNumbersSum40 = 0\n    var factorizationNumbersSum41 = 0\n\
    \    var factorizationNumbersSum42 = 0\n    var factorizationNumbersSum43 = 0\n\
    \    var factorizationNumbersSum44 = 0\n    var factorizationNumbersSum45 = 0\n\
    \    var factorizationNumbersSum46 = 0\n    var factorizationNumbersSum47 = 0\n\
    \    var factorizationNumbersSum48 = 0\n    var factorizationNumbersSum49 = 0\n\
    \    var factorizationNumbersSum50 = 0\n    var factorizationNumbersSum51 = 0\n\
    \    var factorizationNumbersSum52 = 0\n    var factorizationNumbersSum53 = 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_87bh5wc.swift:6:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp_87bh5wc.swift:7:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp_87bh5wc.swift:8:9: warning: variable 'factorizationNumber' was\
    \ never used; consider replacing with '_' or removing it\n    var factorizationNumber:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmp_87bh5wc.swift:9:9:\
    \ warning: variable 'factorizationNumbers' was never used; consider replacing\
    \ with '_' or removing it\n    var factorizationNumbers: [Int] = []\n        ^~~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp_87bh5wc.swift:10:9: warning: initialization of variable 'factorizationNumbersCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumbersCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmp_87bh5wc.swift:11:9: warning: initialization of variable 'factorizationNumbersSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumbersSum = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp_87bh5wc.swift:12:9: warning: initialization of variable 'factorizationNumbersSum2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumbersSum2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp_87bh5wc.swift:13:9: warning: initialization of variable 'factorizationNumbersSum3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumbersSum3 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp_87bh5wc.swift:14:9: warning: initialization of variable 'factorizationNumbersSum4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumbersSum4 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp_87bh5wc.swift:1"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n)\n \
    \   for factor in factorization {\n        if factors.contains(factor) {\n   \
    \         factors[factor] *= factor\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2g_s3k60.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var factorizationIndex2\
    \ = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4 = 0\n    var\
    \ factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var factorizationIndex7\
    \ = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9 = 0\n    var\
    \ factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n    var factorizationIndex12\
    \ = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14 = 0\n  \
    \  var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n    var factorizationIndex17\
    \ = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19 = 0\n  \
    \  var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n    var factorizationIndex22\
    \ = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24 = 0\n  \
    \  var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n    var factorizationIndex27\
    \ = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29 = 0\n  \
    \  var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n    var factorizationIndex32\
    \ = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34 = 0\n  \
    \  var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n    var factorizationIndex37\
    \ = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39 = 0\n  \
    \  var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n    var factorizationIndex42\
    \ = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44 = 0\n  \
    \  var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n    var factorizationIndex47\
    \ = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49 = 0\n  \
    \  var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n    var factorizationIndex52\
    \ = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54 = 0\n  \
    \  var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n    var factorizationIndex57\
    \ = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59 = 0\n  \
    \  var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n    var factorizationIndex62\
    \ = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64 = 0\n  \
    \  var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n    var factorizationIndex67\
    \ = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69 = 0\n  \
    \  var factorizationIndex70 = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpovd7od6s.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:8:9: warning:\
    \ initialization of variable 'primeFactorizationIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:9:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovd7od6s.swift:10:9: warning: initialization of variable 'factorizationIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:11:9:\
    \ warning: initialization of variable 'factorizationIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:12:9: warning:\
    \ initialization of variable 'factorizationIndex4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex4 = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:13:9: warning: initialization\
    \ of variable 'factorizationIndex5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var factorizationIndex5 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovd7od6s.swift:14:9: warning: initialization of variable 'factorizationIndex6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex6 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.s"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ current: Int = 0\n    var factor: Int = 0\n    var isPrime: Bool = false\n \
    \   var isPrime2: Bool = false\n    var isPrime3: Bool = false\n    var isPrime4:\
    \ Bool = false\n    var isPrime5: Bool = false\n    var isPrime6: Bool = false\n\
    \    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n    var isPrime9:\
    \ Bool = false\n    var isPrime10: Bool = false\n    var isPrime11: Bool = false\n\
    \    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n    var isPrime14:\
    \ Bool = false\n    var isPrime15: Bool = false\n    var isPrime16: Bool = false\n\
    \    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n    var isPrime19:\
    \ Bool = false\n    var isPrime20: Bool = false\n    var isPrime21: Bool = false\n\
    \    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n    var isPrime24:\
    \ Bool = false\n    var isPrime25: Bool = false\n    var isPrime26: Bool = false\n\
    \    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n    var isPrime29:\
    \ Bool = false\n    var isPrime30: Bool = false\n    var isPrime31: Bool = false\n\
    \    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n    var isPrime34:\
    \ Bool = false\n    var isPrime35: Bool = false\n    var isPrime36: Bool = false\n\
    \    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n    var isPrime39:\
    \ Bool = false\n    var isPrime40: Bool = false\n    var isPrime41: Bool = false\n\
    \    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n    var isPrime44:\
    \ Bool = false\n    var isPrime45: Bool = false\n    var isPrime46: Bool = false\n\
    \    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n    var isPrime49:\
    \ Bool = false\n    var isPrime50: Bool = false\n    var isPrime51: Bool = false\n\
    \    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n    var isPrime54:\
    \ Bool = false\n    var isPrime55\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsgg6kxch.swift:64:9: error: type annotation missing in pattern\n\
    \    var isPrime55\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorCount\
    \ = 0\n    var factorizationFactorIndex = 0\n    var factorizationFactorValue\
    \ = 1\n    var factorizationFactorValueCount = 0\n    var factorizationFactorValueIndex\
    \ = 0\n    var factorizationFactorValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv80qtw_9.swift:19:9: error: invalid redeclaration of 'factorizationFactorValueValueCount'\n\
    \    var factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:16:9:\
    \ note: 'factorizationFactorValueValueCount' previously declared here\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueIndex'\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:17:9:\
    \ note: 'factorizationFactorValueValueIndex' previously declared here\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueValue'\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:18:9:\
    \ note: 'factorizationFactorValueValueValue' previously declared here\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueCount'\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:16:9:\
    \ note: 'factorizationFactorValueValueCount' previously declared here\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueIndex'\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:17:9:\
    \ note: 'factorizationFactorValueValueIndex' previously declared here\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueValue'\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:18:9:\
    \ note: 'factorizationFactorValueValueValue' previously declared here\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueCount'\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:16:9:\
    \ note: 'fac"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor = 2\n    while factor <=\
    \ n {\n        if n % factor == 0 {\n            factorization[factor] = factorization[factor]\
    \ + 1\n            n /= factor\n        } else {\n            factor++\n     \
    \   }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk1ciu9r1.swift:11:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmpk1ciu9r1.swift:13:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            factor++\n                  ^~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ currentFactorizationCount = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6hjhsaky.swift:10:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9: note:\
    \ 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:11:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:12:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:13:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:14:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:15:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:16:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:17:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:18:9: err"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorIndex\
    \ = 0\n    var factorizationFactorCount = 0\n    var factorizationFactorCountIndex\
    \ = 0\n    var factorizationFactorCountMax = 0\n    var factorizationFactorCountMaxIndex\
    \ = 0\n    var factorizationFactorCountMin = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiaynb9vw.swift:17:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:18:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpiaynb9vw.swift:19:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:20:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpiaynb9vw.swift:21:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpiaynb9vw.swift:23:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared h"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    for factor in factorization {\n        factors.append(factor)\n    }\n  \
    \  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps79eomoi.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ i: Int = 0\n    for factor in factorization {\n        factors.append(factor)\n\
    \        factorization[i] = factorization[i] * factor\n        i += 1\n    }\n\
    \    factors.append(n)\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmp1k3rc1p0/tmp1k3rc1p0.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b81a32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b81729b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b81729988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b817287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1k3rc1p0                        0x00005594300e75e2 <unavailable> + 5602

    5    libc.so.6                          0x00002b0b81c1e460 __libc_start_main +
    245

    6    tmp1k3rc1p0                        0x00005594300e7239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n  \
    \  var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp5s76ol6.swift:10:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpp5s76ol6.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpp5s76ol6.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrime = true\n\
    \        ^\n/tmp/tmpp5s76ol6.swift:24:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:22:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpp5s76ol6.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpp5s76ol6.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpp5s76ol6.swift:35:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n       \
    \ ^\n/tmp/tmpp5s76ol6.swift:33:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpp5s76ol6.swift:36:9: error: invalid redeclarati"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n)\n \
    \   for factor in factorization {\n        factors.append(factor)\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbhx1g8ss.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex\
    \ = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorization = false\n    var isPrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorization = false\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimeFactorization = false\n    var isPrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimeFactorization = false\n    var isPrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimeFactorization = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization =\
    \ false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi1563k_6.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeFactorizationIndex'\n\
    \    var isPrimePrimePrimePrimePrimePrimeFactorizationIndex = 0\n        ^\n/tmp/tmpi1563k_6.swift:20:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeFactorizationIndex' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimeFactorizationIndex = 0\n     \
    \   ^\n/tmp/tmpi1563k_6.swift:27:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = false\n\
    \        ^\n/tmp/tmpi1563k_6.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = false\n        ^\n/tmp/tmpi1563k_6.swift:34:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationMax = 0\n    var factorizationMin\
    \ = 0\n    var factorizationSum = 0\n    var factorizationProduct = 1\n    var\
    \ factorizationProductSum = 0\n    var factorizationProductSum2 = 0\n    var factorizationProductSum3\
    \ = 0\n    var factorizationProductSum4 = 0\n    var factorizationProductSum5\
    \ = 0\n    var factorizationProductSum6 = 0\n    var factorizationProductSum7\
    \ = 0\n    var factorizationProductSum8 = 0\n    var factorizationProductSum9\
    \ = 0\n    var factorizationProductSum10 = 0\n    var factorizationProductSum11\
    \ = 0\n    var factorizationProductSum12 = 0\n    var factorizationProductSum13\
    \ = 0\n    var factorizationProductSum14 = 0\n    var factorizationProductSum15\
    \ = 0\n    var factorizationProductSum16 = 0\n    var factorizationProductSum17\
    \ = 0\n    var factorizationProductSum18 = 0\n    var factorizationProductSum19\
    \ = 0\n    var factorizationProductSum20 = 0\n    var factorizationProductSum21\
    \ = 0\n    var factorizationProductSum22 = 0\n    var factorizationProductSum23\
    \ = 0\n    var factorizationProductSum24 = 0\n    var factorizationProductSum25\
    \ = 0\n    var factorizationProductSum26 = 0\n    var factorizationProductSum27\
    \ = 0\n    var factorizationProductSum28 = 0\n    var factorizationProductSum29\
    \ = 0\n    var factorizationProductSum30 = 0\n    var factorizationProductSum31\
    \ = 0\n    var factorizationProductSum32 = 0\n    var factorizationProductSum33\
    \ = 0\n    var factorizationProductSum34 = 0\n    var factorizationProductSum35\
    \ = 0\n    var factorizationProductSum36 = 0\n    var factorizationProductSum37\
    \ = 0\n    var factorizationProductSum38 = 0\n    var factorizationProductSum39\
    \ = 0\n    var factorizationProductSum40 = 0\n    var factorizationProductSum41\
    \ = 0\n    var factorizationProductSum42 = 0\n    var factorizationProductSum43\
    \ = 0\n    var factorizationProductSum44 = 0\n    var factorizationProductSum45\
    \ = 0\n    var factorizationProductSum46 = 0\n    var factorizationProductSum47\
    \ = 0\n    var factorizationProductSum48 = 0\n    var factorizationProductSum49\
    \ = 0\n    var factorizationProductSum50 = 0\n    var factorizationProductSum51\
    \ = 0\n    var factorizationProductSum52 = 0\n    var factorizationProductSum53\
    \ = 0\n    var factorizationProductSum54 = 0\n    var factorizationProductSum55\
    \ = 0\n    var factorizationProductSum56 = 0\n    var factorizationProductSum57\
    \ = 0\n    var factorizationProductSum58 = 0\n    var factorizationProductSum59\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0xoy5x_p.swift:71:9: error: type annotation missing in pattern\n\
    \    var factorizationProductSum59\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationIndexCount = 0\n    var factorizationIndexCountMax\
    \ = Int(Int64.max) / Int(Int64.max)\n    var factorizationIndexCountMax2 = Int(Int64.max)\
    \ / Int(Int64.max) / 2\n    var factorizationIndexCountMax3 = Int(Int64.max) /\
    \ Int(Int64.max) / 3\n    var factorizationIndexCountMax4 = Int(Int64.max) / Int(Int64.max)\
    \ / 4\n    var factorizationIndexCountMax5 = Int(Int64.max) / Int(Int64.max) /\
    \ 5\n    var factorizationIndexCountMax6 = Int(Int64.max) / Int(Int64.max) / 6\n\
    \    var factorizationIndexCountMax7 = Int(Int64.max) / Int(Int64.max) / 7\n \
    \   var factorizationIndexCountMax8 = Int(Int64.max) / Int(Int64.max) / 8\n  \
    \  var factorizationIndexCountMax9 = Int(Int64.max) / Int(Int64.max) / 9\n   \
    \ var factorizationIndexCountMax10 = Int(Int64.max) / Int(Int64.max) / 10\n  \
    \  var factorizationIndexCountMax11 = Int(Int64.max) / Int(Int64.max) / 11\n \
    \   var factorizationIndexCountMax12 = Int(Int64.max) / Int(Int64.max) / 12\n\
    \    var factorizationIndexCountMax13 = Int(Int64.max) / Int(Int64.max) / 13\n\
    \    var factorizationIndexCountMax14 = Int(Int64.max) / Int(Int64.max) / 14\n\
    \    var factorizationIndexCountMax15 = Int(Int64.max) / Int(Int64.max) / 15\n\
    \    var factorizationIndexCountMax16 = Int(Int64.max) / Int(Int64.max) / 16\n\
    \    var factorizationIndexCountMax17 = Int(Int64.max) / Int(Int64.max) / 17\n\
    \    var factorizationIndexCountMax18 = Int(Int64.max) / Int(Int64.max) / 18\n\
    \    var factorizationIndexCountMax19 = Int(Int64.max) / Int(Int64.max) / 19\n\
    \    var factorizationIndexCountMax20 = Int(Int64.max) / Int(Int64.max) / 2\n\
    \    var factorizationIndexCountMax21 = Int(Int64.max) / Int(Int64.max) / 2\n\
    \    var factorizationIndexCountMax22 = Int(Int64.max) / Int(Int64.max) / 2\n\
    \    var factorizationIndexCountMax23 = Int(Int64.max) / Int(Int64.max) / 2\n\
    \    var factorizationIndexCountMax24 = Int(Int64.max) / Int(Int64.max) / 2\n\
    \    var factorizationIndexCountMax25 = Int(Int64.max) / Int(Int64.max) / 2\n\
    \    var factorizationIndexCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkq2ts34h.swift:35:9: error: type annotation missing in pattern\n\
    \    var factorizationIndexCount\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationPrime = [Int]()\n    var primeFactorizationPrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrime = [Int]()\n    var primeFactorizationPrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrime = [Int]()\n    var\
    \ primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo6teucr1.swift:19:9: error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimeCount'\n\
    \    var primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:17:9:\
    \ note: 'primeFactorizationPrimePrimePrimePrimeCount' previously declared here\n\
    \    var primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:20:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:18:9:\
    \ note: 'primeFactorizationPrimePrimePrimePrimePrime' previously declared here\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:22:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:18:9:\
    \ note: 'primeFactorizationPrimePrimePrimePrimePrime' previously declared here\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimePrimeCount'\n\
    \    var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmpo6teucr1.swift:21:9: note: 'primeFactorizationPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:24:9: error: invalid redeclaration\
    \ of 'primeFactorizationPrimePrimePrimePrimePrime'\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:18:9: note: 'primeFactorizationPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:25:9: error: invalid redeclaration\
    \ of 'primeFactorizationPrimePrimePrimePrimePrimeCount'\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:21:9: note: 'primeFactorization"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactorization\
    \ = [Int]()\n    var factorization = [Int]()\n    var isPrime = true\n    var\
    \ isFactorization = true\n    var isPrimeFactorization = true\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorization = true\n    var isPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrime = true\n    var\
    \ isPrimeFactorizationPrimeFactorizationFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuatpd760.swift:22:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:21:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:21:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:26:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmpuatpd760.swift:26:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationIndex = 0\n    var isPrime = true\n   \
    \ var isPrimeIndex = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorization = true\n    var isPrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimeFactorization = true\n    var isPrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeFactorization = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx3t7ziq4.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimeFactorization = true\n        ^\n/tmp/tmpx3t7ziq4.swift:21:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeFactorization' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimeFactorization = true\n        ^\n/tmp/tmpx3t7ziq4.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = true\n\
    \        ^\n/tmp/tmpx3t7ziq4.swift:26:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n        ^\n/tmp/tmpx3t7ziq4.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n        ^\n/tmp/tmpx3t7ziq4.swift:31:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n        ^\n/tmp/tmpx3t7ziq4.swift:34:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationIndexCount = 0\n    var factorizationIndexCountMax\
    \ = Int(ceil(log2(n)))\n    for factor in factorizationIndexCountMax {\n     \
    \   factorizationIndexCount = 0\n        while factorizationIndexCount < factor\
    \ {\n            if n % 2 == 0 {\n                factorizationIndexCount += 1\n\
    \                factorizationIndexCount += factorizationIndexCountMax\n     \
    \       }\n            n /= 2\n        }\n        factorizationIndexCount += 1\n\
    \        factorizationIndexCountMax = Int(ceil(log2(n)))\n        factorizationIndexCount\
    \ += factorizationIndexCountMax\n        factorizationIndexCountMax = Int(ceil(log2(n)))\n\
    \        factorizationIndexCount += factorizationIndexCountMax\n        factorizationIndexCountMax\
    \ = Int(ceil(log2(n)))\n        factorizationIndexCount += factorizationIndexCountMax\n\
    \        factorizationIndexCountMax = Int(ceil(log2(n)))\n        factorizationIndexCount\
    \ += factorizationIndexCountMax\n        factorizationIndexCountMax = Int(ceil(log2(n)))\n\
    \        factorizationIndexCount += factorizationIndexCountMax\n        factorizationIndexCountMax\
    \ = Int(ceil(log2(n)))\n        factorizationIndexCount += factorizationIndexCountMax\n\
    \        factorizationIndexCountMax = Int(ceil(log2(n)))\n        factorizationIndexCount\
    \ += factorizationIndexCountMax\n        factorizationIndexCountMax = Int(ceil(log2(n)))\n\
    \        factorizationIndexCount += factorizationIndexCountMax\n        factorizationIndexCountMax\
    \ = Int(ceil(log2(n)))\n        factorizationIndexCount += factorizationIndexCountMax\n\
    \        factorizationIndexCountMax = Int(ceil(log2(n)))\n        factorizationIndexCount\
    \ += factorizationIndexCountMax\n        factorizationIndexCountMax = Int(ceil(log2(n)))\n\
    \        factorizationIndexCount += factorizationIndexCountMax\n        factorizationIndexCountMax\
    \ = Int(ceil(log2(n)))\n        factorizationIndexCount += factorizationIndexCountMax\n\
    \        factorizationIndexCountMax = Int(ceil(log2(n)))\n        factorizationIndexCount\
    \ += factorizationIndexCountMax\n        factorizationIndexCountMax = Int(ceil(log2(n)))\n\
    \        factorizationIndexCount += factorizationIndexCountMax\n        factorizationIndexCountMax\
    \ = Int(ceil(log2(n)))\n        factorizationIndexCount += factorizationIndexCountMax\n\
    \        factorizationIndexCountMax = Int(ceil(log2(n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7hpacdj8.swift:52:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp7hpacdj8.swift:51:51: note: to match this opening '('\n        factorizationIndexCountMax\
    \ = Int(ceil(log2(n\n                                                  ^\n/tmp/tmp7hpacdj8.swift:74:38:\
    \ error: expected '}' at end of brace statement\nassert(factorize(n: 18) == [2,\
    \ 3, 3])\n                                     ^\n/tmp/tmp7hpacdj8.swift:5:33:\
    \ note: to match this opening '{'\nfunc factorize(n: Int) -> [Int] {\n       \
    \                         ^\n/tmp/tmp7hpacdj8.swift:10:42: error: cannot find\
    \ 'ceil' in scope\n    var factorizationIndexCountMax = Int(ceil(log2(n)))\n \
    \                                        ^~~~\n/tmp/tmp7hpacdj8.swift:10:47: error:\
    \ cannot find 'log2' in scope\n    var factorizationIndexCountMax = Int(ceil(log2(n)))\n\
    \                                              ^~~~\n/tmp/tmp7hpacdj8.swift:55:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factor = 1\n    var isPrime = true\n\
    \    var isPrime2 = true\n    var isPrime3 = true\n    var isPrime4 = true\n \
    \   var isPrime5 = true\n    var isPrime6 = true\n    var isPrime7 = true\n  \
    \  var isPrime8 = true\n    var isPrime9 = true\n    var isPrime10 = true\n  \
    \  var isPrime11 = true\n    var isPrime12 = true\n    var isPrime13 = true\n\
    \    var isPrime14 = true\n    var isPrime15 = true\n    var isPrime16 = true\n\
    \    var isPrime17 = true\n    var isPrime18 = true\n    var isPrime19 = true\n\
    \    var isPrime20 = true\n    var isPrime21 = true\n    var isPrime22 = true\n\
    \    var isPrime23 = true\n    var isPrime24 = true\n    var isPrime25 = true\n\
    \    var isPrime26 = true\n    var isPrime27 = true\n    var isPrime28 = true\n\
    \    var isPrime29 = true\n    var isPrime30 = true\n    var isPrime31 = true\n\
    \    var isPrime32 = true\n    var isPrime33 = true\n    var isPrime34 = true\n\
    \    var isPrime35 = true\n    var isPrime36 = true\n    var isPrime37 = true\n\
    \    var isPrime38 = true\n    var isPrime39 = true\n    var isPrime40 = true\n\
    \    var isPrime41 = true\n    var isPrime42 = true\n    var isPrime43 = true\n\
    \    var isPrime44 = true\n    var isPrime45 = true\n    var isPrime46 = true\n\
    \    var isPrime47 = true\n    var isPrime48 = true\n    var isPrime49 = true\n\
    \    var isPrime50 = true\n    var isPrime51 = true\n    var isPrime52 = true\n\
    \    var isPrime53 = true\n    var isPrime54 = true\n    var isPrime55 = true\n\
    \    var isPrime56 = true\n    var isPrime57 = true\n    var isPrime58 = true\n\
    \    var isPrime59 = true\n    var isPrime60 = true\n    var isPrime61 = true\n\
    \    var isPrime62 = true\n    var isPrime63 = true\n    var isPrime64 = true\n\
    \    var isPrime65 = true\n    var isPrime66 = true\n    var isPrime67 = true\n\
    \    var isPrime68 = true\n    var isPrime69 = true\n    var isPrime70\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbizdrw7v.swift:77:9: error: type annotation missing in pattern\n\
    \    var isPrime70\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    for factor in factorization {\n        factors.append(factor)\n    }\n  \
    \  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps79eomoi.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var primeFactorizationCountMax\
    \ = Int()\n    var primeFactorizationCountMaxIndex = -1\n    var primeFactorizationCountMaxValue\
    \ = Int()\n    var primeFactorizationCountMaxValueIndex = -1\n    var primeFactorizationCountMaxValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n    var primeFactorizationCountMaxValueValueValueValue = Int()\n    var\
    \ primeFactorizationCountMaxValueValueValueIndex = -1\n    var primeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var primeFactorizationCountMaxValueValueValueIndex = -1\n    var\
    \ primeFactorizationCountMaxValueValueValueValue = Int()\n    var primeFactorizationCountMaxValueValueValueIndex\
    \ = -1\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0905_j2t.swift:18:9: error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0905_j2t.swift:16:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0905_j2t.swift:19:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueValue'\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0905_j2t.swift:17:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueValue' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0905_j2t.swift:20:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0905_j2t.swift:16:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0905_j2t.swift:21:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueValue'\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0905_j2t.swift:17:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueValue' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0905_j2t.swift:22:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0905_j2t.swift:16:9:\
    \ note: 'primeFactorizationCountMaxValueValueValueIndex' previously declared here\n\
    \    var primeFactorizationCountMaxValueValueValueIndex = -1\n        ^\n/tmp/tmp0905_j2t.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationCountMaxValueValueValueValue'\n\
    \    var primeFactorizationCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmp0905_j2t.swift:17:9:\
    \ note: 'primeFactorizationCoun"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeFactors = [Bool]()\n \
    \   var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCountMax = [Int]()\n\
    \    var isPrimeFactorsCountMaxIndex = 0\n    var isPrimeFactorsCountMaxValue\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMax = 0\n    var isPrimeFactorsCountMaxValueMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMax = 0\n    var\
    \ isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMax = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMax = -1\n    var\
    \ isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n \
    \   var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = -1\n    var\
    \ isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = -1\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMaxMax\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwz4nt3dz.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax = 0\n        ^\n/tmp/tmpwz4nt3dz.swift:25:9:\
    \ note: 'isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMax = 0\n        ^\n/tmp/tmpwz4nt3dz.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMax = -1\n        ^\n\
    /tmp/tmpwz4nt3dz.swift:30:9: note: 'isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMax\
    \ = -1\n        ^\n/tmp/tmpwz4nt3dz.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmpwz4nt3dz.swift:31:9: note: 'isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmpwz4nt3dz.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = -1\n        ^\n/tmp/tmpwz4nt3dz.swift:36:9: note: 'isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = -1\n        ^\n/tmp/tmpwz4nt3dz.swift:39:9: error: type annotation missing\
    \ in pattern\n    var isPrimeFactorsCountMaxIndexMaxMaxMaxMaxMaxMaxMaxMaxMax\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primeFactors: [Int] = []\n    var isPrime:\
    \ [Bool] = []\n    var isPrimeCount: Int = 0\n    var isPrimeCountMax: Int = 2\n\
    \    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMaxIndex2: Int = 0\n\
    \    var isPrimeCountMaxIndex3: Int = 0\n    var isPrimeCountMaxIndex4: Int =\
    \ 0\n    var isPrimeCountMaxIndex5: Int = 0\n    var isPrimeCountMaxIndex6: Int\
    \ = 0\n    var isPrimeCountMaxIndex7: Int = 0\n    var isPrimeCountMaxIndex8:\
    \ Int = 0\n    var isPrimeCountMaxIndex9: Int = 0\n    var isPrimeCountMaxIndex10:\
    \ Int = 0\n    var isPrimeCountMaxIndex11: Int = 0\n    var isPrimeCountMaxIndex12:\
    \ Int = 0\n    var isPrimeCountMaxIndex13: Int = 0\n    var isPrimeCountMaxIndex14:\
    \ Int = 0\n    var isPrimeCountMaxIndex15: Int = 0\n    var isPrimeCountMaxIndex16:\
    \ Int = 0\n    var isPrimeCountMaxIndex17: Int = 0\n    var isPrimeCountMaxIndex18:\
    \ Int = 0\n    var isPrimeCountMaxIndex19: Int = 0\n    var isPrimeCountMaxIndex20:\
    \ Int = 0\n    var isPrimeCountMaxIndex21: Int = 0\n    var isPrimeCountMaxIndex22:\
    \ Int = 0\n    var isPrimeCountMaxIndex23: Int = 0\n    var isPrimeCountMaxIndex24:\
    \ Int = 0\n    var isPrimeCountMaxIndex25: Int = 0\n    var isPrimeCountMaxIndex26:\
    \ Int = 0\n    var isPrimeCountMaxIndex27: Int = 0\n    var isPrimeCountMaxIndex28:\
    \ Int = 0\n    var isPrimeCountMaxIndex29: Int = 0\n    var isPrimeCountMaxIndex30:\
    \ Int = 0\n    var isPrimeCountMaxIndex31: Int = 0\n    var isPrimeCountMaxIndex32:\
    \ Int = 0\n    var isPrimeCountMaxIndex33: Int = 0\n    var isPrimeCountMaxIndex34:\
    \ Int = 0\n    var isPrimeCountMaxIndex35: Int = 0\n    var isPrimeCountMaxIndex36:\
    \ Int = 0\n    var isPrimeCountMaxIndex37: Int = 0\n    var isPrimeCountMaxIndex38:\
    \ Int = 0\n    var isPrimeCountMaxIndex39: Int = 0\n    var isPrimeCountMaxIndex40\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1niqv7k6.swift:50:9: error: type annotation missing in pattern\n\
    \    var isPrimeCountMaxIndex40\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationSum = 0\n    var factorizationSumCount = 0\n    var factorizationSumCountMax\
    \ = 0\n    var factorizationSumCountMaxIndex = 0\n    var factorizationSumCountMin\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var factorizationSumCountMaxIndex\
    \ = 0\n    var factorizationSumCountMinIndex = 0\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpr24lh_r3.swift:64:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpr24lh_r3.swift:14:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpr24lh_r3.swift:11:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpr24lh_r3.swift:15:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex = 0\n\
    \        ^\n/tmp/tmpr24lh_r3.swift:13:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = 0\n      \
    \  ^\n/tmp/tmpr24lh_r3.swift:16:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpr24lh_r3.swift:11:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpr24lh_r3.swift:17:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex = 0\n\
    \        ^\n/tmp/tmpr24lh_r3.swift:13:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = 0\n      \
    \  ^\n/tmp/tmpr24lh_r3.swift:18:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpr24lh_r3.swift:11:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    var factorizationSumCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpr24lh_r3.swift:19:9: error: invalid redeclaration of\
    \ 'factorizationSumCountMinIndex'\n    var factorizationSumCountMinIndex = 0\n\
    \        ^\n/tmp/tmpr24lh_r3.swift:13:9: note: 'factorizationSumCountMinIndex'\
    \ previously declared here\n    var factorizationSumCountMinIndex = 0\n      \
    \  ^\n/tmp/tmpr24lh_r3.swift:20:9: error: invalid redeclaration of 'factorizationSumCountMaxIndex'\n\
    \    var factorizationSumCountMaxIndex = 0\n        ^\n/tmp/tmpr24lh_r3.swift:11:9:\
    \ note: 'factorizationSumCountMaxIndex' previously declared here\n    va"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    for factor in factorization {\n        if factors.contains(factor) {\n  \
    \          factors[factor] += 1\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2e399pvy.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationSumCount = 0\n    var factorizationSumCountMax\
    \ = 0\n    var factorizationSumCountMaxCount = 0\n    var factorizationSumCountMaxCountMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMax = 0\n    var factorizationSumCountMaxCountMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factorizationSumCountMaxCountMaxMaxMax\
    \ = 0\n    var factorizationSumCountMaxCountMaxMaxMax = 0\n    var factor\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphd27p3uj.swift:16:9: error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMax'\n\
    \    var factorizationSumCountMaxCountMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:15:9:\
    \ note: 'factorizationSumCountMaxCountMaxMax' previously declared here\n    var\
    \ factorizationSumCountMaxCountMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:18:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMaxMax'\n \
    \   var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:17:9:\
    \ note: 'factorizationSumCountMaxCountMaxMaxMax' previously declared here\n  \
    \  var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:19:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMaxMax'\n \
    \   var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:17:9:\
    \ note: 'factorizationSumCountMaxCountMaxMaxMax' previously declared here\n  \
    \  var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMaxMax'\n \
    \   var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:17:9:\
    \ note: 'factorizationSumCountMaxCountMaxMaxMax' previously declared here\n  \
    \  var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMaxMax'\n \
    \   var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:17:9:\
    \ note: 'factorizationSumCountMaxCountMaxMaxMax' previously declared here\n  \
    \  var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMaxMax'\n \
    \   var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:17:9:\
    \ note: 'factorizationSumCountMaxCountMaxMaxMax' previously declared here\n  \
    \  var factorizationSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmphd27p3uj.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxCountMaxMaxMax'\n \
    \   var "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount = 0\n   \
    \ var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk5zrq11b.swift:21:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpk5zrq11b.swift:19:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpk5zrq11b.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpk5zrq11b.swift:20:9: note: 'isPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n\
    \        ^\n/tmp/tmpk5zrq11b.swift:26:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpk5zrq11b.swift:24:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpk5zrq11b.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n\
    /tmp/tmpk5zrq11b.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationCount\
    \ = [Int]()\n    var isPrimeFactorizationCountMax = Int()\n    var isPrimeFactorizationCountMaxIndex\
    \ = Int()\n    var isPrimeFactorizationCountMaxValue = Int()\n    var isPrimeFactorizationCountMaxIndexValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueIndex = Int()\n    var isPrimeFactorizationCountMaxValueValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueIndexValue = Int()\n    var\
    \ isPrimeFactorizationCountMaxValueValueIndex = Int()\n    var isPrimeFactorizationCountMaxValueValueValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueIndexValueValue = Int()\n\
    \    var isPrimeFactorizationCountMaxValueValueIndexValue = Int()\n    var isPrimeFactorizationCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueValueValueValue = Int()\n\
    \    var isPrimeFactorizationCountMaxValueIndexValueValue = Int()\n    var isPrimeFactorizationCountMaxValueValueIndexValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueValueValueIndex = Int()\n\
    \    var isPrimeFactorizationCountMaxValueValueValueValue = Int()\n    var isPrimeFactorizationCountMaxValueIndexValueValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueValueIndexValue = Int()\n\
    \    var isPrimeFactorizationCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueIndexValueValue = Int()\n\
    \    var isPrimeFactorizationCountMaxValueValueIndexValue = Int()\n    var isPrimeFactorizationCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueValueValueValue = Int()\n\
    \    var isPrimeFactorizationCountMaxValueIndexValueValue = Int()\n    var isPrimeFactorizationCountMaxValueValueIndexValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueValueValueIndex = Int()\n\
    \    var isPrimeFactorizationCountMaxValueValueValueValue = Int()\n    var isPrimeFactorizationCountMaxValueIndexValueValue\
    \ = Int()\n    var isPrimeFactorizationCountMaxValueValueIndexValue = Int()\n\
    \    var isPrimeFactorizationCountMaxValueValueValueIndex = Int()\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpneo9_scu.swift:43:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpneo9_scu.swift:24:9: error: invalid redeclaration of 'isPrimeFactorizationCountMaxValueIndexValueValue'\n\
    \    var isPrimeFactorizationCountMaxValueIndexValueValue = Int()\n        ^\n\
    /tmp/tmpneo9_scu.swift:20:9: note: 'isPrimeFactorizationCountMaxValueIndexValueValue'\
    \ previously declared here\n    var isPrimeFactorizationCountMaxValueIndexValueValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationCountMaxValueValueIndexValue'\n    var isPrimeFactorizationCountMaxValueValueIndexValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:21:9: note: 'isPrimeFactorizationCountMaxValueValueIndexValue'\
    \ previously declared here\n    var isPrimeFactorizationCountMaxValueValueIndexValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationCountMaxValueValueValueIndex'\n    var isPrimeFactorizationCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:22:9: note: 'isPrimeFactorizationCountMaxValueValueValueIndex'\
    \ previously declared here\n    var isPrimeFactorizationCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationCountMaxValueValueValueValue'\n    var isPrimeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:23:9: note: 'isPrimeFactorizationCountMaxValueValueValueValue'\
    \ previously declared here\n    var isPrimeFactorizationCountMaxValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationCountMaxValueIndexValueValue'\n    var isPrimeFactorizationCountMaxValueIndexValueValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:20:9: note: 'isPrimeFactorizationCountMaxValueIndexValueValue'\
    \ previously declared here\n    var isPrimeFactorizationCountMaxValueIndexValueValue\
    \ = Int()\n        ^\n/tmp/tmpneo9_scu.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationCountMaxValueValueIndexValue'\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primeFactorization: [Int] = []\n   \
    \ var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrime = false\n    var isPrimeFactorizationPrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrime = false\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = false\n   \
    \ var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = false\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3hr7f4s0.swift:22:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrime = false\n        ^\n/tmp/tmp3hr7f4s0.swift:21:9:\
    \ note: 'isPrimeFactorizationPrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrime = false\n        ^\n/tmp/tmp3hr7f4s0.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n        ^\n\
    /tmp/tmp3hr7f4s0.swift:23:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmp3hr7f4s0.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmp3hr7f4s0.swift:25:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmp3hr7f4s0.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmp3hr7f4s0.swift:25:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmp3hr7f4s0.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n   \
    \ var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \        ^\n/tmp/tmp3hr7f4s0.swift:29:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmp3hr7f4s0.swift:32:9: error: invalid redeclaration\
    \ of 'i"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Int]()\n    var isPrimeCountMax = Int()\n    var isPrimeCountMaxIndex\
    \ = Int()\n    var isPrimeCountMin = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountMaxValue = Int()\n    var isPrimeCountMinValue = Int()\n\
    \    var isPrimeCountMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw114dgl_.swift:17:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpw114dgl_.swift:12:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpw114dgl_.swift:18:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = Int()\n        ^\n\
    /tmp/tmpw114dgl_.swift:14:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex = Int()\n        ^\n/tmp/tmpw114dgl_.swift:19:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValue'\n    var isPrimeCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmpw114dgl_.swift:15:9: note: 'isPrimeCountMaxValue'\
    \ previously declared here\n    var isPrimeCountMaxValue = Int()\n        ^\n\
    /tmp/tmpw114dgl_.swift:20:9: error: invalid redeclaration of 'isPrimeCountMinValue'\n\
    \    var isPrimeCountMinValue = Int()\n        ^\n/tmp/tmpw114dgl_.swift:16:9:\
    \ note: 'isPrimeCountMinValue' previously declared here\n    var isPrimeCountMinValue\
    \ = Int()\n        ^\n/tmp/tmpw114dgl_.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex = Int()\n        ^\n\
    /tmp/tmpw114dgl_.swift:12:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpw114dgl_.swift:22:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex\
    \ = Int()\n        ^\n/tmp/tmpw114dgl_.swift:14:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex = Int()\n        ^\n\
    /tmp/tmpw114dgl_.swift:23:9: error: invalid redeclaration of 'isPrimeCountMaxValue'\n\
    \    var isPrimeCountMaxValue = Int()\n        ^\n/tmp/tmpw114dgl_.swift:15:9:\
    \ note: 'isPrimeCountMaxValue' previously declared here\n    var isPrimeCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmpw114dgl_.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinValue'\n    var isPrimeCountMinValue = Int()\n        ^\n\
    /tmp/tmpw114dgl_.swift:16:9: note: 'isPrimeCountMinValue' previously declared\
    \ here\n    var"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationIsPrime\
    \ = true\n    var factorizationIsPrimeIndex = 0\n    var factorizationIsPrimeFactor\
    \ = 1\n    var factorizationIsPrimeFactorIndex = 0\n    var factorizationIsPrimeFactorIsPrime\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeIndex = 0\n    var factorizationIsPrimeFactorIsPrimeFactor\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeFactorIndex = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrime\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeIndex = 0\n  \
    \  var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactor = true\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrime = true\n\
    \    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeIndex = 0\n\
    \    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactor = true\n\
    \    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrime\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactor\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrime\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeIndex\
    \ = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactor\
    \ = true\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrime\
    \ = true\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpywbso__c.swift:27:9: error: invalid redeclaration of 'factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex'\n\
    \    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n        ^\n/tmp/tmpywbso__c.swift:25:9: note: 'factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex'\
    \ previously declared here\n    var factorizationIsPrimeFactorIsPrimeFactorIsPrimeFactorIsPrimeFactorIndex\
    \ = 0\n        ^\n/tmp/tmpywbso__c.swift:35:9: error: type annotation missing\
    \ in pattern\n    var factor\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    var factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationFactor\
    \ = 1\n    var factorizationRemainder = 0\n    var factorizationFactorIndex =\
    \ 0\n    var factorizationFactorRemainder = 0\n    var factorizationFactorRemainderIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCount = 0\n    var factorizationFactorRemainderIndexCountMax\
    \ = 0\n    var factorizationFactorRemainderIndexCountMin = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n    var factorizationFactorRemainderIndexCountMinIndex = 0\n    var factorizationFactorRemainder\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3gxux9w7.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3gxux9w7.swift:20:9: error: invalid redeclaration\
    \ of 'factorizationFactorRemainderIndexCountMaxIndex'\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:18:9: note: 'factorizationFactorRemainderIndexCountMaxIndex'\
    \ previously declared here\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:21:9: error: invalid redeclaration of\
    \ 'factorizationFactorRemainderIndexCountMinIndex'\n    var factorizationFactorRemainderIndexCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:19:9: note: 'factorizationFactorRemainderIndexCountMinIndex'\
    \ previously declared here\n    var factorizationFactorRemainderIndexCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationFactorRemainderIndexCountMaxIndex'\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:18:9: note: 'factorizationFactorRemainderIndexCountMaxIndex'\
    \ previously declared here\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationFactorRemainderIndexCountMinIndex'\n    var factorizationFactorRemainderIndexCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:19:9: note: 'factorizationFactorRemainderIndexCountMinIndex'\
    \ previously declared here\n    var factorizationFactorRemainderIndexCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:24:9: error: invalid redeclaration of\
    \ 'factorizationFactorRemainderIndexCountMaxIndex'\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:18:9: note: 'factorizationFactorRemainderIndexCountMaxIndex'\
    \ previously declared here\n    var factorizationFactorRemainderIndexCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp3gxux9w7.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationFactorRemain"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var factorizationIndex\
    \ = 0\n    var currentFactorizationIndex = -1\n    var currentFactorization =\
    \ 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorizationIndexCount = 0\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7geutenp.swift:76:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp7geutenp.swift:13:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp7geutenp.swift:9:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmp7geutenp.swift:14:9: error: invalid redeclaration of\
    \ 'currentFactorizationCount'\n    var currentFactorizationCount = 0\n       \
    \ ^\n/tmp/tmp7geutenp.swift:11:9: note: 'currentFactorizationCount' previously\
    \ declared here\n    var currentFactorizationCount = 0\n        ^\n/tmp/tmp7geutenp.swift:15:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCount'\n    var currentFactorizationIndexCount\
    \ = 0\n        ^\n/tmp/tmp7geutenp.swift:12:9: note: 'currentFactorizationIndexCount'\
    \ previously declared here\n    var currentFactorizationIndexCount = 0\n     \
    \   ^\n/tmp/tmp7geutenp.swift:16:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp7geutenp.swift:9:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmp7geutenp.swift:17:9: error: invalid redeclaration of\
    \ 'currentFactorizationCount'\n    var currentFactorizationCount = 0\n       \
    \ ^\n/tmp/tmp7geutenp.swift:11:9: note: 'currentFactorizationCount' previously\
    \ declared here\n    var currentFactorizationCount = 0\n        ^\n/tmp/tmp7geutenp.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCount'\n    var currentFactorizationIndexCount\
    \ = 0\n        ^\n/tmp/tmp7geutenp.swift:12:9: note: 'currentFactorizationIndexCount'\
    \ previously declared here\n    var currentFactorizationIndexCount = 0\n     \
    \   ^\n/tmp/tmp7geutenp.swift:19:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp7geutenp.swift:9:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmp7geutenp.swift:20:"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationSum2 = 0\n    var factorizationSum3\
    \ = 0\n    var factorizationSum4 = 0\n    var factorizationSum5 = 0\n    var factorizationSum6\
    \ = 0\n    var factorizationSum7 = 0\n    var factorizationSum8 = 0\n    var factorizationSum9\
    \ = 0\n    var factorizationSum10 = 0\n    var factorizationSum11 = 0\n    var\
    \ factorizationSum12 = 0\n    var factorizationSum13 = 0\n    var factorizationSum14\
    \ = 0\n    var factorizationSum15 = 0\n    var factorizationSum16 = 0\n    var\
    \ factorizationSum17 = 0\n    var factorizationSum18 = 0\n    var factorizationSum19\
    \ = 0\n    var factorizationSum20 = 0\n    var factorizationSum21 = 0\n    var\
    \ factorizationSum22 = 0\n    var factorizationSum23 = 0\n    var factorizationSum24\
    \ = 0\n    var factorizationSum25 = 0\n    var factorizationSum26 = 0\n    var\
    \ factorizationSum27 = 0\n    var factorizationSum28 = 0\n    var factorizationSum29\
    \ = 0\n    var factorizationSum30 = 0\n    var factorizationSum31 = 0\n    var\
    \ factorizationSum32 = 0\n    var factorizationSum33 = 0\n    var factorizationSum34\
    \ = 0\n    var factorizationSum35 = 0\n    var factorizationSum36 = 0\n    var\
    \ factorizationSum37 = 0\n    var factorizationSum38 = 0\n    var factorizationSum39\
    \ = 0\n    var factorizationSum40 = 0\n    var factorizationSum41 = 0\n    var\
    \ factorizationSum42 = 0\n    var factorizationSum43 = 0\n    var factorizationSum44\
    \ = 0\n    var factorizationSum45 = 0\n    var factorizationSum46 = 0\n    var\
    \ factorizationSum47 = 0\n    var factorizationSum48 = 0\n    var factorizationSum49\
    \ = 0\n    var factorizationSum50 = 0\n    var factorizationSum51 = 0\n    var\
    \ factorizationSum52 = 0\n    var factorizationSum53 = 0\n    var factorizationSum54\
    \ = 0\n    var factorizationSum55 = 0\n    var factorizationSum56 = 0\n    var\
    \ factorizationSum57 = 0\n    var factorizationSum58 = 0\n    var factorizationSum59\
    \ = 0\n    var factorizationSum60 = 0\n    var factorizationSum61 = 0\n    var\
    \ factorizationSum62 = 0\n    var factorizationSum63 = 0\n    var factorizationSum64\
    \ = 0\n    var factorizationSum65 = 0\n    var factorizationSum66 = 0\n    var\
    \ factorizationSum67 = 0\n    var factorizationSum68 = 0\n    var factorizationSum69\
    \ = 0\n    var factorizationSum70 = 0\n    var factorizationSum71 = 0\n    var\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkqyh_d3h.swift:79:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n)\n \
    \   for factor in factorization {\n        factors.append(factor)\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbhx1g8ss.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationIndex = 0\n    var primeFactorizationCount = 1\n   \
    \ var currentFactorizationIndex = 0\n    var currentFactorizationCount = 1\n \
    \   var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n  \
    \  var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n   \
    \ var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var\
    \ currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization\
    \ = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization =\
    \ [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n\
    \    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n  \
    \  var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n   \
    \ var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex =\
    \ 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n \
    \   var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n  \
    \  var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n   \
    \ var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var\
    \ currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization\
    \ = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization =\
    \ [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n\
    \    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n  \
    \  var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n   \
    \ var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex =\
    \ 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n \
    \   var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n  \
    \  var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n   \
    \ var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var\
    \ currentFactorization = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkxx4_26f.swift:78:31: error: expected initial value after '='\n\
    \    var currentFactorization = \n                              ^\n/tmp/tmpkxx4_26f.swift:13:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndex'\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpkxx4_26f.swift:10:9: note: 'currentFactorizationIndex'\
    \ previously declared here\n    var currentFactorizationIndex = 0\n        ^\n\
    /tmp/tmpkxx4_26f.swift:14:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization = [1]\n        ^\n/tmp/tmpkxx4_26f.swift:12:9: note:\
    \ 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpkxx4_26f.swift:15:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndex'\n    var currentFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmpkxx4_26f.swift:10:9: note: 'currentFactorizationIndex' previously\
    \ declared here\n    var currentFactorizationIndex = 0\n        ^\n/tmp/tmpkxx4_26f.swift:16:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpkxx4_26f.swift:12:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization = [1]\n        ^\n/tmp/tmpkxx4_26f.swift:17:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndex'\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpkxx4_26f.swift:10:9: note: 'currentFactorizationIndex'\
    \ previously declared here\n    var currentFactorizationIndex = 0\n        ^\n\
    /tmp/tmpkxx4_26f.swift:18:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization = [1]\n        ^\n/tmp/tmpkxx4_26f.swift:12:9: note:\
    \ 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpkxx4_26f.swift:19:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndex'\n    var currentFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmpkxx4_26f.swift:10:9: note: 'currentFactorizationIndex' previously\
    \ declared here\n    var currentFactorizationIndex = 0\n        ^\n/tmp/tmpkxx4_26f.swift:20:9:\
    \ error: invalid redecla"
  stdout: ''
  timestamp: 1660009304
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationValue = 1\n    var factorizationValueIndex\
    \ = 0\n    var factorizationValueIndexMax = factorizationValueIndex\n\n    while\
    \ factorizationIndex < factorizationCount {\n        factorizationValue = factorization[factorizationIndex]\n\
    \        factorizationValueIndex = 0\n        while factorizationValueIndex <\
    \ factorizationValueIndexMax {\n            if n % factorizationValue == 0 {\n\
    \                factorizationCount += 1\n                factorization[factorizationIndex]\
    \ = factorizationValue\n                break\n            }\n            factorizationValueIndex\
    \ += 1\n        }\n        factorizationIndex += 1\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp2a8f39fz/tmp2a8f39fz.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc52647c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc5233eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc5233e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc5233d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2a8f39fz                        0x000055a5040a64b2 <unavailable> + 5298

    5    libc.so.6                          0x00002adc52833460 __libc_start_main +
    245

    6    tmp2a8f39fz                        0x000055a5040a6109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimeFactorization\
    \ = true\n    var isPrimePrimeFactorizationCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization = true\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9tk43__5.swift:42:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp9tk43__5.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:8:9: warning:\
    \ initialization of variable 'primeFactorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:9:9: warning:\
    \ initialization of variable 'isPrime' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmp9tk43__5.swift:10:9: warning: initialization of variable 'isPrimeCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:11:9:\
    \ warning: initialization of variable 'isPrimeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactorization\
    \ = true\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:12:9: warning:\
    \ initialization of variable 'isPrimeFactorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactorizationCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:13:9:\
    \ warning: initialization of variable 'isPrimePrime' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimePrime = true\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp9tk43__5.swift:14:9: warning: initialization\
    \ of variable 'isPrimePrimeCount' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimePrimeCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \ "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeCount = [Int]()\n    var isPrimeCount2 = [Int]()\n    var isPrimeCount3\
    \ = [Int]()\n    var isPrimeCount4 = [Int]()\n    var isPrimeCount5 = [Int]()\n\
    \    var isPrimeCount6 = [Int]()\n    var isPrimeCount7 = [Int]()\n    var isPrimeCount8\
    \ = [Int]()\n    var isPrimeCount9 = [Int]()\n    var isPrimeCount10 = [Int]()\n\
    \    var isPrimeCount11 = [Int]()\n    var isPrimeCount12 = [Int]()\n    var isPrimeCount13\
    \ = [Int]()\n    var isPrimeCount14 = [Int]()\n    var isPrimeCount15 = [Int]()\n\
    \    var isPrimeCount16 = [Int]()\n    var isPrimeCount17 = [Int]()\n    var isPrimeCount18\
    \ = [Int]()\n    var isPrimeCount19 = [Int]()\n    var isPrimeCount20 = [Int]()\n\
    \    var isPrimeCount21 = [Int]()\n    var isPrimeCount22 = [Int]()\n    var isPrimeCount23\
    \ = [Int]()\n    var isPrimeCount24 = [Int]()\n    var isPrimeCount25 = [Int]()\n\
    \    var isPrimeCount26 = [Int]()\n    var isPrimeCount27 = [Int]()\n    var isPrimeCount28\
    \ = [Int]()\n    var isPrimeCount29 = [Int]()\n    var isPrimeCount30 = [Int]()\n\
    \    var isPrimeCount31 = [Int]()\n    var isPrimeCount32 = [Int]()\n    var isPrimeCount33\
    \ = [Int]()\n    var isPrimeCount34 = [Int]()\n    var isPrimeCount35 = [Int]()\n\
    \    var isPrimeCount36 = [Int]()\n    var isPrimeCount37 = [Int]()\n    var isPrimeCount38\
    \ = [Int]()\n    var isPrimeCount39 = [Int]()\n    var isPrimeCount40 = [Int]()\n\
    \    var isPrimeCount41 = [Int]()\n    var isPrimeCount42 = [Int]()\n    var isPrimeCount43\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8t47qg5w.swift:53:9: error: type annotation missing in pattern\n\
    \    var isPrimeCount43\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n  \
    \  var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp5s76ol6.swift:10:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpp5s76ol6.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpp5s76ol6.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrime = true\n\
    \        ^\n/tmp/tmpp5s76ol6.swift:24:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:22:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpp5s76ol6.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpp5s76ol6.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpp5s76ol6.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpp5s76ol6.swift:35:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n       \
    \ ^\n/tmp/tmpp5s76ol6.swift:33:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpp5s76ol6.swift:36:9: error: invalid redeclarati"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var isPrime = true\n    var isFactorization\
    \ = false\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime =\
    \ false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp38par69j.swift:31:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \        ^\n/tmp/tmp38par69j.swift:28:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp38par69j.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex'\n  \
    \  var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n\
    \        ^\n/tmp/tmp38par69j.swift:29:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n        ^\n/tmp/tmp38par69j.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount'\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount = 0\n   \
    \     ^\n/tmp/tmp38par69j.swift:30:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n        ^\n/tmp/tmp38par69j.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp38par69j.swift:35:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp38par69j.swift:39:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp38par69"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ currentFactorizationCount = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = n\n\n    while currentFactorizationValue\
    \ > 1 {\n        if currentFactorizationValue % 2 == 0 {\n            currentFactorizationValue\
    \ /= 2\n            currentFactorizationCount += 1\n        } else {\n       \
    \     currentFactorizationValue /= 2\n            currentFactorizationCount -=\
    \ 1\n        }\n\n        if currentFactorizationCount > 0 {\n            currentFactorization[currentFactorizationIndex]\
    \ = currentFactorizationCount\n            currentFactorizationIndex += 1\n  \
    \          currentFactorizationCount = 0\n        }\n\n        if currentFactorizationIndex\
    \ == currentFactorization.count {\n            factorizationCount += currentFactorizationCount\n\
    \            factorization = append(factorization, currentFactorization)\n   \
    \         currentFactorizationIndex = 0\n            currentFactorizationCount\
    \ = 0\n            currentFactorization = [1]\n        }\n    }\n\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpc152is9d.swift:30:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, currentFactorization)\n     \
    \                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationNumber = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberSum =\
    \ 0\n    var factorizationNumberSumCount = 0\n    var factorizationNumberSumIndex\
    \ = 0\n    var factorizationNumberSumSum = 0\n    var factorizationNumberSumSumCount\
    \ = 0\n    var factorizationNumberSumSumIndex = 0\n    var factorizationNumberSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6n2pis95.swift:22:9: error: invalid redeclaration of 'factorizationNumberSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:19:9:\
    \ note: 'factorizationNumberSumSumSumCount' previously declared here\n    var\
    \ factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumIndex'\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:20:9:\
    \ note: 'factorizationNumberSumSumSumIndex' previously declared here\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSum'\n    var factorizationNumberSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmp6n2pis95.swift:21:9: note: 'factorizationNumberSumSumSumSum'\
    \ previously declared here\n    var factorizationNumberSumSumSumSum = 0\n    \
    \    ^\n/tmp/tmp6n2pis95.swift:25:9: error: invalid redeclaration of 'factorizationNumberSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:19:9:\
    \ note: 'factorizationNumberSumSumSumCount' previously declared here\n    var\
    \ factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumIndex'\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:20:9:\
    \ note: 'factorizationNumberSumSumSumIndex' previously declared here\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSum'\n    var factorizationNumberSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmp6n2pis95.swift:21:9: note: 'factorizationNumberSumSumSumSum'\
    \ previously declared here\n    var factorizationNumberSumSumSumSum = 0\n    \
    \    ^\n/tmp/tmp6n2pis95.swift:28:9: error: invalid redeclaration of 'factorizationNumberSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:19:9:\
    \ note: 'factorizationNumberSumSumSumCount' previously"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factor = 1\n    var prime = 1\n\
    \    var primeFactorization = [Int]()\n    var primeFactor = 1\n    var primeFactorizationCount\
    \ = 0\n    var primeFactorizationIndex = 0\n    var primeFactorizationCountIndex\
    \ = 0\n    var primeFactorizationCountMax = 0\n    var primeFactorizationCountMaxIndex\
    \ = 0\n    var primeFactorizationCountMin = 0\n    var primeFactorizationCountMinIndex\
    \ = 0\n    var primeFactorizationCountMax2 = 0\n    var primeFactorizationCountMax2Index\
    \ = 0\n    var primeFactorizationCountMin2 = 0\n    var primeFactorizationCountMin2Index\
    \ = 0\n    var primeFactorizationCountMax3 = 0\n    var primeFactorizationCountMax3Index\
    \ = 0\n    var primeFactorizationCountMin3 = 0\n    var primeFactorizationCountMin3Index\
    \ = 0\n    var primeFactorizationCountMax4 = 0\n    var primeFactorizationCountMax4Index\
    \ = 0\n    var primeFactorizationCountMin4 = 0\n    var primeFactorizationCountMin4Index\
    \ = 0\n    var primeFactorizationCountMax5 = 0\n    var primeFactorizationCountMax5Index\
    \ = 0\n    var primeFactorizationCountMin5 = 0\n    var primeFactorizationCountMin5Index\
    \ = 0\n    var primeFactorizationCountMax6 = 0\n    var primeFactorizationCountMax6Index\
    \ = 0\n    var primeFactorizationCountMin6 = 0\n    var primeFactorizationCountMin6Index\
    \ = 0\n    var primeFactorizationCountMax7 = 0\n    var primeFactorizationCountMax7Index\
    \ = 0\n    var primeFactorizationCountMin7 = 0\n    var primeFactorizationCountMin7Index\
    \ = 0\n    var primeFactorizationCountMax8 = 0\n    var primeFactorizationCountMax8Index\
    \ = 0\n    var primeFactorizationCountMin8 = 0\n    var primeFactorizationCountMin8Index\
    \ = 0\n    var primeFactorizationCountMax9 = 0\n    var primeFactorizationCountMax9Index\
    \ = 0\n    var primeFactorizationCountMin9 = 0\n    var primeFactorizationCountMin9Index\
    \ = 0\n    var primeFactorizationCountMax10 = 0\n    var primeFactorizationCountMax10Index\
    \ = 0\n    var primeFactorizationCountMin10 = 0\n    var primeFactorizationCountMin10Index\
    \ = 0\n    var primeFactorizationCountMax11 = 0\n    var primeFactorizationCountMax11Index\
    \ = 0\n    var primeFactorizationCountMin11 = 0\n    var primeFactorizationCountMin11Index\
    \ = 0\n    var primeFactorizationCountMax12 = 0\n    var primeFactorizationCountMax12Index\
    \ = 0\n    var primeFactorizationCountMin12 = 0\n    var primeFactorizationCountMin12Index\
    \ = 0\n    var primeFactorizationCountMax13 = 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp36ay1nd3.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp36ay1nd3.swift:7:9:\
    \ warning: initialization of variable 'factor' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factor = 1\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp36ay1nd3.swift:8:9: warning: initialization of variable 'prime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime = 1\n    ~~~~^~~~~\n    _\n/tmp/tmp36ay1nd3.swift:9:9: warning:\
    \ initialization of variable 'primeFactorization' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primeFactorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp36ay1nd3.swift:10:9: warning: initialization\
    \ of variable 'primeFactor' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var primeFactor = 1\n    ~~~~^~~~~~~~~~~\n    _\n\
    /tmp/tmp36ay1nd3.swift:11:9: warning: initialization of variable 'primeFactorizationCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp36ay1nd3.swift:12:9: warning: initialization of variable 'primeFactorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp36ay1nd3.swift:13:9: warning: initialization of variable 'primeFactorizationCountIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorizationCountIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp36ay1nd3.swift:14:9: warning: initialization of variable 'primeFactorizationCountMax'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorizationCountMax = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n \
    \   _\n/tmp/tmp36ay1nd3.swift:15:9: warning: initialization of vari"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var factorizationCount = 1\n    var primeFactorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var factorizationNumber = 0\n\
    \    var primeFactorizationNumber = 0\n    var factorizationNumberIndex = 0\n\
    \    var primeFactorizationNumberIndex = 0\n    var factorizationNumberIndex2\
    \ = 0\n    var primeFactorizationNumberIndex2 = 0\n    var factorizationNumberIndex3\
    \ = 0\n    var primeFactorizationNumberIndex3 = 0\n    var factorizationNumberIndex4\
    \ = 0\n    var primeFactorizationNumberIndex4 = 0\n    var factorizationNumberIndex5\
    \ = 0\n    var primeFactorizationNumberIndex5 = 0\n    var factorizationNumberIndex6\
    \ = 0\n    var primeFactorizationNumberIndex6 = 0\n    var factorizationNumberIndex7\
    \ = 0\n    var primeFactorizationNumberIndex7 = 0\n    var factorizationNumberIndex8\
    \ = 0\n    var primeFactorizationNumberIndex8 = 0\n    var factorizationNumberIndex9\
    \ = 0\n    var primeFactorizationNumberIndex9 = 0\n    var factorizationNumberIndex10\
    \ = 0\n    var primeFactorizationNumberIndex10 = 0\n    var factorizationNumberIndex11\
    \ = 0\n    var primeFactorizationNumberIndex11 = 0\n    var factorizationNumberIndex12\
    \ = 0\n    var primeFactorizationNumberIndex12 = 0\n    var factorizationNumberIndex13\
    \ = 0\n    var primeFactorizationNumberIndex13 = 0\n    var factorizationNumberIndex14\
    \ = 0\n    var primeFactorizationNumberIndex14 = 0\n    var factorizationNumberIndex15\
    \ = 0\n    var primeFactorizationNumberIndex15 = 0\n    var factorizationNumberIndex16\
    \ = 0\n    var primeFactorizationNumberIndex16 = 0\n    var factorizationNumberIndex17\
    \ = 0\n    var primeFactorizationNumberIndex17 = 0\n    var factorizationNumberIndex18\
    \ = 0\n    var primeFactorizationNumberIndex18 = 0\n    var factorizationNumberIndex19\
    \ = 0\n    var primeFactorizationNumberIndex19 = 0\n    var factorizationNumberIndex20\
    \ = 0\n    var primeFactorizationNumberIndex20 = 0\n    var factorizationNumberIndex21\
    \ = 0\n    var primeFactorizationNumberIndex21 = 0\n    var factorizationNumberIndex22\
    \ = 0\n    var primeFactorizationNumberIndex22 = 0\n    var factorizationNumberIndex23\
    \ = 0\n    var primeFactorizationNumberIndex23 = 0\n    var factorizationNumberIndex24\
    \ = 0\n    var primeFactorizationNumberIndex24 = 0\n    var factorizationNumberIndex25\
    \ = 0\n    var primeFactorizationNumberIndex25 = 0\n    var factorizationNumberIndex26\
    \ = 0\n    var primeFactorizationNumberIndex26 = 0\n    var factorizationNumberIndex27\
    \ = 0\n    var primeFactorizationNumberIndex27 = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyc0b7o6n.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpyc0b7o6n.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyc0b7o6n.swift:8:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 1\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpyc0b7o6n.swift:9:9: warning: initialization of variable 'primeFactorizationCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorizationCount = 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpyc0b7o6n.swift:10:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyc0b7o6n.swift:11:9:\
    \ warning: initialization of variable 'primeFactorizationIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyc0b7o6n.swift:12:9: warning:\
    \ initialization of variable 'factorizationNumber' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationNumber = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyc0b7o6n.swift:13:9: warning: initialization\
    \ of variable 'primeFactorizationNumber' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var primeFactorizationNumber = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpyc0b7o6n.swift:14:9: warning: initialization\
    \ of variable 'factorizationNumberIndex' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var factorizationNumberIndex = 0\n   \
    \ ~~~~^~~~~~~~~~"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var factorizationCount\
    \ = 0\n    var factorizationSum = 0\n    var factorizationSum2 = 0\n    var factorizationSum3\
    \ = 0\n    var factorizationSum4 = 0\n    var factorizationSum5 = 0\n    var factorizationSum6\
    \ = 0\n    var factorizationSum7 = 0\n    var factorizationSum8 = 0\n    var factorizationSum9\
    \ = 0\n    var factorizationSum10 = 0\n    var factorizationSum11 = 0\n    var\
    \ factorizationSum12 = 0\n    var factorizationSum13 = 0\n    var factorizationSum14\
    \ = 0\n    var factorizationSum15 = 0\n    var factorizationSum16 = 0\n    var\
    \ factorizationSum17 = 0\n    var factorizationSum18 = 0\n    var factorizationSum19\
    \ = 0\n    var factorizationSum20 = 0\n    var factorizationSum21 = 0\n    var\
    \ factorizationSum22 = 0\n    var factorizationSum23 = 0\n    var factorizationSum24\
    \ = 0\n    var factorizationSum25 = 0\n    var factorizationSum26 = 0\n    var\
    \ factorizationSum27 = 0\n    var factorizationSum28 = 0\n    var factorizationSum29\
    \ = 0\n    var factorizationSum30 = 0\n    var factorizationSum31 = 0\n    var\
    \ factorizationSum32 = 0\n    var factorizationSum33 = 0\n    var factorizationSum34\
    \ = 0\n    var factorizationSum35 = 0\n    var factorizationSum36 = 0\n    var\
    \ factorizationSum37 = 0\n    var factorizationSum38 = 0\n    var factorizationSum39\
    \ = 0\n    var factorizationSum40 = 0\n    var factorizationSum41 = 0\n    var\
    \ factorizationSum42 = 0\n    var factorizationSum43 = 0\n    var factorizationSum44\
    \ = 0\n    var factorizationSum45 = 0\n    var factorizationSum46 = 0\n    var\
    \ factorizationSum47 = 0\n    var factorizationSum48 = 0\n    var factorizationSum49\
    \ = 0\n    var factorizationSum50 = 0\n    var factorizationSum51 = 0\n    var\
    \ factorizationSum52 = 0\n    var factorizationSum53 = 0\n    var factorizationSum54\
    \ = 0\n    var factorizationSum55 = 0\n    var factorizationSum56 = 0\n    var\
    \ factorizationSum57 = 0\n    var factorizationSum58 = 0\n    var factorizationSum59\
    \ = 0\n    var factorizationSum60 = 0\n    var factorizationSum61 = 0\n    var\
    \ factorizationSum62 = 0\n    var factorizationSum63 = 0\n    var factorizationSum64\
    \ = 0\n    var factorizationSum65 = 0\n    var factorizationSum66 = 0\n    var\
    \ factorizationSum67 = 0\n    var factorizationSum68 = 0\n    var factorizationSum69\
    \ = 0\n    var factorizationSum70 = 0\n    var factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8oh97muz.swift:79:9: error: type annotation missing in pattern\n\
    \    var factor\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var primeFactorizationIndex = [Int]()\n\
    \    var primeFactorizationIndexCount = [Int]()\n    var primeFactorizationIndexCountMax\
    \ = Int()\n    var primeFactorizationIndexCountMaxIndex = Int()\n    var primeFactorizationIndexCountMin\
    \ = Int()\n    var primeFactorizationIndexCountMinIndex = Int()\n    var primeFactorizationIndexCountMaxValue\
    \ = Int()\n    var primeFactorizationIndexCountMinValue = Int()\n    var primeFactorizationIndexCountMaxValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMinValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValue = Int()\n    var primeFactorizationIndexCountMinValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueIndex = Int()\n  \
    \  var primeFactorizationIndexCountMinValueValueIndex = Int()\n    var primeFactorizationIndexCountMaxValueValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMinValueValueValue = Int()\n  \
    \  var primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueValue =\
    \ Int()\n    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMaxValueValueValueValueIndex = Int()\n  \
    \  var primeFactorizationIndexCountMinValueValueValueValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueValueValue = Int()\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex =\
    \ Int()\n    var primeFactorizationIndexCountMinValueValueValueValueIndex = Int()\n\
    \    var primeFactorizationIndexCountMaxValueValueValueValueValue = Int()\n  \
    \  var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMinValueValueValueValueIndex =\
    \ Int()\n    var primeFactorizationIndexCountMaxValueValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_kd1yj7q.swift:32:9: error: invalid redeclaration of 'primeFactorizationIndexCountMinValueValueValueValue'\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n       \
    \ ^\n/tmp/tmp_kd1yj7q.swift:28:9: note: 'primeFactorizationIndexCountMinValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:33:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValueIndex'\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:29:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:34:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueValueIndex'\n    var primeFactorizationIndexCountMinValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:30:9: note: 'primeFactorizationIndexCountMinValueValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:35:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValueValue'\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:31:9: note: 'primeFactorizationIndexCountMaxValueValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:36:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueValue'\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:28:9: note: 'primeFactorizationIndexCountMinValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmp_kd1yj7q.swift:37:9: error: invalid redeclaration\
    \ of 'p"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ currentFactorizationCount = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n    var currentFactorization = 0\n    var currentFactorization = 0\n  \
    \  var currentFactorization = 0\n    var currentFactorization = 0\n    var currentFactorization\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6hjhsaky.swift:10:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9: note:\
    \ 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:11:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:12:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:13:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:14:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:15:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:16:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:17:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = 0\n        ^\n/tmp/tmp6hjhsaky.swift:9:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = 0\n        ^\n/tmp/tmp6hjhsaky.swift:18:9: err"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationSum2 = 0\n    var factorizationSum3\
    \ = 0\n    var factorizationSum4 = 0\n    var factorizationSum5 = 0\n    var factorizationSum6\
    \ = 0\n    var factorizationSum7 = 0\n    var factorizationSum8 = 0\n    var factorizationSum9\
    \ = 0\n    var factorizationSum10 = 0\n    var factorizationSum11 = 0\n    var\
    \ factorizationSum12 = 0\n    var factorizationSum13 = 0\n    var factorizationSum14\
    \ = 0\n    var factorizationSum15 = 0\n    var factorizationSum16 = 0\n    var\
    \ factorizationSum17 = 0\n    var factorizationSum18 = 0\n    var factorizationSum19\
    \ = 0\n    var factorizationSum20 = 0\n    var factorizationSum21 = 0\n    var\
    \ factorizationSum22 = 0\n    var factorizationSum23 = 0\n    var factorizationSum24\
    \ = 0\n    var factorizationSum25 = 0\n    var factorizationSum26 = 0\n    var\
    \ factorizationSum27 = 0\n    var factorizationSum28 = 0\n    var factorizationSum29\
    \ = 0\n    var factorizationSum30 = 0\n    var factorizationSum31 = 0\n    var\
    \ factorizationSum32 = 0\n    var factorizationSum33 = 0\n    var factorizationSum34\
    \ = 0\n    var factorizationSum35 = 0\n    var factorizationSum36 = 0\n    var\
    \ factorizationSum37 = 0\n    var factorizationSum38 = 0\n    var factorizationSum39\
    \ = 0\n    var factorizationSum40 = 0\n    var factorizationSum41 = 0\n    var\
    \ factorizationSum42 = 0\n    var factorizationSum43 = 0\n    var factorizationSum44\
    \ = 0\n    var factorizationSum45 = 0\n    var factorizationSum46 = 0\n    var\
    \ factorizationSum47 = 0\n    var factorizationSum48 = 0\n    var factorizationSum49\
    \ = 0\n    var factorizationSum50 = 0\n    var factorizationSum51 = 0\n    var\
    \ factorizationSum52 = 0\n    var factorizationSum53 = 0\n    var factorizationSum54\
    \ = 0\n    var factorizationSum55 = 0\n    var factorizationSum56 = 0\n    var\
    \ factorizationSum57 = 0\n    var factorizationSum58 = 0\n    var factorizationSum59\
    \ = 0\n    var factorizationSum60 = 0\n    var factorizationSum61 = 0\n    var\
    \ factorizationSum62 = 0\n    var factorizationSum63 = 0\n    var factorizationSum64\
    \ = 0\n    var factorizationSum65 = 0\n    var factorizationSum66 = 0\n    var\
    \ factorizationSum67 = 0\n    var factorizationSum68 = 0\n    var factorizationSum69\
    \ = 0\n    var factorizationSum70 = 0\n    var factorizationSum71 = 0\n    var\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkqyh_d3h.swift:79:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = factorization.count\n\
    \    var factorizationIndexMaxMinusOne = factorizationIndexMax - 1\n    var factorizationIndexMinusOne\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusTwo = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusThree = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusFour = factorizationIndex - 1\n    var factorizationIndexMinusFive\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusSix = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusSeven = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusEight = factorizationIndex - 1\n    var factorizationIndexMinusNine\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusTen = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusEleven = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusTwelve = factorizationIndex - 1\n    var factorizationIndexMinusThirteen\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusFourteen = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusFifteen = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusSixteen = factorizationIndex - 1\n    var factorizationIndexMinusSeventeen\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusEighteen = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusNineteen = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusTwenty = factorizationIndex - 1\n    var factorizationIndexMinusThirty\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusFourty = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusFifty = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusSixty = factorizationIndex - 1\n    var factorizationIndexMinusSeventy\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusEighty = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusNinety = factorizationIndex - 1\n    var\
    \ factorizationIndexMinusOne = factorizationIndex - 1\n    var factorizationIndexMinusTwo\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusThree = factorizationIndex\
    \ - 1\n    var factorizationIndexMinusFour = factorizationIndex - 1\n    var factorizationIndexMinusFive\
    \ = factorizationIndex - 1\n    var factorizationIndexMinusSix = factorizationIndex\
    \ - 1\n    var factorizationIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3tu7s2px.swift:38:9: error: invalid redeclaration of 'factorizationIndexMinusOne'\n\
    \    var factorizationIndexMinusOne = factorizationIndex - 1\n        ^\n/tmp/tmp3tu7s2px.swift:11:9:\
    \ note: 'factorizationIndexMinusOne' previously declared here\n    var factorizationIndexMinusOne\
    \ = factorizationIndex - 1\n        ^\n/tmp/tmp3tu7s2px.swift:39:9: error: invalid\
    \ redeclaration of 'factorizationIndexMinusTwo'\n    var factorizationIndexMinusTwo\
    \ = factorizationIndex - 1\n        ^\n/tmp/tmp3tu7s2px.swift:12:9: note: 'factorizationIndexMinusTwo'\
    \ previously declared here\n    var factorizationIndexMinusTwo = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:40:9: error: invalid redeclaration of\
    \ 'factorizationIndexMinusThree'\n    var factorizationIndexMinusThree = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:13:9: note: 'factorizationIndexMinusThree'\
    \ previously declared here\n    var factorizationIndexMinusThree = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:41:9: error: invalid redeclaration of\
    \ 'factorizationIndexMinusFour'\n    var factorizationIndexMinusFour = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:14:9: note: 'factorizationIndexMinusFour'\
    \ previously declared here\n    var factorizationIndexMinusFour = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:42:9: error: invalid redeclaration of\
    \ 'factorizationIndexMinusFive'\n    var factorizationIndexMinusFive = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:15:9: note: 'factorizationIndexMinusFive'\
    \ previously declared here\n    var factorizationIndexMinusFive = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:43:9: error: invalid redeclaration of\
    \ 'factorizationIndexMinusSix'\n    var factorizationIndexMinusSix = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:16:9: note: 'factorizationIndexMinusSix'\
    \ previously declared here\n    var factorizationIndexMinusSix = factorizationIndex\
    \ - 1\n        ^\n/tmp/tmp3tu7s2px.swift:44:9: error: type annotation missing\
    \ in pattern\n    var factorizationIndex\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primeFactors: [Int] = []\n    var isPrime:\
    \ [Bool] = []\n    var isPrimeFactors: [Bool] = []\n    var isPrimeFactorsCount:\
    \ [Int] = []\n    var isPrimeFactorsCountMax: Int = 1\n    var isPrimeFactorsCountMin:\
    \ Int = 1\n    var isPrimeFactorsCountMinMax: Int = 1\n    var isPrimeFactorsCountMaxMin:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMin:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n    var isPrimeFactorsCountMinMaxMinMaxMaxMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp495_fm0m.swift:19:9: error: invalid redeclaration of 'isPrimeFactorsCountMinMaxMinMaxMax'\n\
    \    var isPrimeFactorsCountMinMaxMinMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:18:9:\
    \ note: 'isPrimeFactorsCountMinMaxMinMaxMax' previously declared here\n    var\
    \ isPrimeFactorsCountMinMaxMinMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:21:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMinMaxMinMaxMaxMax'\n  \
    \  var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:20:9:\
    \ note: 'isPrimeFactorsCountMinMaxMinMaxMaxMax' previously declared here\n   \
    \ var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:22:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMinMaxMinMaxMaxMax'\n  \
    \  var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:20:9:\
    \ note: 'isPrimeFactorsCountMinMaxMinMaxMaxMax' previously declared here\n   \
    \ var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMinMaxMinMaxMaxMax'\n  \
    \  var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:20:9:\
    \ note: 'isPrimeFactorsCountMinMaxMinMaxMaxMax' previously declared here\n   \
    \ var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMinMaxMinMaxMaxMax'\n  \
    \  var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:20:9:\
    \ note: 'isPrimeFactorsCountMinMaxMinMaxMaxMax' previously declared here\n   \
    \ var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMinMaxMinMaxMaxMax'\n  \
    \  var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:20:9:\
    \ note: 'isPrimeFactorsCountMinMaxMinMaxMaxMax' previously declared here\n   \
    \ var isPrimeFactorsCountMinMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp495_fm0m.swift:26:9:\
    \ error: invalid redeclaration of 'isPrimeFacto"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = []\n    var current:\
    \ Int\n    var factor: Int\n    var i: Int\n    var j: Int\n    var k: Int\n \
    \   var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n    var y: Int\n    var z: Int\n    var a: Int\n\
    \    var b: Int\n    var c: Int\n    var d: Int\n    var e: Int\n    var f: Int\n\
    \    var g: Int\n    var h: Int\n    var i: Int\n    var j: Int\n    var k: Int\n\
    \    var l: Int\n    var m: Int\n    var n: Int\n    var p: Int\n    var q: Int\n\
    \    var r: Int\n    var s: Int\n    var t: Int\n    var u: Int\n    var v: Int\n\
    \    var w: Int\n    var x: Int\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw7nk3y0a.swift:35:9: error: invalid redeclaration of 'i'\n    var\
    \ i: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:10:9: note: 'i' previously declared\
    \ here\n    var i: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:36:9: error: invalid\
    \ redeclaration of 'j'\n    var j: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:11:9:\
    \ note: 'j' previously declared here\n    var j: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:37:9:\
    \ error: invalid redeclaration of 'k'\n    var k: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:12:9:\
    \ note: 'k' previously declared here\n    var k: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:38:9:\
    \ error: invalid redeclaration of 'l'\n    var l: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:13:9:\
    \ note: 'l' previously declared here\n    var l: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:39:9:\
    \ error: invalid redeclaration of 'm'\n    var m: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:14:9:\
    \ note: 'm' previously declared here\n    var m: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:40:9:\
    \ error: invalid redeclaration of 'n'\n    var n: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:15:9:\
    \ note: 'n' previously declared here\n    var n: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:41:9:\
    \ error: invalid redeclaration of 'p'\n    var p: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:16:9:\
    \ note: 'p' previously declared here\n    var p: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:42:9:\
    \ error: invalid redeclaration of 'q'\n    var q: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:17:9:\
    \ note: 'q' previously declared here\n    var q: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:43:9:\
    \ error: invalid redeclaration of 'r'\n    var r: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:18:9:\
    \ note: 'r' previously declared here\n    var r: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:44:9:\
    \ error: invalid redeclaration of 's'\n    var s: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:19:9:\
    \ note: 's' previously declared here\n    var s: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:45:9:\
    \ error: invalid redeclaration of 't'\n    var t: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:20:9:\
    \ note: 't' previously declared here\n    var t: Int\n        ^\n/tmp/tmpw7nk3y0a.swift:46:9:\
    \ error: invalid redeclaration of 'u'\n    var u: Int"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var factorizationCount = 0\n    var primeFactorizationCount = 0\n    var\
    \ factorizationPrimeCount = 0\n    var primeFactorizationPrimeCount = 0\n    var\
    \ factorizationPrimeCountMax = 0\n    var primeFactorizationPrimeCountMax = 0\n\
    \    var factorizationPrimeCountMaxMax = 0\n    var primeFactorizationPrimeCountMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n    var factorizationPrimeCountMaxMaxMax = 0\n    var prime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps5dehm34.swift:18:9: error: invalid redeclaration of 'factorizationPrimeCountMaxMaxMax'\n\
    \    var factorizationPrimeCountMaxMaxMax = 0\n        ^\n/tmp/tmps5dehm34.swift:16:9:\
    \ note: 'factorizationPrimeCountMaxMaxMax' previously declared here\n    var factorizationPrimeCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmps5dehm34.swift:19:9: error: invalid redeclaration of\
    \ 'primeFactorizationPrimeCountMaxMaxMax'\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmps5dehm34.swift:17:9: note: 'primeFactorizationPrimeCountMaxMaxMax'\
    \ previously declared here\n    var primeFactorizationPrimeCountMaxMaxMax = 0\n\
    \        ^\n/tmp/tmps5dehm34.swift:20:9: error: invalid redeclaration of 'factorizationPrimeCountMaxMaxMax'\n\
    \    var factorizationPrimeCountMaxMaxMax = 0\n        ^\n/tmp/tmps5dehm34.swift:16:9:\
    \ note: 'factorizationPrimeCountMaxMaxMax' previously declared here\n    var factorizationPrimeCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmps5dehm34.swift:21:9: error: invalid redeclaration of\
    \ 'primeFactorizationPrimeCountMaxMaxMax'\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmps5dehm34.swift:17:9: note: 'primeFactorizationPrimeCountMaxMaxMax'\
    \ previously declared here\n    var primeFactorizationPrimeCountMaxMaxMax = 0\n\
    \        ^\n/tmp/tmps5dehm34.swift:22:9: error: invalid redeclaration of 'factorizationPrimeCountMaxMaxMax'\n\
    \    var factorizationPrimeCountMaxMaxMax = 0\n        ^\n/tmp/tmps5dehm34.swift:16:9:\
    \ note: 'factorizationPrimeCountMaxMaxMax' previously declared here\n    var factorizationPrimeCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmps5dehm34.swift:23:9: error: invalid redeclaration of\
    \ 'primeFactorizationPrimeCountMaxMaxMax'\n    var primeFactorizationPrimeCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmps5dehm34.swift:17:9: note: 'primeFactorizationPrimeCountMaxMaxMax'\
    \ previously declared here\n    var primeFactorizationPrimeCountMaxMaxMax = 0\n\
    \        ^\n/tmp/tmps5dehm34.swift:24:9: error: invalid redeclaration of 'factorizationPrimeCountMaxMaxMax'\n\
    \    var factorizationPrimeCountMaxMaxMax = 0\n        ^\n/tmp/tmps5dehm34.swift:16:9:\
    \ no"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            factors.append(i)\n            n /= i\n      \
    \  } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk44a6247.swift:11:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationCount = 0\n    var factorizationIndex = 0\n    var isPrime = true\n\
    \    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeIndexCount\
    \ = 0\n    var isPrimeIndex2 = 0\n    var isPrimeIndexCount2 = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeIndexCount3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeIndexCount4\
    \ = 0\n    var isPrimeIndex5 = 0\n    var isPrimeIndexCount5 = 0\n    var isPrimeIndex6\
    \ = 0\n    var isPrimeIndexCount6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeIndexCount7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeIndexCount8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeIndexCount9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeIndexCount10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeIndexCount11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeIndexCount12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeIndexCount13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeIndexCount14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeIndexCount15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeIndexCount16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeIndexCount17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeIndexCount18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeIndexCount19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeIndexCount20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeIndexCount21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeIndexCount22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeIndexCount23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeIndexCount24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeIndexCount25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeIndexCount26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeIndexCount27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeIndexCount28\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2n25sez7.swift:67:9: error: type annotation missing in pattern\n\
    \    var isPrimeIndexCount28\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isFactorization = false\n\
    \    var isFactorizationPrime = false\n    var isFactorizationPrimeIndex = -1\n\
    \    var isFactorizationPrimeIndex2 = -1\n    var isFactorizationPrimeIndex3 =\
    \ -1\n    var isFactorizationPrimeIndex4 = -1\n    var isFactorizationPrimeIndex5\
    \ = -1\n    var isFactorizationPrimeIndex6 = -1\n    var isFactorizationPrimeIndex7\
    \ = -1\n    var isFactorizationPrimeIndex8 = -1\n    var isFactorizationPrimeIndex9\
    \ = -1\n    var isFactorizationPrimeIndex10 = -1\n    var isFactorizationPrimeIndex11\
    \ = -1\n    var isFactorizationPrimeIndex12 = -1\n    var isFactorizationPrimeIndex13\
    \ = -1\n    var isFactorizationPrimeIndex14 = -1\n    var isFactorizationPrimeIndex15\
    \ = -1\n    var isFactorizationPrimeIndex16 = -1\n    var isFactorizationPrimeIndex17\
    \ = -1\n    var isFactorizationPrimeIndex18 = -1\n    var isFactorizationPrimeIndex19\
    \ = -1\n    var isFactorizationPrimeIndex20 = -1\n    var isFactorizationPrimeIndex21\
    \ = -1\n    var isFactorizationPrimeIndex22 = -1\n    var isFactorizationPrimeIndex23\
    \ = -1\n    var isFactorizationPrimeIndex24 = -1\n    var isFactorizationPrimeIndex25\
    \ = -1\n    var isFactorizationPrimeIndex26 = -1\n    var isFactorizationPrimeIndex27\
    \ = -1\n    var isFactorizationPrimeIndex28 = -1\n    var isFactorizationPrimeIndex29\
    \ = -1\n    var isFactorizationPrimeIndex30 = -1\n    var isFactorizationPrimeIndex31\
    \ = -1\n    var isFactorizationPrimeIndex32 = -1\n    var isFactorizationPrimeIndex33\
    \ = -1\n    var isFactorizationPrimeIndex34 = -1\n    var isFactorizationPrimeIndex35\
    \ = -1\n    var isFactorizationPrimeIndex36 = -1\n    var isFactorizationPrimeIndex37\
    \ = -1\n    var isFactorizationPrimeIndex38 = -1\n    var isFactorizationPrimeIndex39\
    \ = -1\n    var isFactorizationPrimeIndex40 = -1\n    var isFactorizationPrimeIndex41\
    \ = -1\n    var isFactorizationPrimeIndex42 = -1\n    var isFactorizationPrimeIndex43\
    \ = -1\n    var isFactorizationPrimeIndex44 = -1\n    var isFactorizationPrimeIndex45\
    \ = -1\n    var isFactorizationPrimeIndex46 = -1\n    var isFactorizationPrimeIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqnas5293.swift:58:9: error: type annotation missing in pattern\n\
    \    var isFactorizationPrimeIndex\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationMax = 0\n    var factorizationMin\
    \ = Int64(1)\n    var factorizationMaxIndex = Int64(-1)\n    var factorizationMinIndex\
    \ = Int64(-1)\n    var factorizationMaxFactor = Int64(1)\n    var factorizationMinFactor\
    \ = Int64(1)\n    var factorizationMaxFactorIndex = Int64(-1)\n    var factorizationMinFactorIndex\
    \ = Int64(-1)\n    var factorizationMaxFactorCount = Int64(1)\n    var factorizationMinFactorCount\
    \ = Int64(1)\n    var factorizationMaxFactorCountIndex = Int64(-1)\n    var factorizationMinFactorCountIndex\
    \ = Int64(-1)\n    var factorizationMaxFactorCountFactor = Int64(1)\n    var factorizationMinFactorCountFactor\
    \ = Int64(1)\n    var factorizationMaxFactorCountFactorIndex = Int64(-1)\n   \
    \ var factorizationMinFactorCountFactorIndex = Int64(-1)\n    var factorizationMaxFactorCountFactorCount\
    \ = Int64(1)\n    var factorizationMinFactorCountFactorCount = Int64(1)\n    var\
    \ factorizationMaxFactorCountFactorCountIndex = Int64(-1)\n    var factorizationMinFactorCountFactorCountIndex\
    \ = Int64(-1)\n    var factorizationMaxFactorCountFactorCountFactor = Int64(1)\n\
    \    var factorizationMinFactorCountFactorCountFactor = Int64(1)\n    var factorizationMaxFactorCountFactorCountFactorIndex\
    \ = Int64(-1)\n    var factorizationMinFactorCountFactorCountFactorIndex = Int64(-1)\n\
    \    var factorizationMaxFactorCountFactorCountFactorCount = Int64(1)\n    var\
    \ factorizationMinFactorCountFactorCountFactorCount = Int64(1)\n    var factorizationMaxFactorCountFactorCountFactorCountIndex\
    \ = Int64(-1)\n    var factorizationMinFactorCountFactorCountFactorCountIndex\
    \ = Int64(-1)\n    var factorizationMaxFactorCountFactorCountFactorCountFactor\
    \ = Int64(1)\n    var factorizationMinFactorCountFactorCountFactorCountFactor\
    \ = Int64(1)\n    var factorizationMaxFactorCountFactorCountFactorCountFactorIndex\
    \ = Int64(-1)\n    var factorizationMinFactorCountFactorCountFactorCountFactorIndex\
    \ = Int64(-1)\n    var factorizationMaxFactorCountFactorCountFactorCountFactorCount\
    \ = Int64(1)\n    var factorizationMinFactorCountFactorCountFactorCountFactorCount\
    \ = Int64(1)\n    var factorizationMaxFactorCountFactorCountFactorCountFactorCountIndex\
    \ = Int64(-1)\n    var factorizationMinFactorCountFactorCountFactorCountFactorCountIndex\
    \ = Int64(-1)\n    var factorizationMaxFactorCountFactorCountFactorCountFactorCountFactor\
    \ = Int64(1)\n    var factorizationMinFactorCountFactorCountFactorCount\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpj9yzp3t7.swift:47:9: error: type annotation missing in pattern\n\
    \    var factorizationMinFactorCountFactorCountFactorCount\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isFactorization = false\n\
    \    var isFactorizationPrime = true\n    var isFactorizationPrimeIndex = 0\n\
    \    var isFactorizationPrimeCount = 1\n    var isFactorizationPrimeIndex2 = 0\n\
    \    var isFactorizationPrimeCount2 = 0\n    var isFactorizationPrimeIndex3 =\
    \ 0\n    var isFactorizationPrimeCount3 = 0\n    var isFactorizationPrimeIndex4\
    \ = 0\n    var isFactorizationPrimeCount4 = 0\n    var isFactorizationPrimeIndex5\
    \ = 0\n    var isFactorizationPrimeCount5 = 0\n    var isFactorizationPrimeIndex6\
    \ = 0\n    var isFactorizationPrimeCount6 = 0\n    var isFactorizationPrimeIndex7\
    \ = 0\n    var isFactorizationPrimeCount7 = 0\n    var isFactorizationPrimeIndex8\
    \ = 0\n    var isFactorizationPrimeCount8 = 0\n    var isFactorizationPrimeIndex9\
    \ = 0\n    var isFactorizationPrimeCount9 = 0\n    var isFactorizationPrimeIndex10\
    \ = 0\n    var isFactorizationPrimeCount10 = 0\n    var isFactorizationPrimeIndex11\
    \ = 0\n    var isFactorizationPrimeCount11 = 0\n    var isFactorizationPrimeIndex12\
    \ = 0\n    var isFactorizationPrimeCount12 = 0\n    var isFactorizationPrimeIndex13\
    \ = 0\n    var isFactorizationPrimeCount13 = 0\n    var isFactorizationPrimeIndex14\
    \ = 0\n    var isFactorizationPrimeCount14 = 0\n    var isFactorizationPrimeIndex15\
    \ = 0\n    var isFactorizationPrimeCount15 = 0\n    var isFactorizationPrimeIndex16\
    \ = 0\n    var isFactorizationPrimeCount16 = 0\n    var isFactorizationPrimeIndex17\
    \ = 0\n    var isFactorizationPrimeCount17 = 0\n    var isFactorizationPrimeIndex18\
    \ = 0\n    var isFactorizationPrimeCount18 = 0\n    var isFactorizationPrimeIndex19\
    \ = 0\n    var isFactorizationPrimeCount19 = 0\n    var isFactorizationPrimeIndex20\
    \ = 0\n    var isFactorizationPrimeCount20 = 0\n    var isFactorizationPrimeIndex21\
    \ = 0\n    var isFactorizationPrimeCount21 = 0\n    var isFactorizationPrimeIndex22\
    \ = 0\n    var isFactorizationPrimeCount22 = 0\n    var isFactorizationPrimeIndex23\
    \ = 0\n    var isFactorizationPrimeCount23 = 0\n    var isFactorizationPrimeIndex24\
    \ = 0\n    var isFactorizationPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsscheap6.swift:59:9: error: type annotation missing in pattern\n\
    \    var isFactorizationPri\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationCountIndex = 0\n    var factorizationCountMax\
    \ = 0\n    var factorizationCountMaxIndex = 0\n    var factorizationCountMaxIndex2\
    \ = 0\n    var factorizationCountMaxIndex3 = 0\n    var factorizationCountMaxIndex4\
    \ = 0\n    var factorizationCountMaxIndex5 = 0\n    var factorizationCountMaxIndex6\
    \ = 0\n    var factorizationCountMaxIndex7 = 0\n    var factorizationCountMaxIndex8\
    \ = 0\n    var factorizationCountMaxIndex9 = 0\n    var factorizationCountMaxIndex10\
    \ = 0\n    var factorizationCountMaxIndex11 = 0\n    var factorizationCountMaxIndex12\
    \ = 0\n    var factorizationCountMaxIndex13 = 0\n    var factorizationCountMaxIndex14\
    \ = 0\n    var factorizationCountMaxIndex15 = 0\n    var factorizationCountMaxIndex16\
    \ = 0\n    var factorizationCountMaxIndex17 = 0\n    var factorizationCountMaxIndex18\
    \ = 0\n    var factorizationCountMaxIndex19 = 0\n    var factorizationCountMaxIndex20\
    \ = 0\n    var factorizationCountMaxIndex21 = 0\n    var factorizationCountMaxIndex22\
    \ = 0\n    var factorizationCountMaxIndex23 = 0\n    var factorizationCountMaxIndex24\
    \ = 0\n    var factorizationCountMaxIndex25 = 0\n    var factorizationCountMaxIndex26\
    \ = 0\n    var factorizationCountMaxIndex27 = 0\n    var factorizationCountMaxIndex28\
    \ = 0\n    var factorizationCountMaxIndex29 = 0\n    var factorizationCountMaxIndex30\
    \ = 0\n    var factorizationCountMaxIndex31 = 0\n    var factorizationCountMaxIndex32\
    \ = 0\n    var factorizationCountMaxIndex33 = 0\n    var factorizationCountMaxIndex34\
    \ = 0\n    var factorizationCountMaxIndex35 = 0\n    var factorizationCountMaxIndex36\
    \ = 0\n    var factorizationCountMaxIndex37 = 0\n    var factorizationCountMaxIndex38\
    \ = 0\n    var factorizationCountMaxIndex39 = 0\n    var factorizationCountMaxIndex40\
    \ = 0\n    var factorizationCountMaxIndex41 = 0\n    var factorizationCountMaxIndex42\
    \ = 0\n    var factorizationCountMaxIndex43 = 0\n    var factorizationCountMaxIndex44\
    \ = 0\n    var factorizationCountMaxIndex45 = 0\n    var factorizationCountMaxIndex46\
    \ = 0\n    var factorizationCountMaxIndex47 = 0\n    var factorizationCountMaxIndex48\
    \ = 0\n    var factorizationCountMaxIndex49 = 0\n    var factorizationCountMaxIndex50\
    \ = 0\n    var factorizationCountMaxIndex51 = 0\n    var factorizationCountMaxIndex52\
    \ = 0\n    var factorizationCountMaxIndex53 = 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo9b8h4qp.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpo9b8h4qp.swift:7:9:\
    \ warning: initialization of variable 'factorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationCount\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpo9b8h4qp.swift:8:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpo9b8h4qp.swift:9:9: warning: initialization of variable 'factorizationCountIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationCountIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpo9b8h4qp.swift:10:9: warning: initialization of variable 'factorizationCountMax'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationCountMax = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpo9b8h4qp.swift:11:9:\
    \ warning: initialization of variable 'factorizationCountMaxIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationCountMaxIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpo9b8h4qp.swift:12:9:\
    \ warning: initialization of variable 'factorizationCountMaxIndex2' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationCountMaxIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpo9b8h4qp.swift:13:9:\
    \ warning: initialization of variable 'factorizationCountMaxIndex3' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationCountMaxIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpo9b8h4qp.swift:14:9:\
    \ warning: initialization of variable 'factorizationCountMaxIndex4' was never\
    \ used; consider replacing with assignment to '_' or removing it\n "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor: Int\n    var i: Int\n\
    \    var j: Int\n    var k: Int\n    var count: Int\n    var factors: Int\n  \
    \  var factorsArray: [Int]\n    var factorsArrayCopy: [Int]\n    var factorsArrayCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopy: [Int]\n    var factorsArrayCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopy: [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopy: [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n    var\
    \ factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n    var\
    \ factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n    var factorsArrayCopyCopyCopyCopyCopy\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5by6h37m.swift:22:9: error: invalid redeclaration of 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopy'\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n        ^\n/tmp/tmp5by6h37m.swift:21:9:\
    \ note: 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopy' previously declared here\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n        ^\n/tmp/tmp5by6h37m.swift:24:9:\
    \ error: invalid redeclaration of 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopy'\n\
    \    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopy: [Int]\n        ^\n\
    /tmp/tmp5by6h37m.swift:23:9: note: 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopy'\
    \ previously declared here\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:26:9: error: invalid redeclaration\
    \ of 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:25:9: note: 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\
    \ previously declared here\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:28:9: error: invalid redeclaration\
    \ of 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:27:9: note: 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\
    \ previously declared here\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:29:9: error: invalid redeclaration\
    \ of 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:27:9: note: 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\
    \ previously declared here\n    var factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy:\
    \ [Int]\n        ^\n/tmp/tmp5by6h37m.swift:32:9: error: invalid redeclaration\
    \ of 'factorsArrayCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy'\n "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationSum2 = 0\n    var factorizationSum3\
    \ = 0\n    var factorizationSum4 = 0\n    var factorizationSum5 = 0\n    var factorizationSum6\
    \ = 0\n    var factorizationSum7 = 0\n    var factorizationSum8 = 0\n    var factorizationSum9\
    \ = 0\n    var factorizationSum10 = 0\n    var factorizationSum11 = 0\n    var\
    \ factorizationSum12 = 0\n    var factorizationSum13 = 0\n    var factorizationSum14\
    \ = 0\n    var factorizationSum15 = 0\n    var factorizationSum16 = 0\n    var\
    \ factorizationSum17 = 0\n    var factorizationSum18 = 0\n    var factorizationSum19\
    \ = 0\n    var factorizationSum20 = 0\n    var factorizationSum21 = 0\n    var\
    \ factorizationSum22 = 0\n    var factorizationSum23 = 0\n    var factorizationSum24\
    \ = 0\n    var factorizationSum25 = 0\n    var factorizationSum26 = 0\n    var\
    \ factorizationSum27 = 0\n    var factorizationSum28 = 0\n    var factorizationSum29\
    \ = 0\n    var factorizationSum30 = 0\n    var factorizationSum31 = 0\n    var\
    \ factorizationSum32 = 0\n    var factorizationSum33 = 0\n    var factorizationSum34\
    \ = 0\n    var factorizationSum35 = 0\n    var factorizationSum36 = 0\n    var\
    \ factorizationSum37 = 0\n    var factorizationSum38 = 0\n    var factorizationSum39\
    \ = 0\n    var factorizationSum40 = 0\n    var factorizationSum41 = 0\n    var\
    \ factorizationSum42 = 0\n    var factorizationSum43 = 0\n    var factorizationSum44\
    \ = 0\n    var factorizationSum45 = 0\n    var factorizationSum46 = 0\n    var\
    \ factorizationSum47 = 0\n    var factorizationSum48 = 0\n    var factorizationSum49\
    \ = 0\n    var factorizationSum50 = 0\n    var factorizationSum51 = 0\n    var\
    \ factorizationSum52 = 0\n    var factorizationSum53 = 0\n    var factorizationSum54\
    \ = 0\n    var factorizationSum55 = 0\n    var factorizationSum56 = 0\n    var\
    \ factorizationSum57 = 0\n    var factorizationSum58 = 0\n    var factorizationSum59\
    \ = 0\n    var factorizationSum60 = 0\n    var factorizationSum61 = 0\n    var\
    \ factorizationSum62 = 0\n    var factorizationSum63 = 0\n    var factorizationSum64\
    \ = 0\n    var factorizationSum65 = 0\n    var factorizationSum66 = 0\n    var\
    \ factorizationSum67 = 0\n    var factorizationSum68 = 0\n    var factorizationSum69\
    \ = 0\n    var factorizationSum70 = 0\n    var factorizationSum71 = 0\n    var\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkqyh_d3h.swift:79:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = true\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrime = true\n    var isPrimeFactorizationPrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = true\n   \
    \ var isPrimeFactorizationPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime =\
    \ true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp404uhdkf.swift:34:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isFactorizationComplete\
    \ = false\n    var isFactorizationCompleteIndex = 0\n    var isPrimeIndex = 0\n\
    \    var isPrimeIndex2 = 0\n    var isPrimeIndex3 = 0\n    var isPrimeIndex4 =\
    \ 0\n    var isPrimeIndex5 = 0\n    var isPrimeIndex6 = 0\n    var isPrimeIndex7\
    \ = 0\n    var isPrimeIndex8 = 0\n    var isPrimeIndex9 = 0\n    var isPrimeIndex10\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeIndex12 = 0\n    var isPrimeIndex13\
    \ = 0\n    var isPrimeIndex14 = 0\n    var isPrimeIndex15 = 0\n    var isPrimeIndex16\
    \ = 0\n    var isPrimeIndex17 = 0\n    var isPrimeIndex18 = 0\n    var isPrimeIndex19\
    \ = 0\n    var isPrimeIndex20 = 0\n    var isPrimeIndex21 = 0\n    var isPrimeIndex22\
    \ = 0\n    var isPrimeIndex23 = 0\n    var isPrimeIndex24 = 0\n    var isPrimeIndex25\
    \ = 0\n    var isPrimeIndex26 = 0\n    var isPrimeIndex27 = 0\n    var isPrimeIndex28\
    \ = 0\n    var isPrimeIndex29 = 0\n    var isPrimeIndex30 = 0\n    var isPrimeIndex31\
    \ = 0\n    var isPrimeIndex32 = 0\n    var isPrimeIndex33 = 0\n    var isPrimeIndex34\
    \ = 0\n    var isPrimeIndex35 = 0\n    var isPrimeIndex36 = 0\n    var isPrimeIndex37\
    \ = 0\n    var isPrimeIndex38 = 0\n    var isPrimeIndex39 = 0\n    var isPrimeIndex40\
    \ = 0\n    var isPrimeIndex41 = 0\n    var isPrimeIndex42 = 0\n    var isPrimeIndex43\
    \ = 0\n    var isPrimeIndex44 = 0\n    var isPrimeIndex45 = 0\n    var isPrimeIndex46\
    \ = 0\n    var isPrimeIndex47 = 0\n    var isPrimeIndex48 = 0\n    var isPrimeIndex49\
    \ = 0\n    var isPrimeIndex50 = 0\n    var isPrimeIndex51 = 0\n    var isPrimeIndex52\
    \ = 0\n    var isPrimeIndex53 = 0\n    var isPrimeIndex54 = 0\n    var isPrimeIndex55\
    \ = 0\n    var isPrimeIndex56 = 0\n    var isPrimeIndex57 = 0\n    var isPrimeIndex58\
    \ = 0\n    var isPrimeIndex59 = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp10xe9o67.swift:6:9: warning: variable 'factors' was never used;\
    \ consider replacing with '_' or removing it\n    var factors: [Int] = []\n  \
    \      ^~~~~~~\n        _\n/tmp/tmp10xe9o67.swift:7:9: warning: variable 'factorization'\
    \ was never used; consider replacing with '_' or removing it\n    var factorization:\
    \ [Int] = [n]\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp10xe9o67.swift:8:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp10xe9o67.swift:9:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmp10xe9o67.swift:10:9: warning:\
    \ initialization of variable 'isFactorizationComplete' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isFactorizationComplete\
    \ = false\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp10xe9o67.swift:11:9:\
    \ warning: initialization of variable 'isFactorizationCompleteIndex' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var isFactorizationCompleteIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp10xe9o67.swift:12:9:\
    \ warning: initialization of variable 'isPrimeIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp10xe9o67.swift:13:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmp10xe9o67.swift:14:9: warning: initialization of variable 'isPrimeIndex3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex3 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp10xe9o67.swift:15:9:\
    \ warning: initialization of variable 'isPrimeIndex4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationSumCount\
    \ = 0\n    var factorizationSumIndex = 0\n    var factorizationSumCountIndex =\
    \ 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpteo7urbz.swift:13:9: error: invalid redeclaration of 'factorizationSumCountIndex'\n\
    \    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpteo7urbz.swift:12:9:\
    \ note: 'factorizationSumCountIndex' previously declared here\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpteo7urbz.swift:14:9: error: invalid redeclaration of\
    \ 'factorizationSumCountIndex'\n    var factorizationSumCountIndex = 0\n     \
    \   ^\n/tmp/tmpteo7urbz.swift:12:9: note: 'factorizationSumCountIndex' previously\
    \ declared here\n    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpteo7urbz.swift:15:9:\
    \ error: invalid redeclaration of 'factorizationSumCountIndex'\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpteo7urbz.swift:12:9: note: 'factorizationSumCountIndex'\
    \ previously declared here\n    var factorizationSumCountIndex = 0\n        ^\n\
    /tmp/tmpteo7urbz.swift:16:9: error: invalid redeclaration of 'factorizationSumCountIndex'\n\
    \    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpteo7urbz.swift:12:9:\
    \ note: 'factorizationSumCountIndex' previously declared here\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpteo7urbz.swift:17:9: error: invalid redeclaration of\
    \ 'factorizationSumCountIndex'\n    var factorizationSumCountIndex = 0\n     \
    \   ^\n/tmp/tmpteo7urbz.swift:12:9: note: 'factorizationSumCountIndex' previously\
    \ declared here\n    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpteo7urbz.swift:18:9:\
    \ error: invalid redeclaration of 'factorizationSumCountIndex'\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpteo7urbz.swift:12:9: note: 'factorizationSumCountIndex'\
    \ previously declared here\n    var factorizationSumCountIndex = 0\n        ^\n\
    /tmp/tmpteo7urbz.swift:19:9: error: invalid redeclaration of 'factorizationSumCountIndex'\n\
    \    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpteo7urbz.swift:12:9:\
    \ note: 'factorizationSumCountIndex' previously declared here\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpteo7urbz.swift:20:9: error: invalid redeclaration of\
    \ 'factorizationSumCountIndex'\n    var factorizati"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primes = [Int]()\n    var primeFactorization\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeFactorization = [Bool]()\n\
    \    var isPrimeFactorization2 = [Bool]()\n    var isPrimeFactorization3 = [Bool]()\n\
    \    var isPrimeFactorization4 = [Bool]()\n    var isPrimeFactorization5 = [Bool]()\n\
    \    var isPrimeFactorization6 = [Bool]()\n    var isPrimeFactorization7 = [Bool]()\n\
    \    var isPrimeFactorization8 = [Bool]()\n    var isPrimeFactorization9 = [Bool]()\n\
    \    var isPrimeFactorization10 = [Bool]()\n    var isPrimeFactorization11 = [Bool]()\n\
    \    var isPrimeFactorization12 = [Bool]()\n    var isPrimeFactorization13 = [Bool]()\n\
    \    var isPrimeFactorization14 = [Bool]()\n    var isPrimeFactorization15 = [Bool]()\n\
    \    var isPrimeFactorization16 = [Bool]()\n    var isPrimeFactorization17 = [Bool]()\n\
    \    var isPrimeFactorization18 = [Bool]()\n    var isPrimeFactorization19 = [Bool]()\n\
    \    var isPrimeFactorization20 = [Bool]()\n    var isPrimeFactorization21 = [Bool]()\n\
    \    var isPrimeFactorization22 = [Bool]()\n    var isPrimeFactorization23 = [Bool]()\n\
    \    var isPrimeFactorization24 = [Bool]()\n    var isPrimeFactorization25 = [Bool]()\n\
    \    var isPrimeFactorization26 = [Bool]()\n    var isPrimeFactorization27 = [Bool]()\n\
    \    var isPrimeFactorization28 = [Bool]()\n    var isPrimeFactorization29 = [Bool]()\n\
    \    var isPrimeFactorization30 = [Bool]()\n    var isPrimeFactorization31 = [Bool]()\n\
    \    var isPrimeFactorization32 = [Bool]()\n    var isPrimeFactorization33 = [Bool]()\n\
    \    var isPrimeFactorization34 = [Bool]()\n    var isPrimeFactorization35 = [Bool]()\n\
    \    var isPrimeFactorization36 = [Bool]()\n    var isPrimeFactorization37 = [Bool]()\n\
    \    var isPrimeFactorization38 = [Bool]()\n    var isPrimeFactorization39 = [Bool]()\n\
    \    var isPrimeFactorization40 = [Bool]()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9v9665zq.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp9v9665zq.swift:7:9:\
    \ warning: initialization of variable 'primes' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primes = [Int]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp9v9665zq.swift:8:9: warning: initialization of variable 'primeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorization = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp9v9665zq.swift:9:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = [Bool]()\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmp9v9665zq.swift:10:9: warning: initialization of variable 'isPrimeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp9v9665zq.swift:11:9: warning: initialization of variable 'isPrimeFactorization2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization2 = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp9v9665zq.swift:12:9: warning: initialization of variable 'isPrimeFactorization3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization3 = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp9v9665zq.swift:13:9: warning: initialization of variable 'isPrimeFactorization4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization4 = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp9v9665zq.swift:14:9: warning: initialization of variable 'isPrimeFactorization5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization5 = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmp9v9665zq.swift:15:9"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactors\
    \ = [1]\n    var factorization = [1]\n    var isPrime = true\n    var isFactorization\
    \ = true\n    var isPrimeFactorization = true\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimePrime = true\n    var isPrimeFactorizationPrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpid69bgpg.swift:24:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:23:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:23:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:26:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:26:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpid69bgpg.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrime"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var isPrime: Bool = false\n    var isFactorization: Bool = false\n    var\
    \ isPrimeFactorization: Bool = false\n    var isPrimeFactorizationPrime: Bool\
    \ = false\n    var isPrimeFactorizationFactorization: Bool = false\n    var isPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrime: Bool = false\n\
    \    var isPrimeFactorizationPrimeFactorizationFactorization: Bool = false\n \
    \   var isPrimeFactorizationPrimeFactorizationPrimeFactorization: Bool = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime: Bool =\
    \ false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp52z0q2zx.swift:20:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:19:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:23:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:27:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp52z0q2zx.swift:27:9: note: 'isPrimeFacto"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n: n)\n\
    \    var factorizationCount = 1\n    var factorizationIndex = 0\n    while factorizationIndex\
    \ < factorization.count {\n        factors.append(factorization[factorizationIndex])\n\
    \        factorizationCount *= factorization[factorizationIndex]\n        factorizationIndex\
    \ += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjd1gl599.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n: n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n  \
    \  var primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqweb9bga.swift:10:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmpqweb9bga.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpqweb9bga.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpqweb9bga.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrime = true\n\
    \        ^\n/tmp/tmpqweb9bga.swift:24:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpqweb9bga.swift:22:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimeCount' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpqweb9bga.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpqweb9bga.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpqweb9bga.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpqweb9bga.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpqweb9bga.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpqweb9bga.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpqweb9bga.swift:33:9: error: invalid redeclaration of 'isPrimePrimePrimePr"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var factorizationCount = 0\n    var\
    \ primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var primeFactorizationArray\
    \ = [Int]()\n    var factorizationArray = [Int]()\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var primeFactorizationArrayIndex\
    \ = 0\n    var factorizationArrayIndex = 0\n    var primeFactorizationArrayCount\
    \ = 0\n    var factorizationArrayCount = 0\n    var prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp86stlzme.swift:18:9: error: invalid redeclaration of 'primeFactorizationArrayIndex'\n\
    \    var primeFactorizationArrayIndex = 0\n        ^\n/tmp/tmp86stlzme.swift:14:9:\
    \ note: 'primeFactorizationArrayIndex' previously declared here\n    var primeFactorizationArrayIndex\
    \ = 0\n        ^\n/tmp/tmp86stlzme.swift:19:9: error: invalid redeclaration of\
    \ 'factorizationArrayIndex'\n    var factorizationArrayIndex = 0\n        ^\n\
    /tmp/tmp86stlzme.swift:15:9: note: 'factorizationArrayIndex' previously declared\
    \ here\n    var factorizationArrayIndex = 0\n        ^\n/tmp/tmp86stlzme.swift:20:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayCount'\n    var primeFactorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp86stlzme.swift:16:9: note: 'primeFactorizationArrayCount'\
    \ previously declared here\n    var primeFactorizationArrayCount = 0\n       \
    \ ^\n/tmp/tmp86stlzme.swift:21:9: error: invalid redeclaration of 'factorizationArrayCount'\n\
    \    var factorizationArrayCount = 0\n        ^\n/tmp/tmp86stlzme.swift:17:9:\
    \ note: 'factorizationArrayCount' previously declared here\n    var factorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp86stlzme.swift:22:9: error: invalid redeclaration of\
    \ 'primeFactorizationArrayIndex'\n    var primeFactorizationArrayIndex = 0\n \
    \       ^\n/tmp/tmp86stlzme.swift:14:9: note: 'primeFactorizationArrayIndex' previously\
    \ declared here\n    var primeFactorizationArrayIndex = 0\n        ^\n/tmp/tmp86stlzme.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationArrayIndex'\n    var factorizationArrayIndex\
    \ = 0\n        ^\n/tmp/tmp86stlzme.swift:15:9: note: 'factorizationArrayIndex'\
    \ previously declared here\n    var factorizationArrayIndex = 0\n        ^\n/tmp/tmp86stlzme.swift:24:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayCount'\n    var primeFactorizationArrayCount\
    \ = 0\n        ^\n/tmp/tmp86stlzme.swift:16:9: note: 'primeFactorizationArrayCount'\
    \ previously declared here\n    var primeFactorizationArrayCount = 0\n       \
    \ ^\n/tmp/tmp86stlzme.swift:25:9: error: invalid redeclaration of 'factorizationArrayCount'\n\
    \    var factorizationArray"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationSum2 = 0\n    var factorizationSum3\
    \ = 0\n    var factorizationSum4 = 0\n    var factorizationSum5 = 0\n    var factorizationSum6\
    \ = 0\n    var factorizationSum7 = 0\n    var factorizationSum8 = 0\n    var factorizationSum9\
    \ = 0\n    var factorizationSum10 = 0\n    var factorizationSum11 = 0\n    var\
    \ factorizationSum12 = 0\n    var factorizationSum13 = 0\n    var factorizationSum14\
    \ = 0\n    var factorizationSum15 = 0\n    var factorizationSum16 = 0\n    var\
    \ factorizationSum17 = 0\n    var factorizationSum18 = 0\n    var factorizationSum19\
    \ = 0\n    var factorizationSum20 = 0\n    var factorizationSum21 = 0\n    var\
    \ factorizationSum22 = 0\n    var factorizationSum23 = 0\n    var factorizationSum24\
    \ = 0\n    var factorizationSum25 = 0\n    var factorizationSum26 = 0\n    var\
    \ factorizationSum27 = 0\n    var factorizationSum28 = 0\n    var factorizationSum29\
    \ = 0\n    var factorizationSum30 = 0\n    var factorizationSum31 = 0\n    var\
    \ factorizationSum32 = 0\n    var factorizationSum33 = 0\n    var factorizationSum34\
    \ = 0\n    var factorizationSum35 = 0\n    var factorizationSum36 = 0\n    var\
    \ factorizationSum37 = 0\n    var factorizationSum38 = 0\n    var factorizationSum39\
    \ = 0\n    var factorizationSum40 = 0\n    var factorizationSum41 = 0\n    var\
    \ factorizationSum42 = 0\n    var factorizationSum43 = 0\n    var factorizationSum44\
    \ = 0\n    var factorizationSum45 = 0\n    var factorizationSum46 = 0\n    var\
    \ factorizationSum47 = 0\n    var factorizationSum48 = 0\n    var factorizationSum49\
    \ = 0\n    var factorizationSum50 = 0\n    var factorizationSum51 = 0\n    var\
    \ factorizationSum52 = 0\n    var factorizationSum53 = 0\n    var factorizationSum54\
    \ = 0\n    var factorizationSum55 = 0\n    var factorizationSum56 = 0\n    var\
    \ factorizationSum57 = 0\n    var factorizationSum58 = 0\n    var factorizationSum59\
    \ = 0\n    var factorizationSum60 = 0\n    var factorizationSum61 = 0\n    var\
    \ factorizationSum62 = 0\n    var factorizationSum63 = 0\n    var factorizationSum64\
    \ = 0\n    var factorizationSum65 = 0\n    var factorizationSum66 = 0\n    var\
    \ factorizationSum67 = 0\n    var factorizationSum68 = 0\n    var factorizationSum69\
    \ = 0\n    var factorizationSum70 = 0\n    var factorizationSum71 = 0\n    var\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkqyh_d3h.swift:79:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexCount = 0\n    var factorizationIndexCountMax\
    \ = IntMax\n\n    while factorizationIndexCount < factorizationIndexCountMax {\n\
    \        if n % factorization[factorizationIndex] == 0 {\n            factorizationCount\
    \ += 1\n            factorizationIndexCount += 1\n        } else {\n         \
    \   factorizationIndexCount += 1\n        }\n        if factorizationIndexCount\
    \ == factorizationIndexCountMax {\n            factorizationIndexCountMax = IntMax\n\
    \        }\n        factorizationIndex += 1\n    }\n    factorizationCount +=\
    \ 1\n    factorizationIndexCount += 1\n    for _ in 0..<factorizationCount {\n\
    \        factorization.append(1)\n    }\n    for _ in 0..<factorizationCount {\n\
    \        factorizationIndex += 1\n    }\n    for _ in 0..<factorizationIndexCount\
    \ {\n        factorizationIndexCount += 1\n    }\n    return factorization\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm3fe8ldj.swift:10:38: error: cannot find 'IntMax' in scope\n  \
    \  var factorizationIndexCountMax = IntMax\n                                 \
    \    ^~~~~~\n/tmp/tmpm3fe8ldj.swift:20:42: error: cannot find 'IntMax' in scope\n\
    \            factorizationIndexCountMax = IntMax\n                           \
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var isPrime = true\n    var isPrimeCount =\
    \ 0\n    var isPrimeIndex = -1\n    var isPrimeIndexCount = 0\n    var isPrimeIndexCountMax\
    \ = IntMax\n\n    for _ in 0..<n {\n        if isPrimeIndexCount == isPrimeIndexCountMax\
    \ {\n            factorizationCount += isPrimeIndexCount\n            factorizationIndex\
    \ += 1\n            isPrimeIndexCount = 0\n            isPrimeIndexCountMax =\
    \ IntMax\n        }\n\n        if isPrime {\n            factorization[factorizationIndex]\
    \ += isPrimeCount\n            isPrimeCount = 0\n        } else {\n          \
    \  isPrimeIndexCount += 1\n        }\n\n        isPrime = !isPrime\n        isPrimeIndex\
    \ = isPrimeIndexCount - 1\n        isPrimeIndexCountMax = isPrimeIndexCount +\
    \ 1\n    }\n\n    factorizationCount += isPrimeIndexCount\n    factorizationIndex\
    \ += 1\n    factorizationCount += isPrimeIndexCountMax\n    factorizationIndex\
    \ += 1\n\n    for _ in 0..<factorizationCount {\n        factorization.append(0)\n\
    \    }\n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8m53kv4e.swift:13:32: error: cannot find 'IntMax' in scope\n  \
    \  var isPrimeIndexCountMax = IntMax\n                               ^~~~~~\n\
    /tmp/tmp8m53kv4e.swift:17:35: error: cannot convert value of type 'Int' to expected\
    \ argument type 'Array<Int>'\n            factorizationCount += isPrimeIndexCount\n\
    \                                  ^\n/tmp/tmp8m53kv4e.swift:20:36: error: cannot\
    \ find 'IntMax' in scope\n            isPrimeIndexCountMax = IntMax\n        \
    \                           ^~~~~~\n/tmp/tmp8m53kv4e.swift:35:27: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Array<Int>'\n    factorizationCount\
    \ += isPrimeIndexCount\n                          ^\n/tmp/tmp8m53kv4e.swift:40:18:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    for _ in 0..<factorizationCount {\n                 ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 0\n    var\
    \ currentFactorizationCount = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrimeValue\
    \ = 1\n    var currentFactorizationIsPrimeIsPrime = true\n    var currentFactorizationIsPrimeIsPrimeIndex\
    \ = 0\n    var currentFactorizationIsPrimeIsPrimeValue = 1\n    var currentFactorizationIsPrimeIsPrimeIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIndex = 0\n    var\
    \ currentFactorizationIsPrimeIsPrimeIsPrimeValue = 1\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIndex = 0\n\
    \    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeValue = 1\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeValue =\
    \ 1\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime =\
    \ true\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeValue\
    \ = 1\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeValue\
    \ = 1\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIsPrimeIndex\
    \ = 0\n    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIs\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_id1ye1f.swift:35:9: error: type annotation missing in pattern\n\
    \    var currentFactorizationIsPrimeIsPrimeIsPrimeIsPrimeIs\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationCountMax = Int()\n    var factorizationCountMaxIndex = 0\n\
    \    var factorizationCountMaxValue = 0\n    var factorizationCountMaxValueIndex\
    \ = 0\n    var factorizationCountMaxValue2 = 0\n    var factorizationCountMaxValue2Index\
    \ = 0\n    var factorizationCountMaxValue3 = 0\n    var factorizationCountMaxValue3Index\
    \ = 0\n    var factorizationCountMaxValue4 = 0\n    var factorizationCountMaxValue4Index\
    \ = 0\n    var factorizationCountMaxValue5 = 0\n    var factorizationCountMaxValue5Index\
    \ = 0\n    var factorizationCountMaxValue6 = 0\n    var factorizationCountMaxValue6Index\
    \ = 0\n    var factorizationCountMaxValue7 = 0\n    var factorizationCountMaxValue7Index\
    \ = 0\n    var factorizationCountMaxValue8 = 0\n    var factorizationCountMaxValue8Index\
    \ = 0\n    var factorizationCountMaxValue9 = 0\n    var factorizationCountMaxValue9Index\
    \ = 0\n    var factorizationCountMaxValue10 = 0\n    var factorizationCountMaxValue10Index\
    \ = 0\n    var factorizationCountMaxValue11 = 0\n    var factorizationCountMaxValue11Index\
    \ = 0\n    var factorizationCountMaxValue12 = 0\n    var factorizationCountMaxValue12Index\
    \ = 0\n    var factorizationCountMaxValue13 = 0\n    var factorizationCountMaxValue13Index\
    \ = 0\n    var factorizationCountMaxValue14 = 0\n    var factorizationCountMaxValue14Index\
    \ = 0\n    var factorizationCountMaxValue15 = 0\n    var factorizationCountMaxValue15Index\
    \ = 0\n    var factorizationCountMaxValue16 = 0\n    var factorizationCountMaxValue16Index\
    \ = 0\n    var factorizationCountMaxValue17 = 0\n    var factorizationCountMaxValue17Index\
    \ = 0\n    var factorizationCountMaxValue18 = 0\n    var factorizationCountMaxValue18Index\
    \ = 0\n    var factorizationCountMaxValue19 = 0\n    var factorizationCountMaxValue19Index\
    \ = 0\n    var factorizationCountMaxValue20 = 0\n    var factorizationCountMaxValue20Index\
    \ = 0\n    var factorizationCountMaxValue21 = 0\n    var factorizationCountMaxValue21Index\
    \ = 0\n    var factorizationCountMaxValue22 = 0\n    var factorizationCountMaxValue22Index\
    \ = 0\n    var factorizationCountMaxValue23 = 0\n    var factorizationCountMaxValue23Index\
    \ = 0\n    var factorizationCountMaxValue24 = 0\n    var factorizationCountMaxValue24Index\
    \ = 0\n    var factorizationCountMaxValue25 = 0\n    var factorizationCountMaxValue25Index\
    \ = 0\n    var factorizationCountMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpye4ccych.swift:60:9: error: type annotation missing in pattern\n\
    \    var factorizationCountMax\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 0\n    var factorizationFactorCount\
    \ = 0\n    var factorizationFactorIndex = 0\n    var factorizationFactor2 = 0\n\
    \    var factorizationFactor2Count = 0\n    var factorizationFactor2Index = 0\n\
    \    var factorizationFactor3 = 0\n    var factorizationFactor3Count = 0\n   \
    \ var factorizationFactor3Index = 0\n    var factorizationFactor4 = 0\n    var\
    \ factorizationFactor4Count = 0\n    var factorizationFactor4Index = 0\n    var\
    \ factorizationFactor5 = 0\n    var factorizationFactor5Count = 0\n    var factorizationFactor5Index\
    \ = 0\n    var factorizationFactor6 = 0\n    var factorizationFactor6Count = 0\n\
    \    var factorizationFactor6Index = 0\n    var factorizationFactor7 = 0\n   \
    \ var factorizationFactor7Count = 0\n    var factorizationFactor7Index = 0\n \
    \   var factorizationFactor8 = 0\n    var factorizationFactor8Count = 0\n    var\
    \ factorizationFactor8Index = 0\n    var factorizationFactor9 = 0\n    var factorizationFactor9Count\
    \ = 0\n    var factorizationFactor9Index = 0\n    var factorizationFactor10 =\
    \ 0\n    var factorizationFactor10Count = 0\n    var factorizationFactor10Index\
    \ = 0\n    var factorizationFactor11 = 0\n    var factorizationFactor11Count =\
    \ 0\n    var factorizationFactor11Index = 0\n    var factorizationFactor12 = 0\n\
    \    var factorizationFactor12Count = 0\n    var factorizationFactor12Index =\
    \ 0\n    var factorizationFactor13 = 0\n    var factorizationFactor13Count = 0\n\
    \    var factorizationFactor13Index = 0\n    var factorizationFactor14 = 0\n \
    \   var factorizationFactor14Count = 0\n    var factorizationFactor14Index = 0\n\
    \    var factorizationFactor15 = 0\n    var factorizationFactor15Count = 0\n \
    \   var factorizationFactor15Index = 0\n    var factorizationFactor16 = 0\n  \
    \  var factorizationFactor16Count = 0\n    var factorizationFactor16Index = 0\n\
    \    var factorizationFactor17 = 0\n    var factorizationFactor17Count = 0\n \
    \   var factorizationFactor17Index = 0\n    var factorizationFactor18 = 0\n  \
    \  var factorizationFactor18Count = 0\n    var factorizationFactor18Index = 0\n\
    \    var factorizationFactor19 = 0\n    var factorizationFactor19Count = 0\n \
    \   var factorizationFactor19Index = 0\n    var factorizationFactor20 = 0\n  \
    \  var factorizationFactor20Count = 0\n    var factorizationFactor20Index = 0\n\
    \    var factorizationFactor21 = 0\n    var factorizationFactor21Count = 0\n \
    \   var factorizationFactor21Index = 0\n    var factorizationFactor22 = 0\n  \
    \  var factorizationFactor22Count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0bvwxrqe.swift:73:9: error: type annotation missing in pattern\n\
    \    var factorizationFactor22Count\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationSum = [Int]()\n    var factorizationSumCount = [Int]()\n\
    \    var factorizationSumCountMax = Int()\n    var factorizationSumCountMin =\
    \ Int()\n    var factorizationSumCountMaxIndex = Int()\n    var factorizationSumCountMinIndex\
    \ = Int()\n    var factorizationSumCountMaxValue = Int()\n    var factorizationSumCountMinValue\
    \ = Int()\n    var factorizationSumCountMaxValueIndex = Int()\n    var factorizationSumCountMinValueIndex\
    \ = Int()\n    var factorizationSumCountMaxValueValue = Int()\n    var factorizationSumCountMinValueValue\
    \ = Int()\n    var factorizationSumCountMaxValueValueIndex = Int()\n    var factorizationSumCountMinValueValueIndex\
    \ = Int()\n    var factorizationSumCountMaxValueValueValue = Int()\n    var factorizationSumCountMinValueValueValue\
    \ = Int()\n    var factorizationSumCountMaxValueValueValueIndex = Int()\n    var\
    \ factorizationSumCountMinValueValueValueIndex = Int()\n    var factorizationSumCountMaxValueValueValueValue\
    \ = Int()\n    var factorizationSumCountMinValueValueValueValue = Int()\n    var\
    \ factorizationSumCountMaxValueValueValueIndex = Int()\n    var factorizationSumCountMinValueValueValueIndex\
    \ = Int()\n    var factorizationSumCountMaxValueValueValueValue = Int()\n    var\
    \ factorizationSumCountMinValueValueValueValue = Int()\n    var factorizationSumCountMaxValueValueValueIndex\
    \ = Int()\n    var factorizationSumCountMinValueValueValueIndex = Int()\n    var\
    \ factorizationSumCountMaxValueValueValueValue = Int()\n    var factorizationSumCountMinValueValueValueValue\
    \ = Int()\n    var factorizationSumCountMaxValueValueValueIndex = Int()\n    var\
    \ factorizationSumCountMinValueValueValueIndex = Int()\n    var factorizationSumCountMaxValueValueValueValue\
    \ = Int()\n    var factorizationSumCountMinValueValueValueValue = Int()\n    var\
    \ factorizationSumCountMaxValueValueValueIndex = Int()\n    var factorizationSumCountMinValueValueValueIndex\
    \ = Int()\n    var factorizationSumCountMaxValueValueValueValue = Int()\n    var\
    \ factorizationSumCountMinValueValueValueValue = Int()\n    var factorizationSumCountMaxValueValueValueIndex\
    \ = Int()\n    var factorizationSumCountMinValueValueValueIndex = Int()\n    var\
    \ factorizationSumCountMaxValueValueValueValue = Int()\n    var factorizationSumCountMinValueValueValueValue\
    \ = Int()\n    var factorizationSumCountMaxValueValueValueIndex = Int()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqmlqq_m6.swift:28:9: error: invalid redeclaration of 'factorizationSumCountMaxValueValueValueIndex'\n\
    \    var factorizationSumCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:24:9:\
    \ note: 'factorizationSumCountMaxValueValueValueIndex' previously declared here\n\
    \    var factorizationSumCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:29:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMinValueValueValueIndex'\n\
    \    var factorizationSumCountMinValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:25:9:\
    \ note: 'factorizationSumCountMinValueValueValueIndex' previously declared here\n\
    \    var factorizationSumCountMinValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:30:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxValueValueValueValue'\n\
    \    var factorizationSumCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:26:9:\
    \ note: 'factorizationSumCountMaxValueValueValueValue' previously declared here\n\
    \    var factorizationSumCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:31:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMinValueValueValueValue'\n\
    \    var factorizationSumCountMinValueValueValueValue = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:27:9:\
    \ note: 'factorizationSumCountMinValueValueValueValue' previously declared here\n\
    \    var factorizationSumCountMinValueValueValueValue = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:32:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMaxValueValueValueIndex'\n\
    \    var factorizationSumCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:24:9:\
    \ note: 'factorizationSumCountMaxValueValueValueIndex' previously declared here\n\
    \    var factorizationSumCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:33:9:\
    \ error: invalid redeclaration of 'factorizationSumCountMinValueValueValueIndex'\n\
    \    var factorizationSumCountMinValueValueValueIndex = Int()\n        ^\n/tmp/tmpqmlqq_m6.swift:25:9:\
    \ note: 'factorizationSumCountMinValueValueValueIndex' pr"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = factorization(n)\n    for prime\
    \ in primes {\n        if n % prime == 0 {\n            factors.append(prime)\n\
    \            n /= prime\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq83tfkzj.swift:7:18: error: cannot find 'factorization' in scope\n\
    \    var primes = factorization(n)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var currentFactorization\
    \ = [Int]()\n    var currentFactorizationIndex = 0\n    var currentFactorizationValue\
    \ = 0\n    var currentFactorizationCount = 0\n    var currentFactorizationValueIndex\
    \ = 0\n    var currentFactorizationValueCount = 0\n    var currentFactorizationValueSum\
    \ = 0\n    var currentFactorizationValueSumIndex = 0\n    var currentFactorizationValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValue = 0\n    var currentFactorizationValueSumValueIndex\
    \ = 0\n    var currentFactorizationValueSumValueCount = 0\n    var currentFactorizationValueSumValueSum\
    \ = 0\n    var currentFactorizationValueSumValueSumIndex = 0\n    var currentFactorizationValueSumValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValueSumValue = 0\n    var currentFactorizationValueSumValueSumIndex\
    \ = 0\n    var currentFactorizationValueSumValueSumCount = 0\n    var currentFactorizationValueSumValueSumValueSum\
    \ = 0\n    var currentFactorizationValueSumValueSumIndex = 0\n    var currentFactorizationValueSumValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValueSumValueSum = 0\n    var currentFactorizationValueSumValueSumIndex\
    \ = 0\n    var currentFactorizationValueSumValueSumCount = 0\n    var currentFactorizationValueSumValueSumValueSum\
    \ = 0\n    var currentFactorizationValueSumValueSumIndex = 0\n    var currentFactorizationValueSumValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValueSumValueSum = 0\n    var currentFactorizationValueSumValueSumIndex\
    \ = 0\n    var currentFactorizationValueSumValueSumCount = 0\n    var currentFactorizationValueSumValueSumValueSum\
    \ = 0\n    var currentFactorizationValueSumValueSumIndex = 0\n    var currentFactorizationValueSumValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValueSumValueSum = 0\n    var currentFactorizationValueSumValueSumIndex\
    \ = 0\n    var currentFactorizationValueSumValueSumCount = 0\n    var currentFactorizationValueSumValueSumValueSum\
    \ = 0\n    var currentFactorizationValueSumValueSumIndex = 0\n    var currentFactorizationValueSumValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValueSumValueSum = 0\n    var currentFactorizationValueSumValueSumIndex\
    \ = 0\n    var currentFactorizationValueSumValueSumCount = 0\n    var currentFactorizationValueSumValueSumValueSum\
    \ = 0\n    var currentFactorizationValueSumValueSumIndex = 0\n    var currentFactorizationValueSumValueSumCount\
    \ = 0\n    var currentFactorizationValueSumValueSumValueSum = 0\n    var currentFactorizationValueSumValueSumIndex\
    \ = 0\n    var current\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3pjhht9j.swift:24:9: error: invalid redeclaration of 'currentFactorizationValueSumValueSumIndex'\n\
    \    var currentFactorizationValueSumValueSumIndex = 0\n        ^\n/tmp/tmp3pjhht9j.swift:21:9:\
    \ note: 'currentFactorizationValueSumValueSumIndex' previously declared here\n\
    \    var currentFactorizationValueSumValueSumIndex = 0\n        ^\n/tmp/tmp3pjhht9j.swift:25:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumValueSumCount'\n\
    \    var currentFactorizationValueSumValueSumCount = 0\n        ^\n/tmp/tmp3pjhht9j.swift:22:9:\
    \ note: 'currentFactorizationValueSumValueSumCount' previously declared here\n\
    \    var currentFactorizationValueSumValueSumCount = 0\n        ^\n/tmp/tmp3pjhht9j.swift:27:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumValueSumIndex'\n\
    \    var currentFactorizationValueSumValueSumIndex = 0\n        ^\n/tmp/tmp3pjhht9j.swift:21:9:\
    \ note: 'currentFactorizationValueSumValueSumIndex' previously declared here\n\
    \    var currentFactorizationValueSumValueSumIndex = 0\n        ^\n/tmp/tmp3pjhht9j.swift:28:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumValueSumCount'\n\
    \    var currentFactorizationValueSumValueSumCount = 0\n        ^\n/tmp/tmp3pjhht9j.swift:22:9:\
    \ note: 'currentFactorizationValueSumValueSumCount' previously declared here\n\
    \    var currentFactorizationValueSumValueSumCount = 0\n        ^\n/tmp/tmp3pjhht9j.swift:29:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumValueSumValueSum'\n\
    \    var currentFactorizationValueSumValueSumValueSum = 0\n        ^\n/tmp/tmp3pjhht9j.swift:26:9:\
    \ note: 'currentFactorizationValueSumValueSumValueSum' previously declared here\n\
    \    var currentFactorizationValueSumValueSumValueSum = 0\n        ^\n/tmp/tmp3pjhht9j.swift:30:9:\
    \ error: invalid redeclaration of 'currentFactorizationValueSumValueSumIndex'\n\
    \    var currentFactorizationValueSumValueSumIndex = 0\n        ^\n/tmp/tmp3pjhht9j.swift:21:9:\
    \ note: 'currentFactorizationValueSumValueSumIndex' previously declared here\n\
    \    var currentFactorizationValueSumValueSumIndex = 0\n        ^\n/tmp/tmp3pjhht"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ factorizationIndex = 0\n    var factorizationNumber = 0\n    var isPrime = true\n\
    \    var isPrimeIndex = 0\n    var isPrimeNumber = 0\n    var isPrimeNumberIndex\
    \ = 0\n    var isPrimeNumber2 = 0\n    var isPrimeNumber2Index = 0\n    var isPrimeNumber3\
    \ = 0\n    var isPrimeNumber3Index = 0\n    var isPrimeNumber4 = 0\n    var isPrimeNumber4Index\
    \ = 0\n    var isPrimeNumber5 = 0\n    var isPrimeNumber5Index = 0\n    var isPrimeNumber6\
    \ = 0\n    var isPrimeNumber6Index = 0\n    var isPrimeNumber7 = 0\n    var isPrimeNumber7Index\
    \ = 0\n    var isPrimeNumber8 = 0\n    var isPrimeNumber8Index = 0\n    var isPrimeNumber9\
    \ = 0\n    var isPrimeNumber9Index = 0\n    var isPrimeNumber10 = 0\n    var isPrimeNumber10Index\
    \ = 0\n    var isPrimeNumber11 = 0\n    var isPrimeNumber11Index = 0\n    var\
    \ isPrimeNumber12 = 0\n    var isPrimeNumber12Index = 0\n    var isPrimeNumber13\
    \ = 0\n    var isPrimeNumber13Index = 0\n    var isPrimeNumber14 = 0\n    var\
    \ isPrimeNumber14Index = 0\n    var isPrimeNumber15 = 0\n    var isPrimeNumber15Index\
    \ = 0\n    var isPrimeNumber16 = 0\n    var isPrimeNumber16Index = 0\n    var\
    \ isPrimeNumber17 = 0\n    var isPrimeNumber17Index = 0\n    var isPrimeNumber18\
    \ = 0\n    var isPrimeNumber18Index = 0\n    var isPrimeNumber19 = 0\n    var\
    \ isPrimeNumber19Index = 0\n    var isPrimeNumber20 = 0\n    var isPrimeNumber20Index\
    \ = 0\n    var isPrimeNumber21 = 0\n    var isPrimeNumber21Index = 0\n    var\
    \ isPrimeNumber22 = 0\n    var isPrimeNumber22Index = 0\n    var isPrimeNumber23\
    \ = 0\n    var isPrimeNumber23Index = 0\n    var isPrimeNumber24 = 0\n    var\
    \ isPrimeNumber24Index = 0\n    var isPrimeNumber25 = 0\n    var isPrimeNumber25Index\
    \ = 0\n    var isPrimeNumber26 = 0\n    var isPrimeNumber26Index = 0\n    var\
    \ isPrimeNumber27 = 0\n    var isPrimeNumber27Index = 0\n    var isPrimeNumber28\
    \ = 0\n    var isPrimeNumber28Index = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsm4pw8lo.swift:6:9: warning: variable 'factors' was never used;\
    \ consider replacing with '_' or removing it\n    var factors: [Int] = []\n  \
    \      ^~~~~~~\n        _\n/tmp/tmpsm4pw8lo.swift:7:9: warning: variable 'factorization'\
    \ was never used; consider replacing with '_' or removing it\n    var factorization:\
    \ [Int] = [1]\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpsm4pw8lo.swift:8:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpsm4pw8lo.swift:9:9: warning: initialization of variable 'factorizationNumber'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationNumber = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpsm4pw8lo.swift:10:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpsm4pw8lo.swift:11:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpsm4pw8lo.swift:12:9:\
    \ warning: initialization of variable 'isPrimeNumber' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeNumber = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpsm4pw8lo.swift:13:9: warning: initialization\
    \ of variable 'isPrimeNumberIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeNumberIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpsm4pw8lo.swift:14:9: warning: initialization of variable 'isPrimeNumber2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeNumber2 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpsm4pw8lo.swift:15:9:\
    \ warning: initialization of variable 'isPrimeNumber2Index' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeNumber2Index\
    \ = 0\n    ~~~~^~~~"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var factorizationCount = 0\n    var primeFactorizationCount = 0\n    var\
    \ factorizationPrimeCount = 0\n    var factorizationPrimeCountPrime = 0\n    var\
    \ factorizationPrimeCountPrimePrime = 0\n    var factorizationPrimeCountPrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrime = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrime = 0\n   \
    \ var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrime = 0\n    var\
    \ factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrime = 0\n    var\
    \ factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrime = 0\n    var\
    \ factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrime = 0\n \
    \   var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxrcs49wf.swift:19:9: error: invalid redeclaration of 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrime = 0\n\
    \        ^\n/tmp/tmpxrcs49wf.swift:18:9: note: 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:22:9: note: 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:24:9: note: 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:26:9: note: 'factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var factorizationPrimeCountPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmpxrcs49wf.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationPrimeCountPrimePrimePrimePrimePri"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorIndex\
    \ = 0\n    var factorizationFactorCount = 0\n    var factorizationFactorCountIndex\
    \ = 0\n    var factorizationFactorCountMax = 0\n    var factorizationFactorCountMaxIndex\
    \ = 0\n    var factorizationFactorCountMin = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiaynb9vw.swift:17:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:18:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpiaynb9vw.swift:19:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:20:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpiaynb9vw.swift:21:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpiaynb9vw.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpiaynb9vw.swift:23:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmpiaynb9vw.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared h"
  stdout: ''
  timestamp: 1660009304
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            i += 1\n            factors.append(i)\n      \
    \  }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp4s6tqd4t/tmp4s6tqd4t.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b59cf1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b599e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b599e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b599e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4s6tqd4t                        0x000055ccee39e4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b7b59edd460 __libc_start_main +
    245

    6    tmp4s6tqd4t                        0x000055ccee39e119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ currentFactorizationCount = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = -1\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorizationValue = 1\n    var currentFactorizationIndexMax\
    \ = factorization.count\n    var currentFactorizationValueMax = factorization[currentFactorizationIndexMax]\n\
    \    var currentFactorizationIndexMin = currentFactorizationIndexMax\n    var\
    \ currentFactorizationValueMin = currentFactorizationValueMax\n    var currentFactorizationIndex\
    \ = 0\n    var current\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3krasdyr.swift:16:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp3krasdyr.swift:10:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmp3krasdyr.swift:17:9: error: invalid redeclaration of\
    \ 'currentFactorizationValue'\n    var currentFactorizationValue = 1\n       \
    \ ^\n/tmp/tmp3krasdyr.swift:11:9: note: 'currentFactorizationValue' previously\
    \ declared here\n    var currentFactorizationValue = 1\n        ^\n/tmp/tmp3krasdyr.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMax'\n    var currentFactorizationIndexMax\
    \ = factorization.count\n        ^\n/tmp/tmp3krasdyr.swift:12:9: note: 'currentFactorizationIndexMax'\
    \ previously declared here\n    var currentFactorizationIndexMax = factorization.count\n\
    \        ^\n/tmp/tmp3krasdyr.swift:22:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp3krasdyr.swift:10:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmp3krasdyr.swift:23:9: error: invalid redeclaration of\
    \ 'currentFactorizationValue'\n    var currentFactorizationValue = 1\n       \
    \ ^\n/tmp/tmp3krasdyr.swift:11:9: note: 'currentFactorizationValue' previously\
    \ declared here\n    var currentFactorizationValue = 1\n        ^\n/tmp/tmp3krasdyr.swift:24:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexMax'\n    var currentFactorizationIndexMax\
    \ = factorization.count\n        ^\n/tmp/tmp3krasdyr.swift:12:9: note: 'currentFactorizationIndexMax'\
    \ previously declared here\n    var currentFactorizationIndexMax = factorization.count\n\
    \        ^\n/tmp/tmp3krasdyr.swift:28:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmp3krasdyr.swift:10:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmp3krasdyr.swift:29:9: error: in"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var isPrime: [Bool] = []\n    var isPrimeIndex = 0\n    var isPrimeIndex2\
    \ = 0\n    var isPrimeIndex3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeIndex5\
    \ = 0\n    var isPrimeIndex6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeIndex9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeIndex11\
    \ = 0\n    var isPrimeIndex12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeIndex14\
    \ = 0\n    var isPrimeIndex15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeIndex17\
    \ = 0\n    var isPrimeIndex18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeIndex20\
    \ = 0\n    var isPrimeIndex21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeIndex24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeIndex26\
    \ = 0\n    var isPrimeIndex27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeIndex29\
    \ = 0\n    var isPrimeIndex30 = 0\n    var isPrimeIndex31 = 0\n    var isPrimeIndex32\
    \ = 0\n    var isPrimeIndex33 = 0\n    var isPrimeIndex34 = 0\n    var isPrimeIndex35\
    \ = 0\n    var isPrimeIndex36 = 0\n    var isPrimeIndex37 = 0\n    var isPrimeIndex38\
    \ = 0\n    var isPrimeIndex39 = 0\n    var isPrimeIndex40 = 0\n    var isPrimeIndex41\
    \ = 0\n    var isPrimeIndex42 = 0\n    var isPrimeIndex43 = 0\n    var isPrimeIndex44\
    \ = 0\n    var isPrimeIndex45 = 0\n    var isPrimeIndex46 = 0\n    var isPrimeIndex47\
    \ = 0\n    var isPrimeIndex48 = 0\n    var isPrimeIndex49 = 0\n    var isPrimeIndex50\
    \ = 0\n    var isPrimeIndex51 = 0\n    var isPrimeIndex52 = 0\n    var isPrimeIndex53\
    \ = 0\n    var isPrimeIndex54 = 0\n    var isPrimeIndex55 = 0\n    var isPrimeIndex56\
    \ = 0\n    var isPrimeIndex57 = 0\n    var isPrimeIndex58 = 0\n    var isPrimeIndex59\
    \ = 0\n    var isPrimeIndex60 = 0\n    var isPrimeIndex61 = 0\n    var is\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpn2htq_gx.swift:70:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpn2htq_gx.swift:6:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpn2htq_gx.swift:7:9: warning:\
    \ variable 'primeFactorization' was never used; consider replacing with '_' or\
    \ removing it\n    var primeFactorization: [Int] = []\n        ^~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpn2htq_gx.swift:8:9: warning: variable 'isPrime' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrime: [Bool] =\
    \ []\n        ^~~~~~~\n        _\n/tmp/tmpn2htq_gx.swift:9:9: warning: initialization\
    \ of variable 'isPrimeIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n\
    /tmp/tmpn2htq_gx.swift:10:9: warning: initialization of variable 'isPrimeIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpn2htq_gx.swift:11:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpn2htq_gx.swift:12:9: warning: initialization\
    \ of variable 'isPrimeIndex4' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex4 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmpn2htq_gx.swift:13:9: warning: initialization of variable 'isPrimeIndex5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex5 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpn2htq_gx.swift:14:9:\
    \ warning: initialization of variable 'isPrimeIndex6' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex6 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpn2htq_gx.swift:15:9: warning: initialization\
    \ of variable 'isPrimeIndex7' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIn"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeCount = 0\n    var isPrimeCountMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMax2 = Int(sqrt(Double(n)))\n  \
    \  var isPrimeCountMax3 = Int(sqrt(Double(n)))\n    var isPrimeCountMax4 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n    var isPrimeCountMax10 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax11 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax12 = Int(sqrt(Double(n)))\n    var isPrimeCountMax13 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax14 = Int(sqrt(Double(n)))\n    var isPrimeCountMax15 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax16 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax17 = Int(sqrt(Double(n)))\n    var isPrimeCountMax18 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax19 = Int(sqrt(Double(n)))\n    var isPrimeCountMax20 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax21 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax22 = Int(sqrt(Double(n)))\n    var isPrimeCountMax23 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax24 = Int(sqrt(Double(n)))\n    var isPrimeCountMax25 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax26 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax27 = Int(sqrt(Double(n)))\n    var isPrimeCountMax28 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax29 = Int(sqrt(Double(n)))\n    var isPrimeCountMax30 =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMax31 = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMax32 = Int(sqrt(Double(n)))\n    var isPrimeCountMax33 = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMax34 = Int(sqrt(Double(n)))\n    var isPrimeCountMax35 =\
    \ Int(sqrt(Double(n)))\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphgv9ymis.swift:45:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmphgv9ymis.swift:10:31: error: cannot find 'sqrt' in scope\n    var\
    \ isPrimeCountMax = Int(sqrt(Double(n)))\n                              ^~~~\n\
    /tmp/tmphgv9ymis.swift:11:32: error: cannot find 'sqrt' in scope\n    var isPrimeCountMax2\
    \ = Int(sqrt(Double(n)))\n                               ^~~~\n/tmp/tmphgv9ymis.swift:12:32:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMax3 = Int(sqrt(Double(n)))\n\
    \                               ^~~~\n/tmp/tmphgv9ymis.swift:13:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax4 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmphgv9ymis.swift:14:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax5 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmphgv9ymis.swift:15:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax6 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmphgv9ymis.swift:16:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax7 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmphgv9ymis.swift:17:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax8 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmphgv9ymis.swift:18:32: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax9 = Int(sqrt(Double(n)))\n    \
    \                           ^~~~\n/tmp/tmphgv9ymis.swift:19:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax10 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmphgv9ymis.swift:20:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax11 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmphgv9ymis.swift:21:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax12 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmphgv9ymis.swift:22:33: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax13 = Int(sqrt(Double(n)))\n   \
    \                             ^~~~\n/tmp/tmphgv9ymis.swift:23:33: erro"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    var factor = 1\n    while i\
    \ < n {\n        while n % i == 0 {\n            factors.append(factor)\n    \
    \        n /= i\n        }\n        factor = 1\n        i += 1\n    }\n    if\
    \ n > 1 {\n        factors.append(factor)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpj8pg6bno.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMax2 = factorizationIndexMax * factorizationIndexMax\n\
    \    var factorizationIndexMax3 = factorizationIndexMax2 * factorizationIndexMax\n\
    \    var factorizationIndexMax4 = factorizationIndexMax3 * factorizationIndexMax\n\
    \    var factorizationIndexMax5 = factorizationIndexMax4 * factorizationIndexMax\n\
    \    var factorizationIndexMax6 = factorizationIndexMax5 * factorizationIndexMax\n\
    \    var factorizationIndexMax7 = factorizationIndexMax6 * factorizationIndexMax\n\
    \    var factorizationIndexMax8 = factorizationIndexMax7 * factorizationIndexMax\n\
    \    var factorizationIndexMax9 = factorizationIndexMax8 * factorizationIndexMax\n\
    \    var factorizationIndexMax10 = factorizationIndexMax9 * factorizationIndexMax\n\
    \    var factorizationIndexMax11 = factorizationIndexMax10 * factorizationIndexMax\n\
    \    var factorizationIndexMax12 = factorizationIndexMax11 * factorizationIndexMax\n\
    \    var factorizationIndexMax13 = factorizationIndexMax12 * factorizationIndexMax\n\
    \    var factorizationIndexMax14 = factorizationIndexMax13 * factorizationIndexMax\n\
    \    var factorizationIndexMax15 = factorizationIndexMax14 * factorizationIndexMax\n\
    \    var factorizationIndexMax16 = factorizationIndexMax15 * factorizationIndexMax\n\
    \    var factorizationIndexMax17 = factorizationIndexMax16 * factorizationIndexMax\n\
    \    var factorizationIndexMax18 = factorizationIndexMax17 * factorizationIndexMax\n\
    \    var factorizationIndexMax19 = factorizationIndexMax18 * factorizationIndexMax\n\
    \    var factorizationIndexMax20 = factorizationIndexMax19 * factorizationIndexMax\n\
    \    var factorizationIndexMax21 = factorizationIndexMax20 * factorizationIndexMax\n\
    \    var factorizationIndexMax22 = factorizationIndexMax21 * factorizationIndexMax\n\
    \    var factorizationIndexMax23 = factorizationIndexMax22 * factorizationIndexMax\n\
    \    var factorizationIndexMax24 = factorizationIndexMax23 * factorizationIndexMax\n\
    \    var factorizationIndexMax25 = factorizationIndexMax24 * factorizationIndexMax\n\
    \    var factorizationIndexMax26 = factorizationIndexMax25 * factorizationIndexMax\n\
    \    var factorizationIndexMax27 = factorizationIndexMax26 * factorizationIndexMax\n\
    \    var factorizationIndexMax28 = factorizationIndexMax27 * factorizationIndexMax\n\
    \    var factorizationIndexMax29 = factorizationIndexMax28\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0pnman4p.swift:9:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var factorizationCount = 0\n    var\
    \ primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var primeFactorizationNumber\
    \ = 0\n    var factorizationNumber = 0\n    var primeFactorizationNumberCount\
    \ = 0\n    var factorizationNumberCount = 0\n    var primeFactorizationNumberIndex\
    \ = 0\n    var factorizationNumberIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactorizationNumberIndexIndex\
    \ = 0\n    var factorizationNumberIndexIndex = 0\n    var primeFactorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var primeFactor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1hah41h1.swift:22:9: error: invalid redeclaration of 'primeFactorizationNumberCountIndex'\n\
    \    var primeFactorizationNumberCountIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:18:9:\
    \ note: 'primeFactorizationNumberCountIndex' previously declared here\n    var\
    \ primeFactorizationNumberCountIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmp1hah41h1.swift:19:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmp1hah41h1.swift:24:9: error: invalid redeclaration of 'primeFactorizationNumberIndexIndex'\n\
    \    var primeFactorizationNumberIndexIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:20:9:\
    \ note: 'primeFactorizationNumberIndexIndex' previously declared here\n    var\
    \ primeFactorizationNumberIndexIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationNumberIndexIndex'\n    var factorizationNumberIndexIndex\
    \ = 0\n        ^\n/tmp/tmp1hah41h1.swift:21:9: note: 'factorizationNumberIndexIndex'\
    \ previously declared here\n    var factorizationNumberIndexIndex = 0\n      \
    \  ^\n/tmp/tmp1hah41h1.swift:26:9: error: invalid redeclaration of 'primeFactorizationNumberCountIndex'\n\
    \    var primeFactorizationNumberCountIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:18:9:\
    \ note: 'primeFactorizationNumberCountIndex' previously declared here\n    var\
    \ primeFactorizationNumberCountIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationNumberCountIndex'\n    var factorizationNumberCountIndex\
    \ = 0\n        ^\n/tmp/tmp1hah41h1.swift:19:9: note: 'factorizationNumberCountIndex'\
    \ previously declared here\n    var factorizationNumberCountIndex = 0\n      \
    \  ^\n/tmp/tmp1hah41h1.swift:28:9: error: invalid redeclaration of 'primeFactorizationNumberIndexIndex'\n\
    \    var primeFactorizationNumberIndexIndex = 0\n        ^\n/tmp/tmp1hah41h1.swift:20:9:\
    \ note: 'primeFactorizationNumberIndexIndex' previously declared here\n  "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var factorizationIndex2\
    \ = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4 = 0\n    var\
    \ factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var factorizationIndex7\
    \ = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9 = 0\n    var\
    \ factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n    var factorizationIndex12\
    \ = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14 = 0\n  \
    \  var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n    var factorizationIndex17\
    \ = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19 = 0\n  \
    \  var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n    var factorizationIndex22\
    \ = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24 = 0\n  \
    \  var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n    var factorizationIndex27\
    \ = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29 = 0\n  \
    \  var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n    var factorizationIndex32\
    \ = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34 = 0\n  \
    \  var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n    var factorizationIndex37\
    \ = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39 = 0\n  \
    \  var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n    var factorizationIndex42\
    \ = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44 = 0\n  \
    \  var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n    var factorizationIndex47\
    \ = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49 = 0\n  \
    \  var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n    var factorizationIndex52\
    \ = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54 = 0\n  \
    \  var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n    var factorizationIndex57\
    \ = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59 = 0\n  \
    \  var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n    var factorizationIndex62\
    \ = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64 = 0\n  \
    \  var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n    var factorizationIndex67\
    \ = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69 = 0\n  \
    \  var factorizationIndex70 = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpovd7od6s.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:8:9: warning:\
    \ initialization of variable 'primeFactorizationIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:9:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovd7od6s.swift:10:9: warning: initialization of variable 'factorizationIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:11:9:\
    \ warning: initialization of variable 'factorizationIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:12:9: warning:\
    \ initialization of variable 'factorizationIndex4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex4 = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:13:9: warning: initialization\
    \ of variable 'factorizationIndex5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var factorizationIndex5 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovd7od6s.swift:14:9: warning: initialization of variable 'factorizationIndex6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex6 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.s"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primeFactorization: [Int] = []\n   \
    \ var primeFactorizationIndex = 0\n    var primeFactorizationCount = 0\n    var\
    \ isPrime: Bool = false\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n\
    \    var isPrimeFactorization: Bool = false\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationCount = 0\n\n    for factor in factorization(n)\
    \ {\n        if factor == 1 {\n            factors.append(factor)\n          \
    \  primeFactorizationCount += 1\n        } else {\n            if factor % 2 ==\
    \ 0 {\n                isPrime = true\n                primeFactorization[primeFactorizationIndex]\
    \ = factor\n                primeFactorizationIndex += 1\n                isPrimeCount\
    \ += 1\n            } else {\n                isPrime = false\n              \
    \  primeFactorization[primeFactorizationIndex] = factor\n                primeFactorizationIndex\
    \ += 1\n                isPrimeCount += 1\n            }\n        }\n    }\n\n\
    \    if isPrimeCount != primeFactorizationCount {\n        return nil\n    }\n\
    \n    if isPrimeCount > 0 {\n        primeFactorizationIndex = 0\n        primeFactorizationCount\
    \ = 0\n        isPrimeIndex = 0\n        isPrimeCount = 0\n        isPrimeFactorizationIndex\
    \ = 0\n        isPrimeFactorizationCount = 0\n        for factor in primeFactorization\
    \ {\n            if factor == 1 {\n                factors.append(factor)\n  \
    \              primeFactorizationCount += 1\n            } else {\n          \
    \      if factor % 2 == 0 {\n                    isPrime = true\n            \
    \        primeFactorization[primeFactorizationIndex] = factor\n              \
    \      primeFactorizationIndex += 1\n                    isPrimeCount += 1\n \
    \               } else {\n                    isPrime = false\n              \
    \      primeFactorization[primeFactorizationIndex] = factor\n                \
    \    primeFactorizationIndex += 1\n                    isPrimeCount += 1\n   \
    \             }\n            }\n        }\n    }\n\n    if isPrimeCount != primeFactorizationCount\
    \ {\n        return nil\n    }\n\n    if isPrimeCount > 0 {\n        primeFactorizationIndex\
    \ = 0\n        primeFactorizationCount = 0\n        isPrimeIndex = 0\n       \
    \ isPrimeCount = 0\n        isPrimeFactorizationIndex = 0\n        isPrimeFactorizationCount\
    \ = 0\n        for factor in primeFactorization {\n            if factor == 1\
    \ {\n                factors.append(factor)\n                primeFactorizationCount\
    \ += 1\n            } else {\n                if factor % 2 == 0 {\n         \
    \           isPrime = true\n                    primeFactorization[primeFactorizationIndex]\
    \ = factor\n                    primeFactorizationIndex += 1\n               \
    \     isPrimeCount += 1\n                } else {\n                    isPrime\
    \ = false\n                    primeFactorization[primeFactorizationIndex] = factor\n\
    \                    primeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsslge9y1.swift:114:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmpsslge9y1.swift:82:20: note: to match this opening '{'\n            } else\
    \ {\n                   ^\n/tmp/tmpsslge9y1.swift:114:38: error: expected '}'\
    \ at end of brace statement\nassert(factorize(n: 18) == [2, 3, 3])\n         \
    \                            ^\n/tmp/tmpsslge9y1.swift:78:42: note: to match this\
    \ opening '{'\n        for factor in primeFactorization {\n                  \
    \                       ^\n/tmp/tmpsslge9y1.swift:114:38: error: expected '}'\
    \ at end of brace statement\nassert(factorize(n: 18) == [2, 3, 3])\n         \
    \                            ^\n/tmp/tmpsslge9y1.swift:71:25: note: to match this\
    \ opening '{'\n    if isPrimeCount > 0 {\n                        ^\n/tmp/tmpsslge9y1.swift:114:38:\
    \ error: expected '}' at end of brace statement\nassert(factorize(n: 18) == [2,\
    \ 3, 3])\n                                     ^\n/tmp/tmpsslge9y1.swift:5:33:\
    \ note: to match this opening '{'\nfunc factorize(n: Int) -> [Int] {\n       \
    \                         ^\n/tmp/tmpsslge9y1.swift:17:19: error: cannot find\
    \ 'factorization' in scope\n    for factor in factorization(n) {\n           \
    \       ^~~~~~~~~~~~~\n/tmp/tmpsslge9y1.swift:37:16: error: 'nil' is incompatible\
    \ with return type '[Int]'\n        return nil\n               ^\n/tmp/tmpsslge9y1.swift:68:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n/tmp/tmpsslge9y1.swift:91:21: error: cannot find 'primeFactor'\
    \ in scope\n                    primeFactor\n                    ^~~~~~~~~~~\n\
    /tmp/tmpsslge9y1.swift:95:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationProduct\
    \ = 1\n    var factorizationProductSum = 0\n    var factorizationProductSum2 =\
    \ 0\n    var factorizationProductSum3 = 0\n    var factorizationProductSum4 =\
    \ 0\n    var factorizationProductSum5 = 0\n    var factorizationProductSum6 =\
    \ 0\n    var factorizationProductSum7 = 0\n    var factorizationProductSum8 =\
    \ 0\n    var factorizationProductSum9 = 0\n    var factorizationProductSum10 =\
    \ 0\n    var factorizationProductSum11 = 0\n    var factorizationProductSum12\
    \ = 0\n    var factorizationProductSum13 = 0\n    var factorizationProductSum14\
    \ = 0\n    var factorizationProductSum15 = 0\n    var factorizationProductSum16\
    \ = 0\n    var factorizationProductSum17 = 0\n    var factorizationProductSum18\
    \ = 0\n    var factorizationProductSum19 = 0\n    var factorizationProductSum20\
    \ = 0\n    var factorizationProductSum21 = 0\n    var factorizationProductSum22\
    \ = 0\n    var factorizationProductSum23 = 0\n    var factorizationProductSum24\
    \ = 0\n    var factorizationProductSum25 = 0\n    var factorizationProductSum26\
    \ = 0\n    var factorizationProductSum27 = 0\n    var factorizationProductSum28\
    \ = 0\n    var factorizationProductSum29 = 0\n    var factorizationProductSum30\
    \ = 0\n    var factorizationProductSum31 = 0\n    var factorizationProductSum32\
    \ = 0\n    var factorizationProductSum33 = 0\n    var factorizationProductSum34\
    \ = 0\n    var factorizationProductSum35 = 0\n    var factorizationProductSum36\
    \ = 0\n    var factorizationProductSum37 = 0\n    var factorizationProductSum38\
    \ = 0\n    var factorizationProductSum39 = 0\n    var factorizationProductSum40\
    \ = 0\n    var factorizationProductSum41 = 0\n    var factorizationProductSum42\
    \ = 0\n    var factorizationProductSum43 = 0\n    var factorizationProductSum44\
    \ = 0\n    var factorizationProductSum45 = 0\n    var factorizationProductSum46\
    \ = 0\n    var factorizationProductSum47 = 0\n    var factorizationProductSum48\
    \ = 0\n    var factorizationProductSum49 = 0\n    var factorizationProductSum50\
    \ = 0\n    var factorizationProductSum51 = 0\n    var factorizationProductSum52\
    \ = 0\n    var factorizationProductSum53 = 0\n    var factorizationProductSum54\
    \ = 0\n    var factorizationProductSum55 = 0\n    var factorizationProductSum56\
    \ = 0\n    var factorizationProductSum57 = 0\n    var factorizationProductSum58\
    \ = 0\n    var factorizationProductSum59 = 0\n    var factorizationProductSum60\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1qafwjcl.swift:71:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp1qafwjcl.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:7:9:\
    \ warning: initialization of variable 'factorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationCount\
    \ = 1\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:8:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp1qafwjcl.swift:9:9: warning: initialization of variable 'factorizationSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationSum = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:10:9:\
    \ warning: initialization of variable 'factorizationProduct' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProduct\
    \ = 1\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:11:9: warning:\
    \ initialization of variable 'factorizationProductSum' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:12:9: warning:\
    \ initialization of variable 'factorizationProductSum2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:13:9: warning:\
    \ initialization of variable 'factorizationProductSum3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationProductSum3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp1qafwjcl.swift:14:9: warning:\
    \ initialization of variable 'factorizationProductSum4' was never used; consider\
    \ replacing with assignment to '_' or re"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = factorization.count\n\
    \    var factorizationIndexMin = 1\n    var factorizationIndexMaxMin = factorizationIndexMax\n\
    \    var factorizationIndexMinMax = factorizationIndexMin\n    var factorizationIndexMaxMinMin\
    \ = factorizationIndexMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMax\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMaxMin\n    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n    var factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgml8o7n1.swift:15:9: error: invalid redeclaration of 'factorizationIndexMinMaxMin'\n\
    \    var factorizationIndexMinMaxMin = factorizationIndexMinMaxMin\n        ^\n\
    /tmp/tmpgml8o7n1.swift:14:9: note: 'factorizationIndexMinMaxMin' previously declared\
    \ here\n    var factorizationIndexMinMaxMin = factorizationIndexMinMax\n     \
    \   ^\n/tmp/tmpgml8o7n1.swift:43:9: error: type annotation missing in pattern\n\
    \    var factor\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorCount\
    \ = 0\n    var factorizationFactorIndex = 0\n    var factorizationFactorIndexCount\
    \ = 0\n    var factorizationFactorIndexCountMax = IntMax\n    var factorizationFactorIndexCountMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMin = IntMax\n    var factorizationFactorIndexCountMinMax\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factorizationFactorIndexCountMaxMinMin = IntMax\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprfxfzdxx.swift:13:44: error: cannot find 'IntMax' in scope\n  \
    \  var factorizationFactorIndexCountMax = IntMax\n                           \
    \                ^~~~~~\n/tmp/tmprfxfzdxx.swift:14:44: error: cannot find 'IntMin'\
    \ in scope\n    var factorizationFactorIndexCountMin = IntMin\n              \
    \                             ^~~~~~\n/tmp/tmprfxfzdxx.swift:15:47: error: cannot\
    \ find 'IntMax' in scope\n    var factorizationFactorIndexCountMaxMin = IntMax\n\
    \                                              ^~~~~~\n/tmp/tmprfxfzdxx.swift:16:47:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationFactorIndexCountMinMax\
    \ = IntMin\n                                              ^~~~~~\n/tmp/tmprfxfzdxx.swift:17:50:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMax\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:18:50:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:19:50:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMax\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:20:50:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:21:50:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMax\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:22:50:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMin\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:23:50:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ = IntMax\n                                                 ^~~~~~\n/tmp/tmprfxfzdxx.swift:24:50:\
    \ error: cannot find 'IntMin' in scope\n    var factorizationFactorIndexCountMaxMinMin\
    \ ="
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationPrime = [Int]()\n    var primeFactorizationPrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrime = [Int]()\n    var primeFactorizationPrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrime = [Int]()\n    var\
    \ primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n \
    \   var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n    var primeFactorizationPrimePrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo6teucr1.swift:19:9: error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimeCount'\n\
    \    var primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:17:9:\
    \ note: 'primeFactorizationPrimePrimePrimePrimeCount' previously declared here\n\
    \    var primeFactorizationPrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:20:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:18:9:\
    \ note: 'primeFactorizationPrimePrimePrimePrimePrime' previously declared here\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:22:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:18:9:\
    \ note: 'primeFactorizationPrimePrimePrimePrimePrime' previously declared here\n\
    \    var primeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:23:9:\
    \ error: invalid redeclaration of 'primeFactorizationPrimePrimePrimePrimePrimeCount'\n\
    \    var primeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmpo6teucr1.swift:21:9: note: 'primeFactorizationPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:24:9: error: invalid redeclaration\
    \ of 'primeFactorizationPrimePrimePrimePrimePrime'\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:18:9: note: 'primeFactorizationPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var primeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:25:9: error: invalid redeclaration\
    \ of 'primeFactorizationPrimePrimePrimePrimePrimeCount'\n    var primeFactorizationPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpo6teucr1.swift:21:9: note: 'primeFactorization"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationCountMax = Int()\n    var factorizationCountMaxIndex = 0\n\
    \    var factorizationCountMaxValue = Int()\n    var factorizationCountMaxValueIndex\
    \ = 0\n    var factorizationCountMaxValueValue = 0\n    var factorizationCountMaxValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValue = 0\n    var factorizationCountMaxValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4qxo5u75.swift:51:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp4qxo5u75.swift:19:9: error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmp4qxo5u75.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmp4qxo5u75.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmp4qxo5u75.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmp4qxo5u75.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmp4qxo5u75.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmp4qxo5u75.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmp4qxo5u75.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmp4qxo5u75.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmp4qxo5u75.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmp4qxo5u75.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmp4qxo5"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ currentFactor = 1\n    var currentCount = 0\n    var currentSum = 0\n    var\
    \ currentSumOfSquares = 0\n    var currentSumOfCubes = 0\n    var currentSumOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowers = 0\n    var currentSumOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowers = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers = 0\n\
    \    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers =\
    \ 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowers\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplceas2wz.swift:24:9: error: invalid redeclaration of 'currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers'\n\
    \    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n        ^\n/tmp/tmplceas2wz.swift:23:9: note: 'currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers'\
    \ previously declared here\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n        ^\n/tmp/tmplceas2wz.swift:27:9: error: invalid redeclaration of\
    \ 'currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers'\n\
    \    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n        ^\n/tmp/tmplceas2wz.swift:26:9: note: 'currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers'\
    \ previously declared here\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowersOfPowers\
    \ = 0\n        ^\n/tmp/tmplceas2wz.swift:29:9: error: type annotation missing\
    \ in pattern\n    var currentSumOfPowersOfPowersOfPowersOfPowersOfPowers\n   \
    \     ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ currentFactor = 1\n    var currentFactorCount = 1\n    var currentFactorIndex\
    \ = 0\n    var isPrime = true\n    var isPrimeIndex = -1\n    var isPrimeCount\
    \ = 0\n    var isPrimeIndexCount = 0\n    var isPrimeIndex = 0\n    var isPrimeIndex2\
    \ = 0\n    var isPrimeIndex2Count = 0\n    var isPrimeIndex3 = 0\n    var isPrimeIndex3Count\
    \ = 0\n    var isPrimeIndex4 = 0\n    var isPrimeIndex4Count = 0\n    var isPrimeIndex5\
    \ = 0\n    var isPrimeIndex5Count = 0\n    var isPrimeIndex6 = 0\n    var isPrimeIndex6Count\
    \ = 0\n    var isPrimeIndex7 = 0\n    var isPrimeIndex7Count = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeIndex8Count = 0\n    var isPrimeIndex9 = 0\n    var isPrimeIndex9Count\
    \ = 0\n    var isPrimeIndex10 = 0\n    var isPrimeIndex10Count = 0\n    var isPrimeIndex11\
    \ = 0\n    var isPrimeIndex11Count = 0\n    var isPrimeIndex12 = 0\n    var isPrimeIndex12Count\
    \ = 0\n    var isPrimeIndex13 = 0\n    var isPrimeIndex13Count = 0\n    var isPrimeIndex14\
    \ = 0\n    var isPrimeIndex14Count = 0\n    var isPrimeIndex15 = 0\n    var isPrimeIndex15Count\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeIndex16Count = 0\n    var isPrimeIndex17\
    \ = 0\n    var isPrimeIndex17Count = 0\n    var isPrimeIndex18 = 0\n    var isPrimeIndex18Count\
    \ = 0\n    var isPrimeIndex19 = 0\n    var isPrimeIndex19Count = 0\n    var isPrimeIndex20\
    \ = 0\n    var isPrimeIndex20Count = 0\n    var isPrimeIndex21 = 0\n    var isPrimeIndex21Count\
    \ = 0\n    var isPrimeIndex22 = 0\n    var isPrimeIndex22Count = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeIndex23Count = 0\n    var isPrimeIndex24 = 0\n    var isPrimeIndex24Count\
    \ = 0\n    var isPrimeIndex25 = 0\n    var isPrimeIndex25Count = 0\n    var isPrimeIndex26\
    \ = 0\n    var isPrimeIndex26Count = 0\n    var isPrimeIndex27 = 0\n    var isPrimeIndex27Count\
    \ = 0\n    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpl452gmrv.swift:15:9: error: invalid redeclaration of 'isPrimeIndex'\n\
    \    var isPrimeIndex = 0\n        ^\n/tmp/tmpl452gmrv.swift:12:9: note: 'isPrimeIndex'\
    \ previously declared here\n    var isPrimeIndex = -1\n        ^\n/tmp/tmpl452gmrv.swift:68:9:\
    \ error: type annotation missing in pattern\n    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationNumber = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberCountIndex\
    \ = 0\n    var factorizationNumberCountMax = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMin = 0\n    var factorizationNumberCountMinIndex\
    \ = 0\n    var factorizationNumberCountMaxMin = 0\n    var factorizationNumberCountMaxMinIndex\
    \ = 0\n    var factorizationNumberCountMinMax = 0\n    var factorizationNumberCountMinMaxIndex\
    \ = 0\n    var factorizationNumberCountMaxMinMax = 0\n    var factorizationNumberCountMaxMinMaxIndex\
    \ = 0\n    var factorizationNumberCountMinMaxMin = 0\n    var factorizationNumberCountMinMaxMinIndex\
    \ = 0\n    var factorizationNumberCountMaxMinMaxMin = 0\n    var factorizationNumberCountMaxMinMaxMinIndex\
    \ = 0\n    var factorizationNumberCountMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumberCountMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMin\
    \ = 0\n    var factorizationNumberCountMaxMinMaxMinMaxIndex = 0\n    var factorizationNumberCountMaxMinMaxMinMaxMin\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumberCountMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxIndex\
    \ = 0\n    var factorizationNumberCountMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax\
    \ = 0\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n    var factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpghv6szm0.swift:36:9: error: invalid redeclaration of 'factorizationNumberCountMinMaxMinMaxMinMaxIndex'\n\
    \    var factorizationNumberCountMinMaxMinMaxMinMaxIndex = 0\n        ^\n/tmp/tmpghv6szm0.swift:34:9:\
    \ note: 'factorizationNumberCountMinMaxMinMaxMinMaxIndex' previously declared\
    \ here\n    var factorizationNumberCountMinMaxMinMaxMinMaxIndex = 0\n        ^\n\
    /tmp/tmpghv6szm0.swift:37:9: error: invalid redeclaration of 'factorizationNumberCountMaxMinMaxMinMaxMinMax'\n\
    \    var factorizationNumberCountMaxMinMaxMinMaxMinMax = 0\n        ^\n/tmp/tmpghv6szm0.swift:35:9:\
    \ note: 'factorizationNumberCountMaxMinMaxMinMaxMinMax' previously declared here\n\
    \    var factorizationNumberCountMaxMinMaxMinMaxMinMax = 0\n        ^\n/tmp/tmpghv6szm0.swift:39:9:\
    \ error: invalid redeclaration of 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax'\n\
    \    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n        ^\n/tmp/tmpghv6szm0.swift:38:9:\
    \ note: 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax' previously declared\
    \ here\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n       \
    \ ^\n/tmp/tmpghv6szm0.swift:40:9: error: invalid redeclaration of 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax'\n\
    \    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n        ^\n/tmp/tmpghv6szm0.swift:38:9:\
    \ note: 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax' previously declared\
    \ here\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n       \
    \ ^\n/tmp/tmpghv6szm0.swift:41:9: error: invalid redeclaration of 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax'\n\
    \    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n        ^\n/tmp/tmpghv6szm0.swift:38:9:\
    \ note: 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax' previously declared\
    \ here\n    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n       \
    \ ^\n/tmp/tmpghv6szm0.swift:42:9: error: invalid redeclaration of 'factorizationNumberCountMinMaxMinMaxMinMaxMinMax'\n\
    \    var factorizationNumberCountMinMaxMinMaxMinMaxMinMax = 0\n        ^\n/tmp/tmpghv6szm0.swift:38:9:\
    \ note: 'factorizationNumberC"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n)\n \
    \   for factor in factorization {\n        if factors.contains(factor) {\n   \
    \         factors[factor] += 1\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9jxt1skh.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primes: [Int] = []\n    var primeFactors:\
    \ [Int] = []\n    var factorization: [Int] = []\n    var primeFactorsCount = 0\n\
    \    var factorizationCount = 0\n    var factorizationCountMax = Int(log2(Double(n)))\n\
    \    var factorizationCountMax2 = Int(log2(Double(n)))\n    var factorizationCountMax3\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax4 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax5 = Int(log2(Double(n)))\n    var factorizationCountMax6\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax7 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax8 = Int(log2(Double(n)))\n    var factorizationCountMax9\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax10 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax11 = Int(log2(Double(n)))\n    var factorizationCountMax12\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax13 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax14 = Int(log2(Double(n)))\n    var factorizationCountMax15\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax16 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax17 = Int(log2(Double(n)))\n    var factorizationCountMax18\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax19 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax20 = Int(log2(Double(n)))\n    var factorizationCountMax21\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax22 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax23 = Int(log2(Double(n)))\n    var factorizationCountMax24\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax25 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax26 = Int(log2(Double(n)))\n    var factorizationCountMax27\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax28 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax29 = Int(log2(Double(n)))\n    var factorizationCountMax30\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax31 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax32 = Int(log2(Double(n)))\n    var factorizationCountMax33\
    \ = Int(log2(Double(n)))\n    var factorizationCountMax34 = Int(log2(Double(n)))\n\
    \    var factorizationCountMax35 = Int(log\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmph9vbjfq0.swift:47:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmph9vbjfq0.swift:46:38: note: to match this opening '('\n    var factorizationCountMax35\
    \ = Int(log\n                                     ^\n/tmp/tmph9vbjfq0.swift:12:37:\
    \ error: cannot find 'log2' in scope\n    var factorizationCountMax = Int(log2(Double(n)))\n\
    \                                    ^~~~\n/tmp/tmph9vbjfq0.swift:13:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax2 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:14:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax3 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:15:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax4 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:16:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax5 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:17:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax6 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:18:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax7 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:19:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax8 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:20:38: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax9 = Int(log2(Double(n)))\n\
    \                                     ^~~~\n/tmp/tmph9vbjfq0.swift:21:39: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax10 = Int(log2(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmph9vbjfq0.swift:22:39: error:\
    \ cannot find 'log2' in scope\n    var factorizationCountMax11 = Int(log2(Double(n)))\n\
    \                                      ^~~~\n/tmp/tmph9vbjfq0.swift:23:39: error:\
    \ cannot find 'log2' in s"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var primeFactorizationIndex = 0\n\
    \    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimeIndex = 0\n\
    \    var isPrimeCountIndex = 0\n    var isPrimeCountMax = 0\n    var isPrimeCountMaxIndex\
    \ = 0\n    var isPrimeCountMin = 0\n    var isPrimeCountMinIndex = 0\n    var\
    \ isPrimeCountSum = 0\n    var isPrimeCountSumIndex = 0\n    var isPrimeCountProduct\
    \ = 0\n    var isPrimeCountProductIndex = 0\n    var isPrimeCountProductMax =\
    \ 0\n    var isPrimeCountProductMaxIndex = 0\n    var isPrimeCountProductMin =\
    \ 0\n    var isPrimeCountProductMinIndex = 0\n    var isPrimeCountProductSum =\
    \ 0\n    var isPrimeCountProductSumIndex = 0\n    var isPrimeCountProductProduct\
    \ = 0\n    var isPrimeCountProductProductIndex = 0\n    var isPrimeCountProductProductMax\
    \ = 0\n    var isPrimeCountProductProductMaxIndex = 0\n    var isPrimeCountProductProductMin\
    \ = 0\n    var isPrimeCountProductProductMinIndex = 0\n    var isPrimeCountProductProductSum\
    \ = 0\n    var isPrimeCountProductProductSumIndex = 0\n    var isPrimeCountProductProductProduct\
    \ = 0\n    var isPrimeCountProductProductProductIndex = 0\n    var isPrimeCountProductProductProductMax\
    \ = 0\n    var isPrimeCountProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductMin\
    \ = 0\n    var isPrimeCountProductProductProductMinIndex = 0\n    var isPrimeCountProductProductProductSum\
    \ = 0\n    var isPrimeCountProductProductProductSumIndex = 0\n    var isPrimeCountProductProductProductProduct\
    \ = 0\n    var isPrimeCountProductProductProductProductIndex = 0\n    var isPrimeCountProductProductProductProductMax\
    \ = 0\n    var isPrimeCountProductProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductMin\
    \ = 0\n    var isPrimeCountProductProductProductMinIndex = 0\n    var isPrimeCountProductProductProductSum\
    \ = 0\n    var isPrimeCountProductProductProductSumIndex = 0\n    var isPrimeCountProductProductProductProduct\
    \ = 0\n    var isPrimeCountProductProductProductProductIndex = 0\n    var isPrimeCountProductProductProductProductMax\
    \ = 0\n    var isPrimeCountProductProductProductProductMaxIndex = 0\n    var isPrimeCountProductProductProductMin\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkyhtfs11.swift:48:9: error: invalid redeclaration of 'isPrimeCountProductProductProductMin'\n\
    \    var isPrimeCountProductProductProductMin = 0\n        ^\n/tmp/tmpkyhtfs11.swift:40:9:\
    \ note: 'isPrimeCountProductProductProductMin' previously declared here\n    var\
    \ isPrimeCountProductProductProductMin = 0\n        ^\n/tmp/tmpkyhtfs11.swift:49:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductMinIndex'\n\
    \    var isPrimeCountProductProductProductMinIndex = 0\n        ^\n/tmp/tmpkyhtfs11.swift:41:9:\
    \ note: 'isPrimeCountProductProductProductMinIndex' previously declared here\n\
    \    var isPrimeCountProductProductProductMinIndex = 0\n        ^\n/tmp/tmpkyhtfs11.swift:50:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductSum'\n   \
    \ var isPrimeCountProductProductProductSum = 0\n        ^\n/tmp/tmpkyhtfs11.swift:42:9:\
    \ note: 'isPrimeCountProductProductProductSum' previously declared here\n    var\
    \ isPrimeCountProductProductProductSum = 0\n        ^\n/tmp/tmpkyhtfs11.swift:51:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductSumIndex'\n\
    \    var isPrimeCountProductProductProductSumIndex = 0\n        ^\n/tmp/tmpkyhtfs11.swift:43:9:\
    \ note: 'isPrimeCountProductProductProductSumIndex' previously declared here\n\
    \    var isPrimeCountProductProductProductSumIndex = 0\n        ^\n/tmp/tmpkyhtfs11.swift:52:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductProduct'\n\
    \    var isPrimeCountProductProductProductProduct = 0\n        ^\n/tmp/tmpkyhtfs11.swift:44:9:\
    \ note: 'isPrimeCountProductProductProductProduct' previously declared here\n\
    \    var isPrimeCountProductProductProductProduct = 0\n        ^\n/tmp/tmpkyhtfs11.swift:53:9:\
    \ error: invalid redeclaration of 'isPrimeCountProductProductProductProductIndex'\n\
    \    var isPrimeCountProductProductProductProductIndex = 0\n        ^\n/tmp/tmpkyhtfs11.swift:45:9:\
    \ note: 'isPrimeCountProductProductProductProductIndex' previously declared here\n\
    \    var isPrimeCountProductProductProductProductIndex = 0\n        ^\n/tmp/tmpkyhtfs11.swift:54:9:\
    \ error: invalid redeclarat"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Int]()\n    var isPrimeCount2 = [Int]()\n    var isPrimeCount3\
    \ = [Int]()\n    var isPrimeCount4 = [Int]()\n    var isPrimeCount5 = [Int]()\n\
    \    var isPrimeCount6 = [Int]()\n    var isPrimeCount7 = [Int]()\n    var isPrimeCount8\
    \ = [Int]()\n    var isPrimeCount9 = [Int]()\n    var isPrimeCount10 = [Int]()\n\
    \    var isPrimeCount11 = [Int]()\n    var isPrimeCount12 = [Int]()\n    var isPrimeCount13\
    \ = [Int]()\n    var isPrimeCount14 = [Int]()\n    var isPrimeCount15 = [Int]()\n\
    \    var isPrimeCount16 = [Int]()\n    var isPrimeCount17 = [Int]()\n    var isPrimeCount18\
    \ = [Int]()\n    var isPrimeCount19 = [Int]()\n    var isPrimeCount20 = [Int]()\n\
    \    var isPrimeCount21 = [Int]()\n    var isPrimeCount22 = [Int]()\n    var isPrimeCount23\
    \ = [Int]()\n    var isPrimeCount24 = [Int]()\n    var isPrimeCount25 = [Int]()\n\
    \    var isPrimeCount26 = [Int]()\n    var isPrimeCount27 = [Int]()\n    var isPrimeCount28\
    \ = [Int]()\n    var isPrimeCount29 = [Int]()\n    var isPrimeCount30 = [Int]()\n\
    \    var isPrimeCount31 = [Int]()\n    var isPrimeCount32 = [Int]()\n    var isPrimeCount33\
    \ = [Int]()\n    var isPrimeCount34 = [Int]()\n    var isPrimeCount35 = [Int]()\n\
    \    var isPrimeCount36 = [Int]()\n    var isPrimeCount37 = [Int]()\n    var isPrimeCount38\
    \ = [Int]()\n    var isPrimeCount39 = [Int]()\n    var isPrimeCount40 = [Int]()\n\
    \    var isPrimeCount41 = [Int]()\n    var isPrimeCount42 = [Int]()\n    var isPrimeCount43\
    \ = [Int]()\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_dqls643.swift:53:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmp_dqls643.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:8:9: warning:\
    \ initialization of variable 'primeFactorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationCount\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:9:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = [Bool]()\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmp_dqls643.swift:10:9: warning: initialization of variable 'isPrimeCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount = [Int]()\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:11:9:\
    \ warning: initialization of variable 'isPrimeCount2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount2 = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:12:9: warning: initialization\
    \ of variable 'isPrimeCount3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeCount3 = [Int]()\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp_dqls643.swift:13:9: warning: initialization of variable 'isPrimeCount4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount4 = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:14:9:\
    \ warning: initialization of variable 'isPrimeCount5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount5 = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp_dqls643.swift:15:9"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationIndexCount = 0\n    var factorizationIndexCountMax\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n    var\
    \ factorizationIndexCountMaxInt64 = Int(IntMax)\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n    var factorizationIndexCountMaxInt64 = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprhka9c8h.swift:44:42: error: expected initial value after '='\n\
    \    var factorizationIndexCountMaxInt64 = \n                                \
    \         ^\n/tmp/tmprhka9c8h.swift:10:42: error: cannot find 'IntMax' in scope\n\
    \    var factorizationIndexCountMax = Int(IntMax)\n                          \
    \               ^~~~~~\n/tmp/tmprhka9c8h.swift:11:45: error: cannot find 'IntMax'\
    \ in scope\n    var factorizationIndexCountMaxInt = Int(IntMax)\n            \
    \                                ^~~~~~\n/tmp/tmprhka9c8h.swift:12:47: error:\
    \ cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64 = Int(IntMax)\n\
    \                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:13:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:14:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:15:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:16:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:17:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:18:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:19:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                              ^~~~~~\n/tmp/tmprhka9c8h.swift:20:47:\
    \ error: cannot find 'IntMax' in scope\n    var factorizationIndexCountMaxInt64\
    \ = Int(IntMax)\n                                             "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int()\n    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMin = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountSum = Int()\n    var\
    \ isPrimeCountSumIndex = Int()\n    var isPrimeCountSumMax = Int()\n    var isPrimeCountSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumMin = Int()\n    var isPrimeCountSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSum = Int()\n    var isPrimeCountSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumMax = Int()\n    var isPrimeCountSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumMin = Int()\n    var isPrimeCountSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSum = Int()\n    var isPrimeCountSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumMax = Int()\n    var isPrimeCountSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumMin = Int()\n    var isPrimeCountSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMin = Int()\n    var isPrimeCountSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMin = Int()\n    var isPrimeCountSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0h7vaf65.swift:39:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumIndex'\n\
    \    var isPrimeCountSumSumSumSumIndex = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:33:9:\
    \ note: 'isPrimeCountSumSumSumSumIndex' previously declared here\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumMax'\n    var isPrimeCountSumSumSumSumMax = Int()\n\
    \        ^\n/tmp/tmp0h7vaf65.swift:34:9: note: 'isPrimeCountSumSumSumSumMax' previously\
    \ declared here\n    var isPrimeCountSumSumSumSumMax = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:41:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumMaxIndex'\n    var\
    \ isPrimeCountSumSumSumSumMaxIndex = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:35:9:\
    \ note: 'isPrimeCountSumSumSumSumMaxIndex' previously declared here\n    var isPrimeCountSumSumSumSumMaxIndex\
    \ = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:42:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumMin'\n    var isPrimeCountSumSumSumSumMin = Int()\n\
    \        ^\n/tmp/tmp0h7vaf65.swift:36:9: note: 'isPrimeCountSumSumSumSumMin' previously\
    \ declared here\n    var isPrimeCountSumSumSumSumMin = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:43:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumMinIndex'\n    var\
    \ isPrimeCountSumSumSumSumMinIndex = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:37:9:\
    \ note: 'isPrimeCountSumSumSumSumMinIndex' previously declared here\n    var isPrimeCountSumSumSumSumMinIndex\
    \ = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:44:9: error: invalid redeclaration\
    \ of 'isPrimeCountSumSumSumSumSum'\n    var isPrimeCountSumSumSumSumSum = Int()\n\
    \        ^\n/tmp/tmp0h7vaf65.swift:38:9: note: 'isPrimeCountSumSumSumSumSum' previously\
    \ declared here\n    var isPrimeCountSumSumSumSumSum = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:45:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumIndex'\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n        ^\n/tmp/tmp0h7vaf65.swift:33:9: note: 'isPrimeCountSumSumSumSumIndex'\
    \ previously declared here\n    var isPrimeCountSumSu"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimePrime\
    \ = [Bool]()\n    var isPrimePrimeCount = [Int]()\n    var isPrimePrimePrime =\
    \ [Bool]()\n    var isPrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var\
    \ isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbk5pn05f.swift:20:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpbk5pn05f.swift:18:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime\
    \ = [Bool]()\n        ^\n/tmp/tmpbk5pn05f.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpbk5pn05f.swift:19:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = [Int]()\n\
    \        ^\n/tmp/tmpbk5pn05f.swift:23:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpbk5pn05f.swift:19:9:\
    \ note: 'isPrimePrimePrimePrimePrimeCount' previously declared here\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpbk5pn05f.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n        ^\n/tmp/tmpbk5pn05f.swift:22:9: note: 'isPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \        ^\n/tmp/tmpbk5pn05f.swift:26:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpbk5pn05f.swift:22:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n        ^\n/tmp/tmpbk5pn05f.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpbk5pn05f.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \        ^\n/tmp/tmpbk5pn05f.swift:30:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n      "
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Int]()\n    var isPrimeCountMax = Int.max\n    var isPrimeCountMin\
    \ = Int.min\n    var isPrimeCountSum = 0\n    var isPrimeCountSumMax = 0\n   \
    \ var isPrimeCountSumMin = 0\n    var isPrimeCountSumSum = 0\n    var isPrimeCountSumSumMax\
    \ = 0\n    var isPrimeCountSumSumMin = 0\n    var isPrimeCountSumSumSum = 0\n\
    \    var isPrimeCountSumSumSumMax = 0\n    var isPrimeCountSumSumSumMin = 0\n\
    \    var isPrimeCountSumSumSumSum = 0\n    var isPrimeCountSumSumSumSumMax = 0\n\
    \    var isPrimeCountSumSumSumSumMin = 0\n    var isPrimeCountSumSumSumSumSum\
    \ = 0\n    var isPrimeCountSumSumSumSumMax = 0\n    var isPrimeCountSumSumSumSumMin\
    \ = 0\n    var isPrimeCountSumSumSumSumSum = 0\n    var isPrimeCountSumSumSumSumSumMax\
    \ = 0\n    var isPrimeCountSumSumSumSumSumMin = 0\n    var isPrimeCountSumSumSumSumSumSum\
    \ = 0\n    var isPrimeCountSumSumSumSumSumMax = 0\n    var isPrimeCountSumSumSumSumSumMin\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSum = 0\n    var isPrimeCountSumSumSumSumSumMax\
    \ = 0\n    var isPrimeCountSumSumSumSumSumMin = 0\n    var isPrimeCountSumSumSumSumSumSum\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSumMax = 0\n    var isPrimeCountSumSumSumSumSumSumMin\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSumSum = 0\n    var isPrimeCountSumSumSumSumSumSumMax\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSumMin = 0\n    var isPrimeCountSumSumSumSumSumSumSum\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSumMax = 0\n    var isPrimeCountSumSumSumSumSumSumMin\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSumSum = 0\n    var isPrimeCountSumSumSumSumSumSumSumMax\
    \ = 0\n    var isPrimeCountSumSumSumSumSumSumSumMin = 0\n    var \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1llldjrs.swift:49:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp1llldjrs.swift:26:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumMax'\n\
    \    var isPrimeCountSumSumSumSumMax = 0\n        ^\n/tmp/tmp1llldjrs.swift:23:9:\
    \ note: 'isPrimeCountSumSumSumSumMax' previously declared here\n    var isPrimeCountSumSumSumSumMax\
    \ = 0\n        ^\n/tmp/tmp1llldjrs.swift:27:9: error: invalid redeclaration of\
    \ 'isPrimeCountSumSumSumSumMin'\n    var isPrimeCountSumSumSumSumMin = 0\n   \
    \     ^\n/tmp/tmp1llldjrs.swift:24:9: note: 'isPrimeCountSumSumSumSumMin' previously\
    \ declared here\n    var isPrimeCountSumSumSumSumMin = 0\n        ^\n/tmp/tmp1llldjrs.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSum'\n    var isPrimeCountSumSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmp1llldjrs.swift:25:9: note: 'isPrimeCountSumSumSumSumSum'\
    \ previously declared here\n    var isPrimeCountSumSumSumSumSum = 0\n        ^\n\
    /tmp/tmp1llldjrs.swift:32:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumMax'\n\
    \    var isPrimeCountSumSumSumSumSumMax = 0\n        ^\n/tmp/tmp1llldjrs.swift:29:9:\
    \ note: 'isPrimeCountSumSumSumSumSumMax' previously declared here\n    var isPrimeCountSumSumSumSumSumMax\
    \ = 0\n        ^\n/tmp/tmp1llldjrs.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeCountSumSumSumSumSumMin'\n    var isPrimeCountSumSumSumSumSumMin = 0\n\
    \        ^\n/tmp/tmp1llldjrs.swift:30:9: note: 'isPrimeCountSumSumSumSumSumMin'\
    \ previously declared here\n    var isPrimeCountSumSumSumSumSumMin = 0\n     \
    \   ^\n/tmp/tmp1llldjrs.swift:34:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSum'\n\
    \    var isPrimeCountSumSumSumSumSumSum = 0\n        ^\n/tmp/tmp1llldjrs.swift:31:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSum' previously declared here\n    var isPrimeCountSumSumSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmp1llldjrs.swift:35:9: error: invalid redeclaration of\
    \ 'isPrimeCountSumSumSumSumSumMax'\n    var isPrimeCountSumSumSumSumSumMax = 0\n\
    \        ^\n/tmp/tmp1llldjrs.swift:29:9: note: 'isPrimeCountSumSumSumSumSumMax'\
    \ previously declared here\n    var isPrime"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primeFactors: [Int] = []\n    var isPrime:\
    \ [Bool] = []\n    var isPrimeCount: Int = 0\n    var isPrimeCountMax: Int = 0\n\
    \    var isPrimeCountMin: Int = 0\n    var isPrimeCountSum: Int = 0\n    var isPrimeCountSumMax:\
    \ Int = 0\n    var isPrimeCountSumMin: Int = 0\n    var isPrimeCountSumSum: Int\
    \ = 0\n    var isPrimeCountSumSumMax: Int = 0\n    var isPrimeCountSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSum: Int = 0\n    var isPrimeCountSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMax:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumMin: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSum:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumMax: Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumMin:\
    \ Int = 0\n    var isPrimeCountSumSumSumSumSumSumSumSumSum: Int = 0\n    var isPrimeCountSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmyezk8i5.swift:31:9: error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumMax'\n\
    \    var isPrimeCountSumSumSumSumSumSumMax: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:28:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumMax' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumMax: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumMin'\n    var\
    \ isPrimeCountSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:29:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumMin' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSum'\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:30:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumSum' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSum'\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:30:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumSum' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumSum: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSumMax'\n   \
    \ var isPrimeCountSumSumSumSumSumSumSumMax: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:34:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumSumMax' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumSumMax: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:38:9:\
    \ error: invalid redeclaration of 'isPrimeCountSumSumSumSumSumSumSumMin'\n   \
    \ var isPrimeCountSumSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:35:9:\
    \ note: 'isPrimeCountSumSumSumSumSumSumSumMin' previously declared here\n    var\
    \ isPrimeCountSumSumSumSumSumSumSumMin: Int = 0\n        ^\n/tmp/tmpmyezk8i5.swift:43:9:\
    \ error: type annotation missing in pattern\n    var isPrimeCountSum\n       \
    \ ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationIndex\
    \ = [Int]()\n    var isPrimeFactorizationIndexCount = [Int]()\n    var isPrimeFactorizationIndexCountMax\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex = Int()\n    var isPrimeFactorizationIndexCountMaxValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueIndex = Int()\n    var\
    \ isPrimeFactorizationIndexCountMaxValueValue = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValue = Int()\n\
    \    var isPrimeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorizationIndexCountMaxValueValueValueValue = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw5bgid_g.swift:39:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpw5bgid_g.swift:23:9: error: invalid redeclaration of 'isPrimeFactorizationIndexCountMaxValueValueValueValueIndex'\n\
    \    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex = Int()\n\
    \        ^\n/tmp/tmpw5bgid_g.swift:21:9: note: 'isPrimeFactorizationIndexCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpw5bgid_g.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationIndexCountMaxValueValueValueValueValue'\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpw5bgid_g.swift:22:9: note: 'isPrimeFactorizationIndexCountMaxValueValueValueValueValue'\
    \ previously declared here\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpw5bgid_g.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationIndexCountMaxValueValueValueValueIndex'\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpw5bgid_g.swift:21:9: note: 'isPrimeFactorizationIndexCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpw5bgid_g.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue'\n    var\
    \ isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue = Int()\n  \
    \      ^\n/tmp/tmpw5bgid_g.swift:26:9: note: 'isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue'\
    \ previously declared here\n    var isPrimeFactorizationIndexCountMaxValueValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpw5bgid_g.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex'\n    var\
    \ isPrimeFactorizationIndexCountMaxValueValueValueValueValueIndex = Int()\n  \
    \      ^\n/tmp/tmpw5bgid_g.swift:27:9: note: 'isPrimeFactorizationIndexCountMaxValueValueValueV"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationValue = 1\n    var factorizationValueIndex\
    \ = 0\n    var factorizationValueIndexMax = Int(sqrt(Double(n)))\n    var factorizationValueMax\
    \ = factorizationValueIndexMax\n    var factorizationValueMaxIndex = 0\n    var\
    \ factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMax)))\n \
    \   var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \    var factorizationValueMaxIndexMax = \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqx1_qe_h.swift:36:40: error: expected initial value after '='\n\
    \    var factorizationValueMaxIndexMax = \n                                  \
    \     ^\n/tmp/tmpqx1_qe_h.swift:11:42: error: cannot find 'sqrt' in scope\n  \
    \  var factorizationValueIndexMax = Int(sqrt(Double(n)))\n                   \
    \                      ^~~~\n/tmp/tmpqx1_qe_h.swift:14:45: error: cannot find\
    \ 'sqrt' in scope\n    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMax)))\n\
    \                                            ^~~~\n/tmp/tmpqx1_qe_h.swift:15:45:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationValueMaxIndexMax =\
    \ Int(sqrt(Double(factorizationValueMaxIndexMax)))\n                         \
    \                   ^~~~\n/tmp/tmpqx1_qe_h.swift:16:45: error: cannot find 'sqrt'\
    \ in scope\n    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \                                            ^~~~\n/tmp/tmpqx1_qe_h.swift:17:45:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationValueMaxIndexMax =\
    \ Int(sqrt(Double(factorizationValueMaxIndexMax)))\n                         \
    \                   ^~~~\n/tmp/tmpqx1_qe_h.swift:18:45: error: cannot find 'sqrt'\
    \ in scope\n    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \                                            ^~~~\n/tmp/tmpqx1_qe_h.swift:19:45:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationValueMaxIndexMax =\
    \ Int(sqrt(Double(factorizationValueMaxIndexMax)))\n                         \
    \                   ^~~~\n/tmp/tmpqx1_qe_h.swift:20:45: error: cannot find 'sqrt'\
    \ in scope\n    var factorizationValueMaxIndexMax = Int(sqrt(Double(factorizationValueMaxIndexMax)))\n\
    \                                            ^~~~\n/tmp/tmpqx1_qe_h.swift:21:45:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationValueMaxIndexMax =\
    \ Int(sqrt(Double(factorizationValueMaxIndexMax)))\n                         \
    \                   ^~~~\n/tmp/tmpqx1_qe_h.swift:22:45: error: cannot find 'sqrt'\
    \ in scope\n    var factorizationValueMaxIndexMax = Int(sq"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount: Int = 0\n\
    \    var factorizationIndex: Int = 0\n    var factorizationNumber: Int = 0\n \
    \   var factorizationNumbers: Int = 0\n    var factorizationNumbersIndex: Int\
    \ = 0\n    var factorizationNumbersIndex2: Int = 0\n    var factorizationNumbersIndex3:\
    \ Int = 0\n    var factorizationNumbersIndex4: Int = 0\n    var factorizationNumbersIndex5:\
    \ Int = 0\n    var factorizationNumbersIndex6: Int = 0\n    var factorizationNumbersIndex7:\
    \ Int = 0\n    var factorizationNumbersIndex8: Int = 0\n    var factorizationNumbersIndex9:\
    \ Int = 0\n    var factorizationNumbersIndex10: Int = 0\n    var factorizationNumbersIndex11:\
    \ Int = 0\n    var factorizationNumbersIndex12: Int = 0\n    var factorizationNumbersIndex13:\
    \ Int = 0\n    var factorizationNumbersIndex14: Int = 0\n    var factorizationNumbersIndex15:\
    \ Int = 0\n    var factorizationNumbersIndex16: Int = 0\n    var factorizationNumbersIndex17:\
    \ Int = 0\n    var factorizationNumbersIndex18: Int = 0\n    var factorizationNumbersIndex19:\
    \ Int = 0\n    var factorizationNumbersIndex20: Int = 0\n    var factorizationNumbersIndex21:\
    \ Int = 0\n    var factorizationNumbersIndex22: Int = 0\n    var factorizationNumbersIndex23:\
    \ Int = 0\n    var factorizationNumbersIndex24: Int = 0\n    var factorizationNumbersIndex25:\
    \ Int = 0\n    var factorizationNumbersIndex26: Int = 0\n    var factorizationNumbersIndex27:\
    \ Int = 0\n    var factorizationNumbersIndex28: Int = 0\n    var factorizationNumbersIndex29:\
    \ Int = 0\n    var factorizationNumbersIndex30: Int = 0\n    var factorizationNumbersIndex31:\
    \ Int = 0\n    var factorizationNumbersIndex32: Int = 0\n    var factorizationNumbersIndex33:\
    \ Int = 0\n    var factorizationNumbersIndex34: Int = 0\n    var factorizationNumbersIndex35:\
    \ Int = 0\n    var factorizationNumbersIndex36: Int = 0\n    var factorizationNumbersIndex37:\
    \ Int = 0\n    var factorizationNumbersIndex38: Int = 0\n    var factorizationNumbersIndex39:\
    \ Int = 0\n    var factorizationNumbersIndex40: Int = 0\n    var factorizationNumbersIndex41:\
    \ Int = 0\n    var factorizationNumbersIndex42: Int = 0\n    var factorizationNumbersIndex43:\
    \ Int = 0\n    var factorizationNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy6usvvpj.swift:54:9: error: type annotation missing in pattern\n\
    \    var factorizationNumbers\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            i += 1\n            factors.append(i)\n      \
    \  }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp4s6tqd4t/tmp4s6tqd4t.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b59cf1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b599e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b599e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b599e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4s6tqd4t                        0x000055ccee39e4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b7b59edd460 __libc_start_main +
    245

    6    tmp4s6tqd4t                        0x000055ccee39e119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Int]()\n    var isPrimeCountMax = Int()\n    var isPrimeCountMaxIndex\
    \ = Int()\n    var isPrimeCountMin = Int()\n    var isPrimeCountMinIndex = Int()\n\
    \    var isPrimeCountSum = Int()\n    var isPrimeCountSumIndex = Int()\n    var\
    \ isPrimeCountSumMax = Int()\n    var isPrimeCountSumMaxIndex = Int()\n    var\
    \ isPrimeCountSumMin = Int()\n    var isPrimeCountSumMinIndex = Int()\n    var\
    \ isPrimeCountSumSum = Int()\n    var isPrimeCountSumSumIndex = Int()\n    var\
    \ isPrimeCountSumSumMax = Int()\n    var isPrimeCountSumSumMaxIndex = Int()\n\
    \    var isPrimeCountSumSumMin = Int()\n    var isPrimeCountSumSumMinIndex = Int()\n\
    \    var isPrimeCountSumSumSum = Int()\n    var isPrimeCountSumSumSumIndex = Int()\n\
    \    var isPrimeCountSumSumSumMax = Int()\n    var isPrimeCountSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumMin = Int()\n    var isPrimeCountSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSum = Int()\n    var isPrimeCountSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMin = Int()\n    var isPrimeCountSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumMin = Int()\n    var isPrimeCountSumSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumSumMax = Int()\n    var isPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2ns04iyj.swift:34:9: error: invalid redeclaration of 'isPrimeCountSumSumSumIndex'\n\
    \    var isPrimeCountSumSumSumIndex = Int()\n        ^\n/tmp/tmp2ns04iyj.swift:28:9:\
    \ note: 'isPrimeCountSumSumSumIndex' previously declared here\n    var isPrimeCountSumSumSumIndex\
    \ = Int()\n        ^\n/tmp/tmp2ns04iyj.swift:48:9: error: type annotation missing\
    \ in pattern\n    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = []\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex\
    \ = 0\n    var isPrimeCount = 0\n    var isPrimeIndex2 = 0\n    var isPrimeCount2\
    \ = 0\n    var isPrimeIndex3 = 0\n    var isPrimeCount3 = 0\n    var isPrimeIndex4\
    \ = 0\n    var isPrimeCount4 = 0\n    var isPrimeIndex5 = 0\n    var isPrimeCount5\
    \ = 0\n    var isPrimeIndex6 = 0\n    var isPrimeCount6 = 0\n    var isPrimeIndex7\
    \ = 0\n    var isPrimeCount7 = 0\n    var isPrimeIndex8 = 0\n    var isPrimeCount8\
    \ = 0\n    var isPrimeIndex9 = 0\n    var isPrimeCount9 = 0\n    var isPrimeIndex10\
    \ = 0\n    var isPrimeCount10 = 0\n    var isPrimeIndex11 = 0\n    var isPrimeCount11\
    \ = 0\n    var isPrimeIndex12 = 0\n    var isPrimeCount12 = 0\n    var isPrimeIndex13\
    \ = 0\n    var isPrimeCount13 = 0\n    var isPrimeIndex14 = 0\n    var isPrimeCount14\
    \ = 0\n    var isPrimeIndex15 = 0\n    var isPrimeCount15 = 0\n    var isPrimeIndex16\
    \ = 0\n    var isPrimeCount16 = 0\n    var isPrimeIndex17 = 0\n    var isPrimeCount17\
    \ = 0\n    var isPrimeIndex18 = 0\n    var isPrimeCount18 = 0\n    var isPrimeIndex19\
    \ = 0\n    var isPrimeCount19 = 0\n    var isPrimeIndex20 = 0\n    var isPrimeCount20\
    \ = 0\n    var isPrimeIndex21 = 0\n    var isPrimeCount21 = 0\n    var isPrimeIndex22\
    \ = 0\n    var isPrimeCount22 = 0\n    var isPrimeIndex23 = 0\n    var isPrimeCount23\
    \ = 0\n    var isPrimeIndex24 = 0\n    var isPrimeCount24 = 0\n    var isPrimeIndex25\
    \ = 0\n    var isPrimeCount25 = 0\n    var isPrimeIndex26 = 0\n    var isPrimeCount26\
    \ = 0\n    var isPrimeIndex27 = 0\n    var isPrimeCount27 = 0\n    var isPrimeIndex28\
    \ = 0\n    var isPrimeCount28 = 0\n    var isPrimeIndex29 = 0\n    var isPrimeCount29\
    \ = 0\n    var isPrimeIndex30 = 0\n    var isPrimeCount30 = 0\n    var isPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz2zg85md.swift:71:9: error: type annotation missing in pattern\n\
    \    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactorizationIsPrimeIndex = 0\n    var currentFactorizationIsPrime\
    \ = true\n    var currentFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpype8aihv.swift:14:9: error: invalid redeclaration of 'currentFactorizationIsPrime'\n\
    \    var currentFactorizationIsPrime = true\n        ^\n/tmp/tmpype8aihv.swift:12:9:\
    \ note: 'currentFactorizationIsPrime' previously declared here\n    var currentFactorizationIsPrime\
    \ = true\n        ^\n/tmp/tmpype8aihv.swift:15:9: error: invalid redeclaration\
    \ of 'currentFactorizationIsPrimeIndex'\n    var currentFactorizationIsPrimeIndex\
    \ = 0\n        ^\n/tmp/tmpype8aihv.swift:13:9: note: 'currentFactorizationIsPrimeIndex'\
    \ previously declared here\n    var currentFactorizationIsPrimeIndex = 0\n   \
    \     ^\n/tmp/tmpype8aihv.swift:16:9: error: invalid redeclaration of 'currentFactorizationIsPrime'\n\
    \    var currentFactorizationIsPrime = true\n        ^\n/tmp/tmpype8aihv.swift:12:9:\
    \ note: 'currentFactorizationIsPrime' previously declared here\n    var currentFactorizationIsPrime\
    \ = true\n        ^\n/tmp/tmpype8aihv.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorizationIsPrimeIndex'\n    var currentFactorizationIsPrimeIndex\
    \ = 0\n        ^\n/tmp/tmpype8aihv.swift:13:9: note: 'currentFactorizationIsPrimeIndex'\
    \ previously declared here\n    var currentFactorizationIsPrimeIndex = 0\n   \
    \     ^\n/tmp/tmpype8aihv.swift:18:9: error: invalid redeclaration of 'currentFactorizationIsPrime'\n\
    \    var currentFactorizationIsPrime = true\n        ^\n/tmp/tmpype8aihv.swift:12:9:\
    \ note: 'currentFactorizationIsPrime' previously declared here\n    var currentFactorizationIsPrime\
    \ = true\n        ^\n/tmp/tmpype8aihv.swift:19:9: error: invalid redeclaration\
    \ of 'currentFactorizationIsPrimeIndex'\n    var currentFactorizationIsPrimeIndex\
    \ = 0\n        ^\n/tmp/tmpype8aihv.swift:13:9: note: 'currentFactorizationIsPrimeIndex'\
    \ previously declared here\n    var currentFactorizationIsPrimeIndex = 0\n   \
    \     ^\n/tmp/tmpype8aihv.swift:20:9: error: invalid redeclaration of 'currentFactorizationIsPrime'\n\
    \    var currentFactorizationIsPrime = true\n        ^\n/tmp/tmpype8aihv.swift:12:9:\
    \ note: 'currentFactorizationIsPrime' previously declared here\n    var currentFactorizationIsPrime\
    \ = true\n       "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    var factor = 1\n    while i\
    \ < n {\n        while n % i == 0 {\n            factors.append(factor)\n    \
    \        n /= i\n        }\n        i += 1\n        factor = 1\n    }\n    if\
    \ n != 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplckjaj5_.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationProduct\
    \ = 1\n    var factorizationFactor = 1\n    var factorizationFactorIndex = 0\n\
    \    var factorizationFactorSum = 0\n    var factorizationFactorProduct = 1\n\
    \    var factorizationFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorizationFactorFactorFactor = 1\n    var factorizationFactorFactorIndex\
    \ = 0\n    var factorizationFactorFactorSum = 0\n    var factorizationFactorFactorProduct\
    \ = 1\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvcq9705c.swift:20:9: error: invalid redeclaration of 'factorizationFactorFactorIndex'\n\
    \    var factorizationFactorFactorIndex = 0\n        ^\n/tmp/tmpvcq9705c.swift:16:9:\
    \ note: 'factorizationFactorFactorIndex' previously declared here\n    var factorizationFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpvcq9705c.swift:21:9: error: invalid redeclaration of\
    \ 'factorizationFactorFactorSum'\n    var factorizationFactorFactorSum = 0\n \
    \       ^\n/tmp/tmpvcq9705c.swift:17:9: note: 'factorizationFactorFactorSum' previously\
    \ declared here\n    var factorizationFactorFactorSum = 0\n        ^\n/tmp/tmpvcq9705c.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationFactorFactorProduct'\n    var\
    \ factorizationFactorFactorProduct = 1\n        ^\n/tmp/tmpvcq9705c.swift:18:9:\
    \ note: 'factorizationFactorFactorProduct' previously declared here\n    var factorizationFactorFactorProduct\
    \ = 1\n        ^\n/tmp/tmpvcq9705c.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationFactorFactorFactor'\n    var factorizationFactorFactorFactor =\
    \ 1\n        ^\n/tmp/tmpvcq9705c.swift:19:9: note: 'factorizationFactorFactorFactor'\
    \ previously declared here\n    var factorizationFactorFactorFactor = 1\n    \
    \    ^\n/tmp/tmpvcq9705c.swift:24:9: error: invalid redeclaration of 'factorizationFactorFactorIndex'\n\
    \    var factorizationFactorFactorIndex = 0\n        ^\n/tmp/tmpvcq9705c.swift:16:9:\
    \ note: 'factorizationFactorFactorIndex' previously declared here\n    var factorizationFactorFactorIndex\
    \ = 0\n        ^\n/tmp/tmpvcq9705c.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationFactorFactorSum'\n    var factorizationFactorFactorSum = 0\n \
    \       ^\n/tmp/tmpvcq9705c.swift:17:9: note: 'factorizationFactorFactorSum' previously\
    \ declared here\n    var factorizationFactorFactorSum = 0\n        ^\n/tmp/tmpvcq9705c.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationFactorFactorProduct'\n    var\
    \ factorizationFactorFactorProduct = 1\n        ^\n/tmp/tmpvcq9705c.swift:18:9:\
    \ note: 'factorizationFactorFactorProduct' previously declared here\n    var factorizationFactorFactorProduct\
    \ = 1\n   "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = []\n    var factorizationCount\
    \ = 0\n    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime\
    \ = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n  \
    \  var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime = true\n   \
    \ var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp35wt9lgz.swift:27:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmp35wt9lgz.swift:25:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n     \
    \   ^\n/tmp/tmp35wt9lgz.swift:28:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmp35wt9lgz.swift:26:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmp35wt9lgz.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp35wt9lgz.swift:31:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp35wt9lgz.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n       \
    \ ^\n/tmp/tmp35wt9lgz.swift:32:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmp35wt9lgz.swift:36:9: error: type annotation missing\
    \ in pattern\n    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization: Bool = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimePrimeFactorization: Bool = false\n    var isPrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdyuecoj4.swift:21:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n        ^\n/tmp/tmpdyuecoj4.swift:19:9:\
    \ note: 'isPrimePrimePrimePrimePrimeFactorization' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n        ^\n/tmp/tmpdyuecoj4.swift:33:9:\
    \ error: type annotation missing in pattern\n    var isPrimePrimePrimePrimePrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount = 0\n   \
    \ var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbrbnf45e.swift:21:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:19:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpbrbnf45e.swift:20:9: note: 'isPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n\
    \        ^\n/tmp/tmpbrbnf45e.swift:26:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpbrbnf45e.swift:24:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpbrbnf45e.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n\
    /tmp/tmpbrbnf45e.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:31:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpbrbnf45e.swift:32:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previou"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            factors.append(i)\n            n /= i\n      \
    \  } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk44a6247.swift:11:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorIndex\
    \ = 0\n    var factorizationFactorCount = 1\n    var factorizationFactorCountIndex\
    \ = 0\n    var factorizationFactorCountMax = 0\n    var factorizationFactorCountMaxIndex\
    \ = 0\n    var factorizationFactorCountMin = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\
    \ = 0\n    var factorizationFactorCountMaxIndex = 0\n    var factorizationFactorCountMinIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7wzzo_wu.swift:17:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:18:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmp7wzzo_wu.swift:19:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:20:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmp7wzzo_wu.swift:21:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared here\n    var factorizationFactorCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:22:9: error: invalid redeclaration of\
    \ 'factorizationFactorCountMinIndex'\n    var factorizationFactorCountMinIndex\
    \ = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:16:9: note: 'factorizationFactorCountMinIndex'\
    \ previously declared here\n    var factorizationFactorCountMinIndex = 0\n   \
    \     ^\n/tmp/tmp7wzzo_wu.swift:23:9: error: invalid redeclaration of 'factorizationFactorCountMaxIndex'\n\
    \    var factorizationFactorCountMaxIndex = 0\n        ^\n/tmp/tmp7wzzo_wu.swift:14:9:\
    \ note: 'factorizationFactorCountMaxIndex' previously declared h"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var factorizationIndex2\
    \ = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4 = 0\n    var\
    \ factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var factorizationIndex7\
    \ = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9 = 0\n    var\
    \ factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n    var factorizationIndex12\
    \ = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14 = 0\n  \
    \  var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n    var factorizationIndex17\
    \ = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19 = 0\n  \
    \  var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n    var factorizationIndex22\
    \ = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24 = 0\n  \
    \  var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n    var factorizationIndex27\
    \ = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29 = 0\n  \
    \  var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n    var factorizationIndex32\
    \ = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34 = 0\n  \
    \  var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n    var factorizationIndex37\
    \ = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39 = 0\n  \
    \  var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n    var factorizationIndex42\
    \ = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44 = 0\n  \
    \  var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n    var factorizationIndex47\
    \ = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49 = 0\n  \
    \  var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n    var factorizationIndex52\
    \ = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54 = 0\n  \
    \  var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n    var factorizationIndex57\
    \ = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59 = 0\n  \
    \  var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n    var factorizationIndex62\
    \ = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64 = 0\n  \
    \  var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n    var factorizationIndex67\
    \ = 0\n    var factorizationIndex68 = 0\n    var factorizationIndex69 = 0\n  \
    \  var factorizationIndex70 = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpovd7od6s.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:8:9: warning:\
    \ initialization of variable 'primeFactorizationIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:9:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovd7od6s.swift:10:9: warning: initialization of variable 'factorizationIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex2 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:11:9:\
    \ warning: initialization of variable 'factorizationIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:12:9: warning:\
    \ initialization of variable 'factorizationIndex4' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex4 = 0\n   \
    \ ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.swift:13:9: warning: initialization\
    \ of variable 'factorizationIndex5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var factorizationIndex5 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovd7od6s.swift:14:9: warning: initialization of variable 'factorizationIndex6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex6 = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpovd7od6s.s"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationIndex\
    \ = [Int]()\n    var isPrimeFactorizationIndexCount = [Int]()\n    var isPrimeFactorizationIndexCountMax\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex = Int()\n    var isPrimeFactorizationIndexCountMaxIndex2\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex3 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex4\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex5 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex6\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex7 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex8\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex9 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex10\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex11 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex12\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex13 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex14\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex15 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex16\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex17 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex18\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex19 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex20\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex21 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex22\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex23 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex24\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex25 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex26\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex27 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex28\
    \ = Int()\n    var isPrimeFactorizationIndexCountMaxIndex29 = Int()\n    var isPrimeFactorizationIndexCountMaxIndex30\
    \ = Int()\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcbio1p0y.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpcbio1p0y.swift:7:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpcbio1p0y.swift:8:9: warning:\
    \ initialization of variable 'isPrime' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrime = [Bool]()\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpcbio1p0y.swift:9:9: warning: initialization of variable 'isPrimeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpcbio1p0y.swift:10:9: warning: initialization of variable 'isPrimeFactorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndex = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcbio1p0y.swift:11:9: warning: initialization of variable 'isPrimeFactorizationIndexCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndexCount = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcbio1p0y.swift:12:9: warning: initialization of variable 'isPrimeFactorizationIndexCountMax'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndexCountMax = Int()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcbio1p0y.swift:13:9: warning: initialization of variable 'isPrimeFactorizationIndexCountMaxIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndexCountMaxIndex = Int()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpcbio1p0y.swift:14:9: warning: initialization of variable 'isPrimeFactorizationIndexCountMaxInd"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor: Int\n    var i: Int\n\
    \    var j: Int\n    var k: Int\n    var count: Int\n    var prime: Int\n    var\
    \ primeFactors: [Int] = []\n    var isPrime: Bool\n    var isPrimeFactor: Bool\n\
    \    var isPrimeFactor2: Bool\n    var isPrimeFactor3: Bool\n    var isPrimeFactor4:\
    \ Bool\n    var isPrimeFactor5: Bool\n    var isPrimeFactor6: Bool\n    var isPrimeFactor7:\
    \ Bool\n    var isPrimeFactor8: Bool\n    var isPrimeFactor9: Bool\n    var isPrimeFactor10:\
    \ Bool\n    var isPrimeFactor11: Bool\n    var isPrimeFactor12: Bool\n    var\
    \ isPrimeFactor13: Bool\n    var isPrimeFactor14: Bool\n    var isPrimeFactor15:\
    \ Bool\n    var isPrimeFactor16: Bool\n    var isPrimeFactor17: Bool\n    var\
    \ isPrimeFactor18: Bool\n    var isPrimeFactor19: Bool\n    var isPrimeFactor20:\
    \ Bool\n    var isPrimeFactor21: Bool\n    var isPrimeFactor22: Bool\n    var\
    \ isPrimeFactor23: Bool\n    var isPrimeFactor24: Bool\n    var isPrimeFactor25:\
    \ Bool\n    var isPrimeFactor26: Bool\n    var isPrimeFactor27: Bool\n    var\
    \ isPrimeFactor28: Bool\n    var isPrimeFactor29: Bool\n    var isPrimeFactor30:\
    \ Bool\n    var isPrimeFactor31: Bool\n    var isPrimeFactor32: Bool\n    var\
    \ isPrimeFactor33: Bool\n    var isPrimeFactor34: Bool\n    var isPrimeFactor35:\
    \ Bool\n    var isPrimeFactor36: Bool\n    var isPrimeFactor37: Bool\n    var\
    \ isPrimeFactor38: Bool\n    var isPrimeFactor39: Bool\n    var isPrimeFactor40:\
    \ Bool\n    var isPrimeFactor41: Bool\n    var isPrimeFactor42: Bool\n    var\
    \ isPrimeFactor43: Bool\n    var isPrimeFactor44: Bool\n    var isPrimeFactor45:\
    \ Bool\n    var isPrimeFactor46: Bool\n    var isPrimeFactor47: Bool\n    var\
    \ isPrimeFactor48: Bool\n    var isPrimeFactor49: Bool\n    var isPrimeFactor50:\
    \ Bool\n    var isPrimeFactor51: Bool\n    var isPrimeFactor52: Bool\n    var\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcrn6_xyz.swift:67:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpcrn6_xyz.swift:6:9: warning: variable 'factorization' was never used;\
    \ consider replacing with '_' or removing it\n    var factorization: [Int] = []\n\
    \        ^~~~~~~~~~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:7:9: warning: variable\
    \ 'factor' was never used; consider replacing with '_' or removing it\n    var\
    \ factor: Int\n        ^~~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:8:9: warning:\
    \ variable 'i' was never used; consider replacing with '_' or removing it\n  \
    \  var i: Int\n        ^\n        _\n/tmp/tmpcrn6_xyz.swift:9:9: warning: variable\
    \ 'j' was never used; consider replacing with '_' or removing it\n    var j: Int\n\
    \        ^\n        _\n/tmp/tmpcrn6_xyz.swift:10:9: warning: variable 'k' was\
    \ never used; consider replacing with '_' or removing it\n    var k: Int\n   \
    \     ^\n        _\n/tmp/tmpcrn6_xyz.swift:11:9: warning: variable 'count' was\
    \ never used; consider replacing with '_' or removing it\n    var count: Int\n\
    \        ^~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:12:9: warning: variable 'prime'\
    \ was never used; consider replacing with '_' or removing it\n    var prime: Int\n\
    \        ^~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:13:9: warning: variable 'primeFactors'\
    \ was never used; consider replacing with '_' or removing it\n    var primeFactors:\
    \ [Int] = []\n        ^~~~~~~~~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:14:9: warning:\
    \ variable 'isPrime' was never used; consider replacing with '_' or removing it\n\
    \    var isPrime: Bool\n        ^~~~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:15:9:\
    \ warning: variable 'isPrimeFactor' was never used; consider replacing with '_'\
    \ or removing it\n    var isPrimeFactor: Bool\n        ^~~~~~~~~~~~~\n       \
    \ _\n/tmp/tmpcrn6_xyz.swift:16:9: warning: variable 'isPrimeFactor2' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrimeFactor2: Bool\n\
    \        ^~~~~~~~~~~~~~\n        _\n/tmp/tmpcrn6_xyz.swift:17:9: warning: variable\
    \ 'isPrimeFactor3' was never used; consider replacing with '_' or removing it\n\
    \    var isPrimeFactor3: Bool\n        ^~~~~~~~"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationIsPrime\
    \ = true\n    var factorizationIsPrimeIndex = -1\n    var factorizationIsPrimeFactor\
    \ = 1\n    var factorizationIsPrimeFactorIndex = -1\n    var factorizationIsPrimeFactorIndex2\
    \ = -1\n    var factorizationIsPrimeFactorIndex3 = -1\n    var factorizationIsPrimeFactorIndex4\
    \ = -1\n    var factorizationIsPrimeFactorIndex5 = -1\n    var factorizationIsPrimeFactorIndex6\
    \ = -1\n    var factorizationIsPrimeFactorIndex7 = -1\n    var factorizationIsPrimeFactorIndex8\
    \ = -1\n    var factorizationIsPrimeFactorIndex9 = -1\n    var factorizationIsPrimeFactorIndex10\
    \ = -1\n    var factorizationIsPrimeFactorIndex11 = -1\n    var factorizationIsPrimeFactorIndex12\
    \ = -1\n    var factorizationIsPrimeFactorIndex13 = -1\n    var factorizationIsPrimeFactorIndex14\
    \ = -1\n    var factorizationIsPrimeFactorIndex15 = -1\n    var factorizationIsPrimeFactorIndex16\
    \ = -1\n    var factorizationIsPrimeFactorIndex17 = -1\n    var factorizationIsPrimeFactorIndex18\
    \ = -1\n    var factorizationIsPrimeFactorIndex19 = -1\n    var factorizationIsPrimeFactorIndex20\
    \ = -1\n    var factorizationIsPrimeFactorIndex21 = -1\n    var factorizationIsPrimeFactorIndex22\
    \ = -1\n    var factorizationIsPrimeFactorIndex23 = -1\n    var factorizationIsPrimeFactorIndex24\
    \ = -1\n    var factorizationIsPrimeFactorIndex25 = -1\n    var factorizationIsPrimeFactorIndex26\
    \ = -1\n    var factorizationIsPrimeFactorIndex27 = -1\n    var factorizationIsPrimeFactorIndex28\
    \ = -1\n    var factorizationIsPrimeFactorIndex29 = -1\n    var factorizationIsPrimeFactorIndex30\
    \ = -1\n    var factorizationIsPrimeFactorIndex31 = -1\n    var factorizationIsPrimeFactorIndex32\
    \ = -1\n    var factorizationIsPrimeFactorIndex33 = -1\n    var factorizationIsPrimeFactorIndex34\
    \ = -1\n    var factorizationIsPrimeFactorIndex35 = -1\n    var factorizationIsPrimeFactorIndex36\
    \ = -1\n    var factorizationIsPrimeFactorIndex37 = -1\n    var factorizationIsPrimeFactorIndex38\
    \ = -1\n    var factorizationIsPrimeFactorIndex39 = -1\n    var factorizationIsPrimeFactorIndex40\
    \ = -1\n    var factorizationIsPrimeFactorIndex41 = -1\n    var factorizationIsPrimeFactor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqd9v94lg.swift:54:9: error: type annotation missing in pattern\n\
    \    var factorizationIsPrimeFactor\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationNumber = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberSum =\
    \ 0\n    var factorizationNumberSumCount = 0\n    var factorizationNumberSumIndex\
    \ = 0\n    var factorizationNumberSumSum = 0\n    var factorizationNumberSumSumCount\
    \ = 0\n    var factorizationNumberSumSumIndex = 0\n    var factorizationNumberSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSumSumSumSum\
    \ = 0\n    var factorizationNumberSumSumSumCount = 0\n    var factorizationNumberSumSumSumIndex\
    \ = 0\n    var factorizationNumberSumSumSumSum = 0\n    var factorizationNumberSumSumSumCount\
    \ = 0\n    var factorizationNumberSumSumSumIndex = 0\n    var factorizationNumberSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6n2pis95.swift:22:9: error: invalid redeclaration of 'factorizationNumberSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:19:9:\
    \ note: 'factorizationNumberSumSumSumCount' previously declared here\n    var\
    \ factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumIndex'\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:20:9:\
    \ note: 'factorizationNumberSumSumSumIndex' previously declared here\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSum'\n    var factorizationNumberSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmp6n2pis95.swift:21:9: note: 'factorizationNumberSumSumSumSum'\
    \ previously declared here\n    var factorizationNumberSumSumSumSum = 0\n    \
    \    ^\n/tmp/tmp6n2pis95.swift:25:9: error: invalid redeclaration of 'factorizationNumberSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:19:9:\
    \ note: 'factorizationNumberSumSumSumCount' previously declared here\n    var\
    \ factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumIndex'\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:20:9:\
    \ note: 'factorizationNumberSumSumSumIndex' previously declared here\n    var\
    \ factorizationNumberSumSumSumIndex = 0\n        ^\n/tmp/tmp6n2pis95.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationNumberSumSumSumSum'\n    var factorizationNumberSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmp6n2pis95.swift:21:9: note: 'factorizationNumberSumSumSumSum'\
    \ previously declared here\n    var factorizationNumberSumSumSumSum = 0\n    \
    \    ^\n/tmp/tmp6n2pis95.swift:28:9: error: invalid redeclaration of 'factorizationNumberSumSumSumCount'\n\
    \    var factorizationNumberSumSumSumCount = 0\n        ^\n/tmp/tmp6n2pis95.swift:19:9:\
    \ note: 'factorizationNumberSumSumSumCount' previously"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n  \
    \  var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization = [1]\n    var factorization\
    \ = [1]\n    var primeFactorization = [1]\n    var factorization = [1]\n    var\
    \ primeFactorization = [1]\n    var factorization = [1]\n    var primeFactorization\
    \ = [1]\n    var factorization = [1]\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorization\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7eb5nd0p.swift:10:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmp7eb5nd0p.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmp7eb5nd0p.swift:11:9: error: invalid redeclaration\
    \ of 'primeFactorization'\n    var primeFactorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:7:9:\
    \ note: 'primeFactorization' previously declared here\n    var primeFactorization\
    \ = [Int]()\n        ^\n/tmp/tmp7eb5nd0p.swift:12:9: error: invalid redeclaration\
    \ of 'factorization'\n    var factorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:6:9:\
    \ note: 'factorization' previously declared here\n    var factorization = [Int]()\n\
    \        ^\n/tmp/tmp7eb5nd0p.swift:13:9: error: invalid redeclaration of 'primeFactorization'\n\
    \    var primeFactorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:7:9: note:\
    \ 'primeFactorization' previously declared here\n    var primeFactorization =\
    \ [Int]()\n        ^\n/tmp/tmp7eb5nd0p.swift:14:9: error: invalid redeclaration\
    \ of 'factorization'\n    var factorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:6:9:\
    \ note: 'factorization' previously declared here\n    var factorization = [Int]()\n\
    \        ^\n/tmp/tmp7eb5nd0p.swift:15:9: error: invalid redeclaration of 'primeFactorization'\n\
    \    var primeFactorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:7:9: note:\
    \ 'primeFactorization' previously declared here\n    var primeFactorization =\
    \ [Int]()\n        ^\n/tmp/tmp7eb5nd0p.swift:16:9: error: invalid redeclaration\
    \ of 'factorization'\n    var factorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:6:9:\
    \ note: 'factorization' previously declared here\n    var factorization = [Int]()\n\
    \        ^\n/tmp/tmp7eb5nd0p.swift:17:9: error: invalid redeclaration of 'primeFactorization'\n\
    \    var primeFactorization = [1]\n        ^\n/tmp/tmp7eb5nd0p.swift:7:9: note:\
    \ 'primeFactorization' previously declared here\n    var primeFactorization =\
    \ [Int]()\n        ^\n/tmp/tmp7eb5nd0p.swift:18:9: error: invalid redeclaration\
    \ of 'factorizatio"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeFactorization\
    \ = [Int]()\n    var isPrimeFactorizationCount = [Int]()\n    var isPrimeFactorizationPrime\
    \ = [Int]()\n    var isPrimeFactorizationPrimeCount = [Int]()\n    var isPrimeFactorizationPrimePrime\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimeCount = [Int]()\n    var isPrimeFactorizationPrimePrimePrime\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimeCount = [Int]()\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrime = [Int]()\n    var isPrimeFactorizationPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrime = [Int]()\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimeCount = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimePrime = [Int]()\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimeCount = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrime = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimePrime = [Int]()\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimeCount = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3zr_r3jy.swift:19:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimeCount'\n\
    \    var isPrimeFactorizationPrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:17:9:\
    \ note: 'isPrimeFactorizationPrimePrimePrimeCount' previously declared here\n\
    \    var isPrimeFactorizationPrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:20:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:18:9:\
    \ note: 'isPrimeFactorizationPrimePrimePrimePrime' previously declared here\n\
    \    var isPrimeFactorizationPrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrime = [Int]()\n        ^\n\
    /tmp/tmp3zr_r3jy.swift:22:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimeCount'\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:21:9: note: 'isPrimeFactorizationPrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrime'\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:22:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimeCount'\n    var isPrimeFactorizationPrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp3zr_r3jy.swift:21:9: note: 'isPrimeFactorizationPrimePrimePrimePrimeCoun"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 0\n    var isPrime = true\n\
    \    var isFactorization = true\n    var isPrimeIndex = 0\n    var isPrimeCount\
    \ = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = true\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_1vne8mf.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactorizationPrimeFactor\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var isPrime: [Bool] = []\n    var isPrimeCount: [Int] = []\n    var isPrimeCountMax:\
    \ Int = 1\n    var isPrimeCountMaxIndex: Int = 0\n    var isPrimeCountMin: Int\
    \ = 1\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeCountMinIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7zv52bpw.swift:14:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:11:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:15:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp7zv52bpw.swift:13:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:16:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:11:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp7zv52bpw.swift:17:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex: Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:13:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:18:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n\
    /tmp/tmp7zv52bpw.swift:11:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:19:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:13:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp7zv52bpw.swift:20:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex: Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:11:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n        ^\n/tmp/tmp7zv52bpw.swift:21:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex: Int = 0\n        ^\n\
    /tmp/tmp7zv52bpw.swift:13:9: note: 'isPrimeCountMinIndex' previously declar"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor = 2\n    var counter =\
    \ 1\n    while factor <= n {\n        while n % factor == 0 {\n            factorization.append(factor)\n\
    \            n /= factor\n            counter += 1\n        }\n        factor\
    \ += 1\n    }\n    if n > 1 {\n        factorization.append(n)\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2e0morz3.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationCountMax = Int()\n    var factorizationCountMaxIndex = 0\n\
    \    var factorizationCountMaxValue = 0\n    var factorizationCountMaxValueIndex\
    \ = 0\n    var factorizationCountMaxValueValue = 0\n    var factorizationCountMaxValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValue = 0\n    var factorizationCountMaxValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = 0\n    var factorizationCountMaxValueValueValueValueValue = 0\n    var factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi7g0gzen.swift:19:9: error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmpi7g0gzen.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmpi7g0gzen.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmpi7g0gzen.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmpi7g0gzen.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmpi7g0gzen.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmpi7g0gzen.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmpi7g0gzen.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmpi7g0gzen.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmpi7g0gzen.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = 0\n        ^\n/tmp/tmpi7g0gzen.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = 0\n        ^\n/tmp/tmpi7g0gzen.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationCountIndex = 0\n    var factorizationIndexMax\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountIndexMax = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMin = Int(sqrt(Double(n)))\n    var factorizationCountIndexMin\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMaxInt = Int(sqrt(Double(n)))\n\
    \    var factorizationCountIndexMaxInt = Int(sqrt(Double(n)))\n    var factorizationIndexMinInt\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountIndexMinInt = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMaxDouble = Int(sqrt(Double(n)))\n    var factorizationCountIndexMaxDouble\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMinDouble = Int(sqrt(Double(n)))\n\
    \    var factorizationCountIndexMinDouble = Int(sqrt(Double(n)))\n    var factorizationIndexMaxDoubleInt\
    \ = Int(sqrt(Double(n)))\n    var factorizationCountIndexMaxDoubleInt = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMinDoubleInt = Int(sqrt(Double(n)))\n    var factorizationCountIndexMinDoubleInt\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMaxDoubleDouble = Int(sqrt(Double(n)))\n\
    \    var factorizationCountIndexMaxDoubleDouble = Int(sqrt(Double(n)))\n    var\
    \ factorizationIndexMinDoubleDouble = Int(sqrt(Double(n)))\n    var factorizationCountIndexMinDoubleDouble\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMaxDoubleDoubleInt = Int(sqrt(Double(n)))\n\
    \    var factorizationCountIndexMaxDoubleDoubleInt = Int(sqrt(Double(n)))\n  \
    \  var factorizationIndexMinDoubleDoubleInt = Int(sqrt(Double(n)))\n    var factorizationCountIndexMinDoubleDoubleInt\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMaxDoubleDoubleDouble = Int(sqrt(Double(n)))\n\
    \    var factorizationCountIndexMaxDoubleDoubleDouble = Int(sqrt(Double(n)))\n\
    \    var factorizationIndexMinDoubleDoubleDouble = Int(sqrt(Double(n)))\n    var\
    \ factorizationCountIndexMinDoubleDoubleDouble = Int(sqrt(Double(n)))\n    var\
    \ factorizationIndexMaxDoubleDoubleDoubleInt = Int(sqrt(Double(n)))\n    var factorizationCountIndexMaxDoubleDoubleDoubleInt\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMinDoubleDoubleDoubleInt =\
    \ Int(sqrt(Double(n)))\n    var factorizationCountIndexMinDoubleDoubleDoubleInt\
    \ = Int(sqrt(Double(n)))\n    var factorizationIndexMaxDoubleDoubleDoubleDouble\
    \ = Int(sqrt(Double(n)))\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcekl8xyl.swift:10:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationIndexMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n/tmp/tmpcekl8xyl.swift:11:42: error: cannot find 'sqrt' in scope\n\
    \    var factorizationCountIndexMax = Int(sqrt(Double(n)))\n                 \
    \                        ^~~~\n/tmp/tmpcekl8xyl.swift:12:37: error: cannot find\
    \ 'sqrt' in scope\n    var factorizationIndexMin = Int(sqrt(Double(n)))\n    \
    \                                ^~~~\n/tmp/tmpcekl8xyl.swift:13:42: error: cannot\
    \ find 'sqrt' in scope\n    var factorizationCountIndexMin = Int(sqrt(Double(n)))\n\
    \                                         ^~~~\n/tmp/tmpcekl8xyl.swift:14:40:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexMaxInt = Int(sqrt(Double(n)))\n\
    \                                       ^~~~\n/tmp/tmpcekl8xyl.swift:15:45: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountIndexMaxInt = Int(sqrt(Double(n)))\n\
    \                                            ^~~~\n/tmp/tmpcekl8xyl.swift:16:40:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexMinInt = Int(sqrt(Double(n)))\n\
    \                                       ^~~~\n/tmp/tmpcekl8xyl.swift:17:45: error:\
    \ cannot find 'sqrt' in scope\n    var factorizationCountIndexMinInt = Int(sqrt(Double(n)))\n\
    \                                            ^~~~\n/tmp/tmpcekl8xyl.swift:18:43:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexMaxDouble = Int(sqrt(Double(n)))\n\
    \                                          ^~~~\n/tmp/tmpcekl8xyl.swift:19:48:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountIndexMaxDouble\
    \ = Int(sqrt(Double(n)))\n                                               ^~~~\n\
    /tmp/tmpcekl8xyl.swift:20:43: error: cannot find 'sqrt' in scope\n    var factorizationIndexMinDouble\
    \ = Int(sqrt(Double(n)))\n                                          ^~~~\n/tmp/tmpcekl8xyl.swift:21:48:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountIndexMinDouble\
    \ = Int(sqrt(Double(n)))\n                                               ^~~~\n\
    /tmp/tmp"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var primeFactorizationIndex = [Int]()\n\
    \    var primeFactorizationIndexCount = [Int]()\n    var primeFactorizationIndexCountMax\
    \ = Int()\n    var primeFactorizationIndexCountMaxIndex = Int()\n    var primeFactorizationIndexCountMin\
    \ = Int()\n    var primeFactorizationIndexCountMinIndex = Int()\n    var primeFactorizationIndexCountMaxValue\
    \ = Int()\n    var primeFactorizationIndexCountMinValue = Int()\n    var primeFactorizationIndexCountMaxValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMinValueIndex = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValue = Int()\n    var primeFactorizationIndexCountMinValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueIndex = Int()\n  \
    \  var primeFactorizationIndexCountMinValueValueIndex = Int()\n    var primeFactorizationIndexCountMaxValueValueValue\
    \ = Int()\n    var primeFactorizationIndexCountMinValueValueValue = Int()\n  \
    \  var primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n    var primeFactorizationIndexCountMaxValueValueValueValue = Int()\n\
    \    var primeFactorizationIndexCountMinValueValueValueValue = Int()\n    var\
    \ primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n    var primeFactorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps9n_9mq1.swift:29:9: error: invalid redeclaration of 'primeFactorizationIndexCountMaxValueValueValueIndex'\n\
    \    var primeFactorizationIndexCountMaxValueValueValueIndex = Int()\n       \
    \ ^\n/tmp/tmps9n_9mq1.swift:25:9: note: 'primeFactorizationIndexCountMaxValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:30:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueIndex'\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:26:9: note: 'primeFactorizationIndexCountMinValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:31:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueValue'\n    var primeFactorizationIndexCountMaxValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:27:9: note: 'primeFactorizationIndexCountMaxValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:32:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueValue'\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:28:9: note: 'primeFactorizationIndexCountMinValueValueValueValue'\
    \ previously declared here\n    var primeFactorizationIndexCountMinValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:33:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMaxValueValueValueIndex'\n    var primeFactorizationIndexCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:25:9: note: 'primeFactorizationIndexCountMaxValueValueValueIndex'\
    \ previously declared here\n    var primeFactorizationIndexCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmps9n_9mq1.swift:34:9: error: invalid redeclaration\
    \ of 'primeFactorizationIndexCountMinValueValueValueIndex'\n    var "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationProduct\
    \ = 1\n    var factorizationIsPrime = true\n    var factorizationIsPrimeSum =\
    \ 0\n    var factorizationIsPrimeProduct = 1\n    var factorizationIsPrimeIndex\
    \ = 0\n    var factorizationIsPrimeSumIndex = 0\n    var factorizationIsPrimeProductIndex\
    \ = 0\n    var factorizationIsPrimeSumProduct = 1\n    var factorizationIsPrimeProductSum\
    \ = 0\n    var factorizationIsPrimeProductSumIndex = 0\n    var factorizationIsPrimeProductSumProduct\
    \ = 1\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n    var factorizationIsPrimeProductSumProductIndex = 0\n    var factorizationIsPrimeProductSumProductIndex\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5x2qdzkv.swift:22:9: error: invalid redeclaration of 'factorizationIsPrimeProductSumProductIndex'\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:21:9:\
    \ note: 'factorizationIsPrimeProductSumProductIndex' previously declared here\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationIsPrimeProductSumProductIndex'\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:21:9:\
    \ note: 'factorizationIsPrimeProductSumProductIndex' previously declared here\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationIsPrimeProductSumProductIndex'\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:21:9:\
    \ note: 'factorizationIsPrimeProductSumProductIndex' previously declared here\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationIsPrimeProductSumProductIndex'\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:21:9:\
    \ note: 'factorizationIsPrimeProductSumProductIndex' previously declared here\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationIsPrimeProductSumProductIndex'\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:21:9:\
    \ note: 'factorizationIsPrimeProductSumProductIndex' previously declared here\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationIsPrimeProductSumProductIndex'\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/tmp/tmp5x2qdzkv.swift:21:9:\
    \ note: 'factorizationIsPrimeProductSumProductIndex' previously declared here\n\
    \    var factorizationIsPrimeProductSumProductIndex = 0\n        ^\n/t"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactorization = [Int]()\n    var primeFactorizationCount\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var\
    \ isPrimeCountSum = [Int]()\n    var isPrimeSum = [Int]()\n    var isPrimeSumCount\
    \ = [Int]()\n    var isPrimeSumCountSum = [Int]()\n    var isPrimeSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSum = [Int]()\n    var isPrimeSumCountSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSum = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSum = [Int]()\n  \
    \  var isPrimeSumCountSumCountSumCountSumCountSumCount = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSum\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCount =\
    \ [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = [Int]()\n    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpspzoi3c3.swift:35:9: error: type annotation missing in pattern\n\
    \    var isPrimeSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = 0\n    var factorizationIndexMaxCount\
    \ = 0\n    var factorizationIndexMaxCountMax = 0\n    var factorizationIndexMaxCountMax2\
    \ = 0\n    var factorizationIndexMaxCountMax3 = 0\n    var factorizationIndexMaxCountMax4\
    \ = 0\n    var factorizationIndexMaxCountMax5 = 0\n    var factorizationIndexMaxCountMax6\
    \ = 0\n    var factorizationIndexMaxCountMax7 = 0\n    var factorizationIndexMaxCountMax8\
    \ = 0\n    var factorizationIndexMaxCountMax9 = 0\n    var factorizationIndexMaxCountMax10\
    \ = 0\n    var factorizationIndexMaxCountMax11 = 0\n    var factorizationIndexMaxCountMax12\
    \ = 0\n    var factorizationIndexMaxCountMax13 = 0\n    var factorizationIndexMaxCountMax14\
    \ = 0\n    var factorizationIndexMaxCountMax15 = 0\n    var factorizationIndexMaxCountMax16\
    \ = 0\n    var factorizationIndexMaxCountMax17 = 0\n    var factorizationIndexMaxCountMax18\
    \ = 0\n    var factorizationIndexMaxCountMax19 = 0\n    var factorizationIndexMaxCountMax20\
    \ = 0\n    var factorizationIndexMaxCountMax21 = 0\n    var factorizationIndexMaxCountMax22\
    \ = 0\n    var factorizationIndexMaxCountMax23 = 0\n    var factorizationIndexMaxCountMax24\
    \ = 0\n    var factorizationIndexMaxCountMax25 = 0\n    var factorizationIndexMaxCountMax26\
    \ = 0\n    var factorizationIndexMaxCountMax27 = 0\n    var factorizationIndexMaxCountMax28\
    \ = 0\n    var factorizationIndexMaxCountMax29 = 0\n    var factorizationIndexMaxCountMax30\
    \ = 0\n    var factorizationIndexMaxCountMax31 = 0\n    var factorizationIndexMaxCountMax32\
    \ = 0\n    var factorizationIndexMaxCountMax33 = 0\n    var factorizationIndexMaxCountMax34\
    \ = 0\n    var factorizationIndexMaxCountMax35 = 0\n    var factorizationIndexMaxCountMax36\
    \ = 0\n    var factorizationIndexMaxCountMax37 = 0\n    var factorizationIndexMaxCountMax38\
    \ = 0\n    var factorizationIndexMaxCountMax39 = 0\n    var factorizationIndexMaxCountMax40\
    \ = 0\n    var factorizationIndexMaxCountMax41 = 0\n    var factorizationIndexMaxCountMax42\
    \ = 0\n    var factorizationIndexMaxCountMax43 = 0\n    var factorizationIndexMaxCountMax44\
    \ = 0\n    var factorizationIndexMaxCountMax45 = 0\n    var factorizationIndexMaxCountMax46\
    \ = 0\n    var factorizationIndexMaxCountMax47 = 0\n    var factorizationIndexMaxCountMax48\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxstp4tbh.swift:6:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpxstp4tbh.swift:7:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpxstp4tbh.swift:8:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxstp4tbh.swift:9:9:\
    \ warning: initialization of variable 'factorizationIndexMax' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationIndexMax\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxstp4tbh.swift:10:9: warning:\
    \ initialization of variable 'factorizationIndexMaxCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationIndexMaxCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxstp4tbh.swift:11:9:\
    \ warning: initialization of variable 'factorizationIndexMaxCountMax' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationIndexMaxCountMax\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxstp4tbh.swift:12:9:\
    \ warning: initialization of variable 'factorizationIndexMaxCountMax2' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationIndexMaxCountMax2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxstp4tbh.swift:13:9:\
    \ warning: initialization of variable 'factorizationIndexMaxCountMax3' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var factorizationIndexMaxCountMax3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpxstp4tbh.swift:14:9:\
    \ warning: initialization of variable 'factorizationIndexMaxCountMax4' was never\
    \ used; consider replacing with assignment to '_' or removi"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n)\n \
    \   for factor in factorization {\n        factors.append(factor)\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbhx1g8ss.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexCount = 0\n    var factorizationIndexCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin2 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin3\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin4 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin5 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin6\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin7 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin8 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin9\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin10 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin11 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin12\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin13 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin14 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin15\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin16 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin17 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin18\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin19 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin20 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin21\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin22 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin23 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin24\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin25 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin26 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin27\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin28 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin29 = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin30\
    \ = Int(floor(sqrt(Double(n))))\n    var factorizationIndexCountMin31 = Int(floor(sqrt(Double(n))))\n\
    \    var factorizationIndexCountMin32 = Int(floor(sqrt(Double(n))))\n    var factorizationIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqvmj4e1g.swift:10:42: error: cannot find 'ceil' in scope\n    var\
    \ factorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n                  \
    \                       ^~~~\n/tmp/tmpqvmj4e1g.swift:10:47: error: cannot find\
    \ 'sqrt' in scope\n    var factorizationIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                              ^~~~\n/tmp/tmpqvmj4e1g.swift:11:42:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                         ^~~~~\n/tmp/tmpqvmj4e1g.swift:11:48:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                               ^~~~\n/tmp/tmpqvmj4e1g.swift:12:43:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMin2 = Int(floor(sqrt(Double(n))))\n\
    \                                          ^~~~~\n/tmp/tmpqvmj4e1g.swift:12:49:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexCountMin2 = Int(floor(sqrt(Double(n))))\n\
    \                                                ^~~~\n/tmp/tmpqvmj4e1g.swift:13:43:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMin3 = Int(floor(sqrt(Double(n))))\n\
    \                                          ^~~~~\n/tmp/tmpqvmj4e1g.swift:13:49:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexCountMin3 = Int(floor(sqrt(Double(n))))\n\
    \                                                ^~~~\n/tmp/tmpqvmj4e1g.swift:14:43:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMin4 = Int(floor(sqrt(Double(n))))\n\
    \                                          ^~~~~\n/tmp/tmpqvmj4e1g.swift:14:49:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationIndexCountMin4 = Int(floor(sqrt(Double(n))))\n\
    \                                                ^~~~\n/tmp/tmpqvmj4e1g.swift:15:43:\
    \ error: cannot find 'floor' in scope\n    var factorizationIndexCountMin5 = Int(floor(sqrt(Double(n))))\n\
    \                                          ^~~~~\n/tmp/tmpqvmj4e1g.swift:15:49:\
    \ error: cannot find 'sqrt' in sc"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationCountMax = Int(math.Log2(Double(n)))\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxIntInt = Int(factorizationCountMaxInt)\n\
    \    var factorizationCountMaxIntIntInt = Int(factorizationCountMaxIntInt)\n \
    \   var factorizationCountMaxIntIntIntInt = Int(factorizationCountMaxIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt =\
    \ Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt =\
    \ Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \    var factorizationCountMaxIntIntIntIntInt\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpn3qs2c9l.swift:8:37: error: cannot find 'math' in scope\n    var\
    \ factorizationCountMax = Int(math.Log2(Double(n)))\n                        \
    \            ^~~~\n/tmp/tmpn3qs2c9l.swift:12:49: error: use of local variable\
    \ 'factorizationCountMaxIntIntIntInt' before its declaration\n    var factorizationCountMaxIntIntIntInt\
    \ = Int(factorizationCountMaxIntIntIntInt)\n                                 \
    \               ^\n/tmp/tmpn3qs2c9l.swift:12:9: note: 'factorizationCountMaxIntIntIntInt'\
    \ declared here\n    var factorizationCountMaxIntIntIntInt = Int(factorizationCountMaxIntIntIntInt)\n\
    \        ^\n/tmp/tmpn3qs2c9l.swift:13:52: error: use of local variable 'factorizationCountMaxIntIntIntIntIntInt'\
    \ before its declaration\n    var factorizationCountMaxIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntInt)\n\
    \                                                   ^\n/tmp/tmpn3qs2c9l.swift:14:9:\
    \ note: 'factorizationCountMaxIntIntIntIntIntInt' declared here\n    var factorizationCountMaxIntIntIntIntIntInt\
    \ = Int(factorizationCountMaxIntIntIntIntIntIntInt)\n        ^\n/tmp/tmpn3qs2c9l.swift:14:55:\
    \ error: use of local variable 'factorizationCountMaxIntIntIntIntIntIntInt' before\
    \ its declaration\n    var factorizationCountMaxIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntInt)\n\
    \                                                      ^\n/tmp/tmpn3qs2c9l.swift:15:9:\
    \ note: 'factorizationCountMaxIntIntIntIntIntIntInt' declared here\n    var factorizationCountMaxIntIntIntIntIntIntInt\
    \ = Int(factorizationCountMaxIntIntIntIntIntIntIntInt)\n        ^\n/tmp/tmpn3qs2c9l.swift:15:58:\
    \ error: use of local variable 'factorizationCountMaxIntIntIntIntIntIntIntInt'\
    \ before its declaration\n    var factorizationCountMaxIntIntIntIntIntIntInt =\
    \ Int(factorizationCountMaxIntIntIntIntIntIntIntInt)\n                       \
    \                                  ^\n/tmp/tmpn3qs2c9l.swift:16:9: note: 'factorizationCountMaxIntIntIntIntIntIntIntInt'\
    \ declared here\n    var factorizationCountMaxIntIntIntIntIntIntIntInt = Int(factorizationCountMaxIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorCount\
    \ = 0\n    var factorizationFactorIndex = 0\n    var factorizationFactorValue\
    \ = 1\n    var factorizationFactorValueCount = 0\n    var factorizationFactorValueIndex\
    \ = 0\n    var factorizationFactorValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n    var factorizationFactorValueValueIndex = 0\n    var factorizationFactorValueValueValue\
    \ = 1\n    var factorizationFactorValueValueCount = 0\n    var factorizationFactorValueValueIndex\
    \ = 0\n    var factorizationFactorValueValueValue = 1\n    var factorizationFactorValueValueCount\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv80qtw_9.swift:19:9: error: invalid redeclaration of 'factorizationFactorValueValueCount'\n\
    \    var factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:16:9:\
    \ note: 'factorizationFactorValueValueCount' previously declared here\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueIndex'\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:17:9:\
    \ note: 'factorizationFactorValueValueIndex' previously declared here\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueValue'\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:18:9:\
    \ note: 'factorizationFactorValueValueValue' previously declared here\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueCount'\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:16:9:\
    \ note: 'factorizationFactorValueValueCount' previously declared here\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueIndex'\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:17:9:\
    \ note: 'factorizationFactorValueValueIndex' previously declared here\n    var\
    \ factorizationFactorValueValueIndex = 0\n        ^\n/tmp/tmpv80qtw_9.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueValue'\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:18:9:\
    \ note: 'factorizationFactorValueValueValue' previously declared here\n    var\
    \ factorizationFactorValueValueValue = 1\n        ^\n/tmp/tmpv80qtw_9.swift:25:9:\
    \ error: invalid redeclaration of 'factorizationFactorValueValueCount'\n    var\
    \ factorizationFactorValueValueCount = 0\n        ^\n/tmp/tmpv80qtw_9.swift:16:9:\
    \ note: 'fac"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var i = 2\n    while i < n {\n        if\
    \ n % i == 0 {\n            factors.append(i)\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n != 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz9w2jd_e.swift:11:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = primeFactors(n)\n    for p in\
    \ primes {\n        if n % p == 0 {\n            factors.append(p)\n         \
    \   n /= p\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7v3b5unh.swift:7:18: error: cannot find 'primeFactors' in scope\n\
    \    var primes = primeFactors(n)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor = 2\n    while factor <=\
    \ n {\n        if n % factor == 0 {\n            factorization = factorization\
    \ + [factor]\n            n /= factor\n        } else {\n            factor +=\
    \ 1\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqxll_t00.swift:11:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    for factor in factorization {\n        factors.append(factor)\n    }\n  \
    \  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps79eomoi.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorsCount = 0\n    var isPrime =\
    \ true\n    var isFactor = false\n    var isFactor2 = false\n    var isFactor3\
    \ = false\n    var isFactor4 = false\n    var isFactor5 = false\n    var isFactor6\
    \ = false\n    var isFactor7 = false\n    var isFactor8 = false\n    var isFactor9\
    \ = false\n    var isFactor10 = false\n    var isFactor11 = false\n    var isFactor12\
    \ = false\n    var isFactor13 = false\n    var isFactor14 = false\n    var isFactor15\
    \ = false\n    var isFactor16 = false\n    var isFactor17 = false\n    var isFactor18\
    \ = false\n    var isFactor19 = false\n    var isFactor20 = false\n    var isFactor21\
    \ = false\n    var isFactor22 = false\n    var isFactor23 = false\n    var isFactor24\
    \ = false\n    var isFactor25 = false\n    var isFactor26 = false\n    var isFactor27\
    \ = false\n    var isFactor28 = false\n    var isFactor29 = false\n    var isFactor30\
    \ = false\n    var isFactor31 = false\n    var isFactor32 = false\n    var isFactor33\
    \ = false\n    var isFactor34 = false\n    var isFactor35 = false\n    var isFactor36\
    \ = false\n    var isFactor37 = false\n    var isFactor38 = false\n    var isFactor39\
    \ = false\n    var isFactor40 = false\n    var isFactor41 = false\n    var isFactor42\
    \ = false\n    var isFactor43 = false\n    var isFactor44 = false\n    var isFactor45\
    \ = false\n    var isFactor46 = false\n    var isFactor47 = false\n    var isFactor48\
    \ = false\n    var isFactor49 = false\n    var isFactor50 = false\n    var isFactor51\
    \ = false\n    var isFactor52 = false\n    var isFactor53 = false\n    var isFactor54\
    \ = false\n    var isFactor55 = false\n    var isFactor56 = false\n    var isFactor57\
    \ = false\n    var isFactor58 = false\n    var isFactor59 = false\n    var isFactor60\
    \ = false\n    var isFactor61 = false\n    var isFactor62 = false\n    var isFactor63\
    \ = false\n    var isFactor64 = false\n    var isFactor65 = false\n    var isFactor66\
    \ = false\n    var isFactor67 = false\n    var isFactor68 = false\n    var isFactor69\
    \ = false\n    var isFactor70 = false\n    var isFactor71 = false\n    var isFactor72\
    \ = false\n    var isFactor73 = false\n    var isFactor74 = false\n    var isFactor75\
    \ = false\n    var isFactor76 = false\n    var isFactor77 = false\n    var isFactor78\
    \ = false\n    var isFactor79 = false\n    var isFactor80\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp79uqior5.swift:88:9: error: type annotation missing in pattern\n\
    \    var isFactor80\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount = 0\n   \
    \ var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n  \
    \  var isPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbrbnf45e.swift:21:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:19:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpbrbnf45e.swift:20:9: note: 'isPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n\
    \        ^\n/tmp/tmpbrbnf45e.swift:26:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpbrbnf45e.swift:24:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpbrbnf45e.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n\
    /tmp/tmpbrbnf45e.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:31:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpbrbnf45e.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpbrbnf45e.swift:32:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previou"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorCount\
    \ = 1\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw6kw4caj.swift:12:9: error: invalid redeclaration of 'factorizationFactorCount'\n\
    \    var factorizationFactorCount = 1\n        ^\n/tmp/tmpw6kw4caj.swift:10:9:\
    \ note: 'factorizationFactorCount' previously declared here\n    var factorizationFactorCount\
    \ = 1\n        ^\n/tmp/tmpw6kw4caj.swift:13:9: error: invalid redeclaration of\
    \ 'factorizationFactorIndex'\n    var factorizationFactorIndex = 0\n        ^\n\
    /tmp/tmpw6kw4caj.swift:11:9: note: 'factorizationFactorIndex' previously declared\
    \ here\n    var factorizationFactorIndex = 0\n        ^\n/tmp/tmpw6kw4caj.swift:14:9:\
    \ error: invalid redeclaration of 'factorizationFactorCount'\n    var factorizationFactorCount\
    \ = 1\n        ^\n/tmp/tmpw6kw4caj.swift:10:9: note: 'factorizationFactorCount'\
    \ previously declared here\n    var factorizationFactorCount = 1\n        ^\n\
    /tmp/tmpw6kw4caj.swift:15:9: error: invalid redeclaration of 'factorizationFactorIndex'\n\
    \    var factorizationFactorIndex = 0\n        ^\n/tmp/tmpw6kw4caj.swift:11:9:\
    \ note: 'factorizationFactorIndex' previously declared here\n    var factorizationFactorIndex\
    \ = 0\n        ^\n/tmp/tmpw6kw4caj.swift:16:9: error: invalid redeclaration of\
    \ 'factorizationFactorCount'\n    var factorizationFactorCount = 1\n        ^\n\
    /tmp/tmpw6kw4caj.swift:10:9: note: 'factorizationFactorCount' previously declared\
    \ here\n    var factorizationFactorCount = 1\n        ^\n/tmp/tmpw6kw4caj.swift:17:9:\
    \ error: invalid redeclaration of 'factorizationFactorIndex'\n    var factorizationFactorIndex\
    \ = 0\n        ^\n/tmp/tmpw6kw4caj.swift:11:9: note: 'factorizationFactorIndex'\
    \ previously declared here\n    var factorizationFactorIndex = 0\n        ^\n\
    /tmp/tmpw6kw4caj.swift:18:9: error: invalid redeclaration of 'factorizationFactorCount'\n\
    \    var factorizationFactorCount = 1\n        ^\n/tmp/tmpw6kw4caj.swift:10:9:\
    \ note: 'factorizationFactorCount' previously declared here\n    var factorizationFactorCount\
    \ = 1\n        ^\n/tmp/tmpw6kw4caj.swift:19:9: error: invalid redeclaration of\
    \ 'factorizationFactorIndex'\n    var factorizationFactorIndex = 0\n        ^\n\
    /tmp/tmpw6kw4caj.swift:11:9: n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationCountMax = Int()\n    var factorizationCountMaxIndex = -1\n\
    \    var factorizationCountMaxValue = Int()\n    var factorizationCountMaxValueIndex\
    \ = -1\n    var factorizationCountMaxValueValue = Int()\n    var factorizationCountMaxValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValue = Int()\n    var factorizationCountMaxValueValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValueValue = Int()\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValueValueValue = Int()\n    var\
    \ factorizationCountMaxValueValueValueValueIndex = -1\n    var factorizationCountMaxValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValueValueIndex = -1\n    var\
    \ factorizationCountMaxValueValueValueValueValue = Int()\n    var factorizationCountMaxValueValueValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValueValueValueValue = Int()\n\
    \    var factorizationCountMaxValueValueValueValueValueIndex = -1\n    var factorizationCountMaxValueValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValueValueValueIndex = -1\n\
    \    var factorizationCountMaxValueValueValueValueValueValueValue = Int()\n  \
    \  var factorizationCountMaxValueValueValueValueValueIndex = -1\n    var factorizationCountMaxValueValueValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValueValueValueValueIndex =\
    \ -1\n    var factorizationCountMaxValueValueValueValueValueValueValue = Int()\n\
    \    var factorizationCountMaxValueValueValueValueValueValueIndex = -1\n    var\
    \ factorizationCountMaxValueValueValueValueValueValueValueValue = Int()\n    var\
    \ factorizationCountMaxValueValueValueValueValueValueIndex = -1\n    var factorizationCountMaxValueValueValueValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValueValueValueValueIndex =\
    \ -1\n    var factorizationCountMaxValueValueValueValueValueValueValueValue =\
    \ Int()\n    var factorizationCountMaxValueValueValueValueValueValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValueValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValueValueValueValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValueValueValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValueValueValueValueValueIndex\
    \ = -1\n    var factorizationCountMaxValueValueValueValueValueValueValueValueValue\
    \ = Int()\n    var factorizationCountMaxValueValueValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1zm_ppu9.swift:19:9: error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp1zm_ppu9.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp1zm_ppu9.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp1zm_ppu9.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp1zm_ppu9.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp1zm_ppu9.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp1zm_ppu9.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp1zm_ppu9.swift:18:9:\
    \ note: 'factorizationCountMaxValueValueValueValueValue' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueValue = Int()\n        ^\n/tmp/tmp1zm_ppu9.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueIndex'\n\
    \    var factorizationCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp1zm_ppu9.swift:17:9:\
    \ note: 'factorizationCountMaxValueValueValueValueIndex' previously declared here\n\
    \    var factorizationCountMaxValueValueValueValueIndex = -1\n        ^\n/tmp/tmp1zm_ppu9.swift:26:9:\
    \ error: invalid redeclaration of 'factorizationCountMaxValueValueValueValueValueValue'\n\
    \    var factorizationCountMaxValueValueValueValueValueValue = Int()\n       \
    \ ^\n/tmp/tmp1zm_ppu9.swift:24:9: note: 'factorizatio"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor: Int\n    var count: Int\
    \ = 0\n    for factor in 2...n {\n        if n % factor == 0 {\n            factorization\
    \ = factorization + [factor]\n            count = count + 1\n        }\n    }\n\
    \    if count > 0 {\n        factorization = factorization + [factor]\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp31cl9sd9.swift:7:9: warning: variable 'factor' was never mutated;\
    \ consider changing to 'let' constant\n    var factor: Int\n    ~~~ ^\n    let\n\
    /tmp/tmp31cl9sd9.swift:16:42: error: variable 'factor' used before being initialized\n\
    \        factorization = factorization + [factor]\n                          \
    \               ^\n/tmp/tmp31cl9sd9.swift:7:9: note: variable defined here\n \
    \   var factor: Int\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = factorization.count\n\
    \    var factorizationIndexMin = 0\n    var factorizationIndexMaxMin = factorizationIndexMax\n\
    \    var factorizationIndexMinMax = factorizationIndexMin\n    var factorizationIndexMinMaxMin\
    \ = factorizationIndexMinMax\n    var factorizationIndexMinMaxMinMax = factorizationIndexMinMaxMin\n\
    \    var factorizationIndexMinMaxMinMaxMin = factorizationIndexMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMin = factorizationIndexMinMaxMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMin = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax =\
    \ factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n \
    \   var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n\
    \    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n\
    \    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpg4aktmkm.swift:16:48: error: use of local variable 'factorizationIndexMinMaxMinMaxMinMax'\
    \ before its declaration\n    var factorizationIndexMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMax\n\
    \                                               ^\n/tmp/tmpg4aktmkm.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMinMax' declared here\n    var factorizationIndexMinMaxMinMaxMinMax\
    \ = factorizationIndexMinMaxMinMaxMinMax\n        ^\n/tmp/tmpg4aktmkm.swift:17:51:\
    \ error: use of local variable 'factorizationIndexMinMaxMinMaxMinMaxMinMax' before\
    \ its declaration\n    var factorizationIndexMinMaxMinMaxMinMaxMin = factorizationIndexMinMaxMinMaxMinMaxMinMax\n\
    \                                                  ^\n/tmp/tmpg4aktmkm.swift:18:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMinMaxMinMax' declared here\n    var factorizationIndexMinMaxMinMaxMinMaxMinMax\
    \ = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax\n        ^\n/tmp/tmpg4aktmkm.swift:18:54:\
    \ error: use of local variable 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ before its declaration\n    var factorizationIndexMinMaxMinMaxMinMaxMinMax =\
    \ factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax\n                         \
    \                            ^\n/tmp/tmpg4aktmkm.swift:20:9: note: 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ declared here\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax\n\
    \        ^\n/tmp/tmpg4aktmkm.swift:19:57: error: use of local variable 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ before its declaration\n    var factorizationIndexMinMaxMinMaxMinMaxMinMaxMin\
    \ = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n                 \
    \                                       ^\n/tmp/tmpg4aktmkm.swift:21:9: note:\
    \ 'factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax' declared here\n   \
    \ var factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = factorizationIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax\n\
    \        ^\n/tmp/tmpg4aktmkm.swift:20:60: error: cannot find 'factorizationI"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var factorization\
    \ = factorizationOf(n)\n    var primeFactorization = factorizationOf(primes[0])\n\
    \    var primeFactorizationIndex = -1\n    var factorizationIndex = -1\n    var\
    \ factorizationIndex2 = -1\n    var factorizationIndex3 = -1\n    var factorizationIndex4\
    \ = -1\n    var factorizationIndex5 = -1\n    var factorizationIndex6 = -1\n \
    \   var factorizationIndex7 = -1\n    var factorizationIndex8 = -1\n    var factorizationIndex9\
    \ = -1\n    var factorizationIndex10 = -1\n    var factorizationIndex11 = -1\n\
    \    var factorizationIndex12 = -1\n    var factorizationIndex13 = -1\n    var\
    \ factorizationIndex14 = -1\n    var factorizationIndex15 = -1\n    var factorizationIndex16\
    \ = -1\n    var factorizationIndex17 = -1\n    var factorizationIndex18 = -1\n\
    \    var factorizationIndex19 = -1\n    var factorizationIndex20 = -1\n    var\
    \ factorizationIndex21 = -1\n    var factorizationIndex22 = -1\n    var factorizationIndex23\
    \ = -1\n    var factorizationIndex24 = -1\n    var factorizationIndex25 = -1\n\
    \    var factorizationIndex26 = -1\n    var factorizationIndex27 = -1\n    var\
    \ factorizationIndex28 = -1\n    var factorizationIndex29 = -1\n    var factorizationIndex30\
    \ = -1\n    var factorizationIndex31 = -1\n    var factorizationIndex32 = -1\n\
    \    var factorizationIndex33 = -1\n    var factorizationIndex34 = -1\n    var\
    \ factorizationIndex35 = -1\n    var factorizationIndex36 = -1\n    var factorizationIndex37\
    \ = -1\n    var factorizationIndex38 = -1\n    var factorizationIndex39 = -1\n\
    \    var factorizationIndex40 = -1\n    var factorizationIndex41 = -1\n    var\
    \ factorizationIndex42 = -1\n    var factorizationIndex43 = -1\n    var factorizationIndex44\
    \ = -1\n    var factorizationIndex45 = -1\n    var factorizationIndex46 = -1\n\
    \    var factorizationIndex47 = -1\n    var factorizationIndex48 = -1\n    var\
    \ factorizationIndex49 = -1\n    var factorizationIndex50 = -1\n    var factorizationIndex51\
    \ = -1\n    var factorizationIndex52 = -1\n    var factorizationIndex53 = -1\n\
    \    var factorizationIndex54 = -1\n    var factorizationIndex55 = -1\n    var\
    \ factorizationIndex56 = -1\n    var factorizationIndex57 = -1\n    var factorizationIndex58\
    \ = -1\n    var factorizationIndex59 = -1\n    var factorizationIndex60 = -1\n\
    \    var factorizationIndex61 = -1\n    var factorizationIndex62 = -1\n    var\
    \ factorizationIndex63 = -1\n    var factorizationIndex64 = -1\n    var factorizationIndex65\
    \ = -1\n    var factorizationIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3lbbwwqa.swift:8:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n\
    /tmp/tmp3lbbwwqa.swift:9:30: error: cannot find 'factorizationOf' in scope\n \
    \   var primeFactorization = factorizationOf(primes[0])\n                    \
    \         ^~~~~~~~~~~~~~~\n/tmp/tmp3lbbwwqa.swift:76:9: error: type annotation\
    \ missing in pattern\n    var factorizationIndex\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var isPrime = [Bool]()\n    var isPrimeCount = 0\n    var isPrimeCountMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMin = Int(sqrt(Double(n)))\n   \
    \ var isPrimeCountMaxMin = Int(sqrt(Double(n)))\n    var isPrimeCountMinMax =\
    \ Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMax = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMin\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMinMaxMinMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n \
    \   var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n)))\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = Int(sqrt(Double(n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxb3ao3kg.swift:33:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpxb3ao3kg.swift:32:87: note: to match this opening '('\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = Int(sqrt(Double(n\n                                                      \
    \                                ^\n/tmp/tmpxb3ao3kg.swift:10:31: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n     \
    \                         ^~~~\n/tmp/tmpxb3ao3kg.swift:11:31: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeCountMin = Int(sqrt(Double(n)))\n          \
    \                    ^~~~\n/tmp/tmpxb3ao3kg.swift:12:34: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeCountMaxMin = Int(sqrt(Double(n)))\n              \
    \                   ^~~~\n/tmp/tmpxb3ao3kg.swift:13:34: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeCountMinMax = Int(sqrt(Double(n)))\n              \
    \                   ^~~~\n/tmp/tmpxb3ao3kg.swift:14:37: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeCountMinMaxMin = Int(sqrt(Double(n)))\n           \
    \                         ^~~~\n/tmp/tmpxb3ao3kg.swift:15:40: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeCountMinMaxMinMax = Int(sqrt(Double(n)))\n \
    \                                      ^~~~\n/tmp/tmpxb3ao3kg.swift:16:43: error:\
    \ cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMin = Int(sqrt(Double(n)))\n\
    \                                          ^~~~\n/tmp/tmpxb3ao3kg.swift:17:46:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMax =\
    \ Int(sqrt(Double(n)))\n                                             ^~~~\n/tmp/tmpxb3ao3kg.swift:18:49:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMaxMin\
    \ = Int(sqrt(Double(n)))\n                                                ^~~~\n\
    /tmp/tmpxb3ao3kg.swift:19:52: error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMinMaxMinMaxMinMax\
    \ = Int(sqrt(Double(n)))\n                                                   ^~~~\n\
    /tmp/tmpxb3ao3kg.swift:20:55: error: cannot find 'sqrt' in scope\n    var isPrimeCountMinMaxMi"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = 0\n    var factorizationCount = 0\n    var isPrime\
    \ = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount\
    \ = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvxkaw8tk.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpvxkaw8tk.swift:20:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpvxkaw8tk.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpvxkaw8tk.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n\
    \        ^\n/tmp/tmpvxkaw8tk.swift:28:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpvxkaw8tk.swift:26:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmpvxkaw8tk.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpvxkaw8tk.swift:27:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpvxkaw8tk.swift:37:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactorization\
    \ = [Int]()\n    var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n\
    \    var isPrimeCount = [Int]()\n    var isPrimeFactorization = [Bool]()\n   \
    \ var isPrimeFactorizationCount = [Int]()\n    var isPrimeFactorizationPrime =\
    \ [Bool]()\n    var isPrimeFactorizationPrimeCount = [Int]()\n    var isPrimeFactorizationPrimeFactorization\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationCount = [Int]()\n\
    \    var isPrimeFactorizationPrimeFactorizationPrime = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = [Bool]()\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpktbq4vjn.swift:27:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpktbq4vjn.swift:25:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpktbq4vjn.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpktbq4vjn.swift:29:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpktbq4vjn.swift:33:9: error: type annotation missing\
    \ in pattern\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactors\
    \ = [1]\n    var factorization = [1]\n    var primeFactorsCount = 1\n    var factorizationCount\
    \ = 1\n    var isPrime = true\n    var isFactorization = true\n    var isPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrime = true\n    var isPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationFactorization = true\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorization = true\n   \
    \ var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = true\n \
    \   var isPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8ly2ozjg.swift:24:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:23:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:27:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:27:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp8ly2ozjg.swift:32:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared h"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor = 1\n    var prime = 1\n\
    \    var isPrime = true\n    var isFactor = false\n    var isFactor2 = false\n\
    \    var isFactor3 = false\n    var isFactor4 = false\n    var isFactor5 = false\n\
    \    var isFactor6 = false\n    var isFactor7 = false\n    var isFactor8 = false\n\
    \    var isFactor9 = false\n    var isFactor10 = false\n    var isFactor11 = false\n\
    \    var isFactor12 = false\n    var isFactor13 = false\n    var isFactor14 =\
    \ false\n    var isFactor15 = false\n    var isFactor16 = false\n    var isFactor17\
    \ = false\n    var isFactor18 = false\n    var isFactor19 = false\n    var isFactor20\
    \ = false\n    var isFactor21 = false\n    var isFactor22 = false\n    var isFactor23\
    \ = false\n    var isFactor24 = false\n    var isFactor25 = false\n    var isFactor26\
    \ = false\n    var isFactor27 = false\n    var isFactor28 = false\n    var isFactor29\
    \ = false\n    var isFactor30 = false\n    var isFactor31 = false\n    var isFactor32\
    \ = false\n    var isFactor33 = false\n    var isFactor34 = false\n    var isFactor35\
    \ = false\n    var isFactor36 = false\n    var isFactor37 = false\n    var isFactor38\
    \ = false\n    var isFactor39 = false\n    var isFactor40 = false\n    var isFactor41\
    \ = false\n    var isFactor42 = false\n    var isFactor43 = false\n    var isFactor44\
    \ = false\n    var isFactor45 = false\n    var isFactor46 = false\n    var isFactor47\
    \ = false\n    var isFactor48 = false\n    var isFactor49 = false\n    var isFactor50\
    \ = false\n    var isFactor51 = false\n    var isFactor52 = false\n    var isFactor53\
    \ = false\n    var isFactor54 = false\n    var isFactor55 = false\n    var isFactor56\
    \ = false\n    var isFactor57 = false\n    var isFactor58 = false\n    var isFactor59\
    \ = false\n    var isFactor60 = false\n    var isFactor61 = false\n    var isFactor62\
    \ = false\n    var isFactor63 = false\n    var isFactor64 = false\n    var isFactor65\
    \ = false\n    var isFactor66 = false\n    var isFactor67 = false\n    var isFactor68\
    \ = false\n    var isFactor69 = false\n    var isFactor70 = false\n    var isFactor71\
    \ = false\n    var isFactor72 = false\n    var isFactor73 = false\n    var isFactor74\
    \ = false\n    var isFactor75 = false\n    var isFactor76 = false\n    var isFactor77\
    \ = false\n    var isFactor78 = false\n    var isFactor79 = false\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgk4a0wta.swift:89:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpgk4a0wta.swift:6:9: warning: variable 'factorization' was never used;\
    \ consider replacing with '_' or removing it\n    var factorization: [Int] = []\n\
    \        ^~~~~~~~~~~~~\n        _\n/tmp/tmpgk4a0wta.swift:7:9: warning: initialization\
    \ of variable 'factor' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var factor = 1\n    ~~~~^~~~~~\n    _\n/tmp/tmpgk4a0wta.swift:8:9:\
    \ warning: initialization of variable 'prime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime = 1\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmpgk4a0wta.swift:9:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmpgk4a0wta.swift:10:9: warning:\
    \ initialization of variable 'isFactor' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isFactor = false\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpgk4a0wta.swift:11:9: warning: initialization of variable 'isFactor2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isFactor2 = false\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpgk4a0wta.swift:12:9:\
    \ warning: initialization of variable 'isFactor3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isFactor3 = false\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpgk4a0wta.swift:13:9: warning: initialization of variable 'isFactor4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isFactor4 = false\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpgk4a0wta.swift:14:9:\
    \ warning: initialization of variable 'isFactor5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isFactor5 = false\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpgk4a0wta.swift:15:9: warning: initialization of variable 'isFactor6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isFactor6 = false\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpgk4a0wta.swift:16:9:\
    \ war"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationMax = Int(sqrt(Double(n)))\n  \
    \  var factorizationMin = factorizationMax\n    var factorizationMaxIndex = 0\n\
    \    var factorizationMinIndex = 0\n    var factorizationMaxValue = n\n    var\
    \ factorizationMinValue = n\n    var factorizationMaxValueIndex = 0\n    var factorizationMinValueIndex\
    \ = 0\n    var factorizationMaxValueValue = n\n    var factorizationMinValueValue\
    \ = 0\n    var factorizationMaxValueValueIndex = 0\n    var factorizationMinValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValue = n\n    var factorizationMinValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValueIndex\
    \ = 0\n    var factorizationMaxValueValueValueValue = n\n    var factorizationMinValueValueValueValue\
    \ = 0\n    var factorizationMaxValueValueValueIndex = 0\n    var factorizationMinValueValueValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_u0360w_.swift:9:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmp_u0360w_.swift:27:9: error: invalid redeclaration of 'factorizationMaxValueValueValueIndex'\n\
    \    var factorizationMaxValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:23:9:\
    \ note: 'factorizationMaxValueValueValueIndex' previously declared here\n    var\
    \ factorizationMaxValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:28:9:\
    \ error: invalid redeclaration of 'factorizationMinValueValueValueIndex'\n   \
    \ var factorizationMinValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:24:9:\
    \ note: 'factorizationMinValueValueValueIndex' previously declared here\n    var\
    \ factorizationMinValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:29:9:\
    \ error: invalid redeclaration of 'factorizationMaxValueValueValueValue'\n   \
    \ var factorizationMaxValueValueValueValue = n\n        ^\n/tmp/tmp_u0360w_.swift:25:9:\
    \ note: 'factorizationMaxValueValueValueValue' previously declared here\n    var\
    \ factorizationMaxValueValueValueValue = n\n        ^\n/tmp/tmp_u0360w_.swift:30:9:\
    \ error: invalid redeclaration of 'factorizationMinValueValueValueValue'\n   \
    \ var factorizationMinValueValueValueValue = 0\n        ^\n/tmp/tmp_u0360w_.swift:26:9:\
    \ note: 'factorizationMinValueValueValueValue' previously declared here\n    var\
    \ factorizationMinValueValueValueValue = 0\n        ^\n/tmp/tmp_u0360w_.swift:31:9:\
    \ error: invalid redeclaration of 'factorizationMaxValueValueValueIndex'\n   \
    \ var factorizationMaxValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:23:9:\
    \ note: 'factorizationMaxValueValueValueIndex' previously declared here\n    var\
    \ factorizationMaxValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:32:9:\
    \ error: invalid redeclaration of 'factorizationMinValueValueValueIndex'\n   \
    \ var factorizationMinValueValueValueIndex = 0\n        ^\n/tmp/tmp_u0360w_.swift:24:9:\
    \ note: 'factorizationMinValueValueValueIndex' previously declared here\n    var\
    \ factorizationMinValueValueValueIndex = 0\n        "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factor = 1\n    var prime = 1\n\
    \    var factorizationCount = 0\n    var isPrime = true\n    while isPrime {\n\
    \        factorizationCount += 1\n        if n % factor == 0 {\n            factorization[factorizationCount]\
    \ = factor\n            n /= factor\n        } else {\n            isPrime = false\n\
    \        }\n        factor += 1\n    }\n    factorization[factorizationCount]\
    \ = n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpad5exx6x.swift:15:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var i = 2\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            i += 1\n            factors.append(i)\n      \
    \  }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp4s6tqd4t/tmp4s6tqd4t.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b59cf1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b599e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b599e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b599e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4s6tqd4t                        0x000055ccee39e4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b7b59edd460 __libc_start_main +
    245

    6    tmp4s6tqd4t                        0x000055ccee39e119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOf(n)\n \
    \   for i in factorization {\n        factors.append(i)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpb2c3e8me.swift:7:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationCountMax = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax2 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin2 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax3 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin3 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax4 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin4 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax5 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin5 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax6 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin6 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax7 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin7 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax8 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin8 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax9 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMin9 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n    var factorizationCountMax10 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpy4ksmdv4.swift:9:38: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationCountMax = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                     ^~~~\n/tmp/tmpy4ksmdv4.swift:10:38:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMin = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                     ^~~~\n/tmp/tmpy4ksmdv4.swift:11:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMax2 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:12:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMin2 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:13:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMax3 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:14:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMin3 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:15:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMax4 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:16:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMin4 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:17:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMax5 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                                      ^~~~\n/tmp/tmpy4ksmdv4.swift:18:39:\
    \ error: cannot find 'sqrt' in scope\n    var factorizationCountMin5 = Int((sqrt(Double(n))).truncatingRemainder(dividingBy:\
    \ Double(2)))\n                          "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexCount = 0\n    var factorizationIndexCountMax\
    \ = Int(log2(factorizationIndexCount))\n    var factorizationIndexCountMin = factorizationIndexCount\
    \ - factorizationIndexCountMax\n    var factorizationIndexCountMinMax = factorizationIndexCount\
    \ - factorizationIndexCountMin\n    var factorizationIndexCountMinMax2 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin\n    var factorizationIndexCountMinMax3\
    \ = factorizationIndexCount - factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n    var factorizationIndexCountMinMax4 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n    var factorizationIndexCountMinMax5 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\n\
    \    var factorizationIndexCountMinMax6 = factorizationIndexCount - factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n    var factorizationIndexCountMinMax7 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n    var factorizationIndexCountMinMax8 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n    var factorizationIndexCountMinMax9 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpytqii9dt.swift:10:42: error: cannot find 'log2' in scope\n    var\
    \ factorizationIndexCountMax = Int(log2(factorizationIndexCount))\n          \
    \                               ^~~~\n/tmp/tmpytqii9dt.swift:13:66: error: binary\
    \ operator '-' cannot be applied to operands of type 'Int' and 'Duration'\n  \
    \  var factorizationIndexCountMinMax2 = factorizationIndexCount - factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n                                         ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpytqii9dt.swift:13:66:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (ContinuousClock.Instant, Duration), (Duration, Duration), (Int, Int), (SuspendingClock.Instant,\
    \ Duration)\n    var factorizationIndexCountMinMax2 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin\n                \
    \                                                 ^\n/tmp/tmpytqii9dt.swift:16:42:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    var factorizationIndexCountMinMax5\
    \ = factorizationIndexCount - factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin\n                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpytqii9dt.swift:17:42: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    var factorizationIndexCountMinMax6 = factorizationIndexCount\
    \ - factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factorizationIndexCountMin * factorizationIndexCountMin\
    \ * factorizationIndexCountMin * factoriza"
  stdout: ''
  timestamp: 1660009602
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primeFactorization: [Int] = []\n   \
    \ var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var factorization\
    \ = factorizationOf(n)\n    \n    for factor in factorization {\n        if factor\
    \ == 1 {\n            factors.append(factor)\n        } else {\n            primeFactorization[primeFactorizationIndex]\
    \ = factor\n            primeFactorizationIndex += 1\n        }\n    }\n    \n\
    \    for factor in factors {\n        factorizationIndex = 0\n        for prime\
    \ in primeFactorization {\n            if factor == prime {\n                factors.append(factor)\n\
    \                factors.append(prime)\n                factorizationIndex +=\
    \ 1\n                primeFactorizationIndex += 1\n                break\n   \
    \         }\n        }\n    }\n    \n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbadzm30v.swift:10:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var currentFactorization = [1]\n    var currentFactorizationCount\
    \ = [Int]()\n    var currentFactorizationIndex = 0\n    var currentFactorizationIndexCount\
    \ = 0\n    var currentFactorizationIndexCountMax = 0\n    var currentFactorizationIndexCountMaxIndex\
    \ = 0\n    var currentFactorizationIndexCountMin = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n    var currentFactorizationIndexCountMaxIndex = 0\n    var currentFactorizationIndexCountMinIndex\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmtsg2b44.swift:17:9: error: invalid redeclaration of 'currentFactorizationIndexCountMaxIndex'\n\
    \    var currentFactorizationIndexCountMaxIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:14:9:\
    \ note: 'currentFactorizationIndexCountMaxIndex' previously declared here\n  \
    \  var currentFactorizationIndexCountMaxIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCountMinIndex'\n \
    \   var currentFactorizationIndexCountMinIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:16:9:\
    \ note: 'currentFactorizationIndexCountMinIndex' previously declared here\n  \
    \  var currentFactorizationIndexCountMinIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:19:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCountMaxIndex'\n \
    \   var currentFactorizationIndexCountMaxIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:14:9:\
    \ note: 'currentFactorizationIndexCountMaxIndex' previously declared here\n  \
    \  var currentFactorizationIndexCountMaxIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:20:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCountMinIndex'\n \
    \   var currentFactorizationIndexCountMinIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:16:9:\
    \ note: 'currentFactorizationIndexCountMinIndex' previously declared here\n  \
    \  var currentFactorizationIndexCountMinIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCountMaxIndex'\n \
    \   var currentFactorizationIndexCountMaxIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:14:9:\
    \ note: 'currentFactorizationIndexCountMaxIndex' previously declared here\n  \
    \  var currentFactorizationIndexCountMaxIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:22:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCountMinIndex'\n \
    \   var currentFactorizationIndexCountMinIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:16:9:\
    \ note: 'currentFactorizationIndexCountMinIndex' previously declared here\n  \
    \  var currentFactorizationIndexCountMinIndex = 0\n        ^\n/tmp/tmpmtsg2b44.swift:23:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndexCountMaxInd"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var currentFactorizationIndex = 0\n    var currentFactorizationCount\
    \ = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex =\
    \ 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n \
    \   var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n  \
    \  var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n   \
    \ var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var\
    \ currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization\
    \ = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization =\
    \ [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n\
    \    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n  \
    \  var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n   \
    \ var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex =\
    \ 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n \
    \   var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n  \
    \  var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n   \
    \ var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var\
    \ currentFactorization = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization\
    \ = [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization =\
    \ [1]\n    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n\
    \    var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n  \
    \  var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n   \
    \ var currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var\
    \ currentFactorizationIndex = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex =\
    \ 0\n    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n \
    \   var currentFactorization = [1]\n    var currentFactorizationIndex = 0\n  \
    \  var currentFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjukp1cpx.swift:12:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = 0\n        ^\n/tmp/tmpjukp1cpx.swift:9:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpjukp1cpx.swift:13:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:11:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:14:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndex'\n    var currentFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmpjukp1cpx.swift:9:9: note: 'currentFactorizationIndex' previously\
    \ declared here\n    var currentFactorizationIndex = 0\n        ^\n/tmp/tmpjukp1cpx.swift:15:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:11:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:16:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndex'\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpjukp1cpx.swift:9:9: note: 'currentFactorizationIndex'\
    \ previously declared here\n    var currentFactorizationIndex = 0\n        ^\n\
    /tmp/tmpjukp1cpx.swift:17:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:11:9: note:\
    \ 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:18:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndex'\n    var currentFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmpjukp1cpx.swift:9:9: note: 'currentFactorizationIndex' previously\
    \ declared here\n    var currentFactorizationIndex = 0\n        ^\n/tmp/tmpjukp1cpx.swift:19:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpjukp1cpx.swift:11:9: note: 'currentFactorization'\
    \ pr"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var primeFactorization: [Int] = []\n\
    \    var primeFactorizationCount = 0\n    var factorizationCount = 0\n    var\
    \ factorizationCountMax = Int(sqrt(Double(n)))\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorizationCountMaxFloat = Float(factorizationCountMax)\n    var factorizationCountMaxInt\
    \ = Int(factorizationCountMax)\n    var factorizationCountMaxDouble = Double(factorizationCountMax)\n\
    \    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5eg6fvpi.swift:10:37: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationCountMax = Int(sqrt(Double(n)))\n                             \
    \       ^~~~\n/tmp/tmp5eg6fvpi.swift:43:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationProduct = 1\n    var factorizationSumProduct\
    \ = 0\n    var factorizationProductSum = 0\n    var factorizationProductSumProduct\
    \ = 0\n    var factorizationProductSumProductProduct = 0\n    var factorizationProductSumProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProductProduct = 0\n    var factorizationProductSumProductProductProduct\
    \ = 0\n    var factorizationProductSumProductProduct\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpux8vdfqa.swift:14:9: error: invalid redeclaration of 'factorizationProductSumProductProduct'\n\
    \    var factorizationProductSumProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:13:9:\
    \ note: 'factorizationProductSumProductProduct' previously declared here\n   \
    \ var factorizationProductSumProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:16:9:\
    \ error: invalid redeclaration of 'factorizationProductSumProductProductProduct'\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:15:9:\
    \ note: 'factorizationProductSumProductProductProduct' previously declared here\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:17:9:\
    \ error: invalid redeclaration of 'factorizationProductSumProductProductProduct'\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:15:9:\
    \ note: 'factorizationProductSumProductProductProduct' previously declared here\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:18:9:\
    \ error: invalid redeclaration of 'factorizationProductSumProductProductProduct'\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:15:9:\
    \ note: 'factorizationProductSumProductProductProduct' previously declared here\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:19:9:\
    \ error: invalid redeclaration of 'factorizationProductSumProductProductProduct'\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:15:9:\
    \ note: 'factorizationProductSumProductProductProduct' previously declared here\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationProductSumProductProductProduct'\n\
    \    var factorizationProductSumProductProductProduct = 0\n        ^\n/tmp/tmpux8vdfqa.swift:15:9:\
    \ note: 'factorizationProductSumProductProductProduct' previously declared here\n\
    \    var factorizationProductSumProductProductProd"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationSumCount\
    \ = 0\n    var factorizationSumIndex = 0\n    var factorizationSumCountIndex =\
    \ 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var factorizationSumCountIndex = 0\n    var factorizationSumCountIndex\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpygtko89m.swift:71:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpygtko89m.swift:13:9: error: invalid redeclaration of 'factorizationSumCountIndex'\n\
    \    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpygtko89m.swift:12:9:\
    \ note: 'factorizationSumCountIndex' previously declared here\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpygtko89m.swift:14:9: error: invalid redeclaration of\
    \ 'factorizationSumCountIndex'\n    var factorizationSumCountIndex = 0\n     \
    \   ^\n/tmp/tmpygtko89m.swift:12:9: note: 'factorizationSumCountIndex' previously\
    \ declared here\n    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpygtko89m.swift:15:9:\
    \ error: invalid redeclaration of 'factorizationSumCountIndex'\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpygtko89m.swift:12:9: note: 'factorizationSumCountIndex'\
    \ previously declared here\n    var factorizationSumCountIndex = 0\n        ^\n\
    /tmp/tmpygtko89m.swift:16:9: error: invalid redeclaration of 'factorizationSumCountIndex'\n\
    \    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpygtko89m.swift:12:9:\
    \ note: 'factorizationSumCountIndex' previously declared here\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpygtko89m.swift:17:9: error: invalid redeclaration of\
    \ 'factorizationSumCountIndex'\n    var factorizationSumCountIndex = 0\n     \
    \   ^\n/tmp/tmpygtko89m.swift:12:9: note: 'factorizationSumCountIndex' previously\
    \ declared here\n    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpygtko89m.swift:18:9:\
    \ error: invalid redeclaration of 'factorizationSumCountIndex'\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpygtko89m.swift:12:9: note: 'factorizationSumCountIndex'\
    \ previously declared here\n    var factorizationSumCountIndex = 0\n        ^\n\
    /tmp/tmpygtko89m.swift:19:9: error: invalid redeclaration of 'factorizationSumCountIndex'\n\
    \    var factorizationSumCountIndex = 0\n        ^\n/tmp/tmpygtko89m.swift:12:9:\
    \ note: 'factorizationSumCountIndex' previously declared here\n    var factorizationSumCountIndex\
    \ = 0\n        ^\n/tmp/tmpygtko89m.swift:20:9: error: in"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var factorization = factorizationOfNumber(n)\n\
    \    for factor in factorization {\n        factors.append(factor)\n    }\n  \
    \  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps79eomoi.swift:7:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009304
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeFactors = [Bool]()\n \
    \   var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCountMax = Int()\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValue\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgdmi7t4g.swift:21:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:22:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:20:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:20:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueIndex' previously declared here\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:26:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValue'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValue = Int()\n        ^\n/tmp/tmpgdmi7t4g.swift:20:9:\
    \ note: 'isPrimeFactorsCountMaxValueValueValueValue' previously declared here\n\
    \    var isPrimeFactorsC"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [n]\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = factorization.count\
    \ - 1\n    var factorizationIndexMin = 0\n    var factorizationIndexMaxMin = 0\n\
    \    var factorizationIndexMinMax = 0\n    var factorizationIndexMaxMinMin = 0\n\
    \    var factorizationIndexMinMaxMin = 0\n    var factorizationIndexMinMaxMinMax\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n    var factorizationIndexMinMaxMinMaxMin\
    \ = 0\n    var factorizationIndexMinMaxMinMaxMin = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz8tj4uk5.swift:17:9: error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n\
    \    var factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMin' previously declared here\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:18:9:\
    \ error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMin' previously declared here\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:19:9:\
    \ error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMin' previously declared here\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMin' previously declared here\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:21:9:\
    \ error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMin' previously declared here\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:22:9:\
    \ error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMaxMin' previously declared here\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationIndexMinMaxMinMaxMin'\n    var\
    \ factorizationIndexMinMaxMinMaxMin = 0\n        ^\n/tmp/tmpz8tj4uk5.swift:16:9:\
    \ note: 'factorizationIndexMinMaxMinMa"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factor = 1\n    var isPrime =\
    \ true\n    var isFactor = false\n    var isPrimeFactorization = false\n    var\
    \ isPrimeFactorization2 = false\n    var isPrimeFactorization3 = false\n    var\
    \ isPrimeFactorization4 = false\n    var isPrimeFactorization5 = false\n    var\
    \ isPrimeFactorization6 = false\n    var isPrimeFactorization7 = false\n    var\
    \ isPrimeFactorization8 = false\n    var isPrimeFactorization9 = false\n    var\
    \ isPrimeFactorization10 = false\n    var isPrimeFactorization11 = false\n   \
    \ var isPrimeFactorization12 = false\n    var isPrimeFactorization13 = false\n\
    \    var isPrimeFactorization14 = false\n    var isPrimeFactorization15 = false\n\
    \    var isPrimeFactorization16 = false\n    var isPrimeFactorization17 = false\n\
    \    var isPrimeFactorization18 = false\n    var isPrimeFactorization19 = false\n\
    \    var isPrimeFactorization20 = false\n    var isPrimeFactorization21 = false\n\
    \    var isPrimeFactorization22 = false\n    var isPrimeFactorization23 = false\n\
    \    var isPrimeFactorization24 = false\n    var isPrimeFactorization25 = false\n\
    \    var isPrimeFactorization26 = false\n    var isPrimeFactorization27 = false\n\
    \    var isPrimeFactorization28 = false\n    var isPrimeFactorization29 = false\n\
    \    var isPrimeFactorization30 = false\n    var isPrimeFactorization31 = false\n\
    \    var isPrimeFactorization32 = false\n    var isPrimeFactorization33 = false\n\
    \    var isPrimeFactorization34 = false\n    var isPrimeFactorization35 = false\n\
    \    var isPrimeFactorization36 = false\n    var isPrimeFactorization37 = false\n\
    \    var isPrimeFactorization38 = false\n    var isPrimeFactorization39 = false\n\
    \    var isPrimeFactorization40 = false\n    var isPrimeFactorization41 = false\n\
    \    var isPrimeFactorization42 = false\n    var isPrimeFactorization43 = false\n\
    \    var isPrimeFactorization44 = false\n    var isPrimeFactorization45 = false\n\
    \    var isPrimeFactorization46 = false\n    var isPrimeFactorization47 = false\n\
    \    var isPrimeFactorization48 = false\n    var isPrimeFactorization49 = false\n\
    \    var isPrimeFactorization50 = false\n    var isPrimeFactorization51 = false\n\
    \    var isPrimeFactorization52 = false\n    var isPrimeFactorization53 = false\n\
    \    var isPrimeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppqe49ynk.swift:63:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactor\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ primeFactorization: [Int] = [1]\n    var primeFactorizationIndex = 0\n    var\
    \ isPrime: Bool = false\n    var isPrimeIndex = 0\n    var isPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationIndex = 0\n    var isPrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimeFactorizationIndex = 0\n    var\
    \ isPrimePrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorizationIndex = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmph081zyh0.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n        ^\n/tmp/tmph081zyh0.swift:20:9:\
    \ note: 'isPrimePrimePrimePrimePrimeFactorization' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n        ^\n/tmp/tmph081zyh0.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \      ^\n/tmp/tmph081zyh0.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmph081zyh0.swift:35:9: error: type annotation\
    \ missing in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePri\n     \
    \   ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var primes = [Int]()\n    var primeFactorization:\
    \ [Int] = []\n    var primeFactorizationCount = 0\n    var isPrime: Bool = false\n\
    \    var isPrimeCount = 0\n    var isPrimeFactorization: Bool = false\n    var\
    \ isPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrime: Bool = false\n\
    \    var isPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationCount = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrime: Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization: Bool\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpa0rwe9v4.swift:36:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpa0rwe9v4.swift:27:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpa0rwe9v4.swift:25:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpa0rwe9v4.swift:28:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n        ^\n/tmp/tmpa0rwe9v4.swift:26:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n        ^\n/tmp/tmpa0rwe9v4.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpa0rwe9v4.swift:31:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpa0rwe9v4.swift:34:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime:\
    \ Bool = false\n        ^\n/tmp/tmpa0rwe9v4.swift:32:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizatio"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationIndex2 = 0\n    var factorizationIndex3\
    \ = 0\n    var factorizationIndex4 = 0\n    var factorizationIndex5 = 0\n    var\
    \ factorizationIndex6 = 0\n    var factorizationIndex7 = 0\n    var factorizationIndex8\
    \ = 0\n    var factorizationIndex9 = 0\n    var factorizationIndex10 = 0\n   \
    \ var factorizationIndex11 = 0\n    var factorizationIndex12 = 0\n    var factorizationIndex13\
    \ = 0\n    var factorizationIndex14 = 0\n    var factorizationIndex15 = 0\n  \
    \  var factorizationIndex16 = 0\n    var factorizationIndex17 = 0\n    var factorizationIndex18\
    \ = 0\n    var factorizationIndex19 = 0\n    var factorizationIndex20 = 0\n  \
    \  var factorizationIndex21 = 0\n    var factorizationIndex22 = 0\n    var factorizationIndex23\
    \ = 0\n    var factorizationIndex24 = 0\n    var factorizationIndex25 = 0\n  \
    \  var factorizationIndex26 = 0\n    var factorizationIndex27 = 0\n    var factorizationIndex28\
    \ = 0\n    var factorizationIndex29 = 0\n    var factorizationIndex30 = 0\n  \
    \  var factorizationIndex31 = 0\n    var factorizationIndex32 = 0\n    var factorizationIndex33\
    \ = 0\n    var factorizationIndex34 = 0\n    var factorizationIndex35 = 0\n  \
    \  var factorizationIndex36 = 0\n    var factorizationIndex37 = 0\n    var factorizationIndex38\
    \ = 0\n    var factorizationIndex39 = 0\n    var factorizationIndex40 = 0\n  \
    \  var factorizationIndex41 = 0\n    var factorizationIndex42 = 0\n    var factorizationIndex43\
    \ = 0\n    var factorizationIndex44 = 0\n    var factorizationIndex45 = 0\n  \
    \  var factorizationIndex46 = 0\n    var factorizationIndex47 = 0\n    var factorizationIndex48\
    \ = 0\n    var factorizationIndex49 = 0\n    var factorizationIndex50 = 0\n  \
    \  var factorizationIndex51 = 0\n    var factorizationIndex52 = 0\n    var factorizationIndex53\
    \ = 0\n    var factorizationIndex54 = 0\n    var factorizationIndex55 = 0\n  \
    \  var factorizationIndex56 = 0\n    var factorizationIndex57 = 0\n    var factorizationIndex58\
    \ = 0\n    var factorizationIndex59 = 0\n    var factorizationIndex60 = 0\n  \
    \  var factorizationIndex61 = 0\n    var factorizationIndex62 = 0\n    var factorizationIndex63\
    \ = 0\n    var factorizationIndex64 = 0\n    var factorizationIndex65 = 0\n  \
    \  var factorizationIndex66 = 0\n    var factorizationIndex67 = 0\n    var factorizationIndex68\
    \ = 0\n    var factorizationIndex69 = 0\n    var factorizationIndex70 = 0\n  \
    \  var factorizationIndex71 = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvtjflssv.swift:79:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = 0\n    var factorizationCount = 0\n    var isPrime\
    \ = true\n    var isPrimeCount = 0\n    var isPrimeFactorization = true\n    var\
    \ isPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrime = true\n  \
    \  var isPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeCount = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeFactorization = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime =\
    \ true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt8nzl87a.swift:28:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpt8nzl87a.swift:26:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpt8nzl87a.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n        ^\n/tmp/tmpt8nzl87a.swift:27:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n        ^\n/tmp/tmpt8nzl87a.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpt8nzl87a.swift:31:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpt8nzl87a.swift:34:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpt8nzl87a.swift:32:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactor"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = [Int]()\n \
    \   var factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorIndex\
    \ = 0\n    var factorizationFactorIndexMax = 0\n    var factorizationFactorIndexMaxIndex\
    \ = 0\n    var factorizationFactorIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n    var factorizationFactorIndexMaxIndexMaxIndexMax\
    \ = 0\n    var factorizationFactorIndexMaxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpykxu74ot.swift:14:9: error: invalid redeclaration of 'factorizationFactorIndexMaxIndexMax'\n\
    \    var factorizationFactorIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:13:9:\
    \ note: 'factorizationFactorIndexMaxIndexMax' previously declared here\n    var\
    \ factorizationFactorIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:16:9:\
    \ error: invalid redeclaration of 'factorizationFactorIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:15:9:\
    \ note: 'factorizationFactorIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:17:9:\
    \ error: invalid redeclaration of 'factorizationFactorIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:15:9:\
    \ note: 'factorizationFactorIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:18:9:\
    \ error: invalid redeclaration of 'factorizationFactorIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:15:9:\
    \ note: 'factorizationFactorIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:19:9:\
    \ error: invalid redeclaration of 'factorizationFactorIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:15:9:\
    \ note: 'factorizationFactorIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:20:9:\
    \ error: invalid redeclaration of 'factorizationFactorIndexMaxIndexMaxIndexMax'\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpykxu74ot.swift:15:9:\
    \ note: 'factorizationFactorIndexMaxIndexMaxIndexMax' previously declared here\n\
    \    var factorizationFactorIndexMaxIndexMaxIndexMax = 0\n        ^\n/tmp/tmpyk"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = []\n    var factorizationCount\
    \ = 0\n    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationCount = 0\n\n    for factor in factorization(n)\
    \ {\n        if factor == 1 {\n            factors.append(factor)\n          \
    \  factorizationCount += 1\n        } else {\n            if isPrime {\n     \
    \           factors.append(factor)\n                factorizationCount += 1\n\
    \            } else {\n                factorizationCount += factor\n        \
    \    }\n        }\n    }\n\n    if isPrime {\n        factors.append(n)\n    \
    \    factorizationCount += 1\n    }\n\n    if isPrimeCount > 1 {\n        isPrimeFactorization\
    \ = true\n    }\n\n    if isPrimeFactorizationCount > 1 {\n        isPrimeFactorization\
    \ = true\n    }\n\n    if isPrimeFactorization {\n        factorizationCount +=\
    \ isPrimeFactorizationCount\n    }\n\n    if factorizationCount > 1 {\n      \
    \  factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount > 1\
    \ {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > 1 {\n        factorizationCount += isPrimeCount\n    }\n\n    if factorizationCount\
    \ > \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp09agpjq8.swift:114:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp09agpjq8.swift:14:19: error: cannot call value of non-function type\
    \ '[Int]'\n    for factor in factorization(n) {\n                  ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationIndex = 0\n    var factorizationSum = 0\n    var factorizationProduct\
    \ = 1\n    var factorizationProductSum = 0\n    var factorizationProductSum2 =\
    \ 0\n    var factorizationProductSum3 = 0\n    var factorizationProductSum4 =\
    \ 0\n    var factorizationProductSum5 = 0\n    var factorizationProductSum6 =\
    \ 0\n    var factorizationProductSum7 = 0\n    var factorizationProductSum8 =\
    \ 0\n    var factorizationProductSum9 = 0\n    var factorizationProductSum10 =\
    \ 0\n    var factorizationProductSum11 = 0\n    var factorizationProductSum12\
    \ = 0\n    var factorizationProductSum13 = 0\n    var factorizationProductSum14\
    \ = 0\n    var factorizationProductSum15 = 0\n    var factorizationProductSum16\
    \ = 0\n    var factorizationProductSum17 = 0\n    var factorizationProductSum18\
    \ = 0\n    var factorizationProductSum19 = 0\n    var factorizationProductSum20\
    \ = 0\n    var factorizationProductSum21 = 0\n    var factorizationProductSum22\
    \ = 0\n    var factorizationProductSum23 = 0\n    var factorizationProductSum24\
    \ = 0\n    var factorizationProductSum25 = 0\n    var factorizationProductSum26\
    \ = 0\n    var factorizationProductSum27 = 0\n    var factorizationProductSum28\
    \ = 0\n    var factorizationProductSum29 = 0\n    var factorizationProductSum30\
    \ = 0\n    var factorizationProductSum31 = 0\n    var factorizationProductSum32\
    \ = 0\n    var factorizationProductSum33 = 0\n    var factorizationProductSum34\
    \ = 0\n    var factorizationProductSum35 = 0\n    var factorizationProductSum36\
    \ = 0\n    var factorizationProductSum37 = 0\n    var factorizationProductSum38\
    \ = 0\n    var factorizationProductSum39 = 0\n    var factorizationProductSum40\
    \ = 0\n    var factorizationProductSum41 = 0\n    var factorizationProductSum42\
    \ = 0\n    var factorizationProductSum43 = 0\n    var factorizationProductSum44\
    \ = 0\n    var factorizationProductSum45 = 0\n    var factorizationProductSum46\
    \ = 0\n    var factorizationProductSum47 = 0\n    var factorizationProductSum48\
    \ = 0\n    var factorizationProductSum49 = 0\n    var factorizationProductSum50\
    \ = 0\n    var factorizationProductSum51 = 0\n    var factorizationProductSum52\
    \ = 0\n    var factorizationProductSum53 = 0\n    var factorizationProductSum54\
    \ = 0\n    var factorizationProductSum55 = 0\n    var factorizationProductSum56\
    \ = 0\n    var factorizationProductSum57 = 0\n    var factorizationProductSum58\
    \ = 0\n    var factorizationProductSum59 = 0\n    var factorizationProductSum60\
    \ = 0\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe2lumced.swift:71:9: error: type annotation missing in pattern\n\
    \    var factor\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = []\n    var factorizationCount\
    \ = 0\n    var factorizationIndex = 0\n    var currentFactorizationIndex = 0\n\
    \    var currentFactorizationCount = 0\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorizationIndex = -1\n    var currentFactorizationCount = 1\n\
    \    var currentFactorization = [1]\n    var currentFactorizationIndex = -1\n\
    \    var currentFactorizationCount = 1\n    var currentFactorization = [1]\n \
    \   var currentFactorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfodhzyu2.swift:13:9: error: invalid redeclaration of 'currentFactorizationIndex'\n\
    \    var currentFactorizationIndex = -1\n        ^\n/tmp/tmpfodhzyu2.swift:10:9:\
    \ note: 'currentFactorizationIndex' previously declared here\n    var currentFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmpfodhzyu2.swift:14:9: error: invalid redeclaration of\
    \ 'currentFactorizationCount'\n    var currentFactorizationCount = 1\n       \
    \ ^\n/tmp/tmpfodhzyu2.swift:11:9: note: 'currentFactorizationCount' previously\
    \ declared here\n    var currentFactorizationCount = 0\n        ^\n/tmp/tmpfodhzyu2.swift:15:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpfodhzyu2.swift:12:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization = [1]\n        ^\n/tmp/tmpfodhzyu2.swift:16:9:\
    \ error: invalid redeclaration of 'currentFactorizationIndex'\n    var currentFactorizationIndex\
    \ = -1\n        ^\n/tmp/tmpfodhzyu2.swift:10:9: note: 'currentFactorizationIndex'\
    \ previously declared here\n    var currentFactorizationIndex = 0\n        ^\n\
    /tmp/tmpfodhzyu2.swift:17:9: error: invalid redeclaration of 'currentFactorizationCount'\n\
    \    var currentFactorizationCount = 1\n        ^\n/tmp/tmpfodhzyu2.swift:11:9:\
    \ note: 'currentFactorizationCount' previously declared here\n    var currentFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpfodhzyu2.swift:18:9: error: invalid redeclaration of\
    \ 'currentFactorization'\n    var currentFactorization = [1]\n        ^\n/tmp/tmpfodhzyu2.swift:12:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization\
    \ = [1]\n        ^\n/tmp/tmpfodhzyu2.swift:19:9: error: invalid redeclaration\
    \ of 'currentFactorizationIndex'\n    var currentFactorizationIndex = -1\n   \
    \     ^\n/tmp/tmpfodhzyu2.swift:10:9: note: 'currentFactorizationIndex' previously\
    \ declared here\n    var currentFactorizationIndex = 0\n        ^\n/tmp/tmpfodhzyu2.swift:20:9:\
    \ error: invalid redeclaration of 'currentFactorizationCount'\n    var currentFactorizationCount\
    \ = 1\n        ^\n/tmp/tmpfodhzyu2.swift:11:9: "
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var factorizationCount = 0\n    var primeFactorizationCount = 0\n    var factorizationIndex\
    \ = 0\n    var primeFactorizationIndex = 0\n    var factorizationArray = [Int]()\n\
    \    var primeFactorizationArray = [Int]()\n    var factorizationArrayCount =\
    \ 0\n    var primeFactorizationArrayCount = 0\n    var factorizationArrayIndex\
    \ = 0\n    var primeFactorizationArrayIndex = 0\n    var factorizationArrayElement\
    \ = 0\n    var primeFactorizationArrayElement = 0\n    var factorizationArrayElementCount\
    \ = 0\n    var primeFactorizationArrayElementCount = 0\n    var factorizationArrayElementIndex\
    \ = 0\n    var primeFactorizationArrayElementIndex = 0\n    var factorizationArrayElementValue\
    \ = 0\n    var primeFactorizationArrayElementValue = 0\n    var factorizationArrayElementValueCount\
    \ = 0\n    var primeFactorizationArrayElementValueCount = 0\n    var factorizationArrayElementValueIndex\
    \ = 0\n    var primeFactorizationArrayElementValueIndex = 0\n    var factorizationArrayElementValueValue\
    \ = 0\n    var primeFactorizationArrayElementValueValue = 0\n    var factorizationArrayElementValueValueCount\
    \ = 0\n    var primeFactorizationArrayElementValueValueCount = 0\n    var factorizationArrayElementValueValueIndex\
    \ = 0\n    var primeFactorizationArrayElementValueValueIndex = 0\n    var factorizationArrayElementValueValueValue\
    \ = 0\n    var primeFactorizationArrayElementValueValueValue = 0\n    var factorizationArrayElementValueValueValueCount\
    \ = 0\n    var primeFactorizationArrayElementValueValueValueCount = 0\n    var\
    \ factorizationArrayElementValueValueValueIndex = 0\n    var primeFactorizationArrayElementValueValueIndex\
    \ = 0\n    var factorizationArrayElementValueValueValueValue = 0\n    var primeFactorizationArrayElementValueValueValueValue\
    \ = 0\n    var factorizationArrayElementValueValueValueCount = 0\n    var primeFactorizationArrayElementValueValueValueCount\
    \ = 0\n    var factorizationArrayElementValueValueValueIndex = 0\n    var primeFactorizationArrayElementValueValueIndex\
    \ = 0\n    var factorizationArrayElementValueValueValueValue = 0\n    var primeFactorizationArrayElementValueValueValueValue\
    \ = 0\n    var factorizationArrayElementValueValueValueCount = 0\n    var primeFactorizationArrayElementValueValueValueCount\
    \ = 0\n    var factorizationArrayElementValueValueValueIndex = 0\n    var primeFactorizationArrayElementValueValueIndex\
    \ = 0\n    var factorizationArrayElementValueValueValueValue = 0\n    var primeFactorizationArrayElementValueValueValueValue\
    \ = 0\n    var factorizationArrayElementValueValueValueCount = 0\n    var primeFactorizationArrayElementValueValueValueCount\
    \ = 0\n    var factorizationArrayElementValueValue\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpf2j94tvp.swift:41:9: error: invalid redeclaration of 'primeFactorizationArrayElementValueValueIndex'\n\
    \    var primeFactorizationArrayElementValueValueIndex = 0\n        ^\n/tmp/tmpf2j94tvp.swift:35:9:\
    \ note: 'primeFactorizationArrayElementValueValueIndex' previously declared here\n\
    \    var primeFactorizationArrayElementValueValueIndex = 0\n        ^\n/tmp/tmpf2j94tvp.swift:44:9:\
    \ error: invalid redeclaration of 'factorizationArrayElementValueValueValueCount'\n\
    \    var factorizationArrayElementValueValueValueCount = 0\n        ^\n/tmp/tmpf2j94tvp.swift:38:9:\
    \ note: 'factorizationArrayElementValueValueValueCount' previously declared here\n\
    \    var factorizationArrayElementValueValueValueCount = 0\n        ^\n/tmp/tmpf2j94tvp.swift:45:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayElementValueValueValueCount'\n\
    \    var primeFactorizationArrayElementValueValueValueCount = 0\n        ^\n/tmp/tmpf2j94tvp.swift:39:9:\
    \ note: 'primeFactorizationArrayElementValueValueValueCount' previously declared\
    \ here\n    var primeFactorizationArrayElementValueValueValueCount = 0\n     \
    \   ^\n/tmp/tmpf2j94tvp.swift:46:9: error: invalid redeclaration of 'factorizationArrayElementValueValueValueIndex'\n\
    \    var factorizationArrayElementValueValueValueIndex = 0\n        ^\n/tmp/tmpf2j94tvp.swift:40:9:\
    \ note: 'factorizationArrayElementValueValueValueIndex' previously declared here\n\
    \    var factorizationArrayElementValueValueValueIndex = 0\n        ^\n/tmp/tmpf2j94tvp.swift:47:9:\
    \ error: invalid redeclaration of 'primeFactorizationArrayElementValueValueIndex'\n\
    \    var primeFactorizationArrayElementValueValueIndex = 0\n        ^\n/tmp/tmpf2j94tvp.swift:35:9:\
    \ note: 'primeFactorizationArrayElementValueValueIndex' previously declared here\n\
    \    var primeFactorizationArrayElementValueValueIndex = 0\n        ^\n/tmp/tmpf2j94tvp.swift:48:9:\
    \ error: invalid redeclaration of 'factorizationArrayElementValueValueValueValue'\n\
    \    var factorizationArrayElementValueValueValueValue = 0\n        ^\n/tmp/tmpf2j94tvp.swift:42:9:\
    \ note: 'factorizationArrayElementValueValueValueValue' pre"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationFactor = 1\n    var factorizationFactorIndex\
    \ = 0\n    var factorizationFactorIndex2 = 0\n    var factorizationFactorIndex3\
    \ = 0\n    var factorizationFactorIndex4 = 0\n    var factorizationFactorIndex5\
    \ = 0\n    var factorizationFactorIndex6 = 0\n    var factorizationFactorIndex7\
    \ = 0\n    var factorizationFactorIndex8 = 0\n    var factorizationFactorIndex9\
    \ = 0\n    var factorizationFactorIndex10 = 0\n    var factorizationFactorIndex11\
    \ = 0\n    var factorizationFactorIndex12 = 0\n    var factorizationFactorIndex13\
    \ = 0\n    var factorizationFactorIndex14 = 0\n    var factorizationFactorIndex15\
    \ = 0\n    var factorizationFactorIndex16 = 0\n    var factorizationFactorIndex17\
    \ = 0\n    var factorizationFactorIndex18 = 0\n    var factorizationFactorIndex19\
    \ = 0\n    var factorizationFactorIndex20 = 0\n    var factorizationFactorIndex21\
    \ = 0\n    var factorizationFactorIndex22 = 0\n    var factorizationFactorIndex23\
    \ = 0\n    var factorizationFactorIndex24 = 0\n    var factorizationFactorIndex25\
    \ = 0\n    var factorizationFactorIndex26 = 0\n    var factorizationFactorIndex27\
    \ = 0\n    var factorizationFactorIndex28 = 0\n    var factorizationFactorIndex29\
    \ = 0\n    var factorizationFactorIndex30 = 0\n    var factorizationFactorIndex31\
    \ = 0\n    var factorizationFactorIndex32 = 0\n    var factorizationFactorIndex33\
    \ = 0\n    var factorizationFactorIndex34 = 0\n    var factorizationFactorIndex35\
    \ = 0\n    var factorizationFactorIndex36 = 0\n    var factorizationFactorIndex37\
    \ = 0\n    var factorizationFactorIndex38 = 0\n    var factorizationFactorIndex39\
    \ = 0\n    var factorizationFactorIndex40 = 0\n    var factorizationFactorIndex41\
    \ = 0\n    var factorizationFactorIndex42 = 0\n    var factorizationFactorIndex43\
    \ = 0\n    var factorizationFactorIndex44 = 0\n    var factorizationFactorIndex45\
    \ = 0\n    var factorizationFactorIndex46 = 0\n    var factorizationFactorIndex47\
    \ = 0\n    var factorizationFactorIndex48 = 0\n    var factorizationFactorIndex49\
    \ = 0\n    var factorizationFactorIndex50 = 0\n    var factorizationFactorIndex51\
    \ = 0\n    var factorizationFactorIndex52 = 0\n    var factorizationFactorIndex53\
    \ = 0\n    var factorizationFactorIndex54 = 0\n    var factorizationFactorIndex55\
    \ = 0\n    var factorizationFactorIndex56 = 0\n    var factorizationFactorIndex57\
    \ = 0\n    var factorizationFactorIndex58 = 0\n    var factorizationFactorIndex59\
    \ = 0\n    var factorizationFactorIndex60 = 0\n    var factorizationFactorIndex61\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvuz3jbfl.swift:6:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:7:9:\
    \ warning: initialization of variable 'factorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationCount\
    \ = 1\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:8:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpvuz3jbfl.swift:9:9: warning: initialization of variable 'factorizationFactor'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationFactor = 1\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:10:9:\
    \ warning: initialization of variable 'factorizationFactorIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationFactorIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:11:9: warning:\
    \ initialization of variable 'factorizationFactorIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationFactorIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:12:9:\
    \ warning: initialization of variable 'factorizationFactorIndex3' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationFactorIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:13:9:\
    \ warning: initialization of variable 'factorizationFactorIndex4' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationFactorIndex4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpvuz3jbfl.swift:14:9:\
    \ warning: initialization of variable 'factorizationFactorIndex5' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationFactor"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var primeFactorization = [Int]()\n \
    \   var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n  \
    \  var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization = [1]\n    var primeFactorizationCount = 1\n    var factorizationCount\
    \ = 1\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationCount = [Int]()\n    var factorizationCount = 0\n \
    \   var primeFactorizationCount = 0\n    var primeFactorization = [1]\n    var\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpumh253yu.swift:10:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmpumh253yu.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:11:9: error: invalid redeclaration\
    \ of 'primeFactorization'\n    var primeFactorization = [1]\n        ^\n/tmp/tmpumh253yu.swift:7:9:\
    \ note: 'primeFactorization' previously declared here\n    var primeFactorization\
    \ = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:12:9: error: invalid redeclaration\
    \ of 'factorization'\n    var factorization = [1]\n        ^\n/tmp/tmpumh253yu.swift:6:9:\
    \ note: 'factorization' previously declared here\n    var factorization = [Int]()\n\
    \        ^\n/tmp/tmpumh253yu.swift:13:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 1\n        ^\n/tmp/tmpumh253yu.swift:8:9: note:\
    \ 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:14:9: error: invalid redeclaration\
    \ of 'factorizationCount'\n    var factorizationCount = 1\n        ^\n/tmp/tmpumh253yu.swift:9:9:\
    \ note: 'factorizationCount' previously declared here\n    var factorizationCount\
    \ = 0\n        ^\n/tmp/tmpumh253yu.swift:15:9: error: invalid redeclaration of\
    \ 'primeFactorization'\n    var primeFactorization = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:7:9:\
    \ note: 'primeFactorization' previously declared here\n    var primeFactorization\
    \ = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:16:9: error: invalid redeclaration\
    \ of 'factorization'\n    var factorization = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:6:9:\
    \ note: 'factorization' previously declared here\n    var factorization = [Int]()\n\
    \        ^\n/tmp/tmpumh253yu.swift:17:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = [Int]()\n        ^\n/tmp/tmpumh253yu.swift:8:9:\
    \ note: 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpumh2"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ primeFactorization: [Int] = [1]\n    var primeFactorizationIndex = 0\n    var\
    \ primeFactorizationCount = 0\n    var isPrime: Bool = false\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime: Bool = false\n    var isPrimePrimeCount = 0\n   \
    \ var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount = 0\n  \
    \  var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz2vgiphp.swift:38:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpz2vgiphp.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz2vgiphp.swift:20:9:\
    \ note: 'isPrimePrimePrimePrimePrimeCount' previously declared here\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpz2vgiphp.swift:23:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz2vgiphp.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n\
    \        ^\n/tmp/tmpz2vgiphp.swift:28:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz2vgiphp.swift:26:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpz2vgiphp.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n\
    /tmp/tmpz2vgiphp.swift:27:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz2vgiphp.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz2vgiphp.swift:31:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpz2vgiphp.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpz2vgiphp.swift:32:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrime"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization = [Int]()\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationIndexMax = factorization.count\n\
    \    var factorizationIndexMin = 1\n    var factorizationIndexMaxMin = factorizationIndexMax\n\
    \    var factorizationIndexMaxMinMin = factorizationIndexMaxMin\n    var factorizationIndexMaxMinMinMin\
    \ = factorizationIndexMaxMinMin\n    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \    var factorizationIndexMaxMinMinMin\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgvck280c.swift:15:9: error: invalid redeclaration of 'factorizationIndexMaxMinMinMinMin'\n\
    \    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMin\n\
    \        ^\n/tmp/tmpgvck280c.swift:14:9: note: 'factorizationIndexMaxMinMinMinMin'\
    \ previously declared here\n    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMin\n\
    \        ^\n/tmp/tmpgvck280c.swift:22:45: error: use of local variable 'factorizationIndexMaxMinMinMinMinMin'\
    \ before its declaration\n    var factorizationIndexMaxMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \                                            ^\n/tmp/tmpgvck280c.swift:23:9: note:\
    \ 'factorizationIndexMaxMinMinMinMinMin' declared here\n    var factorizationIndexMaxMinMinMinMinMin\
    \ = factorizationIndexMaxMinMinMinMinMin\n        ^\n/tmp/tmpgvck280c.swift:23:48:\
    \ error: use of local variable 'factorizationIndexMaxMinMinMinMinMin' before its\
    \ declaration\n    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMin\n\
    \                                               ^\n/tmp/tmpgvck280c.swift:23:9:\
    \ note: 'factorizationIndexMaxMinMinMinMinMin' declared here\n    var factorizationIndexMaxMinMinMinMinMin\
    \ = factorizationIndexMaxMinMinMinMinMin\n        ^\n/tmp/tmpgvck280c.swift:32:48:\
    \ error: cannot find 'factorizationIndexMaxMinMinMinMinMinMin' in scope\n    var\
    \ factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMinMin\n\
    \                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgvck280c.swift:33:48: error: cannot find 'factorizationIndexMaxMinMinMinMinMinMin'\
    \ in scope\n    var factorizationIndexMaxMinMinMinMinMin = factorizationIndexMaxMinMinMinMinMinMin\n\
    \                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgvck280c.swift:35:9: error: type annotation missing in pattern\n    var\
    \ factorizationIndexMaxMinMinMin\n        ^\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primeFactors = [1]\n    var factorization\
    \ = [Int]()\n    var isPrime = true\n    var currentFactor = 1\n    var currentFactorCount\
    \ = 1\n    var currentFactorIndex = 0\n    var currentFactorIndexCount = 0\n \
    \   var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin\
    \ = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin\
    \ = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin\
    \ = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin\
    \ = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin\
    \ = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n    var currentFactorIndexCountMin\
    \ = Int(floor(sqrt(Double(n))))\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprodeox3p.swift:14:42: error: cannot find 'ceil' in scope\n    var\
    \ currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n                  \
    \                       ^~~~\n/tmp/tmprodeox3p.swift:14:47: error: cannot find\
    \ 'sqrt' in scope\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                              ^~~~\n/tmp/tmprodeox3p.swift:15:42:\
    \ error: cannot find 'floor' in scope\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                         ^~~~~\n/tmp/tmprodeox3p.swift:15:48:\
    \ error: cannot find 'sqrt' in scope\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                               ^~~~\n/tmp/tmprodeox3p.swift:16:42:\
    \ error: cannot find 'ceil' in scope\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                         ^~~~\n/tmp/tmprodeox3p.swift:16:47:\
    \ error: cannot find 'sqrt' in scope\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                              ^~~~\n/tmp/tmprodeox3p.swift:17:42:\
    \ error: cannot find 'floor' in scope\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                         ^~~~~\n/tmp/tmprodeox3p.swift:17:48:\
    \ error: cannot find 'sqrt' in scope\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                               ^~~~\n/tmp/tmprodeox3p.swift:18:42:\
    \ error: cannot find 'ceil' in scope\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                         ^~~~\n/tmp/tmprodeox3p.swift:18:47:\
    \ error: cannot find 'sqrt' in scope\n    var currentFactorIndexCountMax = Int(ceil(sqrt(Double(n))))\n\
    \                                              ^~~~\n/tmp/tmprodeox3p.swift:19:42:\
    \ error: cannot find 'floor' in scope\n    var currentFactorIndexCountMin = Int(floor(sqrt(Double(n))))\n\
    \                                         ^~~~~\n/tmp/tmprodeox3p.swift:19:48:\
    \ error: cannot find 'sqrt' in scope\n    var currentFacto"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factors = [Int]()\n    var primes = factorization(n)\n    for prime\
    \ in primes {\n        var factor = 1\n        while prime > 1 {\n           \
    \ if n % prime == 0 {\n                factor *= prime\n                n /= prime\n\
    \            } else {\n                prime = primes[primes.count - 1]\n    \
    \        }\n        }\n        factors.append(factor)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkfbqwehb.swift:7:18: error: cannot find 'factorization' in scope\n\
    \    var primes = factorization(n)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009305
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\nfunc factorize(n: Int) -> [Int]\
    \ {\n    var factorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ factorizationSum = 0\n    var factorizationSumOfFactors = 0\n    var factorizationSumOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactors = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactors =\
    \ 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOf\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq5oux1sd.swift:15:9: error: invalid redeclaration of 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:14:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:17:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:16:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:18:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:16:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:19:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\n\
    \    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:16:9: note: 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors'\
    \ previously declared here\n    var factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFactors\
    \ = 0\n        ^\n/tmp/tmpq5oux1sd.swift:21:9: error: invalid redeclaration of\
    \ 'factorizationSumOfFactorsOfFactorsOfFactorsOfFactorsOfFactorsOfFac"
  stdout: ''
  timestamp: 1660009305
