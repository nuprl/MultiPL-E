language: swift
name: HumanEval_58_common
results:
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = l1\n    for element in l2 {\n\
    \        if commonIndexOf(common, element) == -1 {\n            common = append(common,\
    \ element)\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5l60q2rp.swift:6:12: error: cannot find 'commonIndexOf' in scope\n\
    \        if commonIndexOf(common, element) == -1 {\n           ^~~~~~~~~~~~~\n\
    /tmp/tmp5l60q2rp.swift:7:22: error: cannot find 'append' in scope\n          \
    \  common = append(common, element)\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n            if !result.contains(&y) {\n                result.append(y)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb47ks_09.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpb47ks_09.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n/tmp/tmpb47ks_09.swift:13:33:\
    \ error: '&' used with non-inout argument of type 'Int'\n            if !result.contains(&y)\
    \ {\n                                ^~\n                                \n/tmp/tmpb47ks_09.swift:13:33:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            if !result.contains(&y) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpoap_v31z.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpoap_v31z.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common.append(x)\n\
    \            }\n            if !common.contains(&y) {\n                common.append(y)\n\
    \            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmposkizony.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmposkizony.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n/tmp/tmposkizony.swift:13:33:\
    \ error: '&' used with non-inout argument of type 'Int'\n            if !common.contains(&y)\
    \ {\n                                ^~\n                                \n/tmp/tmposkizony.swift:13:33:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            if !common.contains(&y) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n            if !result.contains(&y) {\n                result.append(y)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg1la0mz1.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpg1la0mz1.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n/tmp/tmpg1la0mz1.swift:13:33:\
    \ error: '&' used with non-inout argument of type 'Int'\n            if !result.contains(&y)\
    \ {\n                                ^~\n                                \n/tmp/tmpg1la0mz1.swift:13:33:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            if !result.contains(&y) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpy6l4oa1m.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpy6l4oa1m.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = Set()\n    for x in l1 {\n  \
    \      if !common.contains(x) {\n            common.add(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !common.contains(x) {\n            common.add(x)\n\
    \        }\n    }\n    return Array(common)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb63eeehy.swift:4:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var common = Set()\n                 ^\n/tmp/tmpb63eeehy.swift:4:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var common\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpoap_v31z.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpoap_v31z.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common.append(x)\n\
    \            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpc8sx0w8v.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpc8sx0w8v.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.insert(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplxhs0k6r.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmplxhs0k6r.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n/tmp/tmplxhs0k6r.swift:11:32:\
    \ error: missing argument for parameter 'at' in call\n                result.insert(x)\n\
    \                               ^\n                               , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common.append(x)\n\
    \            }\n            if !common.contains(&y) {\n                common.append(y)\n\
    \            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmposkizony.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmposkizony.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n/tmp/tmposkizony.swift:13:33:\
    \ error: '&' used with non-inout argument of type 'Int'\n            if !common.contains(&y)\
    \ {\n                                ^~\n                                \n/tmp/tmposkizony.swift:13:33:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            if !common.contains(&y) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = l1\n    for element in l2 {\n\
    \        if commonContains(common, element) {\n            common = common[commonIndexOf(common,\
    \ element)]\n        } else {\n            common = append(common, element)\n\
    \        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9jrf8bxv.swift:6:12: error: cannot find 'commonContains' in scope\n\
    \        if commonContains(common, element) {\n           ^~~~~~~~~~~~~~\n/tmp/tmp9jrf8bxv.swift:7:29:\
    \ error: cannot find 'commonIndexOf' in scope\n            common = common[commonIndexOf(common,\
    \ element)]\n                            ^~~~~~~~~~~~~\n/tmp/tmp9jrf8bxv.swift:7:28:\
    \ error: no 'subscript' candidates produce the expected contextual result type\
    \ '[Int]'\n            common = common[commonIndexOf(common, element)]\n     \
    \                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual result\
    \ type '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\n/tmp/tmp9jrf8bxv.swift:9:22: error: cannot\
    \ find 'append' in scope\n            common = append(common, element)\n     \
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.insert(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplxhs0k6r.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmplxhs0k6r.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n/tmp/tmplxhs0k6r.swift:11:32:\
    \ error: missing argument for parameter 'at' in call\n                result.insert(x)\n\
    \                               ^\n                               , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.insert(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplxhs0k6r.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmplxhs0k6r.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n/tmp/tmplxhs0k6r.swift:11:32:\
    \ error: missing argument for parameter 'at' in call\n                result.insert(x)\n\
    \                               ^\n                               , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n            if !contains(result, y) {\n  \
    \              result = append(result, y)\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp51to6m3p.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmp51to6m3p.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n/tmp/tmp51to6m3p.swift:13:17: error: cannot\
    \ find 'contains' in scope\n            if !contains(result, y) {\n          \
    \      ^~~~~~~~\n/tmp/tmp51to6m3p.swift:14:26: error: cannot find 'append' in\
    \ scope\n                result = append(result, y)\n                        \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                append(result,\
    \ x)\n            }\n            if !contains(result, y) {\n                append(result,\
    \ y)\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpug9r8tl4.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpug9r8tl4.swift:11:17:\
    \ error: cannot find 'append' in scope\n                append(result, x)\n  \
    \              ^~~~~~\n/tmp/tmpug9r8tl4.swift:13:17: error: cannot find 'contains'\
    \ in scope\n            if !contains(result, y) {\n                ^~~~~~~~\n\
    /tmp/tmpug9r8tl4.swift:14:17: error: cannot find 'append' in scope\n         \
    \       append(result, y)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n            if !contains(result, y) {\n  \
    \              result = append(result, y)\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp51to6m3p.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmp51to6m3p.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n/tmp/tmp51to6m3p.swift:13:17: error: cannot\
    \ find 'contains' in scope\n            if !contains(result, y) {\n          \
    \      ^~~~~~~~\n/tmp/tmp51to6m3p.swift:14:26: error: cannot find 'append' in\
    \ scope\n                result = append(result, y)\n                        \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqdhi33h9.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpz90uu_cr.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpz90uu_cr.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common.append(x)\n\
    \            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpc8sx0w8v.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpc8sx0w8v.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = Set()\n    for x in l1 {\n  \
    \      if !common.contains(&x) {\n            common = common.union(&x)\n    \
    \    }\n    }\n    for x in l2 {\n        if !common.contains(&x) {\n        \
    \    common = common.union(&x)\n        }\n    }\n    return Array(common)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkzq3jvzk.swift:4:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var common = Set()\n                 ^\n/tmp/tmpkzq3jvzk.swift:4:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var common\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n/tmp/tmpkzq3jvzk.swift:6:29:\
    \ error: cannot pass immutable value as inout argument: 'x' is a 'let' constant\n\
    \        if !common.contains(&x) {\n                            ^~\n/tmp/tmpkzq3jvzk.swift:7:35:\
    \ error: cannot pass immutable value as inout argument: 'x' is a 'let' constant\n\
    \            common = common.union(&x)\n                                  ^~\n\
    /tmp/tmpkzq3jvzk.swift:11:29: error: cannot pass immutable value as inout argument:\
    \ 'x' is a 'let' constant\n        if !common.contains(&x) {\n               \
    \             ^~\n/tmp/tmpkzq3jvzk.swift:12:35: error: cannot pass immutable value\
    \ as inout argument: 'x' is a 'let' constant\n            common = common.union(&x)\n\
    \                                  ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = Set()\n    for x in l1 {\n  \
    \      if !common.contains(x) {\n            common.add(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !common.contains(x) {\n            common.add(x)\n\
    \        }\n    }\n    return Array(common)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb63eeehy.swift:4:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var common = Set()\n                 ^\n/tmp/tmpb63eeehy.swift:4:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var common\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                append(result,\
    \ x)\n            }\n            if !contains(result, y) {\n                append(result,\
    \ y)\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpug9r8tl4.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpug9r8tl4.swift:11:17:\
    \ error: cannot find 'append' in scope\n                append(result, x)\n  \
    \              ^~~~~~\n/tmp/tmpug9r8tl4.swift:13:17: error: cannot find 'contains'\
    \ in scope\n            if !contains(result, y) {\n                ^~~~~~~~\n\
    /tmp/tmpug9r8tl4.swift:14:17: error: cannot find 'append' in scope\n         \
    \       append(result, y)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = Set()\n    for x in l1 {\n  \
    \      if !common.contains(x) {\n            common.add(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !common.contains(x) {\n            common.add(x)\n\
    \        }\n    }\n    return Array(common)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb63eeehy.swift:4:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var common = Set()\n                 ^\n/tmp/tmpb63eeehy.swift:4:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var common\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnsqpzuz3.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpnsqpzuz3.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for i in l1 {\n\
    \        for j in l2 {\n            if i == j {\n                continue\n  \
    \          }\n            if !common.contains(i) {\n                common.append(i)\n\
    \            }\n            if !common.contains(j) {\n                common.append(j)\n\
    \            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpj8v6wlw_/tmpj8v6wlw_.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac42386ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac423565b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac423565988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4235647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj8v6wlw_                        0x000055c02fb4967c <unavailable> + 5756

    5    libc.so.6                          0x00002ac423a5a460 __libc_start_main +
    245

    6    tmpj8v6wlw_                        0x000055c02fb491f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpy6l4oa1m.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpy6l4oa1m.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                common.append(x)\n\
    \                break\n            }\n        }\n    }\n    return common\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpjefj6p5m/tmpjefj6p5m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91cebe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91ce8dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91ce8df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91ce8de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjefj6p5m                        0x000056360765c60c <unavailable> + 5644

    5    libc.so.6                          0x00002b91cedd4460 __libc_start_main +
    245

    6    tmpjefj6p5m                        0x000056360765c189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common.append(x)\n\
    \            }\n            if !common.contains(&y) {\n                common.append(y)\n\
    \            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmposkizony.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmposkizony.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n/tmp/tmposkizony.swift:13:33:\
    \ error: '&' used with non-inout argument of type 'Int'\n            if !common.contains(&y)\
    \ {\n                                ^~\n                                \n/tmp/tmposkizony.swift:13:33:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            if !common.contains(&y) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common =\
    \ append(common, x)\n            }\n        }\n    }\n    return common\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4pfijluz.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmp4pfijluz.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n/tmp/tmp4pfijluz.swift:11:26:\
    \ error: cannot find 'append' in scope\n                common = append(common,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n            if !result.contains(&y) {\n                result.append(y)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg1la0mz1.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpg1la0mz1.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n/tmp/tmpg1la0mz1.swift:13:33:\
    \ error: '&' used with non-inout argument of type 'Int'\n            if !result.contains(&y)\
    \ {\n                                ^~\n                                \n/tmp/tmpg1la0mz1.swift:13:33:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            if !result.contains(&y) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                common.append(x)\n\
    \                break\n            }\n        }\n    }\n    return common\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpjefj6p5m/tmpjefj6p5m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91cebe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91ce8dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91ce8df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91ce8de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjefj6p5m                        0x000056360765c60c <unavailable> + 5644

    5    libc.so.6                          0x00002b91cedd4460 __libc_start_main +
    245

    6    tmpjefj6p5m                        0x000056360765c189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpy6l4oa1m.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpy6l4oa1m.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                common.append(x)\n\
    \                break\n            }\n        }\n    }\n    return common\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpjefj6p5m/tmpjefj6p5m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91cebe8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91ce8dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91ce8df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91ce8de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjefj6p5m                        0x000056360765c60c <unavailable> + 5644

    5    libc.so.6                          0x00002b91cedd4460 __libc_start_main +
    245

    6    tmpjefj6p5m                        0x000056360765c189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw9fz6kpo.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpw9fz6kpo.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw9fz6kpo.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpw9fz6kpo.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpz90uu_cr.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpz90uu_cr.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = l1\n    for elem in l2 {\n  \
    \      if common.isEmpty {\n            common = l1\n        } else {\n      \
    \      for elem2 in common {\n                if elem == elem2 {\n           \
    \         break\n                }\n            }\n        }\n    }\n    return\
    \ common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmp3_74up_y/tmp3_74up_y.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53a9a5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53a9755b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53a9755988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53a97547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3_74up_y                        0x00005637d2f4760c <unavailable> + 5644

    5    libc.so.6                          0x00002b53a9c4a460 __libc_start_main +
    245

    6    tmp3_74up_y                        0x00005637d2f47189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw9fz6kpo.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpw9fz6kpo.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = l1\n    for element in l2 {\n\
    \        if !common.contains(element) {\n            common.append(element)\n\
    \        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpi99vv4np/tmpi99vv4np.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab23dee7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab23dbdeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab23dbde988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab23dbdd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi99vv4np                        0x0000561fc8a7167c <unavailable> + 5756

    5    libc.so.6                          0x00002ab23e0d3460 __libc_start_main +
    245

    6    tmpi99vv4np                        0x0000561fc8a711f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979337
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n            if !contains(result, y) {\n  \
    \              result = append(result, y)\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp51to6m3p.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmp51to6m3p.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n/tmp/tmp51to6m3p.swift:13:17: error: cannot\
    \ find 'contains' in scope\n            if !contains(result, y) {\n          \
    \      ^~~~~~~~\n/tmp/tmp51to6m3p.swift:14:26: error: cannot find 'append' in\
    \ scope\n                result = append(result, y)\n                        \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw9fz6kpo.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpw9fz6kpo.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !common.contains(&x) {\n                common =\
    \ append(common, x)\n            }\n        }\n    }\n    return common\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4pfijluz.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !common.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmp4pfijluz.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !common.contains(&x) {\n                                ^~\n/tmp/tmp4pfijluz.swift:11:26:\
    \ error: cannot find 'append' in scope\n                common = append(common,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = l1\n    for element in l2 {\n\
    \        if commonIndexOf(common, element) == -1 {\n            common = append(common,\
    \ element)\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5l60q2rp.swift:6:12: error: cannot find 'commonIndexOf' in scope\n\
    \        if commonIndexOf(common, element) == -1 {\n           ^~~~~~~~~~~~~\n\
    /tmp/tmp5l60q2rp.swift:7:22: error: cannot find 'append' in scope\n          \
    \  common = append(common, element)\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n            if !contains(result, y) {\n  \
    \              result = append(result, y)\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxxd181fo.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpxxd181fo.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n/tmp/tmpxxd181fo.swift:13:17: error: cannot\
    \ find 'contains' in scope\n            if !contains(result, y) {\n          \
    \      ^~~~~~~~\n/tmp/tmpxxd181fo.swift:14:26: error: cannot find 'append' in\
    \ scope\n                result = append(result, y)\n                        \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw9fz6kpo.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpw9fz6kpo.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = Set()\n    for x in l1 {\n  \
    \      if !common.contains(&x) {\n            common = common.union(&x)\n    \
    \    }\n    }\n    for x in l2 {\n        if !common.contains(&x) {\n        \
    \    common = common.union(&x)\n        }\n    }\n    return Array(common)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkzq3jvzk.swift:4:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var common = Set()\n                 ^\n/tmp/tmpkzq3jvzk.swift:4:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var common\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n/tmp/tmpkzq3jvzk.swift:6:29:\
    \ error: cannot pass immutable value as inout argument: 'x' is a 'let' constant\n\
    \        if !common.contains(&x) {\n                            ^~\n/tmp/tmpkzq3jvzk.swift:7:35:\
    \ error: cannot pass immutable value as inout argument: 'x' is a 'let' constant\n\
    \            common = common.union(&x)\n                                  ^~\n\
    /tmp/tmpkzq3jvzk.swift:11:29: error: cannot pass immutable value as inout argument:\
    \ 'x' is a 'let' constant\n        if !common.contains(&x) {\n               \
    \             ^~\n/tmp/tmpkzq3jvzk.swift:12:35: error: cannot pass immutable value\
    \ as inout argument: 'x' is a 'let' constant\n            common = common.union(&x)\n\
    \                                  ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !result.contains(&x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe91p0f1x.swift:10:33: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if !result.contains(&x) {\n                        \
    \        ^~\n                                \n/tmp/tmpe91p0f1x.swift:10:33: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if !result.contains(&x) {\n                                ^~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result.append(i)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx56z843e.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw7tcw77u.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw9fz6kpo.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmpw9fz6kpo.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                append(result,\
    \ x)\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkbswesw2.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpkbswesw2.swift:11:17:\
    \ error: cannot find 'append' in scope\n                append(result, x)\n  \
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7eladaep.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7eladaep.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7eladaep.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpoap_v31z.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpoap_v31z.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if result.contains(&x) {\n                continue\n\
    \            }\n            result.insert(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7z7fmv_5.swift:10:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&x) {\n                         \
    \      ^~\n                               \n/tmp/tmp7z7fmv_5.swift:10:32: error:\
    \ cannot pass immutable value as inout argument: 'x' is a 'let' constant\n   \
    \         if result.contains(&x) {\n                               ^~\n/tmp/tmp7z7fmv_5.swift:13:28:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(x)\n\
    \                           ^\n                           , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result =\
    \ append(result, x)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph5pphc_j.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmph5pphc_j.swift:11:26:\
    \ error: cannot find 'append' in scope\n                result = append(result,\
    \ x)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    for x in l2 {\n        if !contains(l1, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60z8b1wd.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp60z8b1wd.swift:11:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, x) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                result.append(x)\n\
    \            }\n            if !contains(result, y) {\n                result.append(y)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpc4ggfuj_.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmpc4ggfuj_.swift:13:17:\
    \ error: cannot find 'contains' in scope\n            if !contains(result, y)\
    \ {\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                continue\n  \
    \          }\n            if !contains(result, x) {\n                append(result,\
    \ x)\n            }\n            if !contains(result, y) {\n                append(result,\
    \ y)\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7nwirhu5.swift:10:17: error: cannot find 'contains' in scope\n\
    \            if !contains(result, x) {\n                ^~~~~~~~\n/tmp/tmp7nwirhu5.swift:11:17:\
    \ error: cannot find 'append' in scope\n                append(result, x)\n  \
    \              ^~~~~~\n/tmp/tmp7nwirhu5.swift:13:17: error: cannot find 'contains'\
    \ in scope\n            if !contains(result, y) {\n                ^~~~~~~~\n\
    /tmp/tmp7nwirhu5.swift:14:17: error: cannot find 'append' in scope\n         \
    \       append(result, y)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            common.append(x)\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7zisht3_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpac0vibfq.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var common = l1\n    for _i in l2 {\n    \
    \    if common.remove(_i) {\n            break\n        }\n    }\n    return common\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3kdib8rq.swift:6:19: error: no exact matches in call to instance\
    \ method 'remove'\n        if common.remove(_i) {\n                  ^\n/tmp/tmp3kdib8rq.swift:6:19:\
    \ note: found candidate with type '(Int) -> Int'\n        if common.remove(_i)\
    \ {\n                  ^\n/tmp/tmp3kdib8rq.swift:6:19: error: type 'Int' cannot\
    \ be used as a boolean; test for '!= 0' instead\n        if common.remove(_i)\
    \ {\n                  ^\n           (                 != 0)\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result = append(result, x)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgypejx98.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmpgypejx98.swift:7:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979336
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two lists.\nfunc common(l1:\
    \ [Int], l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4cjurky_.swift:6:13: error: cannot find 'contains' in scope\n \
    \       if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979336
