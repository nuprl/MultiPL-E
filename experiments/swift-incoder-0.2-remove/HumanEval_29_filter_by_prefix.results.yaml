language: swift
name: HumanEval_29_filter_by_prefix
results:
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9_wljton.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdbvrhhc9.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdbvrhhc9.swift:5:13: warning: initialization of immutable\
    \ value 'prefixLength' was never used; consider replacing with assignment to '_'\
    \ or removing it\n        let prefixLength = string.characters.count\n       \
    \ ~~~~^~~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdbvrhhc9.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdbvrhhc9.swift:5:13: warning: initialization of immutable\
    \ value 'prefixLength' was never used; consider replacing with assignment to '_'\
    \ or removing it\n        let prefixLength = string.characters.count\n       \
    \ ~~~~^~~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        let prefixLength = prefixLength.advanced(by:\
    \ prefix.characters.count)\n        return string.hasPrefix(prefix)\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpju76sich.swift:6:13: error: invalid redeclaration of 'prefixLength'\n\
    \        let prefixLength = prefixLength.advanced(by: prefix.characters.count)\n\
    \            ^\n/tmp/tmpju76sich.swift:5:13: note: 'prefixLength' previously declared\
    \ here\n        let prefixLength = string.characters.count\n            ^\n/tmp/tmpju76sich.swift:5:35:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ prefixLength = string.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpju76sich.swift:6:61:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ prefixLength = prefixLength.advanced(by: prefix.characters.count)\n        \
    \                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        let prefixIndex = string.characters.index(string.startIndex,\
    \ offsetBy: prefixLength)\n        return prefixIndex != nil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpglfzvea_.swift:7:28: warning: comparing non-optional value of type\
    \ 'String.Index' to 'nil' always returns true\n        return prefixIndex != nil\n\
    \               ~~~~~~~~~~~ ^  ~~~\n/tmp/tmpglfzvea_.swift:5:35: error: 'characters'\
    \ is unavailable: Please use String directly\n        let prefixLength = string.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpglfzvea_.swift:6:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        let prefixIndex = string.characters.index(string.startIndex,\
    \ offsetBy: prefixLength)\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let stringWithoutPrefix\
    \ = string.dropFirst(prefix.count)\n        return stringWithoutPrefix.startsWith(prefix)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpabmhq_6g.swift:6:36: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'startsWith'\n        return stringWithoutPrefix.startsWith(prefix)\n\
    \               ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix) && string.characters.count\
    \ >= prefixLength\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qtavs0v.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0qtavs0v.swift:6:51: error: 'characters' is unavailable:\
    \ Please use String directly\n        return string.hasPrefix(prefix) && string.characters.count\
    \ >= prefixLength\n                                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9_wljton.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        let prefixLength = prefixLength < prefix.characters.count\
    \ ? prefixLength : prefix.characters.count\n        return string.hasPrefix(prefix)\
    \ && string.characters.count >= prefixLength\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoyhscmqc.swift:6:13: error: invalid redeclaration of 'prefixLength'\n\
    \        let prefixLength = prefixLength < prefix.characters.count ? prefixLength\
    \ : prefix.characters.count\n            ^\n/tmp/tmpoyhscmqc.swift:5:13: note:\
    \ 'prefixLength' previously declared here\n        let prefixLength = string.characters.count\n\
    \            ^\n/tmp/tmpoyhscmqc.swift:5:35: error: 'characters' is unavailable:\
    \ Please use String directly\n        let prefixLength = string.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoyhscmqc.swift:6:50: error: 'characters' is unavailable:\
    \ Please use String directly\n        let prefixLength = prefixLength < prefix.characters.count\
    \ ? prefixLength : prefix.characters.count\n                                 \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpoyhscmqc.swift:6:91: error: 'characters' is unavailable: Please use\
    \ String directly\n        let prefixLength = prefixLength < prefix.characters.count\
    \ ? prefixLength : prefix.characters.count\n                                 \
    \                                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpoyhscmqc.swift:7:51: error: 'characters'\
    \ is unavailable: Please use String directly\n        return string.hasPrefix(prefix)\
    \ && string.characters.count >= prefixLength\n                               \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let stringToCheck\
    \ = string.lowercaseString\n        return stringToCheck.hasPrefix(prefix.lowercaseString)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq2jgzo4k.swift:5:36: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        let stringToCheck = string.lowercaseString\n    \
    \                        ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let stringPrefix\
    \ = string.prefix(upTo: prefix)\n        return stringPrefix.isEmpty == false\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq32dt259.swift:5:48: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        let stringPrefix = string.prefix(upTo:\
    \ prefix)\n                                               ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdbvrhhc9.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdbvrhhc9.swift:5:13: warning: initialization of immutable\
    \ value 'prefixLength' was never used; consider replacing with assignment to '_'\
    \ or removing it\n        let prefixLength = string.characters.count\n       \
    \ ~~~~^~~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix) && string.characters.count\
    \ >= prefixLength\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7v1rb51k.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7v1rb51k.swift:6:51: error: 'characters' is unavailable:\
    \ Please use String directly\n        return string.hasPrefix(prefix) && string.characters.count\
    \ >= prefixLength\n                                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let stringToCompare\
    \ = string.lowercased().prefix(prefix.count)\n        return stringToCompare.lowercased()\
    \ == prefix\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        return string.hasPrefix(prefix)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let stringPrefix\
    \ = string.prefix(upTo: prefix)\n        return stringPrefix != nil\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8v9b74v8.swift:5:48: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        let stringPrefix = string.prefix(upTo:\
    \ prefix)\n                                               ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix) && prefixLength\
    \ == prefix.characters.count\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmnwhh8cl.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmnwhh8cl.swift:6:67: error: 'characters' is unavailable:\
    \ Please use String directly\n        return string.hasPrefix(prefix) && prefixLength\
    \ == prefix.characters.count\n                                               \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9_wljton.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let stringWithoutPrefix\
    \ = string.dropFirst(prefix.count)\n        return stringWithoutPrefix.startsWith(prefix)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpabmhq_6g.swift:6:36: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'startsWith'\n        return stringWithoutPrefix.startsWith(prefix)\n\
    \               ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qymsvhp.swift:6:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered: [String] = []\n    for string in strings {\n        if\
    \ string.hasPrefix(prefix) {\n            filtered.append(string)\n        }\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdbvrhhc9.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdbvrhhc9.swift:5:13: warning: initialization of immutable\
    \ value 'prefixLength' was never used; consider replacing with assignment to '_'\
    \ or removing it\n        let prefixLength = string.characters.count\n       \
    \ ~~~~^~~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string) -> Bool in\n        let stringToCheck\
    \ = string.lowercased()\n        let prefixToCheck = prefix.lowercased()\n   \
    \     return stringToCheck.hasPrefix(prefixToCheck)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter{ $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    var filtered = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n    return strings.filter { (string: String) -> Bool in\n        let prefixLength\
    \ = string.characters.count\n        return string.hasPrefix(prefix) && prefixLength\
    \ == prefix.characters.count\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmnwhh8cl.swift:5:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmnwhh8cl.swift:6:67: error: 'characters' is unavailable:\
    \ Please use String directly\n        return string.hasPrefix(prefix) && prefixLength\
    \ == prefix.characters.count\n                                               \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978954
