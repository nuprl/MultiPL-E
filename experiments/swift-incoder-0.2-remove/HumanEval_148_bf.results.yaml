language: swift
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == planet2 {\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mercury\" {\n       \
    \ planets.append(\"Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Venus\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    \
    \    return planets\n    }\n    \n    if planet1 == \"Earth\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Mars\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    \
    \    return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    \
    \    return planets\n    }\n    \n    if planet1 == \"Jupiter\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Saturn\")\n    \
    \    planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n       \
    \ return planets\n    }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n      \
    \  return planets\n    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"\
    Mercury\")\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp8ipl2hfi.swift:110:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp8ipl2hfi.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp8ipl2hfi.swift:92:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == planet2 {\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(\"Mercury Venus\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n    \
    \    planets.append(\"Mercury Earth\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Mars\" {\n        planets.append(\"Mercury Mars\")\n    }\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets.append(\"\
    Mercury Jupiter\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"\
    Saturn\" {\n        planets.append(\"Mercury Saturn\")\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(\"Mercury\
    \ Uranus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Neptune\"\
    \ {\n        planets.append(\"Mercury Neptune\")\n    }\n    \n    if planet2\
    \ == \"Mercury\" && planet1 == \"Venus\" {\n        planets.append(\"Mercury Venus\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" && planet1 == \"Earth\" {\n    \
    \    planets.append(\"Mercury Earth\")\n    }\n    \n    if planet2 == \"Mercury\"\
    \ && planet1 == \"Mars\" {\n        planets.append(\"Mercury Mars\")\n    }\n\
    \    \n    if planet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpcmv_wv_b.swift:68:14: error: expected '{' after 'if' condition\n\
    \    if planet\n             ^\n/tmp/tmpcmv_wv_b.swift:68:8: error: cannot find\
    \ 'planet' in scope\n    if planet\n       ^~~~~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == planet2 {\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(\"Mercury\"\
    )\n        planets.append(\"Venus\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Earth\" {\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Earth\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n\
    \        planets.append(\"Mercury\")\n        planets.append(\"Mars\")\n    }\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Jupiter\")\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Saturn\" {\n        planets.append(\"Mercury\")\n\
    \        planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Uranus\" {\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Uranus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Neptune\"\
    \ {\n        planets.append(\"Mercury\")\n        planets.append(\"Neptune\")\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n      \
    \  planets.append(\"Venus\")\n        planets.append(\"Mercury\")\n    }\n   \
    \ \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets.append(\"\
    Venus\")\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp2gnb0klf.swift:92:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp2gnb0klf.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp2gnb0klf.swift:74:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == planet2 {\n        planets.append(planet1)\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n   \
    \ }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n    }\n    \n    if planet1 == \"Saturn\" && planet2\
    \ == \"Jupiter\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n   \
    \ }\n    \n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mars\" \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpv_cn9rgg.swift:71:25: error: expected '{' after 'if' condition\n\
    \    if planet1 == \"Mars\" \n                        ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: Write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpm1zqwsp8/tmpm1zqwsp8.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c9ff42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c9fc39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c9fc39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c9fc387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm1zqwsp8                        0x000055a9aba9951b <unavailable> + 5403

    5    libc.so.6                          0x00002b9ca012e460 __libc_start_main +
    245

    6    tmpm1zqwsp8                        0x000055a9aba990c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n        planets.append(planet1)\n    }\n    \n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n    }\n\
    \    \n    if planet1 == planet2 {\n        planets.append(planet1)\n    }\n \
    \   \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n      \
    \  planets.append(planet1)\n    }\n    \n    if planet1 == \"Earth\" && planet2\
    \ == \"Mars\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n   \
    \ }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n    }\n    \n    if planet1 == \"Uranus\" && planet2\
    \ == \"Neptune\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Neptune\" && planet2 == \"Uranus\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n   \
    \ }\n    \n    if planet1 == \"Mars\" \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp2k51arkq.swift:72:25: error: expected '{' after 'if' condition\n\
    \    if planet1 == \"Mars\" \n                        ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n    case \"Venus\":\n    case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\"\
    :\n    case \"Saturn\":\n    case \"Uranus\":\n    case \"Neptune\":\n    case\
    \ \"Sun\":\n    default:\n        return ()\n    }\n    \n    switch planet2 {\n\
    \    case \"Mercury\":\n    case \"Venus\":\n    case \"Earth\":\n    case \"\
    Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n    case \"Uranus\":\n \
    \   case \"Neptune\":\n    case \"Sun\":\n    default:\n        return ()\n  \
    \  }\n    \n    return ()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpq347cpk8.swift:16:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpq347cpk8.swift:17:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpq347cpk8.swift:18:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpq347cpk8.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpq347cpk8.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpq347cpk8.swift:21:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpq347cpk8.swift:22:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpq347cpk8.swift:23:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Neptune\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpq347cpk8.swift:24:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Sun\":\n    ^~~~~~~~~~~\n                break\n/tmp/tmpq347cpk8.swift:30:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpq347cpk8.swift:31:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpq347cpk8.swift:32:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpq347cpk8.swift:"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == planet2 {\n        planets.append(planet1)\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n   \
    \ }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n    }\n    \n    if planet1 == \"Saturn\" && planet2\
    \ == \"Jupiter\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Venus\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mars\" && plan\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp5_zcnx3o.swift:71:33: error: expected '{' after 'if' condition\n\
    \    if planet1 == \"Mars\" && plan\n                                ^\n/tmp/tmp5_zcnx3o.swift:71:29:\
    \ error: cannot find 'plan' in scope\n    if planet1 == \"Mars\" && plan\n   \
    \                         ^~~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmprt41mvun/tmprt41mvun.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f3c970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f3c667b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f3c667988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f3c6667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprt41mvun                        0x0000555c23a1d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b8f3cb5c460 __libc_start_main +
    245

    6    tmprt41mvun                        0x0000555c23a1d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == planet2 {\n       \
    \ return planets\n    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"\
    Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(\"Mercury\"\
    )\n        planets.append(\"Venus\")\n        planets.append(\"Earth\")\n    \
    \    planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"\
    Saturn\")\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n     \
    \   planets.append(\"Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\"\
    )\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n  \
    \      planets.append(\"Neptune\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Jupiter\" {\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n   \
    \     planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    }\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Uranus\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp1zgl2f4r.swift:67:24: error: unterminated string literal\n    \
    \    planets.append(\"Uranus\n                       ^\n/tmp/tmp1zgl2f4r.swift:89:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp1zgl2f4r.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmp1zgl2f4r.swift:67:24:\
    \ error: missing argument for parameter #1 in call\n        planets.append(\"\
    Uranus\n                       ^\n                       <#String#>\nSwift.Array:6:37:\
    \ note: 'append' declared here\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\n/tmp/tmp1zgl2f4r.swift:71:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"\
    Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\"\
    \ || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n            result.append(planet1)\n\
    \            result.append(planet2)\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzu1472cp/tmpzu1472cp.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55d1ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55d17dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55d17df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55d17de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzu1472cp                        0x00005584fe21662b <unavailable> + 5675

    5    libc.so.6                          0x00002b55d1cd4460 __libc_start_main +
    245

    6    tmpzu1472cp                        0x00005584fe2161d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: Write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp8n1h0gly/tmp8n1h0gly.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbff773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbff46ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbff46a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbff4697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n1h0gly                        0x00005591846ef56b <unavailable> + 5483

    5    libc.so.6                          0x00002adbff95f460 __libc_start_main +
    245

    6    tmp8n1h0gly                        0x00005591846ef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\":\n        switch planet2 {\n\
    \        case \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\":\n            return []\n        default:\n        \
    \    return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n        }\n    default:\n        return [\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp_hezfihh/tmp_hezfihh.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8bf5165c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8bf4e5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8bf4e5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8bf4e5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_hezfihh                        0x000055ed799b257b <unavailable> + 5499

    5    libc.so.6                          0x00002b8bf5351460 __libc_start_main +
    245

    6    tmp_hezfihh                        0x000055ed799b2129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n\
    \    \n    var orbitsBetween = [String]()\n    \n    if orbit1 == nil {\n    \
    \    return orbitsBetween\n    }\n    \n    if orbit2 == nil {\n        return\
    \ orbitsBetween\n    }\n    \n    if orbit1!.distance(orbit2!) < 0 {\n       \
    \ return orbitsBetween\n    }\n    \n    if orbit1!.distance(orbit2!) > 0 {\n\
    \        return orbitsBetween\n    }\n    \n    if orbit1!.distance(orbit2!) ==\
    \ 0 {\n        orbitsBetween.insert(planet1)\n        orbitsBetween.insert(planet2)\n\
    \        return orbitsBetween\n    }\n    \n    if orbit2!.distance(orbit1!) ==\
    \ 0 {\n        orbitsBetween.insert(planet2)\n        orbitsBetween.insert(planet1)\n\
    \        return orbitsBetween\n    }\n    \n    if orbit1!.distance(orbit2!) ==\
    \ orbit1!.distance(orbit2!) {\n        orbitsBetween.insert(planet1)\n       \
    \ orbitsBetween.insert(planet2)\n        return orbitsBetween\n    }\n    \n \
    \   if orbit2!.distance(orbit1!) == orbit2!.distance(orbit1!) {\n        orbitsBetween.insert(planet2)\n\
    \        orbitsBetween.insert(planet1)\n        return orbitsBetween\n    }\n\
    \    \n    if orbit1!.distance(orbit2!) < orbit1!.distance(orbit2!) {\n      \
    \  orbitsBetween.insert(planet1)\n        orbitsBetween.insert(planet2)\n    \
    \    return orbitsBetween\n    }\n    \n    if orbit2!.distance(orbit1!) < orbit2!.distance(orbit1!)\
    \ {\n        orbitsBetween.insert(planet2)\n        orbitsBetween.insert(planet1)\n\
    \        return orbitsBetween\n    }\n    \n    if orbit1!.distance(orbit2!) >\
    \ orbit1!.distance(orbit2!) {\n        orbitsBetween.insert(planet1)\n       \
    \ orbitsBetween.insert(planet2)\n        return orbitsBetween\n    }\n    \n \
    \   if orbit2!.distance(orbit1!) > orbit2!.distance(orbit1!) {\n        orbitsBetween.insert(planet2)\n\
    \        orbitsBetween.insert(planet1)\n        return orbitsBetween\n    }\n\
    \    \n    return orbitsBetween\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpzcje14c0.swift:14:18: error: cannot find 'orbit' in scope\n   \
    \ var orbit1 = orbit(planet1)\n                 ^~~~~\n/tmp/tmpzcje14c0.swift:15:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit2 = orbit(planet2)\n     \
    \            ^~~~~\n/tmp/tmpzcje14c0.swift:36:37: error: missing argument for\
    \ parameter 'at' in call\n        orbitsBetween.insert(planet1)\n            \
    \                        ^\n                                    , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n/tmp/tmpzcje14c0.swift:37:37: error: missing argument\
    \ for parameter 'at' in call\n        orbitsBetween.insert(planet2)\n        \
    \                            ^\n                                    , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n/tmp/tmpzcje14c0.swift:42:37: error: missing argument\
    \ for parameter 'at' in call\n        orbitsBetween.insert(planet2)\n        \
    \                            ^\n                                    , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n/tmp/tmpzcje14c0.swift:43:37: error: missing argument\
    \ for parameter 'at' in call\n        orbitsBetween.insert(planet1)\n        \
    \                            ^\n                                    , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n/tmp/tmpzcje14c0.swift:48:37: error: missing argument\
    \ for parameter 'at' in call\n        orbitsBetween.insert(planet1)\n        \
    \                            ^\n                                    , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    "
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    planets = planets.sorted{ $0.distance(from:\
    \ planet1) < $1.distance(from: planet2) }\n    planets = planets.sorted{ $0.distance(from:\
    \ planet2) < $1.distance(from: planet1) }\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpxdfxxv47.swift:15:56: error: missing argument for parameter 'to'\
    \ in call\n    planets = planets.sorted{ $0.distance(from: planet1) < $1.distance(from:\
    \ planet2) }\n                                                       ^\n     \
    \                                                  , to: <#String.Index#>\nSwift.String:11:17:\
    \ note: 'distance(from:to:)' declared here\n    public func distance(from start:\
    \ String.Index, to end: String.Index) -> Int\n                ^\n/tmp/tmpxdfxxv47.swift:15:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Index'\n\
    \    planets = planets.sorted{ $0.distance(from: planet1) < $1.distance(from:\
    \ planet2) }\n                                                ^\n/tmp/tmpxdfxxv47.swift:15:85:\
    \ error: missing argument for parameter 'to' in call\n    planets = planets.sorted{\
    \ $0.distance(from: planet1) < $1.distance(from: planet2) }\n                \
    \                                                                    ^\n     \
    \                                                                            \
    \   , to: <#String.Index#>\nSwift.String:11:17: note: 'distance(from:to:)' declared\
    \ here\n    public func distance(from start: String.Index, to end: String.Index)\
    \ -> Int\n                ^\n/tmp/tmpxdfxxv47.swift:15:78: error: cannot convert\
    \ value of type 'String' to expected argument type 'String.Index'\n    planets\
    \ = planets.sorted{ $0.distance(from: planet1) < $1.distance(from: planet2) }\n\
    \                                                                            \
    \ ^\n/tmp/tmpxdfxxv47.swift:16:56: error: missing argument for parameter 'to'\
    \ in call\n    planets = planets.sorted{ $0.distance(from: planet2) < $1.distance(from:\
    \ planet1) }\n                                                       ^\n     \
    \                                                  , to: <#String.Index#>\nSwift.String:11:17:\
    \ note: 'distance(from:to:)' declared here\n    public func distance(from start:\
    \ String.Index, to end: String.Index) -> Int\n                ^\n/tmp/tmpxdfxxv47.swift:16:49:\
    \ error: cannot convert value of typ"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == planet2 {\n \
    \       return planets\n    }\n    \n    var sun = Sun()\n    \n    if let orbit1\
    \ = sun.orbit(planet1) {\n        if let orbit2 = sun.orbit(planet2) {\n     \
    \       \n            let distance = orbit1.distance(orbit2)\n            \n \
    \           if distance < 1.0 {\n                planets.append(planet1)\n   \
    \             planets.append(planet2)\n                \n                if distance\
    \ < 1.0 {\n                    planets.append(planet2)\n                    planets.append(planet1)\n\
    \                }\n            }\n        }\n    }\n    \n    return planets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp85qqgoi3.swift:20:15: error: cannot find 'Sun' in scope\n    var\
    \ sun = Sun()\n              ^~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmprt41mvun/tmprt41mvun.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f3c970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f3c667b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f3c667988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f3c6667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprt41mvun                        0x0000555c23a1d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b8f3cb5c460 __libc_start_main +
    245

    6    tmprt41mvun                        0x0000555c23a1d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmprt41mvun/tmprt41mvun.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f3c970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f3c667b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f3c667988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f3c6667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprt41mvun                        0x0000555c23a1d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b8f3cb5c460 __libc_start_main +
    245

    6    tmprt41mvun                        0x0000555c23a1d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp94pk3oli/tmp94pk3oli.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b43029c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b42d20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b42d20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b42d1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94pk3oli                        0x000055712820256b <unavailable> + 5483

    5    libc.so.6                          0x00002b3b43215460 __libc_start_main +
    245

    6    tmp94pk3oli                        0x0000557128202119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmprt41mvun/tmprt41mvun.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f3c970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f3c667b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f3c667988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f3c6667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprt41mvun                        0x0000555c23a1d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b8f3cb5c460 __libc_start_main +
    245

    6    tmprt41mvun                        0x0000555c23a1d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"\
    Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\"\
    \ || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n            result = [planet1,\
    \ planet2]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmptf_2c8yv/tmptf_2c8yv.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7317885c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b731757cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b731757c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b731757b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptf_2c8yv                        0x000055c5cb48d57b <unavailable> + 5499

    5    libc.so.6                          0x00002b7317a71460 __libc_start_main +
    245

    6    tmptf_2c8yv                        0x000055c5cb48d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n    default:\n        return ()\n\
    \    }\n    switch planet2 {\n    case \"Mercury\":\n    case \"Venus\":\n   \
    \ case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\"\
    :\n    case \"Uranus\":\n    case \"Neptune\":\n    default:\n        return ()\n\
    \    }\n    var result = [String]()\n    var mercuryOrbit = orbit(planet1)\n \
    \   var venusOrbit = orbit(planet2)\n    var earthOrbit = orbit(planet1)\n   \
    \ var marsOrbit = orbit(planet2)\n    var jupiterOrbit = orbit(planet1)\n    var\
    \ saturnOrbit = orbit(planet2)\n    var uranusOrbit = orbit(planet1)\n    var\
    \ neptuneOrbit = orbit(planet2)\n    var sunOrbit = orbit(\"Sun\")\n    var mercurySunOrbit\
    \ = orbit(\"Mercury\")\n    var venusSunOrbit = orbit(\"Venus\")\n    var earthSunOrbit\
    \ = orbit(\"Earth\")\n    var marsSunOrbit = orbit(\"Mars\")\n    var jupiterSunOrbit\
    \ = orbit(\"Jupiter\")\n    var saturnSunOrbit = orbit(\"Saturn\")\n    var uranusSunOrbit\
    \ = orbit(\"Uranus\")\n    var neptuneSunOrbit = orbit(\"Neptune\")\n    var mercuryMercuryOrbit\
    \ = orbit(\"Mercury\")\n    var venusMercuryOrbit = orbit(\"Venus\")\n    var\
    \ earthMercuryOrbit = orbit(\"Earth\")\n    var marsMercuryOrbit = orbit(\"Mars\"\
    )\n    var jupiterMercuryOrbit = orbit(\"Jupiter\")\n    var saturnMercuryOrbit\
    \ = orbit(\"Saturn\")\n    var uranusMercuryOrbit = orbit(\"Uranus\")\n    var\
    \ neptuneMercuryOrbit = orbit(\"Neptune\")\n    var mercuryVenusOrbit = orbit(\"\
    Mercury\")\n    var venusVenusOrbit = orbit(\"Venus\")\n    var earth\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp2an73010.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmp2an73010.swift:15:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp2an73010.swift:16:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp2an73010.swift:17:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp2an73010.swift:18:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp2an73010.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp2an73010.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp2an73010.swift:21:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Neptune\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp2an73010.swift:26:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp2an73010.swift:27:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp2an73010.swift:28:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp2an73010.swift:29:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp2an73010.swi"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return [\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Earth\":\n            return\
    \ [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n  \
    \      case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return []\n        default:\n            return []\n        }\n\
    \    case \"Venus\":\n        switch planet2 {\n        case \"Mercury\":\n  \
    \          return [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"\
    Neptune\"]\n        case \"Earth\":\n            return [\"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Mars\":\n            return\
    \ [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Jupiter\"\
    :\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Saturn\"\
    :\n            return [\"Uranus\", \"Neptune\"]\n        case \"Uranus\":\n  \
    \          return [\"Neptune\"]\n        case \"Neptune\":\n            return\
    \ []\n        default:\n            return []\n        }\n    case \"Earth\":\n\
    \        switch planet2 {\n        case \"Mercury\":\n            return [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Venus\":\n\
    \            return [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n        case \"Jupiter\":\n            return [\"Saturn\", \"\
    Uranus\", \"Neptune\"]\n        case \"Saturn\":\n            return [\"Uranus\"\
    , \"Neptune\"]\n        case \"Uranus\":\n            return [\"Neptune\"]\n \
    \       case \"Neptune\":\n            return []\n        default:\n         \
    \   return []\n        }\n    case \"Mars\":\n        switch planet2 {\n     \
    \   case \"Mercury\":\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp729kwytr.swift:73:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"Mercury\":\n        ^~~~~~~~~~~~~~~\n\
    \                        break\n/tmp/tmp729kwytr.swift:95:70: error: expected\
    \ '}' at end of 'switch' statement\nassert(bf(planet1: \"Jupiter\", planet2: \"\
    Makemake\") == [] as [String])\n                                             \
    \                        ^\n/tmp/tmp729kwytr.swift:13:20: note: to match this\
    \ opening '{'\n    switch planet1 {\n                   ^\n/tmp/tmp729kwytr.swift:95:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp729kwytr.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmp729kwytr.swift:72:9:\
    \ error: switch must be exhaustive\n        switch planet2 {\n        ^\n/tmp/tmp729kwytr.swift:72:9:\
    \ note: do you want to add a default clause?\n        switch planet2 {\n     \
    \   ^\n/tmp/tmp729kwytr.swift:77:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmp729kwytr.swift:13:5: error: switch must be exhaustive\n\
    \    switch planet1 {\n    ^\n/tmp/tmp729kwytr.swift:13:5: note: do you want to\
    \ add a default clause?\n    switch planet1 {\n    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var result: [String] = []\n    \n    if planet1 == planet2 {\n\
    \        return result\n    }\n    \n    let planet1Orbit = orbit(planet1)\n \
    \   let planet2Orbit = orbit(planet2)\n    \n    if planet1Orbit == planet2Orbit\
    \ {\n        return result\n    }\n    \n    let planet1Sun = sunOrbit(planet1)\n\
    \    let planet2Sun = sunOrbit(planet2)\n    \n    if planet1Sun == planet2Sun\
    \ {\n        return result\n    }\n    \n    let planet1SunDistance = distance(planet1,\
    \ planet2)\n    let planet2SunDistance = distance(planet2, planet1)\n    \n  \
    \  if planet1SunDistance < planet2SunDistance {\n        result.insert(planet1)\n\
    \    } else {\n        result.insert(planet2)\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpvvxd8g_w.swift:20:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpvvxd8g_w.swift:21:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpvvxd8g_w.swift:27:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmpvvxd8g_w.swift:28:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n\
    /tmp/tmpvvxd8g_w.swift:34:30: error: cannot find 'distance' in scope\n    let\
    \ planet1SunDistance = distance(planet1, planet2)\n                          \
    \   ^~~~~~~~\n/tmp/tmpvvxd8g_w.swift:35:30: error: cannot find 'distance' in scope\n\
    \    let planet2SunDistance = distance(planet2, planet1)\n                   \
    \          ^~~~~~~~\n/tmp/tmpvvxd8g_w.swift:38:30: error: missing argument for\
    \ parameter 'at' in call\n        result.insert(planet1)\n                   \
    \          ^\n                             , at: <#Int#>\nSwift.Array:11:37: note:\
    \ 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n/tmp/tmpvvxd8g_w.swift:40:30: error: missing argument for parameter 'at'\
    \ in call\n        result.insert(planet2)\n                             ^\n  \
    \                           , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    if planet1 == planet2 {\n      \
    \  return result;\n    }\n    \n    let planet1Orbit = planet1Orbit(planet1)\n\
    \    let planet2Orbit = planet2Orbit(planet2)\n    \n    if planet1Orbit == planet2Orbit\
    \ {\n        return result;\n    }\n    \n    let planet1OrbitToSun = planet1OrbitToSun(planet1)\n\
    \    let planet2OrbitToSun = planet2OrbitToSun(planet2)\n    \n    if planet1OrbitToSun\
    \ == planet2OrbitToSun {\n        return result;\n    }\n    \n    let planet1OrbitToSunToPlanet1\
    \ = planet1OrbitToSunToPlanet1(planet1)\n    let planet2OrbitToSunToPlanet1 =\
    \ planet2OrbitToSunToPlanet1(planet2)\n    \n    if planet1OrbitToSunToPlanet1\
    \ == planet2OrbitToSunToPlanet1 {\n        return result;\n    }\n    \n    let\
    \ planet1OrbitToSunToPlanet2 = planet1OrbitToSunToPlanet2(planet1)\n    let planet2OrbitToSunToPlanet2\
    \ = planet2OrbitToSunToPlanet2(planet2)\n    \n    if planet1OrbitToSunToPlanet2\
    \ == planet2OrbitToSunToPlanet2 {\n        return result;\n    }\n    \n    let\
    \ planet1OrbitToSunToPlanet3 = planet1OrbitToSunToPlanet3(planet1)\n    let planet2OrbitToSunToPlanet3\
    \ = planet2OrbitToSunToPlanet3(planet2)\n    \n    if planet1OrbitToSunToPlanet3\
    \ == planet2OrbitToSunToPlanet3 {\n        return result;\n    }\n    \n    let\
    \ planet1OrbitToSunToPlanet4 = planet1OrbitToSunToPlanet4(planet1)\n    let planet2OrbitToSunToPlanet4\
    \ = planet2OrbitToSunToPlanet4(planet2)\n    \n    if planet1OrbitToSunToPlanet4\
    \ == planet2OrbitToSunToPlanet4 {\n        return result;\n    }\n    \n    let\
    \ planet1OrbitToSunToPlanet5 = planet\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpre5gh0l6.swift:19:24: error: use of local variable 'planet1Orbit'\
    \ before its declaration\n    let planet1Orbit = planet1Orbit(planet1)\n     \
    \                  ^\n/tmp/tmpre5gh0l6.swift:19:9: note: 'planet1Orbit' declared\
    \ here\n    let planet1Orbit = planet1Orbit(planet1)\n        ^\n/tmp/tmpre5gh0l6.swift:20:24:\
    \ error: use of local variable 'planet2Orbit' before its declaration\n    let\
    \ planet2Orbit = planet2Orbit(planet2)\n                       ^\n/tmp/tmpre5gh0l6.swift:20:9:\
    \ note: 'planet2Orbit' declared here\n    let planet2Orbit = planet2Orbit(planet2)\n\
    \        ^\n/tmp/tmpre5gh0l6.swift:26:29: error: use of local variable 'planet1OrbitToSun'\
    \ before its declaration\n    let planet1OrbitToSun = planet1OrbitToSun(planet1)\n\
    \                            ^\n/tmp/tmpre5gh0l6.swift:26:9: note: 'planet1OrbitToSun'\
    \ declared here\n    let planet1OrbitToSun = planet1OrbitToSun(planet1)\n    \
    \    ^\n/tmp/tmpre5gh0l6.swift:27:29: error: use of local variable 'planet2OrbitToSun'\
    \ before its declaration\n    let planet2OrbitToSun = planet2OrbitToSun(planet2)\n\
    \                            ^\n/tmp/tmpre5gh0l6.swift:27:9: note: 'planet2OrbitToSun'\
    \ declared here\n    let planet2OrbitToSun = planet2OrbitToSun(planet2)\n    \
    \    ^\n/tmp/tmpre5gh0l6.swift:33:38: error: use of local variable 'planet1OrbitToSunToPlanet1'\
    \ before its declaration\n    let planet1OrbitToSunToPlanet1 = planet1OrbitToSunToPlanet1(planet1)\n\
    \                                     ^\n/tmp/tmpre5gh0l6.swift:33:9: note: 'planet1OrbitToSunToPlanet1'\
    \ declared here\n    let planet1OrbitToSunToPlanet1 = planet1OrbitToSunToPlanet1(planet1)\n\
    \        ^\n/tmp/tmpre5gh0l6.swift:34:38: error: use of local variable 'planet2OrbitToSunToPlanet1'\
    \ before its declaration\n    let planet2OrbitToSunToPlanet1 = planet2OrbitToSunToPlanet1(planet2)\n\
    \                                     ^\n/tmp/tmpre5gh0l6.swift:34:9: note: 'planet2OrbitToSunToPlanet1'\
    \ declared here\n    let planet2OrbitToSunToPlanet1 = planet2OrbitToSunToPlanet1(planet2)\n\
    \        ^\n/tmp/tmpre5gh0l6.swift:40:38: error: use of local variable 'planet"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == planet2 {\n \
    \       return planets\n    }\n    \n    var planet1 = planet1\n    var planet2\
    \ = planet2\n    \n    if planet1 == \"Mercury\" {\n        planet1 = \"Venus\"\
    \n    }\n    \n    if planet1 == \"Venus\" {\n        planet1 = \"Earth\"\n  \
    \  }\n    \n    if planet1 == \"Earth\" {\n        planet1 = \"Mars\"\n    }\n\
    \    \n    if planet1 == \"Mars\" {\n        planet1 = \"Jupiter\"\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planet1 = \"Saturn\"\n    }\n  \
    \  \n    if planet1 == \"Saturn\" {\n        planet1 = \"Uranus\"\n    }\n   \
    \ \n    if planet1 == \"Uranus\" {\n        planet1 = \"Neptune\"\n    }\n   \
    \ \n    if planet1 == \"Neptune\" {\n        planet1 = \"Mercury\"\n    }\n  \
    \  \n    if planet2 == \"Mercury\" {\n        planet2 = \"Venus\"\n    }\n   \
    \ \n    if planet2 == \"Venus\" {\n        planet2 = \"Earth\"\n    }\n    \n\
    \    if planet2 == \"Earth\" {\n        planet2 = \"Mars\"\n    }\n    \n    if\
    \ planet2 == \"Mars\" {\n        planet2 = \"Jupiter\"\n    }\n    \n    if planet2\
    \ == \"Jupiter\" {\n        planet2 = \"Saturn\"\n    }\n    \n    if planet2\
    \ == \"Saturn\" {\n        planet2 = \"Uranus\"\n    }\n    \n    if planet2 ==\
    \ \"Uranus\" {\n        planet2 = \"Neptune\"\n    }\n    \n    if planet2 ==\
    \ \"Neptune\" {\n        planet2 = \"Mercury\"\n    }\n    \n    var planet1Orbit\
    \ = planet1\n    var planet2Orbit = planet2\n    \n    var orbit1 = planet1Orbit\n\
    \    var orbit2 = planet2Orbit\n    \n    var orbit1Orbit = orbit1\n    var orbit2Orbit\
    \ = orbit2\n    \n    var orbit1OrbitSun = orbit1Orbit\n    var orbit2OrbitSun\
    \ = orbit2Orbit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp3e08dzb4.swift:14:9: warning: variable 'planets' was never mutated;\
    \ consider changing to 'let' constant\n    var planets = [String]()\n    ~~~ ^\n\
    \    let\n/tmp/tmp3e08dzb4.swift:87:9: warning: variable 'planet1Orbit' was never\
    \ mutated; consider changing to 'let' constant\n    var planet1Orbit = planet1\n\
    \    ~~~ ^\n    let\n/tmp/tmp3e08dzb4.swift:88:9: warning: variable 'planet2Orbit'\
    \ was never mutated; consider changing to 'let' constant\n    var planet2Orbit\
    \ = planet2\n    ~~~ ^\n    let\n/tmp/tmp3e08dzb4.swift:90:9: warning: variable\
    \ 'orbit1' was never mutated; consider changing to 'let' constant\n    var orbit1\
    \ = planet1Orbit\n    ~~~ ^\n    let\n/tmp/tmp3e08dzb4.swift:91:9: warning: variable\
    \ 'orbit2' was never mutated; consider changing to 'let' constant\n    var orbit2\
    \ = planet2Orbit\n    ~~~ ^\n    let\n/tmp/tmp3e08dzb4.swift:93:9: warning: variable\
    \ 'orbit1Orbit' was never mutated; consider changing to 'let' constant\n    var\
    \ orbit1Orbit = orbit1\n    ~~~ ^\n    let\n/tmp/tmp3e08dzb4.swift:94:9: warning:\
    \ variable 'orbit2Orbit' was never mutated; consider changing to 'let' constant\n\
    \    var orbit2Orbit = orbit2\n    ~~~ ^\n    let\n/tmp/tmp3e08dzb4.swift:96:9:\
    \ warning: initialization of variable 'orbit1OrbitSun' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var orbit1OrbitSun = orbit1Orbit\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp3e08dzb4.swift:97:9: warning: initialization\
    \ of variable 'orbit2OrbitSun' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var orbit2OrbitSun = orbit2Orbit\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp3e08dzb4.swift:98:1: error: missing return in global function\
    \ expected to return '[String]'\n}\n^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return [\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Earth\":\n            return\
    \ [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n  \
    \      case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return []\n        default:\n            return []\n        }\n\
    \    case \"Venus\":\n        switch planet2 {\n        case \"Earth\":\n    \
    \        return [\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"\
    Neptune\"]\n        case \"Mars\":\n            return [\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n        case \"Jupiter\":\n            return [\"\
    Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Saturn\":\n            return\
    \ [\"Uranus\", \"Neptune\"]\n        case \"Uranus\":\n            return [\"\
    Neptune\"]\n        case \"Neptune\":\n            return []\n        default:\n\
    \            return []\n        }\n    case \"Earth\":\n        switch planet2\
    \ {\n        case \"Mercury\":\n            return [\"Mercury\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Mars\":\n    \
    \        return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case\
    \ \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \     case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n       \
    \ case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return []\n        default:\n            return []\n        }\n\
    \    case \"Mars\":\n        switch planet2 {\n        case \"Mercury\":\n   \
    \         return [\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\",\
    \ \"Neptune\"]\n        case \"Jupiter\":\n            return [\"Saturn\", \"\
    Uranus\", \"Neptune\"]\n        case \"Saturn\":\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp67megzro.swift:73:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"Saturn\":\n        ^~~~~~~~~~~~~~\n\
    \                       break\n/tmp/tmp67megzro.swift:96:70: error: expected '}'\
    \ at end of 'switch' statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmp67megzro.swift:13:20: note: to match this opening '{'\n\
    \    switch planet1 {\n                   ^\n/tmp/tmp67megzro.swift:96:70: error:\
    \ expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Makemake\") == [] as [String])\n                                         \
    \                            ^\n/tmp/tmp67megzro.swift:12:55: note: to match this\
    \ opening '{'\nfunc bf(planet1: String, planet2: String) -> [String] {\n     \
    \                                                 ^\n/tmp/tmp67megzro.swift:68:9:\
    \ error: switch must be exhaustive\n        switch planet2 {\n        ^\n/tmp/tmp67megzro.swift:68:9:\
    \ note: do you want to add a default clause?\n        switch planet2 {\n     \
    \   ^\n/tmp/tmp67megzro.swift:78:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmp67megzro.swift:13:5: error: switch must be exhaustive\n\
    \    switch planet1 {\n    ^\n/tmp/tmp67megzro.swift:13:5: note: do you want to\
    \ add a default clause?\n    switch planet1 {\n    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: Write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp8n1h0gly/tmp8n1h0gly.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbff773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbff46ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbff46a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbff4697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n1h0gly                        0x00005591846ef56b <unavailable> + 5483

    5    libc.so.6                          0x00002adbff95f460 __libc_start_main +
    245

    6    tmp8n1h0gly                        0x00005591846ef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    if planet1 != \"Mercury\" && planet1\
    \ != \"Venus\" && planet1 != \"Earth\" && planet1 != \"Mars\" && planet1 != \"\
    Jupiter\" && planet1 != \"Saturn\" && planet1 != \"Uranus\" && planet1 != \"Neptune\"\
    \ {\n        return ()\n    }\n    \n    if planet2 != \"Mercury\" && planet2\
    \ != \"Venus\" && planet2 != \"Earth\" && planet2 != \"Mars\" && planet2 != \"\
    Jupiter\" && planet2 != \"Saturn\" && planet2 != \"Uranus\" && planet2 != \"Neptune\"\
    \ {\n        return ()\n    }\n    \n    let planet1Orbit = planet1.lowercased().components(separatedBy:\
    \ \" \")\n    let planet2Orbit = planet2.lowercased().components(separatedBy:\
    \ \" \")\n    \n    let planet1Orbit1 = planet1Orbit[0]\n    let planet1Orbit2\
    \ = planet1Orbit[1]\n    let planet1Orbit3 = planet1Orbit[2]\n    let planet1Orbit4\
    \ = planet1Orbit[3]\n    let planet1Orbit5 = planet1Orbit[4]\n    let planet1Orbit6\
    \ = planet1Orbit[5]\n    let planet1Orbit7 = planet1Orbit[6]\n    let planet1Orbit8\
    \ = planet1Orbit[7]\n    \n    let planet2Orbit1 = planet2Orbit[0]\n    let planet2Orbit2\
    \ = planet2Orbit[1]\n    let planet2Orbit3 = planet2Orbit[2]\n    let planet2Orbit4\
    \ = planet2Orbit[3]\n    let planet2Orbit5 = planet2Orbit[4]\n    let planet2Orbit6\
    \ = planet2Orbit[5]\n    let planet2Orbit7 = planet2Orbit[6]\n    let planet2Orbit8\
    \ = planet2Orbit[7]\n    \n    let planet1Orbit1String = planet1Orbit1\n    let\
    \ planet1Orbit2String = planet1Orbit2\n    let planet1Orbit3String = planet1Orbit3\n\
    \    let planet1Orbit4String = planet1Orbit4\n    let planet1Orbit5String = planet1Orbit5\n\
    \    let planet1Orbit6String = planet1Orbit\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpw4to6skj.swift:16:16: error: cannot convert return expression of\
    \ type '()' to return type '[String]'\n        return ()\n               ^~\n\
    /tmp/tmpw4to6skj.swift:20:16: error: cannot convert return expression of type\
    \ '()' to return type '[String]'\n        return ()\n               ^~\n/tmp/tmpw4to6skj.swift:23:45:\
    \ error: value of type 'String' has no member 'components'\n    let planet1Orbit\
    \ = planet1.lowercased().components(separatedBy: \" \")\n                    \
    \   ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpw4to6skj.swift:24:45: error: value\
    \ of type 'String' has no member 'components'\n    let planet2Orbit = planet2.lowercased().components(separatedBy:\
    \ \" \")\n                       ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmprt41mvun/tmprt41mvun.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f3c970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f3c667b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f3c667988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f3c6667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprt41mvun                        0x0000555c23a1d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b8f3cb5c460 __libc_start_main +
    245

    6    tmprt41mvun                        0x0000555c23a1d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return [\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Earth\":\n            return\
    \ [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n  \
    \      case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return []\n        default:\n            return []\n        }\n\
    \    case \"Venus\":\n        switch planet2 {\n        case \"Mercury\":\n  \
    \          return [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"\
    Neptune\"]\n        case \"Earth\":\n            return [\"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Mars\":\n            return\
    \ [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Jupiter\"\
    :\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Saturn\"\
    :\n            return [\"Uranus\", \"Neptune\"]\n        case \"Uranus\":\n  \
    \          return [\"Neptune\"]\n        case \"Neptune\":\n            return\
    \ []\n        default:\n            return []\n        }\n    case \"Earth\":\n\
    \        switch planet2 {\n        case \"Mercury\":\n            return [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Venus\":\n\
    \            return [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n        case \"Jupiter\":\n            return [\"Saturn\", \"\
    Uranus\", \"Neptune\"]\n        case \"Saturn\":\n            return [\"Uranus\"\
    , \"Neptune\"]\n        case \"Uranus\":\n            return [\"Neptune\"]\n \
    \       case \"Neptune\":\n            return []\n        default:\n         \
    \   return []\n        }\n    case \"Mars\":\n        switch planet2 {\n     \
    \   case \"Mercury\":\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp729kwytr.swift:73:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"Mercury\":\n        ^~~~~~~~~~~~~~~\n\
    \                        break\n/tmp/tmp729kwytr.swift:95:70: error: expected\
    \ '}' at end of 'switch' statement\nassert(bf(planet1: \"Jupiter\", planet2: \"\
    Makemake\") == [] as [String])\n                                             \
    \                        ^\n/tmp/tmp729kwytr.swift:13:20: note: to match this\
    \ opening '{'\n    switch planet1 {\n                   ^\n/tmp/tmp729kwytr.swift:95:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp729kwytr.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmp729kwytr.swift:72:9:\
    \ error: switch must be exhaustive\n        switch planet2 {\n        ^\n/tmp/tmp729kwytr.swift:72:9:\
    \ note: do you want to add a default clause?\n        switch planet2 {\n     \
    \   ^\n/tmp/tmp729kwytr.swift:77:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmp729kwytr.swift:13:5: error: switch must be exhaustive\n\
    \    switch planet1 {\n    ^\n/tmp/tmp729kwytr.swift:13:5: note: do you want to\
    \ add a default clause?\n    switch planet1 {\n    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n        planets.append(\"Venus\")\n        planets.append(\"Earth\")\n    \
    \    planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"\
    Saturn\")\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\"\
    )\n    case \"Venus\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\"\
    )\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n  \
    \      planets.append(\"Neptune\")\n    case \"Earth\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Mars\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Mars\":\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\"\
    )\n        planets.append(\"Earth\")\n        planets.append(\"Jupiter\")\n  \
    \      planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n      \
    \  planets.append(\"Neptune\")\n    case \"Jupiter\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Saturn\")\n    \
    \    planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Saturn\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        planets.append(\"Uranus\")\n   \
    \     planets.append(\"Neptune\")\n    case \"Uranus\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Neptune\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpmqo6ksu9.swift:100:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpmqo6ksu9.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpmqo6ksu9.swift:15:5:\
    \ error: switch must be exhaustive\n    switch planet1 {\n    ^\n/tmp/tmpmqo6ksu9.swift:15:5:\
    \ note: do you want to add a default clause?\n    switch planet1 {\n    ^\n/tmp/tmpmqo6ksu9.swift:82:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return [\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Earth\":\n            return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Mars\":\n    \
    \        return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Jupiter\":\n            return\
    \ [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n        case \"Saturn\":\n            return [\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Uranus\":\n            return [\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Neptune\":\n            return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        default:\n          \
    \  return []\n        }\n    case \"Venus\":\n        switch planet2 {\n     \
    \   case \"Mercury\":\n            return [\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Earth\":\n            return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Mars\":\n    \
    \        return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Jupiter\":\n            return\
    \ [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n        case \"Saturn\":\n            return [\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Uranus\":\n            return [\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Neptune\":\n            return [\"Mercury\", \"Venus\", \"Earth\", \"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmphq4oegxa.swift:48:50: error: unterminated string literal\n    \
    \        return [\"Mercury\", \"Venus\", \"Earth\", \"\n                     \
    \                            ^\n/tmp/tmphq4oegxa.swift:70:70: error: expected\
    \ '}' at end of 'switch' statement\nassert(bf(planet1: \"Jupiter\", planet2: \"\
    Makemake\") == [] as [String])\n                                             \
    \                        ^\n/tmp/tmphq4oegxa.swift:13:20: note: to match this\
    \ opening '{'\n    switch planet1 {\n                   ^\n/tmp/tmphq4oegxa.swift:70:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmphq4oegxa.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmphq4oegxa.swift:34:9:\
    \ error: switch must be exhaustive\n        switch planet2 {\n        ^\n/tmp/tmphq4oegxa.swift:34:9:\
    \ note: do you want to add a default clause?\n        switch planet2 {\n     \
    \   ^\n/tmp/tmphq4oegxa.swift:52:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmphq4oegxa.swift:13:5: error: switch must be exhaustive\n\
    \    switch planet1 {\n    ^\n/tmp/tmphq4oegxa.swift:13:5: note: do you want to\
    \ add a default clause?\n    switch planet1 {\n    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == planet2 {\n        planets.append(planet1)\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n   \
    \     planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Jupiter\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplgn4jbku.swift:91:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmplgn4jbku.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmplgn4jbku.swift:73:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var result: [String] = []\n    \n    if planet1 == \"Mercury\"\
    \ || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n        \n        if planet2 == \"Mercury\" || planet2 ==\
    \ \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\"\
    \ || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"\
    \ {\n            \n            let planet1Orbit = planet1Orbit(planet1)\n    \
    \        let planet2Orbit = planet2Orbit(planet2)\n            \n            if\
    \ planet1Orbit == planet2Orbit {\n                \n                let planet1OrbitToSun\
    \ = planet1OrbitToSun(planet1)\n                let planet2OrbitToSun = planet2OrbitToSun(planet2)\n\
    \                \n                if planet1OrbitToSun == planet2OrbitToSun {\n\
    \                    \n                    let planet1OrbitToSunToSun = planet1OrbitToSunToSun(planet1)\n\
    \                    let planet2OrbitToSunToSun = planet2OrbitToSunToSun(planet2)\n\
    \                    \n                    if planet1OrbitToSunToSun == planet2OrbitToSunToSun\
    \ {\n                        \n                        let planet1OrbitToSunToSunToSun\
    \ = planet1OrbitToSunToSunToSun(planet1)\n                        let planet2OrbitToSunToSunToSun\
    \ = planet2OrbitToSunToSunToSun(planet2)\n                        \n         \
    \               if planet1OrbitToSunToSunToSun == planet2OrbitToSunToSunToSun\
    \ {\n                            \n                            let planet1OrbitToSunToSunToSunToSun\
    \ = planet1OrbitToSunToSunToSunToSun(planet1)\n                            let\
    \ planet2OrbitToSunToSunToSunToSun = planet2OrbitToSunToSunToSunToSun(planet2)\n\
    \                            \n                            if planet1OrbitToSunToSunToSunToSun\
    \ == plan\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpu6mfzo0b.swift:43:72: error: expected '{' after 'if' condition\n\
    \                            if planet1OrbitToSunToSunToSunToSun == plan\n   \
    \                                                                    ^\n/tmp/tmpu6mfzo0b.swift:65:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpu6mfzo0b.swift:33:73: note: to\
    \ match this opening '{'\n                    if planet1OrbitToSunToSun == planet2OrbitToSunToSun\
    \ {\n                                                                        ^\n\
    /tmp/tmpu6mfzo0b.swift:65:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpu6mfzo0b.swift:28:59:\
    \ note: to match this opening '{'\n                if planet1OrbitToSun == planet2OrbitToSun\
    \ {\n                                                          ^\n/tmp/tmpu6mfzo0b.swift:65:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpu6mfzo0b.swift:23:45: note: to\
    \ match this opening '{'\n            if planet1Orbit == planet2Orbit {\n    \
    \                                        ^\n/tmp/tmpu6mfzo0b.swift:65:70: error:\
    \ expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Makemake\") == [] as [String])\n                                         \
    \                            ^\n/tmp/tmpu6mfzo0b.swift:18:192: note: to match\
    \ this opening '{'\n        if planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" ||\
    \ planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n\
    \                                                                            \
    \                                                                            \
    \          "
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n        return ()\n    default:\n\
    \        return ()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpjw2x15n3.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpjw2x15n3.swift:15:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpjw2x15n3.swift:16:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpjw2x15n3.swift:17:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpjw2x15n3.swift:18:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpjw2x15n3.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpjw2x15n3.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpjw2x15n3.swift:22:16:\
    \ error: cannot convert return expression of type '()' to return type '[String]'\n\
    \        return ()\n               ^~\n/tmp/tmpjw2x15n3.swift:24:16: error: cannot\
    \ convert return expression of type '()' to return type '[String]'\n        return\
    \ ()\n               ^~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: Write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpm1zqwsp8/tmpm1zqwsp8.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c9ff42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c9fc39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c9fc39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c9fc387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm1zqwsp8                        0x000055a9aba9951b <unavailable> + 5403

    5    libc.so.6                          0x00002b9ca012e460 __libc_start_main +
    245

    6    tmpm1zqwsp8                        0x000055a9aba990c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n    case \"Venus\":\n    case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\"\
    :\n    case \"Saturn\":\n    case \"Uranus\":\n    case \"Neptune\":\n    default:\n\
    \        return ()\n    }\n    \n    switch planet2 {\n    case \"Mercury\":\n\
    \    case \"Venus\":\n    case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\"\
    :\n    case \"Saturn\":\n    case \"Uranus\":\n    case \"Neptune\":\n    default:\n\
    \        return ()\n    }\n    \n    let mercuryOrbit = orbit(planet: \"Mercury\"\
    , year: 2020)\n    let venusOrbit = orbit(planet: \"Venus\", year: 2020)\n   \
    \ let earthOrbit = orbit(planet: \"Earth\", year: 2020)\n    let marsOrbit = orbit(planet:\
    \ \"Mars\", year: 2020)\n    let jupiterOrbit = orbit(planet: \"Jupiter\", year:\
    \ 2020)\n    let saturnOrbit = orbit(planet: \"Saturn\", year: 2020)\n    let\
    \ uranusOrbit = orbit(planet: \"Uranus\", year: 2020)\n    let neptuneOrbit =\
    \ orbit(planet: \"Neptune\", year: 2020)\n    \n    let mercurySun = sun(planet:\
    \ \"Mercury\", year: 2020)\n    let venusSun = sun(planet: \"Venus\", year: 2020)\n\
    \    let earthSun = sun(planet: \"Earth\", year: 2020)\n    let marsSun = sun(planet:\
    \ \"Mars\", year: 2020)\n    let jupiterSun = sun(planet: \"Jupiter\", year: 2020)\n\
    \    let saturnSun = sun(planet: \"Saturn\", year: 2020)\n    let uranusSun =\
    \ sun(planet: \"Uranus\", year: 2020)\n    let neptuneSun = sun(planet: \"Neptune\"\
    , year: 2020)\n    \n    let mercuryOrbitSun = mercuryOrbit - mercurySun\n   \
    \ let venusOrbitSun = venusOrbit - venusSun\n    let earthOrbitSun = earthOrbit\
    \ - earthSun\n    let marsOrbitSun = marsOrbit \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp8iwwbzkt.swift:16:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmp8iwwbzkt.swift:17:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp8iwwbzkt.swift:18:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp8iwwbzkt.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp8iwwbzkt.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp8iwwbzkt.swift:21:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp8iwwbzkt.swift:22:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp8iwwbzkt.swift:23:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Neptune\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp8iwwbzkt.swift:29:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp8iwwbzkt.swift:30:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp8iwwbzkt.swift:31:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp8iwwbzkt.swift:32:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp8iwwbzkt.swi"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: write your function here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp7jfne82g/tmp7jfne82g.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f0b968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f0b65fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f0b65f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f0b65e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7jfne82g                        0x000055c39b7c851b <unavailable> + 5403

    5    libc.so.6                          0x00002b3f0bb54460 __libc_start_main +
    245

    6    tmp7jfne82g                        0x000055c39b7c80c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp94pk3oli/tmp94pk3oli.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b43029c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b42d20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b42d20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b42d1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94pk3oli                        0x000055712820256b <unavailable> + 5483

    5    libc.so.6                          0x00002b3b43215460 __libc_start_main +
    245

    6    tmp94pk3oli                        0x0000557128202119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    if planet1 == planet2 {\n      \
    \  return [(planet1)]\n    }\n    \n    if planet1 == \"Mercury\" || planet1 ==\
    \ \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        return [(planet1)]\n    }\n    \n    if planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        return [(planet2)]\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        return [\"Mercury\", \"Venus\"\
    ]\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n    \
    \    return [\"Mercury\", \"Earth\"]\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Mars\" {\n        return [\"Mercury\", \"Mars\"]\n    }\n  \
    \  \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return\
    \ [\"Mercury\", \"Jupiter\"]\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Saturn\" {\n        return [\"Mercury\", \"Saturn\"]\n    }\n    \n   \
    \ if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return [\"Mercury\"\
    , \"Uranus\"]\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Neptune\"\
    \ {\n        return [\"Mercury\", \"Neptune\"]\n    }\n    \n    if planet1 ==\
    \ \"Venus\" && planet2 == \"Mercury\" {\n        return [\"Venus\", \"Mercury\"\
    ]\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n      \
    \  return [\"Venus\", \"Earth\"]\n    }\n    \n    if planet1 == \"Venus\" &&\
    \ planet2 == \"Mars\" {\n        return [\"Venus\", \"Mars\"]\n    }\n    \n \
    \   if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return [\"Venus\"\
    , \"Jupiter\"]\n    }\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpct6hseli.swift:13:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: [String] = []\n\
    \        ^~~~~~\n        _\n/tmp/tmpct6hseli.swift:71:1: error: missing return\
    \ in global function expected to return '[String]'\n}\n^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n        planets.append(\"Venus\")\n        planets.append(\"Earth\")\n    \
    \    planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"\
    Saturn\")\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\"\
    )\n    case \"Venus\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\"\
    )\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n  \
    \      planets.append(\"Neptune\")\n    case \"Earth\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Mars\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Mars\":\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\"\
    )\n        planets.append(\"Earth\")\n        planets.append(\"Jupiter\")\n  \
    \      planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n      \
    \  planets.append(\"Neptune\")\n    case \"Jupiter\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Saturn\")\n    \
    \    planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Saturn\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        planets.append(\"Uranus\")\n   \
    \     planets.append(\"Neptune\")\n    case \"Uranus\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Neptune\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpmqo6ksu9.swift:100:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpmqo6ksu9.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpmqo6ksu9.swift:15:5:\
    \ error: switch must be exhaustive\n    switch planet1 {\n    ^\n/tmp/tmpmqo6ksu9.swift:15:5:\
    \ note: do you want to add a default clause?\n    switch planet1 {\n    ^\n/tmp/tmpmqo6ksu9.swift:82:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == planet2 {\n        planets.append(planet1)\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n   \
    \     planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mars\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Uranus\" &&\
    \ planet2 == \"Neptune\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpxtz33vs4.swift:70:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpxtz33vs4.swift:91:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpxtz33vs4.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpxtz33vs4.swift:69:23:\
    \ error: missing argument for parameter #1 in call\n        planets.append(\n\
    \                      ^\n                      <#String#>\nSwift.Array:6:37:\
    \ note: 'append' declared here\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\n/tmp/tmpxtz33vs4.swift:73:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    guard let planet1Orbit = planet1Orbit(planet:\
    \ planet1),\n        let planet2Orbit = planet2Orbit(planet: planet2) else {\n\
    \        return result\n    }\n    \n    let sunOrbit = sunOrbit()\n    \n   \
    \ let planet1OrbitToSun = planet1Orbit.distance(to: sunOrbit)\n    let planet2OrbitToSun\
    \ = planet2Orbit.distance(to: sunOrbit)\n    \n    let planet1OrbitToSunAndPlanet2\
    \ = planet1OrbitToSun + planet2OrbitToSun\n    \n    if planet1OrbitToSunAndPlanet2\
    \ < 0 {\n        return result\n    }\n    \n    let planet1OrbitToSunAndPlanet2AndPlanet2\
    \ = planet1OrbitToSunAndPlanet2 + planet2OrbitToSun\n    \n    if planet1OrbitToSunAndPlanet2AndPlanet2\
    \ < 0 {\n        return result\n    }\n    \n    let planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2\
    \ = planet1OrbitToSunAndPlanet2AndPlanet2 + planet2OrbitToSun\n    \n    if planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2\
    \ < 0 {\n        return result\n    }\n    \n    let planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2\
    \ = planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2 + planet2OrbitToSun\n    \n\
    \    if planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2 < 0 {\n    \
    \    return result\n    }\n    \n    let planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2AndPlanet2\
    \ = planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2 + planet2OrbitToSun\n\
    \    \n    if planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2AndPlanet2\
    \ < 0 {\n        return result\n    }\n    \n    let planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2AndPlanet2\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmptr2qaczp.swift:15:30: error: cannot find 'planet1Orbit' in scope\n\
    \    guard let planet1Orbit = planet1Orbit(planet: planet1),\n               \
    \              ^~~~~~~~~~~~\n/tmp/tmptr2qaczp.swift:16:28: error: cannot find\
    \ 'planet2Orbit' in scope\n        let planet2Orbit = planet2Orbit(planet: planet2)\
    \ else {\n                           ^~~~~~~~~~~~\n/tmp/tmptr2qaczp.swift:20:20:\
    \ error: use of local variable 'sunOrbit' before its declaration\n    let sunOrbit\
    \ = sunOrbit()\n                   ^\n/tmp/tmptr2qaczp.swift:20:9: note: 'sunOrbit'\
    \ declared here\n    let sunOrbit = sunOrbit()\n        ^\n/tmp/tmptr2qaczp.swift:55:9:\
    \ error: type annotation missing in pattern\n    let planet1OrbitToSunAndPlanet2AndPlanet2AndPlanet2AndPlanet2AndPlanet2\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: Write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp8n1h0gly/tmp8n1h0gly.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbff773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbff46ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbff46a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbff4697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n1h0gly                        0x00005591846ef56b <unavailable> + 5483

    5    libc.so.6                          0x00002adbff95f460 __libc_start_main +
    245

    6    tmp8n1h0gly                        0x00005591846ef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: Write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp8n1h0gly/tmp8n1h0gly.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbff773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbff46ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbff46a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbff4697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n1h0gly                        0x00005591846ef56b <unavailable> + 5483

    5    libc.so.6                          0x00002adbff95f460 __libc_start_main +
    245

    6    tmp8n1h0gly                        0x00005591846ef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n        planets.append(planet1)\n    }\n    \n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n    }\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\"\
    )\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n  \
    \      planets.append(\"Neptune\")\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\"\
    )\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n  \
    \      planets.append(\"Neptune\")\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mars\" && planet2 ==\
    \ \"Mercury\" {\n        planets.append(\"Jupiter\")\n        planets.append(\"\
    Saturn\")\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\"\
    )\n        return planets\n    }\n    \n    if planet1 == \"Jupiter\" && planet2\
    \ == \"Mercury\" {\n        planets.append(\"Saturn\")\n        planets.append(\"\
    Uranus\")\n        planets.append(\"Neptune\")\n        return \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpgxbfpb_v.swift:91:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpgxbfpb_v.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpgxbfpb_v.swift:69:9:\
    \ error: non-void function should return a value\n        return \n        ^\n\
    /tmp/tmpgxbfpb_v.swift:73:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n    case \"Venus\":\n    case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\"\
    :\n    case \"Saturn\":\n    case \"Uranus\":\n    case \"Neptune\":\n    case\
    \ \"Sun\":\n    default:\n        return ()\n    }\n    \n    switch planet2 {\n\
    \    case \"Mercury\":\n    case \"Venus\":\n    case \"Earth\":\n    case \"\
    Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n    case \"Uranus\":\n \
    \   case \"Neptune\":\n    case \"Sun\":\n    default:\n        return ()\n  \
    \  }\n    \n    let planet1Orbit = planet1.lowercased().characters.count\n   \
    \ let planet2Orbit = planet2.lowercased().characters.count\n    \n    if planet1Orbit\
    \ == planet2Orbit {\n        let planet1Orbit = planet1.lowercased().characters.count\n\
    \        let planet2Orbit = planet2.lowercased().characters.count\n        \n\
    \        if planet1Orbit == 0 {\n            return ()\n        } else if planet2Orbit\
    \ == 0 {\n            return ()\n        } else {\n            let planet1Orbit\
    \ = planet1.lowercased().characters.count\n            let planet2Orbit = planet2.lowercased().characters.count\n\
    \            \n            if planet1Orbit == planet2Orbit {\n               \
    \ let planet1Orbit = planet1.lowercased().characters.count\n                let\
    \ planet2Orbit = planet2.lowercased().characters.count\n                \n   \
    \             if planet1Orbit == 0 {\n                    return ()\n        \
    \        } else if planet2Orbit == 0 {\n                    return ()\n      \
    \          } else {\n                    let planet1Orbit = planet1.lowercased().characters.count\n\
    \                    let planet2Orbit = planet2.lowercased().characters.count\n\
    \                    \n                    if planet1Orbit == planet2Orbit {\n\
    \                        let planet1Orbit = planet1.lowercased().characters.count\n\
    \                        let planet2Orbit = planet2.lowercased().characters.count\n\
    \                        \n                        if planet1Orbit == 0 {\n  \
    \                          return ()\n                        } else if planet2Orbit\
    \ == 0 {\n                            return ()\n                        } else\
    \ {\n                            let planet1Orbit = planet1.lowercased().characters.count\n\
    \                            let planet2Orbit\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpxgh2pjyq.swift:16:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpxgh2pjyq.swift:17:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpxgh2pjyq.swift:18:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpxgh2pjyq.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpxgh2pjyq.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpxgh2pjyq.swift:21:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpxgh2pjyq.swift:22:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpxgh2pjyq.swift:23:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Neptune\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpxgh2pjyq.swift:24:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Sun\":\n    ^~~~~~~~~~~\n                break\n/tmp/tmpxgh2pjyq.swift:30:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpxgh2pjyq.swift:31:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpxgh2pjyq.swift:32:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpxgh2pjyq.swift:"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n        return ()\n    default:\n\
    \        return ()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpjw2x15n3.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpjw2x15n3.swift:15:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpjw2x15n3.swift:16:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpjw2x15n3.swift:17:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpjw2x15n3.swift:18:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpjw2x15n3.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpjw2x15n3.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpjw2x15n3.swift:22:16:\
    \ error: cannot convert return expression of type '()' to return type '[String]'\n\
    \        return ()\n               ^~\n/tmp/tmpjw2x15n3.swift:24:16: error: cannot\
    \ convert return expression of type '()' to return type '[String]'\n        return\
    \ ()\n               ^~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp94pk3oli/tmp94pk3oli.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b43029c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b42d20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b42d20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b42d1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94pk3oli                        0x000055712820256b <unavailable> + 5483

    5    libc.so.6                          0x00002b3b43215460 __libc_start_main +
    245

    6    tmp94pk3oli                        0x0000557128202119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return [\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Earth\":\n            return\
    \ [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n  \
    \      case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return [\"Mercury\", \"Venus\"]\n        default:\n           \
    \ return []\n        }\n    case \"Venus\":\n        switch planet2 {\n      \
    \  case \"Earth\":\n            return [\"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n        case \"Mars\":\n            return [\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Jupiter\":\n          \
    \  return [\"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Saturn\":\n  \
    \          return [\"Uranus\", \"Neptune\"]\n        case \"Uranus\":\n      \
    \      return [\"Neptune\"]\n        case \"Neptune\":\n            return [\"\
    Mercury\", \"Venus\"]\n        default:\n            return []\n        }\n  \
    \  case \"Earth\":\n        switch planet2 {\n        case \"Mars\":\n       \
    \     return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case\
    \ \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \     case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n       \
    \ case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return [\"Mercury\", \"Venus\"]\n        default:\n           \
    \ return []\n        }\n    case \"Mars\":\n        switch planet2 {\n       \
    \ case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n    \
    \    case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return [\"Mercury\", \"Venus\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpsbq38nm4.swift:74:32: error: unterminated string literal\n    \
    \        return [\"Mercury\", \"Venus\n                               ^\n/tmp/tmpsbq38nm4.swift:96:70:\
    \ error: expected '}' at end of 'switch' statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpsbq38nm4.swift:13:20: note: to\
    \ match this opening '{'\n    switch planet1 {\n                   ^\n/tmp/tmpsbq38nm4.swift:96:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpsbq38nm4.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmpsbq38nm4.swift:66:9:\
    \ error: switch must be exhaustive\n        switch planet2 {\n        ^\n/tmp/tmpsbq38nm4.swift:66:9:\
    \ note: do you want to add a default clause?\n        switch planet2 {\n     \
    \   ^\n/tmp/tmpsbq38nm4.swift:78:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmpsbq38nm4.swift:13:5: error: switch must be exhaustive\n\
    \    switch planet1 {\n    ^\n/tmp/tmpsbq38nm4.swift:13:5: note: do you want to\
    \ add a default clause?\n    switch planet1 {\n    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    if planet1 == planet2 {\n        return\
    \ result;\n    }\n    \n    let planet1Orbit = planet1.lowercased();\n    let\
    \ planet2Orbit = planet2.lowercased();\n    \n    if planet1Orbit == \"mercury\"\
    \ {\n        if planet2Orbit == \"venus\" {\n            return result;\n    \
    \    }\n    }\n    \n    if planet1Orbit == \"venus\" {\n        if planet2Orbit\
    \ == \"mercury\" {\n            return result;\n        }\n    }\n    \n    if\
    \ planet1Orbit == \"earth\" {\n        if planet2Orbit == \"mars\" {\n       \
    \     return result;\n        }\n    }\n    \n    if planet1Orbit == \"mars\"\
    \ {\n        if planet2Orbit == \"earth\" {\n            return result;\n    \
    \    }\n    }\n    \n    if planet1Orbit == \"jupiter\" {\n        if planet2Orbit\
    \ == \"saturn\" {\n            return result;\n        }\n    }\n    \n    if\
    \ planet1Orbit == \"saturn\" {\n        if planet2Orbit == \"jupiter\" {\n   \
    \         return result;\n        }\n    }\n    \n    if planet1Orbit == \"uranus\"\
    \ {\n        if planet2Orbit == \"neptune\" {\n            return result;\n  \
    \      }\n    }\n    \n    if planet1Orbit == \"neptune\" {\n        if planet2Orbit\
    \ == \"uranus\" {\n            return result;\n        }\n    }\n    \n    return\
    \ [];\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp0dlnh6tv/tmp0dlnh6tv.swift:86: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25efbecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25ef8e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25ef8e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25ef8e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0dlnh6tv                        0x0000564ee923862b <unavailable> + 5675

    5    libc.so.6                          0x00002b25efdd8460 __libc_start_main +
    245

    6    tmp0dlnh6tv                        0x0000564ee92381d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result: [String] = []\n    \n    // TODO: Write your code here\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpm1zqwsp8/tmpm1zqwsp8.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c9ff42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c9fc39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c9fc39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c9fc387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm1zqwsp8                        0x000055a9aba9951b <unavailable> + 5403

    5    libc.so.6                          0x00002b9ca012e460 __libc_start_main +
    245

    6    tmpm1zqwsp8                        0x000055a9aba990c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n        switch planet2 {\n \
    \       case \"Venus\":\n            return [\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Earth\":\n            return\
    \ [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"\
    Mars\":\n            return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n  \
    \      case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return [\"Mercury\", \"Venus\"]\n        default:\n           \
    \ return []\n        }\n    case \"Venus\":\n        switch planet2 {\n      \
    \  case \"Earth\":\n            return [\"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n        case \"Mars\":\n            return [\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Jupiter\":\n          \
    \  return [\"Saturn\", \"Uranus\", \"Neptune\"]\n        case \"Saturn\":\n  \
    \          return [\"Uranus\", \"Neptune\"]\n        case \"Uranus\":\n      \
    \      return [\"Neptune\"]\n        case \"Neptune\":\n            return [\"\
    Mercury\", \"Venus\"]\n        default:\n            return []\n        }\n  \
    \  case \"Earth\":\n        switch planet2 {\n        case \"Mars\":\n       \
    \     return [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        case\
    \ \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \     case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n       \
    \ case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return [\"Mercury\", \"Venus\"]\n        default:\n           \
    \ return []\n        }\n    case \"Mars\":\n        switch planet2 {\n       \
    \ case \"Jupiter\":\n            return [\"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \        case \"Saturn\":\n            return [\"Uranus\", \"Neptune\"]\n    \
    \    case \"Uranus\":\n            return [\"Neptune\"]\n        case \"Neptune\"\
    :\n            return [\"Mercury\", \"Venus\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpsbq38nm4.swift:74:32: error: unterminated string literal\n    \
    \        return [\"Mercury\", \"Venus\n                               ^\n/tmp/tmpsbq38nm4.swift:96:70:\
    \ error: expected '}' at end of 'switch' statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpsbq38nm4.swift:13:20: note: to\
    \ match this opening '{'\n    switch planet1 {\n                   ^\n/tmp/tmpsbq38nm4.swift:96:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpsbq38nm4.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmpsbq38nm4.swift:66:9:\
    \ error: switch must be exhaustive\n        switch planet2 {\n        ^\n/tmp/tmpsbq38nm4.swift:66:9:\
    \ note: do you want to add a default clause?\n        switch planet2 {\n     \
    \   ^\n/tmp/tmpsbq38nm4.swift:78:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmpsbq38nm4.swift:13:5: error: switch must be exhaustive\n\
    \    switch planet1 {\n    ^\n/tmp/tmpsbq38nm4.swift:13:5: note: do you want to\
    \ add a default clause?\n    switch planet1 {\n    ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n        planets.append(\"Venus\")\n        planets.append(\"Earth\")\n    \
    \    planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"\
    Saturn\")\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\"\
    )\n    case \"Venus\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\"\
    )\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n  \
    \      planets.append(\"Neptune\")\n    case \"Earth\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Mars\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Mars\":\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\"\
    )\n        planets.append(\"Earth\")\n        planets.append(\"Jupiter\")\n  \
    \      planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n      \
    \  planets.append(\"Neptune\")\n    case \"Jupiter\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Saturn\")\n    \
    \    planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Saturn\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        planets.append(\"Uranus\")\n   \
    \     planets.append(\"Neptune\")\n    case \"Uranus\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Neptune\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n        \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpmqo6ksu9.swift:100:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpmqo6ksu9.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpmqo6ksu9.swift:15:5:\
    \ error: switch must be exhaustive\n    switch planet1 {\n    ^\n/tmp/tmpmqo6ksu9.swift:15:5:\
    \ note: do you want to add a default clause?\n    switch planet1 {\n    ^\n/tmp/tmpmqo6ksu9.swift:82:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == planet2 {\n        planets.append(planet1)\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n   \
    \     planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Jupiter\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplgn4jbku.swift:91:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmplgn4jbku.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmplgn4jbku.swift:73:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    if planet1 == planet2 {\n        return\
    \ result\n    }\n    \n    let planet1Orbit = planet1.lowercased().components(separatedBy:\
    \ \" \")\n    let planet2Orbit = planet2.lowercased().components(separatedBy:\
    \ \" \")\n    \n    if planet1Orbit.count != 3 || planet2Orbit.count != 3 {\n\
    \        return result\n    }\n    \n    let sunOrbit = planet1Orbit[0] + \" \"\
    \ + planet1Orbit[1] + \" \" + planet1Orbit[2]\n    \n    let planet1Orbit = planet2Orbit[0]\
    \ + \" \" + planet2Orbit[1] + \" \" + planet2Orbit[2]\n    \n    let planet1Orbit\
    \ = planet1Orbit[0] + \" \" + planet1Orbit[1] + \" \" + planet1Orbit[2]\n    \n\
    \    let planet2Orbit = planet2Orbit[0] + \" \" + planet2Orbit[1] + \" \" + planet2Orbit[2]\n\
    \    \n    let planet1Orbit = planet1Orbit[0] + \" \" + planet1Orbit[1] + \" \"\
    \ + planet1Orbit[2]\n    \n    let planet2Orbit = planet2Orbit[0] + \" \" + planet2Orbit[1]\
    \ + \" \" + planet2Orbit[2]\n    \n    let planet1Orbit = planet1Orbit[0] + \"\
    \ \" + planet1Orbit[1] + \" \" + planet1Orbit[2]\n    \n    let planet2Orbit =\
    \ planet2Orbit[0] + \" \" + planet2Orbit[1] + \" \" + planet2Orbit[2]\n    \n\
    \    let planet1Orbit = planet1Orbit[0] + \" \" + planet1Orbit[1] + \" \" + planet1Orbit[2]\n\
    \    \n    let planet2Orbit = planet2Orbit[0] + \" \" + planet2Orbit[1] + \" \"\
    \ + planet2Orbit[2]\n    \n    let planet1Orbit = planet1Orbit[0] + \" \" + planet1Orbit[1]\
    \ + \" \" + planet1Orbit[2]\n    \n    let planet2Orbit = planet2Orbit[0] + \"\
    \ \" + planet2Orbit[1] + \" \" + planet2Orbit[2]\n    \n    let planet1Orbit =\
    \ planet1Orbit[0] + \" \" + planet1Orbit[1] + \" \" + planet1Orbit[2]\n    \n\
    \    let planet2Orbit = planet2Orbit[0] + \" \" + planet2Orbit[1] + \" \" + planet2Orbit[2]\n\
    \    \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp54i7noeg.swift:19:45: error: value of type 'String' has no member\
    \ 'components'\n    let planet1Orbit = planet1.lowercased().components(separatedBy:\
    \ \" \")\n                       ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp54i7noeg.swift:20:45:\
    \ error: value of type 'String' has no member 'components'\n    let planet2Orbit\
    \ = planet2.lowercased().components(separatedBy: \" \")\n                    \
    \   ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n        planets.append(planet1)\n    }\n    \n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n    }\n\
    \    \n    if planet1 == planet2 {\n        planets.append(planet1)\n    }\n \
    \   \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mars\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Uranus\" &&\
    \ planet2 == \"Neptune\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        plan\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp8xnto_kn.swift:92:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp8xnto_kn.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp8xnto_kn.swift:70:9:\
    \ error: cannot find 'plan' in scope\n        plan\n        ^~~~\n/tmp/tmp8xnto_kn.swift:74:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: Write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp8n1h0gly/tmp8n1h0gly.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbff773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbff46ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbff46a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbff4697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n1h0gly                        0x00005591846ef56b <unavailable> + 5483

    5    libc.so.6                          0x00002adbff95f460 __libc_start_main +
    245

    6    tmp8n1h0gly                        0x00005591846ef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" || planet1\
    \ == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planets.append(planet1)\n    }\n    \n    if planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n        planets.append(planet2)\n    }\n    \n    if planet1\
    \ == planet2 {\n        planets.append(planet1)\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n   \
    \ }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n       \
    \ planets.append(planet1)\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Jupiter\" {\n        planets.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Saturn\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Neptune\" {\n        planets.append(planet1)\n    }\n    \n    if planet2\
    \ == \"Mercury\" && planet1 == \"Venus\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" && planet1 == \"Earth\" {\n      \
    \  planets.append(planet2)\n    }\n    \n    if planet2 == \"Mercury\" && planet1\
    \ == \"Mars\" {\n        planets.append(planet2)\n    }\n    \n    if planet2\
    \ == \"Mercury\" && planet1 == \"Jupiter\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpmvurxvrl.swift:71:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n    default:\n        return ()\n\
    \    }\n    switch planet2 {\n    case \"Mercury\":\n    case \"Venus\":\n   \
    \ case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\"\
    :\n    case \"Uranus\":\n    case \"Neptune\":\n    default:\n        return ()\n\
    \    }\n    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    let planet1OrbitSun = planet1Orbit - planet1Sun\n    let planet2OrbitSun\
    \ = planet2Orbit - planet2Sun\n    let planet1OrbitSunDistance = planet1OrbitSun.magnitude\n\
    \    let planet2OrbitSunDistance = planet2OrbitSun.magnitude\n    let planet1OrbitSunDistanceSquared\
    \ = planet1OrbitSunDistance * planet1OrbitSunDistance\n    let planet2OrbitSunDistanceSquared\
    \ = planet2OrbitSunDistance * planet2OrbitSunDistance\n    let planet1OrbitSunDistanceSquared\
    \ = planet1OrbitSunDistance * planet1OrbitSunDistance\n    let planet2OrbitSunDistanceSquared\
    \ = planet2OrbitSunDistance * planet2OrbitSunDistance\n    let planet1OrbitSunDistanceSquared\
    \ = planet1OrbitSunDistance * planet1OrbitSunDistance\n    let planet2OrbitSunDistanceSquared\
    \ = planet2OrbitSunDistance * planet2OrbitSunDistance\n    let planet1OrbitSunDistanceSquared\
    \ = planet1OrbitSunDistance * planet1OrbitSunDistance\n    let planet2OrbitSunDistanceSquared\
    \ = planet2OrbitSunDistance * planet2OrbitSunDistance\n    let planet1OrbitSunDistanceSquared\
    \ = planet1OrbitSunDistance * planet1OrbitSunDistance\n    let planet2OrbitSunDistanceSquared\
    \ = planet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4ygy5nu6.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmp4ygy5nu6.swift:15:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp4ygy5nu6.swift:16:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp4ygy5nu6.swift:17:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp4ygy5nu6.swift:18:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp4ygy5nu6.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp4ygy5nu6.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp4ygy5nu6.swift:21:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Neptune\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp4ygy5nu6.swift:26:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp4ygy5nu6.swift:27:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp4ygy5nu6.swift:28:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp4ygy5nu6.swift:29:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp4ygy5nu6.swi"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp94pk3oli/tmp94pk3oli.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b43029c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b42d20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b42d20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b42d1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94pk3oli                        0x000055712820256b <unavailable> + 5483

    5    libc.so.6                          0x00002b3b43215460 __libc_start_main +
    245

    6    tmp94pk3oli                        0x0000557128202119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\":\n    default:\n        return\
    \ ()\n    }\n    switch planet2 {\n    case \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\":\n    default:\n\
    \        return ()\n    }\n    var result = [String]()\n    let planet1 = planet1.lowercased()\n\
    \    let planet2 = planet2.lowercased()\n    let planet1Orbit = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2Orbit = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet1OrbitIndex = planet1.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n    let planet2OrbitIndex = planet\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpfuqbw03_.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\":\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \            break\n/tmp/tmpfuqbw03_.swift:19:5: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n    case \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\":\n   \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \            break\n/tmp/tmpfuqbw03_.swift:16:16: error: cannot convert return\
    \ expression of type '()' to return type '[String]'\n        return ()\n     \
    \          ^~\n/tmp/tmpfuqbw03_.swift:21:16: error: cannot convert return expression\
    \ of type '()' to return type '[String]'\n        return ()\n               ^~\n\
    /tmp/tmpfuqbw03_.swift:30:9: error: invalid redeclaration of 'planet1OrbitIndex'\n\
    \    let planet1OrbitIndex = planet1.hasPrefix(\"mercury\") ? \"mercury\" : \"\
    mercury\"\n        ^\n/tmp/tmpfuqbw03_.swift:28:9: note: 'planet1OrbitIndex' previously\
    \ declared here\n    let planet1OrbitIndex = planet1.hasPrefix(\"mercury\") ?\
    \ \"mercury\" : \"mercury\"\n        ^\n/tmp/tmpfuqbw03_.swift:31:9: error: invalid\
    \ redeclaration of 'planet2OrbitIndex'\n    let planet2OrbitIndex = planet2.hasPrefix(\"\
    mercury\") ? \"mercury\" : \"mercury\"\n        ^\n/tmp/tmpfuqbw03_.swift:29:9:\
    \ note: 'planet2OrbitIndex' previously declared here\n    let planet2OrbitIndex\
    \ = planet2.hasPrefix(\"mercury\") ? \"mercury\" : \"mercury\"\n        ^\n/tmp/tmpfuqbw03_.swift:32:9:\
    \ error: invalid redeclaration of 'planet1OrbitIndex'\n    let planet1OrbitIndex\
    \ = planet1.hasPrefix(\"mercury\") ? \"mercury\" : \"mercury\"\n        ^\n/tmp/tmpfuqbw03_.swift:28:9:\
    \ note: 'planet1OrbitIndex' previously declared here\n    let planet1OrbitIndex\
    \ = planet1.hasPrefix(\"mercury\") ? \"mercur"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n        planets.append(planet1)\n    }\n    \n    if planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 ==\
    \ \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"\
    Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n    }\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(\"Mercury\")\n\
    \        planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Mars\" {\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Mars\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\"\
    \ {\n        planets.append(\"Mercury\")\n        planets.append(\"Jupiter\")\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(\"Mercury\")\n        planets.append(\"Saturn\")\n    }\n \
    \   \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Uranus\")\n    }\n    \n    if planet1 ==\
    \ \"Mercury\" && planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n        planets.append(\"Neptune\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Earth\" {\n        planets.append(\"Venus\")\n        planets.append(\"\
    Earth\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n\
    \        planets.append(\"Venus\")\n        planets.append(\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpnjrspa2c.swift:70:24: error: unterminated string literal\n    \
    \    planets.append(\"\n                       ^\n/tmp/tmpnjrspa2c.swift:92:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpnjrspa2c.swift:12:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmpnjrspa2c.swift:70:24:\
    \ error: missing argument for parameter #1 in call\n        planets.append(\"\n\
    \                       ^\n                       <#String#>\nSwift.Array:6:37:\
    \ note: 'append' declared here\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\n/tmp/tmpnjrspa2c.swift:74:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n        return ()\n    default:\n\
    \        return ()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpjw2x15n3.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpjw2x15n3.swift:15:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpjw2x15n3.swift:16:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpjw2x15n3.swift:17:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpjw2x15n3.swift:18:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpjw2x15n3.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpjw2x15n3.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpjw2x15n3.swift:22:16:\
    \ error: cannot convert return expression of type '()' to return type '[String]'\n\
    \        return ()\n               ^~\n/tmp/tmpjw2x15n3.swift:24:16: error: cannot\
    \ convert return expression of type '()' to return type '[String]'\n        return\
    \ ()\n               ^~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    // TODO: write your code here\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp94pk3oli/tmp94pk3oli.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b43029c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b42d20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b42d20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b42d1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94pk3oli                        0x000055712820256b <unavailable> + 5483

    5    libc.so.6                          0x00002b3b43215460 __libc_start_main +
    245

    6    tmp94pk3oli                        0x0000557128202119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var result = [String]()\n    \n    if planet1 == planet2 {\n        return\
    \ result;\n    }\n    \n    var planet1Orbit = planet1Orbit(planet1)\n    var\
    \ planet2Orbit = planet2Orbit(planet2)\n    \n    if planet1Orbit == planet2Orbit\
    \ {\n        return result;\n    }\n    \n    var planet1OrbitDist = planet1OrbitDist(planet1,\
    \ planet2)\n    var planet2OrbitDist = planet2OrbitDist(planet1, planet2)\n  \
    \  \n    if planet1OrbitDist < planet2OrbitDist {\n        result.insert(planet1)\n\
    \    } else {\n        result.insert(planet2)\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpso4aesa2.swift:19:24: error: use of local variable 'planet1Orbit'\
    \ before its declaration\n    var planet1Orbit = planet1Orbit(planet1)\n     \
    \                  ^\n/tmp/tmpso4aesa2.swift:19:9: note: 'planet1Orbit' declared\
    \ here\n    var planet1Orbit = planet1Orbit(planet1)\n        ^\n/tmp/tmpso4aesa2.swift:20:24:\
    \ error: use of local variable 'planet2Orbit' before its declaration\n    var\
    \ planet2Orbit = planet2Orbit(planet2)\n                       ^\n/tmp/tmpso4aesa2.swift:20:9:\
    \ note: 'planet2Orbit' declared here\n    var planet2Orbit = planet2Orbit(planet2)\n\
    \        ^\n/tmp/tmpso4aesa2.swift:26:28: error: use of local variable 'planet1OrbitDist'\
    \ before its declaration\n    var planet1OrbitDist = planet1OrbitDist(planet1,\
    \ planet2)\n                           ^\n/tmp/tmpso4aesa2.swift:26:9: note: 'planet1OrbitDist'\
    \ declared here\n    var planet1OrbitDist = planet1OrbitDist(planet1, planet2)\n\
    \        ^\n/tmp/tmpso4aesa2.swift:27:28: error: use of local variable 'planet2OrbitDist'\
    \ before its declaration\n    var planet2OrbitDist = planet2OrbitDist(planet1,\
    \ planet2)\n                           ^\n/tmp/tmpso4aesa2.swift:27:9: note: 'planet2OrbitDist'\
    \ declared here\n    var planet2OrbitDist = planet2OrbitDist(planet1, planet2)\n\
    \        ^\n/tmp/tmpso4aesa2.swift:30:30: error: missing argument for parameter\
    \ 'at' in call\n        result.insert(planet1)\n                             ^\n\
    \                             , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n/tmp/tmpso4aesa2.swift:32:30:\
    \ error: missing argument for parameter 'at' in call\n        result.insert(planet2)\n\
    \                             ^\n                             , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    switch planet1 {\n    case \"Mercury\"\
    :\n    case \"Venus\":\n    case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\"\
    :\n    case \"Saturn\":\n    case \"Uranus\":\n    case \"Neptune\":\n       \
    \ planets.append(planet1)\n    default:\n        return planets\n    }\n    \n\
    \    switch planet2 {\n    case \"Mercury\":\n    case \"Venus\":\n    case \"\
    Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n  \
    \  case \"Uranus\":\n    case \"Neptune\":\n        planets.append(planet2)\n\
    \    default:\n        return planets\n    }\n    \n    var sun = Sun()\n    var\
    \ sunOrbit = sun.orbit(planet1)\n    var sunOrbit2 = sun.orbit(planet2)\n    \n\
    \    var sunDistance = sunOrbit.distance(sunOrbit2)\n    \n    var sunOrbits =\
    \ sunOrbit.orbits(planet2)\n    \n    var sunOrbits2 = sunOrbit2.orbits(planet1)\n\
    \    \n    var sunOrbitsDistance = sunOrbits.distance(sunOrbits2)\n    \n    var\
    \ sunOrbitsDistance2 = sunOrbits2.distance(sunOrbits)\n    \n    var sunOrbitsDistance3\
    \ = sunOrbitsDistance2.distance(sunOrbitsDistance)\n    \n    var sunOrbitsDistance4\
    \ = sunOrbitsDistance3.distance(sunOrbitsDistance2)\n    \n    var sunOrbitsDistance5\
    \ = sunOrbitsDistance4.distance(sunOrbitsDistance3)\n    \n    var sunOrbitsDistance6\
    \ = sunOrbitsDistance5.distance(sunOrbitsDistance4)\n    \n    var sunOrbitsDistance7\
    \ = sunOrbitsDistance6.distance(sunOrbitsDistance5)\n    \n    var sunOrbitsDistance8\
    \ = sunOrbitsDistance7.distance(sunOrbitsDistance6)\n    \n    var sunOrbitsDistance9\
    \ = sunOrbitsDistance8.distance(sunOrbitsDistance7)\n    \n    var sunOrbitsDistance10\
    \ = sunOrbitsDistance9.distance(sunOrbitsDistance8)\n    \n    var sunOrbitsDistance11\
    \ = sunOrbitsDistance10.distance(sunOrbitsDistance9)\n    \n    var sunOrbitsDistance12\
    \ = sunOrbitsDistance11.distance(sunOrbitsDistance10)\n    \n    var sunOrbitsDistance13\
    \ = sunOrbitsDistance12.distance(sunOrbitsDistance11)\n    \n    var sunOrbitsDistance14\
    \ = sunOrbitsDistance\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpp22_r71x.swift:16:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpp22_r71x.swift:17:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpp22_r71x.swift:18:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpp22_r71x.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpp22_r71x.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpp22_r71x.swift:21:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpp22_r71x.swift:22:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpp22_r71x.swift:30:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpp22_r71x.swift:31:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpp22_r71x.swift:32:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpp22_r71x.swift:33:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpp22_r71x.swift:34:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpp22_r71x.swi"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n        return ([planet1, planet2])\n\
    \    default:\n        return ()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp21cqr2_r.swift:14:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmp21cqr2_r.swift:15:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp21cqr2_r.swift:16:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmp21cqr2_r.swift:17:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmp21cqr2_r.swift:18:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmp21cqr2_r.swift:19:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp21cqr2_r.swift:20:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmp21cqr2_r.swift:24:16:\
    \ error: cannot convert return expression of type '()' to return type '[String]'\n\
    \        return ()\n               ^~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: Write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp55468aih/tmp55468aih.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d87897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d8758eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d8758e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d8758d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55468aih                        0x0000559fe0c1356b <unavailable> + 5483

    5    libc.so.6                          0x00002b5d87a83460 __libc_start_main +
    245

    6    tmp55468aih                        0x0000559fe0c13119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    if planet1 == planet2 {\n       \
    \ return planets\n    }\n    \n    let planet1Orbit = orbit(planet1)\n    let\
    \ planet2Orbit = orbit(planet2)\n    \n    if planet1Orbit == planet2Orbit {\n\
    \        return planets\n    }\n    \n    let planet1Sun = sunOrbit(planet1)\n\
    \    let planet2Sun = sunOrbit(planet2)\n    \n    if planet1Sun == planet2Sun\
    \ {\n        return planets\n    }\n    \n    let planet1SunOrbit = planet1Orbit\
    \ - planet1Sun\n    let planet2SunOrbit = planet2Orbit - planet2Sun\n    \n  \
    \  if planet1SunOrbit < planet2SunOrbit {\n        planets.append(planet1)\n \
    \       planets.append(planet2)\n        return planets\n    }\n    \n    planets.append(planet1)\n\
    \    planets.append(planet2)\n    return planets\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmppuxalkbb.swift:19:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmppuxalkbb.swift:20:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmppuxalkbb.swift:26:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmppuxalkbb.swift:27:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var planets = [String]()\n    \n    switch planet1 {\n    case\
    \ \"Mercury\":\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n       \
    \ planets.append(\"Neptune\")\n    case \"Venus\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\"\
    )\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Earth\":\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n       \
    \ planets.append(\"Neptune\")\n    case \"Mars\":\n        planets.append(\"Mercury\"\
    )\n        planets.append(\"Venus\")\n        planets.append(\"Earth\")\n    \
    \    planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n       \
    \ planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    case \"\
    Jupiter\":\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\"\
    )\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n     \
    \   planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n        planets.append(\"\
    Neptune\")\n    case \"Saturn\":\n        planets.append(\"Mercury\")\n      \
    \  planets.append(\"Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Uranus\"\
    )\n        planets.append(\"Neptune\")\n    case \"Uranus\":\n        planets.append(\"\
    Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Neptune\")\n    case\
    \ \"Neptune\":\n        planets.append(\"Mercury\")\n        planets.append(\"\
    Venus\")\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n\
    \        planets.append(\"Jupiter\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp_ypbrz12.swift:100:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp_ypbrz12.swift:12:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp_ypbrz12.swift:16:5:\
    \ error: switch must be exhaustive\n    switch planet1 {\n    ^\n/tmp/tmp_ypbrz12.swift:16:5:\
    \ note: do you want to add a default clause?\n    switch planet1 {\n    ^\n/tmp/tmp_ypbrz12.swift:82:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n    var result = [String]()\n    \n    if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n        if planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" ||\
    \ planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n\
    \            let distance1 = distance(planet1: planet1, planet2: planet2)\n  \
    \          let distance2 = distance(planet1: planet2, planet2: planet1)\n    \
    \        if distance1 < distance2 {\n                result.append(planet1)\n\
    \                result.append(planet2)\n            } else {\n              \
    \  result.append(planet2)\n                result.append(planet1)\n          \
    \  }\n        } else {\n            result.append(planet1)\n            result.append(planet2)\n\
    \        }\n    } else {\n        result.append(planet2)\n        result.append(planet1)\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpfq4uismy.swift:18:29: error: cannot find 'distance' in scope\n\
    \            let distance1 = distance(planet1: planet1, planet2: planet2)\n  \
    \                          ^~~~~~~~\n/tmp/tmpfq4uismy.swift:19:29: error: cannot\
    \ find 'distance' in scope\n            let distance2 = distance(planet1: planet2,\
    \ planet2: planet1)\n                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660011072
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    var planets = [String]()\n    \n    // TODO: write your code here\n \
    \   \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp7lvdj2xz/tmp7lvdj2xz.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ebf098c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ebed8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ebed8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ebed8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7lvdj2xz                        0x00005644117e056b <unavailable> + 5483

    5    libc.so.6                          0x00002b2ebf284460 __libc_start_main +
    245

    6    tmp7lvdj2xz                        0x00005644117e0119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660011072
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmph2f7o02u.swift:14:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660011072
