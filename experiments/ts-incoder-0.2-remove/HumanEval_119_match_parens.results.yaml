language: ts
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let open = 0;\n  let close = 0;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == \"(\") {\n      open++;\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] == \")\") {\n      close++;\n\
    \      if (open > close) {\n        return \"No\";\n      }\n      open--;\n \
    \     stack.pop();\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmphh1we_xv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmphh1we_xv.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmphh1we_xv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n\
    \    if (char === '(') {\n      stack.push(char);\n    } else if (char === ')')\
    \ {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      const\
    \ top = stack.pop();\n      if (top !== char) {\n        return 'No';\n      }\n\
    \    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9e4c9jl8.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9e4c9jl8.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9e4c9jl8.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmplqu6ig8v.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmplqu6ig8v.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmplqu6ig8v.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let index = 0;\n  let result = 'No';\n\
    \  while (index < lst.length) {\n    if (lst[index] === '(') {\n      stack.push(lst[index]);\n\
    \      index++;\n    } else if (lst[index] === ')') {\n      if (stack.length\
    \ === 0) {\n        result = 'Yes';\n        break;\n      }\n      result = stack.pop()\
    \ + result;\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return\
    \ result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp8hw0oo9n.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp8hw0oo9n.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp8hw0oo9n.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      if\
    \ (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length === 0) {\n        return \"No\";\n     \
    \ }\n      stack.pop();\n      stack.push(lst[i]);\n    }\n  }\n  return \"Yes\"\
    ;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpqjqbx9bf.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpqjqbx9bf.js:35:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpqjqbx9bf.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(i);\n    } else if (lst[i] ==\
    \ ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n   \
    \   stack.pop();\n    }\n  }\n  return stack.length === 0 ? 'Yes' : 'No';\n}\n\
    \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp8wyaarya.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp8wyaarya.js:25:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp8wyaarya.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm55xa30p.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm55xa30p.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm55xa30p.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] ===\
    \ '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      let top = stack.pop();\n    \
    \  if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmptzk6wgyt.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmptzk6wgyt.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmptzk6wgyt.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if\
    \ (stack.length === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return\
    \ 'No';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpmmynv5ck.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpmmynv5ck.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpmmynv5ck.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let result = '';\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      while (stack.length > 0 && lst[stack.length\
    \ - 1] !== '(') {\n        result += stack.pop();\n      }\n      if (stack.length\
    \ === 0) {\n        result += '()';\n      }\n      stack.pop();\n    } else {\n\
    \      result += lst[i];\n    }\n  }\n  return result === '()' ? 'Yes' : 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpoon02e_2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpoon02e_2.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpoon02e_2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  const res = [];\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == ')') {\n      if (stack.length == 0) {\n        res.push('No');\n\
    \      } else {\n        const top = stack.pop();\n        if (top != '(') {\n\
    \          res.push('No');\n        } else {\n          res.push('Yes');\n   \
    \     }\n      }\n    }\n  }\n  return res.join('');\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpozl3f6gb.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpozl3f6gb.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpozl3f6gb.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top < i) {\n        return \"No\";\n      }\n    }\n  }\n  return \"\
    Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpx3y5hgyu.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpx3y5hgyu.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpx3y5hgyu.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  let openCount = 0;\n  let\
    \ closeCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] ==\
    \ '(') {\n      openCount++;\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      closeCount++;\n      if (openCount > closeCount) {\n      \
    \  return 'No';\n      }\n      openCount--;\n      stack.pop();\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp4_8x_1vj.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp4_8x_1vj.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp4_8x_1vj.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(open);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      open--;\n      if (open\
    \ < 0) {\n        return \"No\";\n      }\n    } else if (lst[i] === \"(\") {\n\
    \      open++;\n      stack.push(open);\n    } else if (lst[i] === \")\") {\n\
    \      close++;\n      open--;\n      if (open < 0) {\n        return \"No\";\n\
    \      }\n    }\n  }\n  if (open !== close) {\n    return \"No\";\n  }\n  while\
    \ (open > 0) {\n    open--;\n    close--;\n    if (open < 0) {\n      return \"\
    No\";\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmprspb7fpe.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmprspb7fpe.js:53:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmprspb7fpe.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let open = 0;\n  let close = 0;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      open++;\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      close++;\n\
    \      open--;\n      if (open < 0) {\n        return 'No';\n      }\n    } else\
    \ if (open > close) {\n      return 'No';\n    }\n  }\n  return 'Yes';\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp_nypye6v.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp_nypye6v.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp_nypye6v.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] ===\
    \ '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      let top = stack.pop();\n    \
    \  if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmptzk6wgyt.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmptzk6wgyt.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmptzk6wgyt.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if\
    \ (stack.length === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return\
    \ 'No';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpmmynv5ck.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpmmynv5ck.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpmmynv5ck.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm55xa30p.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm55xa30p.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm55xa30p.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      stack.pop();\n    }\n  }\n\
    \  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpol0u284_.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpol0u284_.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpol0u284_.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'Yes';\n      }\n    }\n  }\n\
    \  return 'No';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnt9gpir0.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnt9gpir0.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnt9gpir0.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp79sbamwd.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp79sbamwd.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp79sbamwd.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  let open = 0;\n  let close\
    \ = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      open++;\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n\
    \      close++;\n      if (open > close) {\n        return 'No';\n      }\n  \
    \    open--;\n      stack.pop();\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp8ghwp8pb.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp8ghwp8pb.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp8ghwp8pb.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  let result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == ')') {\n      if (stack.length == 0) {\n        result.push(lst[i]);\n\
    \      } else {\n        stack.pop();\n      }\n    } else {\n      if (stack.length\
    \ == 0) {\n        result.push(lst[i]);\n      }\n    }\n  }\n  if (stack.length\
    \ != 0) {\n    return 'No';\n  }\n  return 'Yes';\n}\n\nconsole.log(match_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpwssv3c48.ts(34,1063): error TS1002: Unterminated
    string literal.

    ../../../../../tmp/tmpwssv3c48.ts(35,1): error TS1005: '','' expected.

    ../../../../../tmp/tmpwssv3c48.ts(35,9): error TS1005: '','' expected.

    '
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top !== lst[i]) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1jjphdm2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1jjphdm2.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1jjphdm2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp79sbamwd.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp79sbamwd.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp79sbamwd.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      stack.pop();\n    } else {\n      return 'No';\n    }\n\
    \  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnss7i5xy.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnss7i5xy.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnss7i5xy.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let openCount: number[] = [];\n  let closeCount: number[]\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n\
    \      openCount[stack.length] = openCount[stack.length] || 0;\n      openCount[stack.length]++;\n\
    \      stack.push(i);\n    } else if (lst[i] === \")\") {\n      closeCount[stack.length]\
    \ = closeCount[stack.length] || 0;\n      closeCount[stack.length]--;\n      if\
    \ (closeCount[stack.length] === 0) {\n        stack.pop();\n      }\n    }\n \
    \ }\n  if (openCount.some(x => x === 0) || closeCount.some(x => x === 0)) {\n\
    \    return \"No\";\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpjl_fu8qt.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpjl_fu8qt.js:36:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpjl_fu8qt.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  let index = 0;\n  while (index < lst.length) {\n    if (lst[index]\
    \ === \"(\") {\n      stack.push(lst[index]);\n      index++;\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      stack.pop();\n      index++;\n    } else {\n      index++;\n    }\n\
    \  }\n  return \"Yes\";\n}\n\nconsole.log(match_parens([\"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp_1aa8o9o.ts(33,1078): error TS1002: Unterminated
    string literal.

    ../../../../../tmp/tmp_1aa8o9o.ts(34,1): error TS1005: '','' expected.

    ../../../../../tmp/tmp_1aa8o9o.ts(34,9): error TS1005: '','' expected.

    '
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == \"(\") {\n      stack.push(i);\n    } else if (lst[i] ==\
    \ \")\") {\n      if (stack.length == 0) {\n        return \"No\";\n      }\n\
    \      let top = stack.pop();\n      if (top < i) {\n        return \"No\";\n\
    \      }\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmptfmdl1a_.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmptfmdl1a_.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmptfmdl1a_.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top !== lst[i]) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1jjphdm2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1jjphdm2.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1jjphdm2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm55xa30p.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm55xa30p.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm55xa30p.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpce449bbz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpce449bbz.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpce449bbz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: number[] = [];\n  const result: string[] = [];\n  for (let i = 0; i <\
    \ lst.length; i++) {\n    const char = lst[i];\n    if (char === \"(\") {\n  \
    \    stack.push(i);\n    } else if (char === \")\") {\n      if (stack.length\
    \ === 0) {\n        result.push(char);\n      } else {\n        const top = stack.pop();\n\
    \        if (top === i) {\n          result.push(char);\n        } else {\n  \
    \        result.push(char);\n        }\n      }\n    }\n  }\n  return result.length\
    \ === lst.length ? \"Yes\" : \"No\";\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpkov5mier.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpkov5mier.js:38:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpkov5mier.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  let openCount = 0;\n  let closeCount = 0;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      openCount++;\n \
    \     stack.push(i);\n    } else if (lst[i] === ')') {\n      closeCount++;\n\
    \      if (openCount > closeCount) {\n        return 'No';\n      }\n      openCount--;\n\
    \      stack.pop();\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp05qppmzy.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp05qppmzy.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp05qppmzy.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  let i = 0;\n  while\
    \ (i < lst.length) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(open);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n    } else if (open > close)\
    \ {\n      return \"No\";\n    }\n    i++;\n  }\n  if (open > close) {\n    return\
    \ \"No\";\n  }\n  while (open > 0) {\n    open--;\n    if (stack[open] === 0)\
    \ {\n      return \"No\";\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpvn70m8m0.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpvn70m8m0.js:46:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpvn70m8m0.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else {\n      if (stack.length != 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  if (stack.length != 0) {\n    return 'No';\n \
    \ }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpjx2opq5i.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpjx2opq5i.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpjx2opq5i.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n\
    \    if (char === \"(\") {\n      stack.push(char);\n    } else if (char === \"\
    )\") {\n      if (stack.length === 0) {\n        return \"No\";\n      }\n   \
    \   const top = stack.pop();\n      if (top !== \"(\") {\n        return \"No\"\
    ;\n      }\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpt1wjdc_t.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpt1wjdc_t.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpt1wjdc_t.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      stack.pop();\n    } else {\n      if (stack.length === 0) {\n\
    \        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm_ykzwmc.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm_ykzwmc.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm_ykzwmc.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(close);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n    }\n  }\n  return \"Yes\"\
    ;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpjlbof_uv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpjlbof_uv.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpjlbof_uv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      stack.push(lst[i]);\n      open++;\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"Yes\";\n      }\n      open--;\n    }\n  }\n  return \"No\"\
    ;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpqqmj60me.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpqqmj60me.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpqqmj60me.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(close);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      open--;\n      if (open\
    \ < 0) {\n        return \"No\";\n      }\n    } else if (open > 0) {\n      open--;\n\
    \    }\n  }\n  if (open > 0) {\n    return \"No\";\n  }\n  let stack2 = [];\n\
    \  let open2 = 0;\n  let close2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (lst[i] === \"(\") {\n      open2++;\n      stack2.push(close2);\n   \
    \ } else if (lst[i] === \")\") {\n      close2++;\n      open2--;\n      if (open2\
    \ < 0) {\n        return \"No\";\n      }\n    } else if (open2 > 0) {\n     \
    \ open2--;\n    }\n  }\n  if (open2 > 0) {\n    return \"No\";\n  }\n  let stack3\
    \ = [];\n  let open3 = 0;\n  let close3 = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      open3++;\n      stack3.push(close3);\n\
    \    } else if (lst[i] === \")\") {\n      close3++;\n      open3--;\n      if\
    \ (open3 < 0) {\n        return \"No\";\n      }\n    } else if (open3 > 0) {\n\
    \      open3--;\n    }\n  }\n  if (open3 > 0) {\n    return \"No\";\n  }\n  let\
    \ stack4 = [];\n  let open4 = 0;\n  let close4 = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      open4++;\n      stack4.push(close4);\n\
    \    } else if (lst[i] === \")\") {\n      close4++;\n      open4--;\n      if\
    \ (open4 < 0) {\n        return \"No\";\n      }\n    } else if (open4 > 0) {\n\
    \      open4--;\n    }\n  }\n  if (open4 > 0) {\n    return \"No\";\n  }\n  let\
    \ stack5 = [];\n  let open5 = 0;\n  let close5 = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      open5++;\n      stack5.push(close5);\n\
    \    } else if (lst[i] === \")\") {\n      close5++;\n      open5--;\n      if\
    \ (open5 < 0) {\n        return \"No\";\n      }\n    } else if (open5 > 0) {\n\
    \      open5--;\n    }\n  }\n  if (open5 > 0) {\n    return \"No\";\n  }\n  let\
    \ stack6 = [];\n  let open6 = 0;\n  let close6 = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      open6++;\n      stack6.push(close6);\n\
    \    } else if (lst[i] === \")\") {\n      close\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpwyhxw15j.ts(143,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      open++;\n    } else if (lst[i] ===\
    \ \")\") {\n      close++;\n    } else {\n      if (open > close) {\n        return\
    \ \"No\";\n      }\n      stack.push(lst[i]);\n    }\n  }\n  if (open > close)\
    \ {\n    return \"No\";\n  }\n  while (open > 0 && close > 0) {\n    if (open\
    \ > close) {\n      return \"No\";\n    }\n    if (open === close) {\n      open--;\n\
    \      close--;\n    } else {\n      stack.pop();\n    }\n  }\n  return \"Yes\"\
    ;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmphcktwreh.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmphcktwreh.js:48:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmphcktwreh.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpce449bbz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpce449bbz.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpce449bbz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      index = stack.pop();\n    } else {\n      index++;\n    }\n  }\n \
    \ return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9zcxkmyh.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9zcxkmyh.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9zcxkmyh.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      stack.pop();\n      stack.push(lst[i]);\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpmwv7o34r.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpmwv7o34r.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpmwv7o34r.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(i);\n    } else if (lst[i] ==\
    \ ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n   \
    \   let top = stack.pop();\n      if (top < i) {\n        return 'No';\n     \
    \ }\n    }\n  }\n  return 'Yes';\n}\n\nconsole.log(match_parens(['(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmprvjujeu1.ts(28,1129): error TS1002: Unterminated
    string literal.

    ../../../../../tmp/tmprvjujeu1.ts(29,1): error TS1005: '','' expected.

    ../../../../../tmp/tmprvjujeu1.ts(29,9): error TS1005: '','' expected.

    '
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let result = 'No';\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        result\
    \ = 'Yes';\n        break;\n      }\n      stack.pop();\n    }\n  }\n  return\
    \ result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpylmuligk.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpylmuligk.js:27:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpylmuligk.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n     \
    \ stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      while (stack.length\
    \ > 0 && lst[stack.length - 1] !== \"(\") {\n        stack.pop();\n      }\n \
    \     if (stack.length === 0) {\n        result.push(lst[i]);\n      }\n    }\n\
    \  }\n  if (stack.length > 0) {\n    return \"No\";\n  }\n  return result.join(\"\
    \");\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmptgqh8ncm.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmptgqh8ncm.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: number[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(i);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      let top = stack.pop();\n      if (top < i) {\n        return 'No';\n  \
    \    }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp697x7y82.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp697x7y82.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp697x7y82.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      open++;\n      stack.push(open);\n\
    \    } else if (lst[i] === ')') {\n      close++;\n      open--;\n      if (open\
    \ < 0) {\n        return 'No';\n      }\n    } else if (open > close) {\n    \
    \  return 'No';\n    }\n  }\n  if (open !== close) {\n    return 'No';\n  }\n\
    \  let stackLen = stack.length;\n  for (let i = 0; i < stackLen; i++) {\n    if\
    \ (stack[i] > close) {\n      return 'No';\n    }\n  }\n  return 'Yes';\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp38yyh5ij.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp38yyh5ij.js:44:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp38yyh5ij.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\nconsole.log(match_parens([\"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\"\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpqxktrimc.ts(32,1): error TS1005: '','' expected.

    ../../../../../tmp/tmpqxktrimc.ts(32,9): error TS1005: '','' expected.

    '
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(i);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      stack.pop();\n    }\n\
    \  }\n  if (open !== close) {\n    return \"No\";\n  }\n  let result = \"Yes\"\
    ;\n  while (open > 0) {\n    open--;\n    if (stack.length > 0) {\n      close\
    \ = stack[stack.length - 1];\n      result = result + \"(\" + lst[open] + \")\"\
    \ + lst[close];\n    } else {\n      result = result + lst[open];\n    }\n  }\n\
    \  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpf4pcouqs.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpf4pcouqs.js:43:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpf4pcouqs.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char\
    \ === \"(\") {\n      stack.push(char);\n    } else if (char === \")\") {\n  \
    \    if (stack.length === 0) {\n        return \"No\";\n      }\n      const top\
    \ = stack.pop();\n      if (top !== char) {\n        return \"No\";\n      }\n\
    \    }\n  }\n  if (stack.length === 0) {\n    return \"Yes\";\n  }\n  return \"\
    No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmplpbu0cog.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmplpbu0cog.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let result: string = \"\";\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    let char = lst[i];\n    if (char === \"(\") {\n      stack.push(i);\n\
    \    } else if (char === \")\") {\n      let index = stack.pop();\n      if (index\
    \ === -1) {\n        return \"No\";\n      }\n      result += lst[stack.length\
    \ - 1];\n      result += lst[index];\n    }\n  }\n  return result === \"()\" ?\
    \ \"Yes\" : \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpmqeesfu0.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpmqeesfu0.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpmqeesfu0.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(i);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      const top = stack.pop();\n      if (top === i) {\n        return 'Yes';\n\
    \      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp_t3kskmz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp_t3kskmz.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp_t3kskmz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(i);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n      stack.pop();\n    }\n \
    \ }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpokcshksf.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpokcshksf.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpokcshksf.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(i);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n      stack.pop();\n    }\n \
    \ }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpokcshksf.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpokcshksf.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpokcshksf.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    }\n  }\n  if (stack.length === 0) {\n    return \"Yes\";\n  }\n  return \"\
    No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpv7mpfk7n.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpv7mpfk7n.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpv7mpfk7n.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top !== lst[i]) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1jjphdm2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1jjphdm2.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1jjphdm2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  let openCount = 0;\n  let\
    \ closeCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] ===\
    \ '(') {\n      openCount++;\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      closeCount++;\n      if (closeCount > openCount) {\n     \
    \   stack.push(lst[i]);\n      }\n    } else if (closeCount > openCount) {\n \
    \     stack.push(lst[i]);\n    }\n  }\n  if (stack.length !== lst.length - 1)\
    \ {\n    return 'No';\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmplaw_1mse.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmplaw_1mse.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmplaw_1mse.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      let top = stack.pop();\n      if (top === index) {\n        return\
    \ \"Yes\";\n      }\n    }\n    index++;\n  }\n  return \"No\";\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpeg_7dmyv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpeg_7dmyv.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpeg_7dmyv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n\
    \    if (char === '(') {\n      stack.push(char);\n    } else if (char === ')')\
    \ {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      const\
    \ top = stack.pop();\n      if (top !== char) {\n        return 'No';\n      }\n\
    \    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9e4c9jl8.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9e4c9jl8.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9e4c9jl8.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n  return 'Yes';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpls8tyq5a.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpls8tyq5a.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpls8tyq5a.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnxos5kxb.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnxos5kxb.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnxos5kxb.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpio6rx54y.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpio6rx54y.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpio6rx54y.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else {\n      if (stack.length == 0) {\n        return\
    \ 'No';\n      }\n      stack.pop();\n      stack.push(lst[i]);\n    }\n  }\n\
    \  return stack.length == 0 ? 'Yes' : 'No';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpsoe660m4.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpsoe660m4.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpsoe660m4.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm55xa30p.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm55xa30p.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm55xa30p.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  let result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        result.push(lst[i]);\n\
    \      } else {\n        stack.pop();\n      }\n    }\n  }\n  if (stack.length\
    \ === 0) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpxeyflb3j.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpxeyflb3j.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpxeyflb3j.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    }\n  }\n  if (stack.length === 0) {\n    return \"Yes\";\n  }\n  return \"\
    No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpv7mpfk7n.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpv7mpfk7n.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpv7mpfk7n.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let result = 'No';\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == ')') {\n      if (stack.length == 0) {\n        result\
    \ = 'Yes';\n        break;\n      }\n      stack.pop();\n    } else {\n      continue;\n\
    \    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpf_lw18c8.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpf_lw18c8.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpf_lw18c8.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top !== lst[i]) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1jjphdm2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1jjphdm2.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1jjphdm2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length === 0) {\n        return \"No\";\n     \
    \ }\n    }\n  }\n  if (stack.length === 0) {\n    return \"Yes\";\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpmyswa3rz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpmyswa3rz.js:36:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpmyswa3rz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top !== lst[i]) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1jjphdm2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1jjphdm2.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1jjphdm2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n      open++;\n\
    \    } else if (lst[i] === ')') {\n      close++;\n      if (open > close) {\n\
    \        return 'Yes';\n      }\n      open--;\n    }\n  }\n  return 'No';\n}\n\
    \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp5iy29bkm.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp5iy29bkm.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp5iy29bkm.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      let top = stack.pop();\n      if (top === index) {\n        return\
    \ \"Yes\";\n      }\n    }\n    index++;\n  }\n  return \"No\";\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpeg_7dmyv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpeg_7dmyv.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpeg_7dmyv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     const top = stack.pop();\n      if (top != '(') {\n        return 'No';\n\
    \      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp3fplqcxt.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp3fplqcxt.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp3fplqcxt.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length === 0) {\n        return \"No\";\n     \
    \ }\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp25nzznh8.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp25nzznh8.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp25nzznh8.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp_tvchdbe.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp_tvchdbe.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp_tvchdbe.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let openCount = 0;\n  let closeCount = 0;\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      openCount++;\n\
    \      stack.push(i);\n    } else if (lst[i] === \")\") {\n      closeCount++;\n\
    \      if (openCount > closeCount) {\n        return \"No\";\n      }\n      openCount--;\n\
    \      stack.pop();\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp36r_1163.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp36r_1163.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp36r_1163.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top < i) {\n        return \"No\";\n      }\n    }\n\
    \  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9cbei7az.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9cbei7az.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9cbei7az.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpqod90ias.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpqod90ias.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpqod90ias.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else {\n      if (stack.length != 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpf1kb7fmg.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpf1kb7fmg.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpf1kb7fmg.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(lst[i]);\n      i++;\n    } else if (lst[i] === \")\"\
    ) {\n      if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \      i++;\n    } else {\n      i++;\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpfx7r65en.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpfx7r65en.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpfx7r65en.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: number[] = [];\n  const stackLen = lst.length;\n  for (let i = 0; i <\
    \ stackLen; i++) {\n    stack.push(0);\n  }\n  for (let i = 0; i < stackLen; i++)\
    \ {\n    const cur = stack[i];\n    if (cur === -1) {\n      continue;\n    }\n\
    \    if (lst[i] === \"(\") {\n      stack[cur] = 1;\n    } else if (lst[i] ===\
    \ \")\") {\n      stack[cur] = -1;\n    } else {\n      stack[cur]++;\n    }\n\
    \  }\n  if (stack[0] === stack[stackLen - 1]) {\n    return \"Yes\";\n  } else\
    \ {\n    return \"No\";\n  }\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnttshyro.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnttshyro.js:41:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnttshyro.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length === 0) {\n        return \"No\";\n     \
    \ }\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp25nzznh8.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp25nzznh8.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp25nzznh8.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpai2l3y_b.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpai2l3y_b.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpai2l3y_b.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else {\n      if (stack.length == 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpgvi_l71w.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpgvi_l71w.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpgvi_l71w.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(open);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      open--;\n      if (open\
    \ < 0) {\n        return \"No\";\n      }\n      if (close !== open) {\n     \
    \   return \"No\";\n      }\n    }\n  }\n  if (open !== close) {\n    return \"\
    No\";\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9_hxtpam.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9_hxtpam.js:38:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9_hxtpam.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpqod90ias.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpqod90ias.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpqod90ias.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let result: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      stack.push(i);\n    } else if (lst[i]\
    \ === \")\") {\n      if (stack.length === 0) {\n        result.push(lst[i]);\n\
    \      } else {\n        let top = stack.pop();\n        if (top < i) {\n    \
    \      result.push(lst[i]);\n        }\n      }\n    }\n  }\n  if (stack.length\
    \ > 0) {\n    return \"No\";\n  }\n  return result.join(\"\");\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp7ihi4b3f.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp7ihi4b3f.js:37:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp7ihi4b3f.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n  if (stack.length\
    \ === 0) {\n    return 'Yes';\n  }\n  return 'No';\n}\n\nconsole.log(match_parens(['(',\
    \ ')']));\nconsole.log(match_parens(['(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(',\
    \ ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\n\
    console.log(match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpc4fo5rtr.ts(42,124): error TS1002: Unterminated string
    literal.

    ../../../../../tmp/tmpc4fo5rtr.ts(43,1): error TS1005: '','' expected.

    ../../../../../tmp/tmpc4fo5rtr.ts(43,9): error TS1005: '','' expected.

    '
  timestamp: 1659979361
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = new Stack<string>();\n  stack.add(lst[0]);\n  let isGood = true;\n \
    \ for (let i = 1; i < lst.length; i++) {\n    const str = lst[i];\n    if (str\
    \ === '(') {\n      stack.add(str);\n    } else if (str === ')') {\n      if (stack.isEmpty())\
    \ {\n        isGood = false;\n        break;\n      }\n      const top = stack.pop();\n\
    \      if (top !== str) {\n        isGood = false;\n        break;\n      }\n\
    \    } else {\n      if (stack.isEmpty()) {\n        isGood = false;\n       \
    \ break;\n      }\n      const top = stack.pop();\n      if (top !== str) {\n\
    \        isGood = false;\n        break;\n      }\n      stack.add(str);\n   \
    \ }\n  }\n  return isGood ? 'Yes' : 'No';\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpbahcd4ir.ts(14,21): error TS2552: Cannot find name
    ''Stack''. Did you mean ''stack''?

    '
  timestamp: 1659979361
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  let i = 0;\n  let j = 0;\n  while (i < lst.length) {\n    while (stack.length\
    \ && lst[i] === stack[stack.length - 1]) {\n      stack.pop();\n    }\n    if\
    \ (lst[i] === '(') {\n      stack.push(lst[i]);\n      i++;\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      j = stack.indexOf(lst[i]);\n      stack.pop();\n      i++;\n    } else\
    \ {\n      i++;\n    }\n  }\n  return stack.length === 0;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmppixgxeje.ts(35,3): error TS2322: Type ''boolean''
    is not assignable to type ''string''.

    '
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if\
    \ (stack.length === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return\
    \ 'No';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpmmynv5ck.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpmmynv5ck.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpmmynv5ck.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let open = 0;\n  let close = 0;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \      open++;\n    } else if (lst[i] === ')') {\n      close++;\n      if (open\
    \ > close) {\n        return 'No';\n      }\n      open--;\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp8b5uved4.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp8b5uved4.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp8b5uved4.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpuw9vd0nv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpuw9vd0nv.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpuw9vd0nv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpio6rx54y.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpio6rx54y.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpio6rx54y.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpce449bbz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpce449bbz.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpce449bbz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n    if (lst[index]\
    \ === '(') {\n      stack.push(index);\n    }\n    if (lst[index] === ')') {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n      index =\
    \ stack.pop();\n    }\n    index++;\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmprbs6slw7.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmprbs6slw7.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmprbs6slw7.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n  return 'Yes';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpls8tyq5a.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpls8tyq5a.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpls8tyq5a.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      let top = stack.pop();\n  \
    \    if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6s24hk1h.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6s24hk1h.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6s24hk1h.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else {\n      if (stack.length != 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpi0f0ecet.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpi0f0ecet.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpi0f0ecet.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      const top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpsmzatfl6.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpsmzatfl6.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpsmzatfl6.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      if\
    \ (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length === 0) {\n        return \"No\";\n     \
    \ }\n      stack.push(lst[i]);\n    }\n  }\n  if (stack.length === 0) {\n    return\
    \ \"Yes\";\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp2d_r0t1r.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp2d_r0t1r.js:37:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp2d_r0t1r.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n \
    \ return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpn5m_l8tq.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpn5m_l8tq.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpn5m_l8tq.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const cur = lst[i];\n    if (cur === '(') {\n      stack.push(cur);\n\
    \    } else if (cur === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== cur) {\n \
    \       return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp71dlcvwi.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp71dlcvwi.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp71dlcvwi.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(open);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      open--;\n      if (open\
    \ < 0) {\n        return \"No\";\n      }\n    } else if (lst[i] === \"(\") {\n\
    \      open++;\n      stack.push(open);\n    } else if (lst[i] === \")\") {\n\
    \      close++;\n      open--;\n      if (open < 0) {\n        return \"No\";\n\
    \      }\n    }\n  }\n  if (open !== close) {\n    return \"No\";\n  }\n  let\
    \ stack2 = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack2.push(open);\n    } else if (lst[i] === \")\") {\n      open\
    \ = stack.pop();\n      close = stack2.pop();\n      if (open !== close) {\n \
    \       return \"No\";\n      }\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpodaza73v.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpodaza73v.js:59:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpodaza73v.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      open++;\n      stack.push(open);\n\
    \    } else if (lst[i] === ')') {\n      close++;\n      if (open > close) {\n\
    \        return 'No';\n      }\n      open--;\n      stack.pop();\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmphe92znfx.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmphe92znfx.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmphe92znfx.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(i);\n    } else if (lst[i] ===\
    \ ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n   \
    \   let top = stack.pop();\n      if (top === i) {\n        return 'Yes';\n  \
    \    }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9k7__4u2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9k7__4u2.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9k7__4u2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const char\
    \ = lst[i];\n    if (char === \"(\") {\n      stack.push(i);\n    } else if (char\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      const top = stack.pop();\n      if (top === i) {\n        return \"\
    Yes\";\n      }\n    }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpzfmu9xkl.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpzfmu9xkl.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpzfmu9xkl.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack: Stack<string> = new Stack();\n  const result: string[] = [];\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char === '(')\
    \ {\n      stack.push(char);\n    } else if (char === ')') {\n      if (stack.length\
    \ === 0) {\n        result.push(char);\n      } else {\n        stack.pop();\n\
    \      }\n    }\n  }\n  if (stack.length === 0) {\n    return 'Yes';\n  }\n  return\
    \ 'No';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpnlrm6fje.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmpnlrm6fje.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      let top = stack.pop();\n  \
    \    if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6s24hk1h.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6s24hk1h.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6s24hk1h.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ == \"(\") {\n      stack.push(i);\n    } else if (lst[i] == \")\") {\n     \
    \ if (stack.length == 0) {\n        return \"No\";\n      }\n      let top = stack.pop();\n\
    \      if (top < i) {\n        return \"No\";\n      }\n    }\n  }\n  return \"\
    Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpad503adp.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpad503adp.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpad503adp.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n  return 'Yes';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpls8tyq5a.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpls8tyq5a.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpls8tyq5a.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n  return 'Yes';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpls8tyq5a.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpls8tyq5a.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpls8tyq5a.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let open = 0;\n  let close = 0;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      open++;\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      close++;\n\
    \      if (open > close) {\n        return 'No';\n      }\n      open--;\n   \
    \   stack.pop();\n    }\n  }\n  return 'Yes';\n}\n\nconsole.log(match_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp54ucfw7v.ts(30,1099): error TS1002: Unterminated
    string literal.

    ../../../../../tmp/tmp54ucfw7v.ts(31,1): error TS1005: '','' expected.

    ../../../../../tmp/tmp54ucfw7v.ts(31,9): error TS1005: '','' expected.

    '
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      const top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6632vx1z.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6632vx1z.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6632vx1z.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      const top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6632vx1z.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6632vx1z.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6632vx1z.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(close);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n    }\n  }\n  if (open > close)\
    \ {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp090ca9bb.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp090ca9bb.js:35:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp090ca9bb.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(i);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      stack.pop();\n    }\n\
    \    if (open > close) {\n      return \"No\";\n    }\n  }\n  return \"Yes\";\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpsl53f6ru.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpsl53f6ru.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpsl53f6ru.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  const stackLen = lst.length;\n  const stackMaxLen = Math.max(stackLen,\
    \ lst[1].length);\n  for (let i = 0; i < stackMaxLen; i++) {\n    stack.push(lst[0][i]);\n\
    \  }\n  for (let i = 1; i < stackLen; i++) {\n    for (let j = 0; j < stackMaxLen;\
    \ j++) {\n      if (stack[j] === lst[i][j]) {\n        stack[j]++;\n        break;\n\
    \      }\n      if (stack[j] === lst[i][j]) {\n        stack[j]++;\n        stack[j\
    \ + 1]++;\n        break;\n      }\n      if (stack[j] === lst[i][j]) {\n    \
    \    stack[j]++;\n        stack[j + 1]++;\n        stack[j + 2]++;\n        break;\n\
    \      }\n      if (stack[j] === lst[i][j]) {\n        stack[j]++;\n        stack[j\
    \ + 1]++;\n        stack[j + 2]++;\n        stack[j + 3]++;\n        break;\n\
    \      }\n    }\n  }\n  if (stackLen === stackMaxLen) {\n    return \"Yes\";\n\
    \  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpbqx8fn99.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpbqx8fn99.js:51:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpbqx8fn99.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n     \
    \ stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      while (stack.length\
    \ > 0 && lst[stack.length - 1] !== \"(\") {\n        result.push(stack.pop());\n\
    \      }\n      stack.pop();\n    } else {\n      while (stack.length > 0 && lst[stack.length\
    \ - 1] !== \"(\") {\n        result.push(stack.pop());\n      }\n      stack.push(lst[i]);\n\
    \    }\n  }\n  while (stack.length > 0) {\n    result.push(stack.pop());\n  }\n\
    \  return result.length === lst.length ? \"Yes\" : \"No\";\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpdvduub1f.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmpdvduub1f.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp79sbamwd.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp79sbamwd.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp79sbamwd.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: number[] = [];\n  const stackLen = lst.length;\n  for (let i = 0; i <\
    \ stackLen; i++) {\n    stack.push(0);\n  }\n  for (let i = 0; i < stackLen; i++)\
    \ {\n    while (stack.length > 0 && lst[stack[stack.length - 1]] !== \"(\") {\n\
    \      stack.pop();\n    }\n    if (stack.length > 0 && lst[stack[stack.length\
    \ - 1]] === \")\") {\n      stack.pop();\n    } else {\n      stack.push(i);\n\
    \    }\n  }\n  if (stack.length > 0) {\n    return \"No\";\n  } else {\n    return\
    \ \"Yes\";\n  }\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6sw83was.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6sw83was.js:37:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6sw83was.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top < i) {\n        return \"No\";\n      }\n    }\n  }\n  return \"\
    Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpzfn890op.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpzfn890op.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpzfn890op.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else {\n      if (stack.length != 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz4ypq717.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz4ypq717.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz4ypq717.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  const open = lst.shift();\n  const\
    \ close = lst.shift();\n  stack.push(open);\n  while (stack.length > 0) {\n  \
    \  const opening = stack.pop();\n    if (opening === close) {\n      return true;\n\
    \    }\n    if (opening === '(') {\n      stack.push(close);\n    } else if (opening\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      return 'No';\n    }\n  }\n  return 'Yes';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpac16vbzk.ts(18,7): error TS2322: Type ''true'' is
    not assignable to type ''string''.

    '
  timestamp: 1659979365
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let result: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      stack.push(i);\n    } else if (lst[i]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      stack.pop();\n    } else {\n      if (stack.length === 0) {\n    \
    \    result.push(lst[i]);\n      }\n    }\n  }\n  if (stack.length === 0) {\n\
    \    return \"Yes\";\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpdctk9470.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpdctk9470.js:37:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpdctk9470.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack:\
    \ number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] ===\
    \ '(') {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top < i) {\n        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp3u8vxsak.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp3u8vxsak.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp3u8vxsak.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnxos5kxb.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnxos5kxb.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnxos5kxb.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  const res = [];\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        res.push('No');\n\
    \      } else {\n        const top = stack.pop();\n        if (top !== lst[i])\
    \ {\n          res.push('No');\n        } else {\n          res.push('Yes');\n\
    \        }\n      }\n    }\n  }\n  return res.join('');\n}\n\nconsole.log(match_parens(['(',\
    \ '(', ')', ')']));\nconsole.log(match_parens(['(', ')', ')']));\nconsole.log(match_parens(['(',\
    \ ')']));\nconsole.log(match_parens(['(']));\nconsole.log(match_parens(['()']));\n\
    console.log(match_parens(['(', '(', ')', ')']));\nconsole.log(match_parens(['(',\
    \ ')', ')', '(', ')']));\nconsole.log(match_parens(['(', '(', ')', ')', '(', ')']));\n\
    console.log(match_parens(['(', '(', ')', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ '(', ')', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ '(', ')', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ '(', ')', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ '(', ')', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\n\
    console.log(match_parens(['(', '(', ')', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', '(', ')',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')']));\nconsole.log(match_parens(['(', '(', ')', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ '(', ')', ')', '(', ')', '(', ')', '\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpldzrpx68.ts(48,68): error TS1002: Unterminated string
    literal.

    ../../../../../tmp/tmpldzrpx68.ts(49,1): error TS1005: '','' expected.

    ../../../../../tmp/tmpldzrpx68.ts(49,9): error TS1005: '','' expected.

    '
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpl6qlx301.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpl6qlx301.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpl6qlx301.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    }\n  }\n  return stack.length === 0 ? 'Yes' : 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpfz_sgj7e.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpfz_sgj7e.js:25:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpfz_sgj7e.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpce449bbz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpce449bbz.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpce449bbz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n\
    \    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnahi791b.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnahi791b.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnahi791b.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let open = 0;\n  let close = 0;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      open++;\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] == ')') {\n      close++;\n\
    \      if (open > close) {\n        return 'No';\n      }\n      open--;\n   \
    \   stack.pop();\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpaokqppg1.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpaokqppg1.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpaokqppg1.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      let top = stack.pop();\n  \
    \    if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6s24hk1h.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6s24hk1h.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6s24hk1h.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmplqu6ig8v.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmplqu6ig8v.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmplqu6ig8v.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char\
    \ === \"(\") {\n      stack.push(char);\n    } else if (char === \")\") {\n  \
    \    if (stack.length === 0) {\n        result.push(char);\n      } else {\n \
    \       stack.pop();\n      }\n    }\n  }\n  if (stack.length > 0) {\n    return\
    \ \"No\";\n  }\n  return result.join(\"\");\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp9z2dagf3.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmp9z2dagf3.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(i);\n    } else if (lst[i] ==\
    \ ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n    \
    \  let top = stack.pop();\n      if (top != i) {\n        return 'No';\n     \
    \ }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpn_zc1ajf.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpn_zc1ajf.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpn_zc1ajf.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp79sbamwd.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp79sbamwd.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp79sbamwd.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp79sbamwd.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp79sbamwd.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp79sbamwd.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(i);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top === i) {\n        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpqod90ias.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpqod90ias.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpqod90ias.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      stack.pop();\n    }\n  }\n\
    \  if (stack.length === 0) {\n    return \"Yes\";\n  }\n  return \"No\";\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpncoi6uos.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpncoi6uos.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpncoi6uos.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push(i);\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      const top = stack.pop();\n      if (top < i) {\n        return 'No';\n\
    \      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmphya65152.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmphya65152.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmphya65152.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      open++;\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      close++;\n      if (open > close) {\n\
    \        return 'No';\n      }\n      open--;\n      stack.pop();\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp8h_f60fa.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp8h_f60fa.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp8h_f60fa.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push('(');\n    } else if (lst[i] ==\
    \ ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n    \
    \  stack.pop();\n    } else {\n      if (stack.length == 0) {\n        return\
    \ 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpcyuaoqa1.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpcyuaoqa1.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpcyuaoqa1.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      stack.push(lst[i]);\n    }\n  }\n  return 'Yes';\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpqrkyc98d.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpqrkyc98d.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpqrkyc98d.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979369
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(i);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n    }\n  }\n  if (open > close)\
    \ {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp3txfxe80.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp3txfxe80.js:35:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp3txfxe80.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979369
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      open++;\n      stack.push(i);\n\
    \    } else if (lst[i] === \")\") {\n      close++;\n      if (open > close) {\n\
    \        return \"No\";\n      }\n      open--;\n    } else if (open > close)\
    \ {\n      return \"No\";\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1pq91kzs.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1pq91kzs.js:35:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1pq91kzs.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.push(lst[i]);\n\
    \    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpk0ulmnp4.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpk0ulmnp4.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpk0ulmnp4.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  stack.push(lst[0]);\n  while (stack.length > 0) {\n    const str = stack.pop();\n\
    \    if (str === '(') {\n      stack.push(lst[1]);\n    } else if (str === ')')\
    \ {\n      if (lst[1] === undefined) {\n        result.push('No');\n      } else\
    \ {\n        result.push('Yes');\n        stack.push(lst[1]);\n      }\n    }\
    \ else {\n      result.push('No');\n    }\n  }\n  return result.join('');\n}\n\
    \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpcx_oo8sv.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmpcx_oo8sv.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      stack.pop();\n    } else {\n      if (stack.length === 0) {\n\
    \        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnhmuolbd.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnhmuolbd.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnhmuolbd.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      if\
    \ (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length === 0) {\n        return \"No\";\n     \
    \ }\n      stack.push(lst[i]);\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9prel8gh.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9prel8gh.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9prel8gh.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  let index = 0;\n  while (index < lst.length) {\n    if (lst[index]\
    \ === \"(\") {\n      stack.push(lst[index]);\n      index++;\n    } else {\n\
    \      if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top !== lst[index]) {\n        return \"No\";\n  \
    \    }\n      index++;\n    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp8l6jzpdr.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp8l6jzpdr.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp8l6jzpdr.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let open = 0;\n  let close = 0;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      open++;\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] == ')') {\n      close++;\n\
    \      if (open > close) {\n        return 'No';\n      }\n      open--;\n   \
    \   stack.pop();\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpaokqppg1.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpaokqppg1.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpaokqppg1.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top !== char) {\n\
    \        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpz1emu94k.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpz1emu94k.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpz1emu94k.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === \"(\") {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === \")\") {\n      if (stack.length === 0) {\n        return \"No\"\
    ;\n      }\n      stack.pop();\n    } else {\n      if (stack.length === 0) {\n\
    \        return \"No\";\n      }\n    }\n  }\n  if (stack.length === 0) {\n  \
    \  return \"Yes\";\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpev92uedo.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmpev92uedo.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      if\
    \ (stack.length === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top !== lst[i]) {\n        return \"No\";\n      }\n    }\n  }\n  return\
    \ \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpzaeli_tq.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpzaeli_tq.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpzaeli_tq.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  let index = 0;\n  while (index < lst.length) {\n    if (lst[index]\
    \ === \"(\") {\n      stack.push(lst[index]);\n      index++;\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      index++;\n      stack.pop();\n    } else {\n      index++;\n    }\n\
    \  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpxw9nuz2p.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpxw9nuz2p.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpxw9nuz2p.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top < i) {\n        return \"No\";\n      }\n    }\n  }\n  return \"\
    Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpx3y5hgyu.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpx3y5hgyu.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpx3y5hgyu.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  const res = [];\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    const cur = lst[i];\n    if (stack.length ===\
    \ 0) {\n      stack.push(cur);\n      res.push(cur);\n    } else if (cur === '(')\
    \ {\n      stack.push(cur);\n    } else if (cur === ')') {\n      if (stack[stack.length\
    \ - 1] === '(') {\n        stack.pop();\n      } else {\n        stack.pop();\n\
    \        res.push(cur);\n      }\n    } else {\n      if (stack[stack.length -\
    \ 1] === '(') {\n        stack.pop();\n        res.push(cur);\n      } else {\n\
    \        stack.pop();\n        res.push(cur);\n      }\n    }\n  }\n  return res.join('');\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpdfn8m7ns.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpdfn8m7ns.js:44:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpdfn8m7ns.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      let top = stack.pop();\n  \
    \    if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp6s24hk1h.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp6s24hk1h.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp6s24hk1h.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979361
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpio6rx54y.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpio6rx54y.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpio6rx54y.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp_tvchdbe.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp_tvchdbe.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp_tvchdbe.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    }\n    if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      let top = stack.pop();\n      if (top === index) {\n        index++;\n\
    \      } else {\n        return \"No\";\n      }\n    }\n    index++;\n  }\n \
    \ return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmprckqk96e.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmprckqk96e.js:36:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmprckqk96e.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top < i) {\n        return \"No\";\n      }\n    }\n\
    \  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9cbei7az.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9cbei7az.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9cbei7az.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpce449bbz.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpce449bbz.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpce449bbz.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  let stack\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n\
    \      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.push(lst[i]);\n\
    \    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpk0ulmnp4.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpk0ulmnp4.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpk0ulmnp4.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let result = 'No';\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      while (stack.length > 0 && lst[stack.length\
    \ - 1] === '(') {\n        stack.pop();\n      }\n      if (stack.length === 0)\
    \ {\n        result = 'Yes';\n        break;\n      }\n    }\n  }\n  return result;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpp4paa079.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpp4paa079.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpp4paa079.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  const res = [];\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        res.push('No');\n\
    \      } else {\n        const top = stack.pop();\n        if (top !== lst[i])\
    \ {\n          res.push('No');\n        } else {\n          res.push('Yes');\n\
    \        }\n      }\n    }\n  }\n  return res.join('');\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpyp3hjspv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpyp3hjspv.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpyp3hjspv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      stack.pop();\n    } else {\n      return 'No';\n    }\n\
    \  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpnss7i5xy.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpnss7i5xy.js:29:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpnss7i5xy.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    }\n    if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      let top = stack.pop();\n      if (top === index) {\n        return\
    \ \"Yes\";\n      }\n    }\n    index++;\n  }\n  return \"No\";\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm_6arx65.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm_6arx65.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm_6arx65.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      let top = stack.pop();\n      if (top === index) {\n        return\
    \ \"Yes\";\n      }\n    }\n    index++;\n  }\n  return \"No\";\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \"\
    )\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpeg_7dmyv.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpeg_7dmyv.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpeg_7dmyv.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979356
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== lst[i]) {\n      \
    \  return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n\nconsole.log(match_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp30rcla7g.ts(28,1123): error TS1002: Unterminated
    string literal.

    ../../../../../tmp/tmp30rcla7g.ts(29,1): error TS1005: '','' expected.

    ../../../../../tmp/tmp30rcla7g.ts(29,9): error TS1005: '','' expected.

    '
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      let top\
    \ = stack.pop();\n      if (top === i) {\n        return \"Yes\";\n      }\n \
    \   }\n  }\n  return \"No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpm55xa30p.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpm55xa30p.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpm55xa30p.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return \"No\";\n      }\n    }\n  }\n\
    \  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpyym60q66.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpyym60q66.js:33:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpyym60q66.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979371
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n     \
    \ stack.push(lst[i]);\n    } else if (lst[i] === \")\") {\n      while (!stack.isEmpty()\
    \ && stack.peek() !== \"(\") {\n        result.push(stack.pop());\n      }\n \
    \     stack.pop();\n    } else {\n      result.push(lst[i]);\n    }\n  }\n  return\
    \ result.length === lst.length ? \"Yes\" : \"No\";\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpeqm7mk9k.ts(14,16): error TS2304: Cannot find name
    ''Stack''.

    ../../../../../tmp/tmpeqm7mk9k.ts(14,36): error TS2552: Cannot find name ''Stack''.
    Did you mean ''stack''?

    '
  timestamp: 1659979370
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(i);\n    } else if (lst[i] ==\
    \ ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n   \
    \   let top = stack.pop();\n      if (top < i) {\n        return 'No';\n     \
    \ }\n    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpwy3xoyu1.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpwy3xoyu1.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpwy3xoyu1.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979371
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return 'No';\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(')\
    \ {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length\
    \ === 0) {\n        return 'No';\n      }\n      const top = stack.pop();\n  \
    \    if (top !== lst[i]) {\n        return 'No';\n      }\n    }\n  }\n  return\
    \ 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp1jjphdm2.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp1jjphdm2.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp1jjphdm2.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979348
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == '(') {\n      stack.push('(');\n    } else if (lst[i]\
    \ == ')') {\n      if (stack.length == 0) {\n        return 'No';\n      }\n \
    \     stack.pop();\n    } else if (stack.length == 0) {\n      return 'No';\n\
    \    }\n  }\n  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpiqui3d_c.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpiqui3d_c.js:28:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpiqui3d_c.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979371
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] == \"(\") {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] == \")\") {\n      if (stack.length == 0) {\n        return \"No\";\n\
    \      }\n      stack.pop();\n    } else {\n      if (stack.length == 0) {\n \
    \       return \"No\";\n      }\n      stack.pop();\n      stack.push(lst[i]);\n\
    \    }\n  }\n  if (stack.length != 0) {\n    return \"No\";\n  }\n  return \"\
    Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmphjd6ratr.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmphjd6ratr.js:35:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmphjd6ratr.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979371
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      index = stack.pop();\n    } else {\n      index++;\n    }\n  }\n \
    \ return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9zcxkmyh.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9zcxkmyh.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9zcxkmyh.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ === \"(\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n   \
    \   if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    }\n  }\n  if (stack.length === 0) {\n    return \"Yes\";\n  }\n  return \"\
    No\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpv7mpfk7n.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpv7mpfk7n.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpv7mpfk7n.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979357
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  let i = 0;\n  while (i < lst.length)\
    \ {\n    if (lst[i] == '(') {\n      stack.push(lst[i]);\n      i++;\n    } else\
    \ if (lst[i] == ')') {\n      if (stack.length == 0) {\n        return 'No';\n\
    \      }\n      stack.pop();\n      i++;\n    } else {\n      i++;\n    }\n  }\n\
    \  return 'Yes';\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9wtxm1k8.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9wtxm1k8.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9wtxm1k8.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979371
- exit_code: 2
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack: string[] = [];\n  let result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        result.push(lst[i]);\n\
    \      } else {\n        stack.pop();\n      }\n    }\n  }\n  if (stack.length\
    \ === 0) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n}\n\nconsole.log(match_parens(['(',\
    \ '(', ')', ')']));\nconsole.log(match_parens(['(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(', ')']));\n\
    console.log(match_parens(['(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\n\
    console.log(match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')']));\nconsole.log(match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')']));\nconsole.log(match_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', \ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp8pz2fp6v.ts(45,9): error TS1005: '','' expected.

    '
  timestamp: 1659979372
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack: number[] = [];\n  let index = 0;\n  while (index < lst.length) {\n  \
    \  if (lst[index] === \"(\") {\n      stack.push(index);\n    } else if (lst[index]\
    \ === \")\") {\n      if (stack.length === 0) {\n        return \"No\";\n    \
    \  }\n      index = stack.pop();\n    } else {\n      index++;\n    }\n  }\n \
    \ return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9zcxkmyh.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9zcxkmyh.js:32:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9zcxkmyh.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979352
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  let stack = [];\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i]\
    \ === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n\
    \      stack.pop();\n    } else {\n      if (stack.length === 0) {\n        return\
    \ 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmplqu6ig8v.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmplqu6ig8v.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmplqu6ig8v.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979347
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  const stack: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if\
    \ (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n\
    \      }\n      stack.pop();\n    } else {\n      if (stack.length === 0) {\n\
    \        return 'Yes';\n      }\n    }\n  }\n  return 'No';\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp9na0zxx4.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp9na0zxx4.js:30:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp9na0zxx4.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  let\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      stack.pop();\n    } else {\n\
    \      if (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    }\n  }\n  return \"Yes\";\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n\
    \  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"\
    No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    (())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n\
    \  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"\
    No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\"\
    )\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmpacn55lx5.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmpacn55lx5.js:34:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmpacn55lx5.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979372
- exit_code: 1
  program: "//You are given a list of two strings, both strings consist of open\n\
    // parentheses '(' or close parentheses ')' only.\n// Your job is to check if\
    \ it is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunction match_parens(lst:\
    \ string[]): string {\n  if (lst.length < 2) {\n    return \"No\";\n  }\n  const\
    \ stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === \"\
    (\") {\n      stack.push(i);\n    } else if (lst[i] === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top !== i) {\n        return \"No\";\n      }\n    }\n  }\n  return\
    \ \"Yes\";\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"\
    ()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\"\
    );\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"\
    ]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
    ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
    )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\"\
    );\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
  status: Exception
  stderr: "internal/modules/cjs/loader.js:883\n  throw err;\n  ^\n\nError: Cannot\
    \ find module 'node:assert'\nRequire stack:\n- /tmp/tmp2ugv3xqg.js\n    at Function.Module._resolveFilename\
    \ (internal/modules/cjs/loader.js:880:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:725:27)\n\
    \    at Module.require (internal/modules/cjs/loader.js:952:19)\n    at require\
    \ (internal/modules/cjs/helpers.js:88:18)\n    at Object.<anonymous> (/tmp/tmp2ugv3xqg.js:31:14)\n\
    \    at Module._compile (internal/modules/cjs/loader.js:1063:30)\n    at Object.Module._extensions..js\
    \ (internal/modules/cjs/loader.js:1092:10)\n    at Module.load (internal/modules/cjs/loader.js:928:32)\n\
    \    at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n    at\
    \ Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\
    \ {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [ '/tmp/tmp2ugv3xqg.js' ]\n\
    }\n"
  stdout: ''
  timestamp: 1659979372
