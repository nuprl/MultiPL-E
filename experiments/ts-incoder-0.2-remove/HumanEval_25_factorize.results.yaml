language: ts
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n\
    \        n /= i;\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n);\n\
    \  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2\n]\n\n\
    should loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmp6vqkaj8p.js:23:12)\n\
    \    at Object.<anonymous> (/tmp/tmp6vqkaj8p.js:31:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2 ],\n \
    \ expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpcwnnrrxj.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpcwnnrrxj.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpcwnnrrxj.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpcwnnrrxj.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let factor = 1;\n  let primeFactor = 2;\n  while (true)\
    \ {\n    if (n % primeFactor === 0) {\n      factors.push(primeFactor);\n    \
    \  n /= primeFactor;\n    } else {\n      factors.push(factor);\n      n /= factor;\n\
    \      factor = 1;\n    }\n    if (n === 1) {\n      break;\n    }\n    primeFactor++;\n\
    \  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffdb97fad70\n 1: 0x2b970bebc727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b970ca5128e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b970c38bf8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b970c51d760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b970c5250cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b970c70f7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b970c06e7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ maxFactor: number = 1;\n    let minFactor: number = 1;\n    let factor: number\
    \ = 1;\n    let factorsCountIndex: number = 0;\n    let factorsIndex: number =\
    \ 0;\n    let factorsCountIndex2: number = 0;\n    let factorsIndex2: number =\
    \ 0;\n    let factorsCountIndex3: number = 0;\n    let factorsIndex3: number =\
    \ 0;\n    let factorsCountIndex4: number = 0;\n    let factorsIndex4: number =\
    \ 0;\n    let factorsCountIndex5: number = 0;\n    let factorsIndex5: number =\
    \ 0;\n    let factorsCountIndex6: number = 0;\n    let factorsIndex6: number =\
    \ 0;\n    let factorsCountIndex7: number = 0;\n    let factorsIndex7: number =\
    \ 0;\n    let factorsCountIndex8: number = 0;\n    let factorsIndex8: number =\
    \ 0;\n    let factorsCountIndex9: number = 0;\n    let factorsIndex9: number =\
    \ 0;\n    let factorsCountIndex10: number = 0;\n    let factorsIndex10: number\
    \ = 0;\n    let factorsCountIndex11: number = 0;\n    let factorsIndex11: number\
    \ = 0;\n    let factorsCountIndex12: number = 0;\n    let factorsIndex12: number\
    \ = 0;\n    let factorsCountIndex13: number = 0;\n    let factorsIndex13: number\
    \ = 0;\n    let factorsCountIndex14: number = 0;\n    let factorsIndex14: number\
    \ = 0;\n    let factorsCountIndex15: number = 0;\n    let factorsIndex15: number\
    \ = 0;\n    let factorsCountIndex16: number = 0;\n    let factorsIndex16: number\
    \ = 0;\n    let factorsCountIndex17: number = 0;\n    let factorsIndex17: number\
    \ = 0;\n    let factorsCountIndex18: number = 0;\n    let factorsIndex18: number\
    \ = 0;\n    let factorsCountIndex19: number = 0;\n    let factorsIndex19: number\
    \ = 0;\n    let factorsCountIndex20: number = 0;\n    let factorsIndex20: number\
    \ = 0;\n    let factorsCountIndex21: number = 0;\n    let factorsIndex21: number\
    \ = 0;\n    let factorsCountIndex22: number = 0;\n    let factorsIndex22: number\
    \ = 0;\n    let factorsCountIndex23: number = 0;\n    let factorsIndex23: number\
    \ = 0;\n    let factorsCountIndex24: number = 0;\n    let factorsIndex24: number\
    \ = 0;\n    let factorsCountIndex25: number = 0;\n    let factorsIndex25: number\
    \ = 0;\n    let factorsCountIndex26: number = 0;\n    let \ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp8fs8ezpz.ts(62,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp8fs8ezpz.ts(78,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ isPrime: boolean;\n    let isFactorized: boolean;\n    let factorization: number[]\
    \ = [];\n\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        isPrime = true;\n\
    \        isFactorized = false;\n        factorization = [];\n\n        for (let\
    \ j = 0; j < factors.length; j++) {\n            if (n % i == 0) {\n         \
    \       factorization.push(i);\n                isPrime = false;\n           \
    \     break;\n            }\n        }\n\n        if (isPrime) {\n           \
    \ primeFactors.push(i);\n        }\n\n        if (isFactorized) {\n          \
    \  factors.push(factorization);\n        }\n    }\n\n    return factors;\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpu9fzc24e.ts(29,26): error TS2345: Argument of type
    ''number[]'' is not assignable to parameter of type ''number''.

    '
  timestamp: 1660014179
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  if (n > 1) {\n    factors.push(n);\n  }\n  return factors;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number[] = [];\n    let factorizationCountMax: number =\
    \ 0;\n    let factorizationCountMaxIndex: number = 0;\n    let factorizationCountMaxValue:\
    \ number = 0;\n    let factorizationCountMaxValueIndex: number = 0;\n    let factorizationCountMaxValueSum:\
    \ number = 0;\n    let factorizationCountMaxValueSumIndex: number = 0;\n    let\
    \ factorizationCountMaxValueSumValue: number = 0;\n    let factorizationCountMaxValueSumValueIndex:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSum: number = 0;\n  \
    \  let factorizationCountMaxValueSumValueSumIndex: number = 0;\n    let factorizationCountMaxValueSumValueSumValue:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumIndex: number = 0;\n\
    \    let factorizationCountMaxValueSumValueSumValueSum: number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumIndex:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValue: number\
    \ = 0;\n    let factorizationCountMaxValueSumValueSumValueSumIndex: number = 0;\n\
    \    let factorizationCountMaxValueSumValueSumValueSumValueSum: number = 0;\n\
    \    let factorizationCountMaxValueSumValueSumValueSumValueSumIndex: number =\
    \ 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValue: number\
    \ = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumIndex: number\
    \ = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSum:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumIndex:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValue:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumIndex:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValueSum:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValueSumIndex:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValueSumValue:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValueSumIndex:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValueSumValueSum:\
    \ number = 0;\n    let factorizationCountMaxValueSumValueSumValueSumValueSumValueSumValueSumValueSumIndex:\
    \ number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpeflopbko.ts(54,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: number[] = [];\n    let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap2: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMap3: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap4: Map<number, number> = new Map();\n    let factorsMapCountMap5:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap6: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMap7: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap8: Map<number, number> = new Map();\n    let factorsMapCountMap9:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap10: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap11: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap12: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap13: Map<number, number> = new Map();\n    let factorsMapCountMap14:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap15: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap16: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap17: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap18: Map<number, number> = new Map();\n    let factorsMapCountMap19:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap20: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap21: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap22: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap23: Map<number, number> = new Map();\n    let factorsMapCountMap24:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap25: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap26: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap27: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap28: Map<number, number> = new Map();\n    let factorsMapCountMap29:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap30: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap31: Map<number, number> = new\
    \ Map();\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp4y94vs4a.ts(42,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp4y94vs4a.ts(58,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014178
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ factorization: number[] = [];\n    let primeFactorsCount: number[] = [];\n \
    \   let factorizationCount: number[] = [];\n    let factorizationCountMax: number[]\
    \ = [];\n    let factorizationCountMaxIndex: number[] = [];\n    let factorizationCountMaxIndexIndex:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex2: number[] = [];\n \
    \   let factorizationCountMaxIndexIndex3: number[] = [];\n    let factorizationCountMaxIndexIndex4:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex5: number[] = [];\n \
    \   let factorizationCountMaxIndexIndex6: number[] = [];\n    let factorizationCountMaxIndexIndex7:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex8: number[] = [];\n \
    \   let factorizationCountMaxIndexIndex9: number[] = [];\n    let factorizationCountMaxIndexIndex10:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex11: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex12: number[] = [];\n    let factorizationCountMaxIndexIndex13:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex14: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex15: number[] = [];\n    let factorizationCountMaxIndexIndex16:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex17: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex18: number[] = [];\n    let factorizationCountMaxIndexIndex19:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex20: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex21: number[] = [];\n    let factorizationCountMaxIndexIndex22:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex23: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex24: number[] = [];\n    let factorizationCountMaxIndexIndex25:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex26: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex27: number[] = [];\n    let factorizationCountMaxIndexIndex28:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex29: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex30: number[] = [];\n    let factorizationCountMaxIndexIndex31:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex32: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex33: number[] = [];\n    let factorizationCountMaxIndexIndex34:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex35: number[] = [];\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp66qnq_qi.ts(63,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMap2: Map<number, number> = new Map();\n\
    \    let factorsMap3: Map<number, number> = new Map();\n    let factorsMap4: Map<number,\
    \ number> = new Map();\n    let factorsMap5: Map<number, number> = new Map();\n\
    \    let factorsMap6: Map<number, number> = new Map();\n    let factorsMap7: Map<number,\
    \ number> = new Map();\n    let factorsMap8: Map<number, number> = new Map();\n\
    \    let factorsMap9: Map<number, number> = new Map();\n    let factorsMap10:\
    \ Map<number, number> = new Map();\n    let factorsMap11: Map<number, number>\
    \ = new Map();\n    let factorsMap12: Map<number, number> = new Map();\n    let\
    \ factorsMap13: Map<number, number> = new Map();\n    let factorsMap14: Map<number,\
    \ number> = new Map();\n    let factorsMap15: Map<number, number> = new Map();\n\
    \    let factorsMap16: Map<number, number> = new Map();\n    let factorsMap17:\
    \ Map<number, number> = new Map();\n    let factorsMap18: Map<number, number>\
    \ = new Map();\n    let factorsMap19: Map<number, number> = new Map();\n    let\
    \ factorsMap20: Map<number, number> = new Map();\n    let factorsMap21: Map<number,\
    \ number> = new Map();\n    let factorsMap22: Map<number, number> = new Map();\n\
    \    let factorsMap23: Map<number, number> = new Map();\n    let factorsMap24:\
    \ Map<number, number> = new Map();\n    let factorsMap25: Map<number, number>\
    \ = new Map();\n    let factorsMap26: Map<number, number> = new Map();\n    let\
    \ factorsMap27: Map<number, number> = new Map();\n    let factorsMap28: Map<number,\
    \ number> = new Map();\n    let factorsMap29: Map<number, number> = new Map();\n\
    \    let factorsMap30: Map<number, number> = new Map();\n    let factorsMap31:\
    \ Map<number, number> = new Map();\n    let factorsMap32: Map<number, number>\
    \ = new Map();\n    let factorsMap33: Map<number, number> = new Map();\n    let\
    \ factorsMap34: Map<number, number> = new Map();\n    let factorsMap35: Map<number,\
    \ number> = new Map();\n    let factorsMap36: Map<number, number> = new Map();\n\
    \    let factorsMap37: Map<number, number> = new Map();\n    let factorsMap38:\
    \ Map<\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpci96tk02.ts(46,9): error TS1005: ''>'' expected.

    ../../../../../tmp/tmpci96tk02.ts(62,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let factor = 1;\n  while (n != 1) {\n    while (n % factor\
    \ == 0) {\n      factors.push(factor);\n      n /= factor;\n    }\n    factor++;\n\
    \  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff321b0d70\n 1: 0x2b1c5465b727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b1c551f028e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b1c54b2af8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b1c54cbc760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b1c54cc40cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b1c54eae7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b1c5480d7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ factorization: number[] = [];\n    let isPrime: boolean;\n    let isFactorized:\
    \ boolean;\n    let isPrimeFactorized: boolean;\n    let isPrimeFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorized: boolean;\n    let isPrimeFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorized: boolean;\n\
    \    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndFactorized: boolean;\n\
    \    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorized: boolean;\n\
    \    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndFactorized:\
    \ boolean;\n    let isPrimeFactorizedAndNotFactorizedAndNotFactorizedAndNotFactorizedAndNot\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpmjhcwvis.ts(45,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const primes: number[] = [];\n  let factor\
    \ = 1;\n  let prime: number = 2;\n  while (factor <= n) {\n    if (n % factor\
    \ === 0) {\n      factors.push(factor);\n      n /= factor;\n    } else {\n  \
    \    factors.push(factor);\n      primes.push(prime);\n      factor = 1;\n   \
    \   prime = 2;\n    }\n  }\n  if (n !== 0) {\n    factors.push(factor);\n    primes.push(prime);\n\
    \  }\n  return primes;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffeb204b490\n 1: 0x2ac44a0cc727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2ac44ac6128e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2ac44a59bf8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2ac44a72d760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2ac44a7350cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2ac44a91f7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2ac44a27e7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorization = factor(n);\n  for (let i\
    \ = 0; i < factorization.length; i++) {\n    let factor = factorization[i];\n\
    \    if (factors.indexOf(factor) === -1) {\n      factors.push(factor);\n    }\n\
    \  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpv5dkz2jg.ts(6,23): error TS2552: Cannot find name
    ''factor''. Did you mean ''factors''?

    '
  timestamp: 1660014179
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factor = 1;\n    while (n > 1) {\n  \
    \      if (n % factor === 0) {\n            factors.push(factor);\n          \
    \  n /= factor;\n        } else {\n            factor *= factor;\n        }\n\
    \    }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffcf8bdd960\n 1: 0x2b52b2cf4727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b52b388928e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b52b31c3f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b52b3355760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b52b335d0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b52b35477db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b52b2ea67f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountArray:\
    \ number[] = [];\n  let factorsCountArray2: number[] = [];\n  let factorsCountArray3:\
    \ number[] = [];\n  let factorsCountArray4: number[] = [];\n  let factorsCountArray5:\
    \ number[] = [];\n  let factorsCountArray6: number[] = [];\n  let factorsCountArray7:\
    \ number[] = [];\n  let factorsCountArray8: number[] = [];\n  let factorsCountArray9:\
    \ number[] = [];\n  let factorsCountArray10: number[] = [];\n  let factorsCountArray11:\
    \ number[] = [];\n  let factorsCountArray12: number[] = [];\n  let factorsCountArray13:\
    \ number[] = [];\n  let factorsCountArray14: number[] = [];\n  let factorsCountArray15:\
    \ number[] = [];\n  let factorsCountArray16: number[] = [];\n  let factorsCountArray17:\
    \ number[] = [];\n  let factorsCountArray18: number[] = [];\n  let factorsCountArray19:\
    \ number[] = [];\n  let factorsCountArray20: number[] = [];\n  let factorsCountArray21:\
    \ number[] = [];\n  let factorsCountArray22: number[] = [];\n  let factorsCountArray23:\
    \ number[] = [];\n  let factorsCountArray24: number[] = [];\n  let factorsCountArray25:\
    \ number[] = [];\n  let factorsCountArray26: number[] = [];\n  let factorsCountArray27:\
    \ number[] = [];\n  let factorsCountArray28: number[] = [];\n  let factorsCountArray29:\
    \ number[] = [];\n  let factorsCountArray30: number[] = [];\n  let factorsCountArray31:\
    \ number[] = [];\n  let factorsCountArray32: number[] = [];\n  let factorsCountArray33:\
    \ number[] = [];\n  let factorsCountArray34: number[] = [];\n  let factorsCountArray35:\
    \ number[] = [];\n  let factorsCountArray36: number[] = [];\n  let factorsCountArray37:\
    \ number[] = [];\n  let factorsCountArray38: number[] = [];\n  let factorsCountArray39:\
    \ number[] = [];\n  let factorsCountArray40: number[] = [];\n  let factorsCountArray41:\
    \ number[] = [];\n  let factorsCountArray42: number[] = [];\n  let factorsCountArray43:\
    \ number[] = [];\n  let factorsCountArray44: number[] = [];\n  let factorsCountArray45:\
    \ number[] = [];\n  let factorsCountArray46\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp0je6lpnb.ts(69,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ primeFactors: number[] = [];\n    let primeFactorsCount: number[] = [];\n  \
    \  let isPrime: boolean;\n    let isPrimeCount: number[] = [];\n    let isPrimePrime:\
    \ boolean;\n    let isPrimePrimeCount: number[] = [];\n    let isPrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimeCount: number[] = [];\n    let\
    \ isPrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrime: boolean;\n    let\
    \ isPrimePrimePrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n\
    \    let isPrimePrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n   \
    \ let isPrimePrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpaqyvvelw.ts(51,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMax: number[] = [];\n    let factorsCountMaxIndex: number[] = [];\n\
    \    let factorsCountMaxIndexIndex: number[] = [];\n    let factorsCountMaxIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndex: number[] = [];\n\
    \    let factorsCountMaxIndexIndexIndexIndexIndex: number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxIndex\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp_ov86k_u.ts(49,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpruerpbt8.js:19:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpruerpbt8.js:28:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factorization: number[] = [];\n  let factor = 1;\n  while (factor <= n)\
    \ {\n    if (n % factor === 0) {\n      factorization.push(factor);\n      n /=\
    \ factor;\n    } else {\n      factor++;\n    }\n  }\n  if (n != 1) {\n    factorization.push(n);\n\
    \  }\n  return factorization;\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffc8a14dc20\n 1: 0x2b89e205d727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b89e2bf228e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b89e252cf8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b89e26be760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b89e26c60cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b89e28b07db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b89e220f7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    const factorsMap: Map<number, number> =\
    \ new Map();\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i\
    \ === 0) {\n            factors.push(i);\n            factorsMap.set(i, 1);\n\
    \        }\n    }\n    for (let i = factors.length - 1; i >= 0; i--) {\n     \
    \   const factor = factors[i];\n        const count = factorsMap.get(factor);\n\
    \        if (count === undefined) {\n            factorsMap.set(factor, 1);\n\
    \        } else {\n            factorsMap.set(factor, count + 1);\n        }\n\
    \    }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp5_7iyl8d.ts(6,23): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmp5_7iyl8d.ts(6,49): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    '
  timestamp: 1660014179
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMap2: Map<number, number> = new Map();\n\
    \    let factorsMap3: Map<number, number> = new Map();\n    let factorsMap4: Map<number,\
    \ number> = new Map();\n    let factorsMap5: Map<number, number> = new Map();\n\
    \    let factorsMap6: Map<number, number> = new Map();\n    let factorsMap7: Map<number,\
    \ number> = new Map();\n    let factorsMap8: Map<number, number> = new Map();\n\
    \    let factorsMap9: Map<number, number> = new Map();\n    let factorsMap10:\
    \ Map<number, number> = new Map();\n    let factorsMap11: Map<number, number>\
    \ = new Map();\n    let factorsMap12: Map<number, number> = new Map();\n    let\
    \ factorsMap13: Map<number, number> = new Map();\n    let factorsMap14: Map<number,\
    \ number> = new Map();\n    let factorsMap15: Map<number, number> = new Map();\n\
    \    let factorsMap16: Map<number, number> = new Map();\n    let factorsMap17:\
    \ Map<number, number> = new Map();\n    let factorsMap18: Map<number, number>\
    \ = new Map();\n    let factorsMap19: Map<number, number> = new Map();\n    let\
    \ factorsMap20: Map<number, number> = new Map();\n    let factorsMap21: Map<number,\
    \ number> = new Map();\n    let factorsMap22: Map<number, number> = new Map();\n\
    \    let factorsMap23: Map<number, number> = new Map();\n    let factorsMap24:\
    \ Map<number, number> = new Map();\n    let factorsMap25: Map<number, number>\
    \ = new Map();\n    let factorsMap26: Map<number, number> = new Map();\n    let\
    \ factorsMap27: Map<number, number> = new Map();\n    let factorsMap28: Map<number,\
    \ number> = new Map();\n    let factorsMap29: Map<number, number> = new Map();\n\
    \    let factorsMap30: Map<number, number> = new Map();\n    let factorsMap31:\
    \ Map<number, number> = new Map();\n    let factorsMap32: Map<number, number>\
    \ = new Map();\n    let factorsMap33: Map<number, number> = new Map();\n    let\
    \ factorsMap34: Map<number, number> = new Map();\n    let factorsMap35: Map<number,\
    \ number> = new Map();\n    let factorsMap36: Map<number, number> = new Map();\n\
    \    let factorsMap37: Map<number, number> = new Map();\n    let factorsMap38:\
    \ Map<\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpci96tk02.ts(46,9): error TS1005: ''>'' expected.

    ../../../../../tmp/tmpci96tk02.ts(62,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   var factors: number[] = [];\n    var factor: number[] = [];\n    var i: number;\n\
    \    var j: number;\n    var factorCount: number;\n    var factorCount2: number;\n\
    \    var factorCount3: number;\n    var factorCount4: number;\n    var factorCount5:\
    \ number;\n    var factorCount6: number;\n    var factorCount7: number;\n    var\
    \ factorCount8: number;\n    var factorCount9: number;\n    var factorCount10:\
    \ number;\n    var factorCount11: number;\n    var factorCount12: number;\n  \
    \  var factorCount13: number;\n    var factorCount14: number;\n    var factorCount15:\
    \ number;\n    var factorCount16: number;\n    var factorCount17: number;\n  \
    \  var factorCount18: number;\n    var factorCount19: number;\n    var factorCount20:\
    \ number;\n    var factorCount21: number;\n    var factorCount22: number;\n  \
    \  var factorCount23: number;\n    var factorCount24: number;\n    var factorCount25:\
    \ number;\n    var factorCount26: number;\n    var factorCount27: number;\n  \
    \  var factorCount28: number;\n    var factorCount29: number;\n    var factorCount30:\
    \ number;\n    var factorCount31: number;\n    var factorCount32: number;\n  \
    \  var factorCount33: number;\n    var factorCount34: number;\n    var factorCount35:\
    \ number;\n    var factorCount36: number;\n    var factorCount37: number;\n  \
    \  var factorCount38: number;\n    var factorCount39: number;\n    var factorCount40:\
    \ number;\n    var factorCount41: number;\n    var factorCount42: number;\n  \
    \  var factorCount43: number;\n    var factorCount44: number;\n    var factorCount45:\
    \ number;\n    var factorCount46: number;\n    var factorCount47: number;\n  \
    \  var factorCount48: number;\n    var factorCount49: number;\n    var factorCount50:\
    \ number;\n    var factorCount51: number;\n    var factorCount52: number;\n  \
    \  var factorCount53: number;\n    var factorCount54: number;\n    var factorCount55:\
    \ number;\n    var factorCount56: number;\n    var factorCount57: number;\n  \
    \  var factorCount58: number;\n    var factorCount59: number;\n    var factorCount60:\
    \ number;\n    var factorCount61: number;\n    var factorCount62: number;\n  \
    \  var factorCount63: number;\n    var factorCount64: number;\n    var factorCount65:\
    \ number;\n    var factorCount66: number;\n    var factorCount67: number;\n  \
    \  var factorCount68: number;\n    var factorCount69: number;\n    var factorCount70:\
    \ number;\n    var factorCount71: number;\n    var factorCount72: number;\n  \
    \  var factorCount73: number;\n    var factorCount74: number;\n    var factorCount75:\
    \ number;\n    var factorCount76: number;\n    var factorCount77: number;\n  \
    \  var factorCount78: number;\n    var factorCount79: number;\n    var factorCount80:\
    \ number;\n    var factorCount81: number;\n    var factor\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpsh_qixlu.ts(107,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  let factorization: number[]\
    \ = [];\n  let factorizationIndex = 0;\n  let factorizationLength = 0;\n  while\
    \ (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n\
    \      factorization[factorizationIndex] = factor;\n      factorizationIndex++;\n\
    \      factorizationLength++;\n      factor++;\n    } else {\n      factor--;\n\
    \    }\n  }\n  if (factorizationLength > 0) {\n    for (let i = factorizationIndex;\
    \ i < factorizationLength; i++) {\n      factors.push(factorization[i]);\n   \
    \ }\n  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  2\n\
    ]\n\nshould loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpl81str7h.js:32:12)\n\
    \    at Object.<anonymous> (/tmp/tmpl81str7h.js:41:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 2 ],\n\
    \  expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let primeFactors: number[] = [];\n  let isPrime:\
    \ boolean;\n  let isPrimeFactor: boolean;\n  let isPrimeFactorFound: boolean;\n\
    \  let isPrimeFactorFoundInFactors: boolean;\n  let isPrimeFactorFoundInPrimeFactors:\
    \ boolean;\n  let isPrimeFactorFoundInPrimeFactorsArray: boolean;\n  let isPrimeFactorFoundInPrimeFactorsArrayIndex:\
    \ number; //Index of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayLength:\
    \ number; //Length of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayMaxIndex:\
    \ number; //Index of prime factor in prime factors array (max index)\n  let isPrimeFactorFoundInPrimeFactorsArrayMaxLength:\
    \ number; //Length of prime factor in prime factors array (max index)\n  let isPrimeFactorFoundInPrimeFactorsArrayMax:\
    \ number; //Max value of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayMin:\
    \ number; //Min value of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayMinIndex:\
    \ number; //Index of prime factor in prime factors array (min index)\n  let isPrimeFactorFoundInPrimeFactorsArrayMinLength:\
    \ number; //Length of prime factor in prime factors array (min index)\n  let isPrimeFactorFoundInPrimeFactorsArrayMin:\
    \ number; //Min value of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArray:\
    \ number[]; //Array containing prime factors of given integer in the order from\
    \ smallest to largest.\n  let isPrimeFactorFoundInPrimeFactorsArrayIndex: number;\
    \ //Index of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayLength:\
    \ number; //Length of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayMaxIndex:\
    \ number; //Index of prime factor in prime factors array (max index)\n  let isPrimeFactorFoundInPrimeFactorsArrayMaxLength:\
    \ number; //Length of prime factor in prime factors array (max index)\n  let isPrimeFactorFoundInPrimeFactorsArrayMax:\
    \ number; //Max value of prime factor in prime factors array\n  let isPrimeFactorFoundInPrimeFactorsArrayMin:\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpegj324nt.ts(29,9): error TS1005: '','' expected.

    ../../../../../tmp/tmpegj324nt.ts(45,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  while (n != 1) {\n    if (n\
    \ % factor == 0) {\n      factors.push(factor);\n      n = n / factor;\n    }\
    \ else {\n      factor *= factor;\n    }\n  }\n  return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffe12ad67c0\n 1: 0x2af31882b727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2af3193c028e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2af318cfaf8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2af318e8c760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2af318e940cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2af31907e7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2af3189dd7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMap2: Map<number, number> = new Map();\n\
    \    let factorsMap3: Map<number, number> = new Map();\n    let factorsMap4: Map<number,\
    \ number> = new Map();\n    let factorsMap5: Map<number, number> = new Map();\n\
    \    let factorsMap6: Map<number, number> = new Map();\n    let factorsMap7: Map<number,\
    \ number> = new Map();\n    let factorsMap8: Map<number, number> = new Map();\n\
    \    let factorsMap9: Map<number, number> = new Map();\n    let factorsMap10:\
    \ Map<number, number> = new Map();\n    let factorsMap11: Map<number, number>\
    \ = new Map();\n    let factorsMap12: Map<number, number> = new Map();\n    let\
    \ factorsMap13: Map<number, number> = new Map();\n    let factorsMap14: Map<number,\
    \ number> = new Map();\n    let factorsMap15: Map<number, number> = new Map();\n\
    \    let factorsMap16: Map<number, number> = new Map();\n    let factorsMap17:\
    \ Map<number, number> = new Map();\n    let factorsMap18: Map<number, number>\
    \ = new Map();\n    let factorsMap19: Map<number, number> = new Map();\n    let\
    \ factorsMap20: Map<number, number> = new Map();\n    let factorsMap21: Map<number,\
    \ number> = new Map();\n    let factorsMap22: Map<number, number> = new Map();\n\
    \    let factorsMap23: Map<number, number> = new Map();\n    let factorsMap24:\
    \ Map<number, number> = new Map();\n    let factorsMap25: Map<number, number>\
    \ = new Map();\n    let factorsMap26: Map<number, number> = new Map();\n    let\
    \ factorsMap27: Map<number, number> = new Map();\n    let factorsMap28: Map<number,\
    \ number> = new Map();\n    let factorsMap29: Map<number, number> = new Map();\n\
    \    let factorsMap30: Map<number, number> = new Map();\n    let factorsMap31:\
    \ Map<number, number> = new Map();\n    let factorsMap32: Map<number, number>\
    \ = new Map();\n    let factorsMap33: Map<number, number> = new Map();\n    let\
    \ factorsMap34: Map<number, number> = new Map();\n    let factorsMap35: Map<number,\
    \ number> = new Map();\n    let factorsMap36: Map<number, number> = new Map();\n\
    \    let factorsMap37: Map<number, number> = new Map();\n    let factorsMap38:\
    \ Map<\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpci96tk02.ts(46,9): error TS1005: ''>'' expected.

    ../../../../../tmp/tmpci96tk02.ts(62,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpcwnnrrxj.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpcwnnrrxj.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let primeFactors: number[] = [];\n  let factorization:\
    \ number[] = [];\n\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i\
    \ === 0) {\n      factors.push(i);\n      factorization.push(1);\n      while\
    \ (n % i === 0) {\n        factors.push(factors[factors.length - 1] * i);\n  \
    \      factorization[factorization.length - 1]++;\n        n = n / i;\n      }\n\
    \    }\n  }\n\n  for (let i = 0; i < factors.length; i++) {\n    primeFactors.push(factors[i]);\n\
    \  }\n\n  return primeFactors;\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpfy0n_ijd.js:27:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpfy0n_ijd.js:36:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationIndex: number[] = [];\n    let factorizationIndexCount: number[]\
    \ = [];\n    let factorizationIndexCountCount: number[] = [];\n    let factorizationIndexCountCount2:\
    \ number[] = [];\n    let factorizationIndexCountCount3: number[] = [];\n    let\
    \ factorizationIndexCountCount4: number[] = [];\n    let factorizationIndexCountCount5:\
    \ number[] = [];\n    let factorizationIndexCountCount6: number[] = [];\n    let\
    \ factorizationIndexCountCount7: number[] = [];\n    let factorizationIndexCountCount8:\
    \ number[] = [];\n    let factorizationIndexCountCount9: number[] = [];\n    let\
    \ factorizationIndexCountCount10: number[] = [];\n    let factorizationIndexCountCount11:\
    \ number[] = [];\n    let factorizationIndexCountCount12: number[] = [];\n   \
    \ let factorizationIndexCountCount13: number[] = [];\n    let factorizationIndexCountCount14:\
    \ number[] = [];\n    let factorizationIndexCountCount15: number[] = [];\n   \
    \ let factorizationIndexCountCount16: number[] = [];\n    let factorizationIndexCountCount17:\
    \ number[] = [];\n    let factorizationIndexCountCount18: number[] = [];\n   \
    \ let factorizationIndexCountCount19: number[] = [];\n    let factorizationIndexCountCount20:\
    \ number[] = [];\n    let factorizationIndexCountCount21: number[] = [];\n   \
    \ let factorizationIndexCountCount22: number[] = [];\n    let factorizationIndexCountCount23:\
    \ number[] = [];\n    let factorizationIndexCountCount24: number[] = [];\n   \
    \ let factorizationIndexCountCount25: number[] = [];\n    let factorizationIndexCountCount26:\
    \ number[] = [];\n    let factorizationIndexCountCount27: number[] = [];\n   \
    \ let factorizationIndexCountCount28: number[] = [];\n    let factorizationIndexCountCount29:\
    \ number[] = [];\n    let factorizationIndexCountCount30: number[] = [];\n   \
    \ let factorizationIndexCountCount31: number[] = [];\n    let factorizationIndexCountCount32:\
    \ number[] = [];\n    let factorizationIndexCountCount33: number[] = [];\n   \
    \ let factorizationIndexCountCount34: number[] = [];\n    let factorizationIndexCountCount35:\
    \ number[] = [];\n    let factorizationIndexCountCount36: number[] = [];\n   \
    \ let factorizationIndexCountCount37: number[] = [];\n    let factorizationIndexCountCount38:\
    \ number[] = [];\n    let factorizationIndexCountCount39: number[] = [];\n   \
    \ let factorizationIndexCountCount40: number[] = [];\n    let factorization\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp6g0gemmm.ts(66,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    let factor = 1;\n    while (n > 1) {\n\
    \        if (n % factor === 0) {\n            factors.push(factor);\n        \
    \    n /= factor;\n        } else {\n            factor *= factor;\n        }\n\
    \    }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fffb1ae6b50\n 1: 0x2ab758a72727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2ab75960728e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2ab758f41f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2ab7590d3760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2ab7590db0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2ab7592c57db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2ab758c247f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountTemp: number[] = [];\n    let factorsTemp: number[] = [];\n    let\
    \ factorsTemp2: number[] = [];\n    let factorsTemp3: number[] = [];\n    let\
    \ factorsTemp4: number[] = [];\n    let factorsTemp5: number[] = [];\n    let\
    \ factorsTemp6: number[] = [];\n    let factorsTemp7: number[] = [];\n    let\
    \ factorsTemp8: number[] = [];\n    let factorsTemp9: number[] = [];\n    let\
    \ factorsTemp10: number[] = [];\n    let factorsTemp11: number[] = [];\n    let\
    \ factorsTemp12: number[] = [];\n    let factorsTemp13: number[] = [];\n    let\
    \ factorsTemp14: number[] = [];\n    let factorsTemp15: number[] = [];\n    let\
    \ factorsTemp16: number[] = [];\n    let factorsTemp17: number[] = [];\n    let\
    \ factorsTemp18: number[] = [];\n    let factorsTemp19: number[] = [];\n    let\
    \ factorsTemp20: number[] = [];\n    let factorsTemp21: number[] = [];\n    let\
    \ factorsTemp22: number[] = [];\n    let factorsTemp23: number[] = [];\n    let\
    \ factorsTemp24: number[] = [];\n    let factorsTemp25: number[] = [];\n    let\
    \ factorsTemp26: number[] = [];\n    let factorsTemp27: number[] = [];\n    let\
    \ factorsTemp28: number[] = [];\n    let factorsTemp29: number[] = [];\n    let\
    \ factorsTemp30: number[] = [];\n    let factorsTemp31: number[] = [];\n    let\
    \ factorsTemp32: number[] = [];\n    let factorsTemp33: number[] = [];\n    let\
    \ factorsTemp34: number[] = [];\n    let factorsTemp35: number[] = [];\n    let\
    \ factorsTemp36: number[] = [];\n    let factorsTemp37: number[] = [];\n    let\
    \ factorsTemp38: number[] = [];\n    let factorsTemp39: number[] = [];\n    let\
    \ factorsTemp40: number[] = [];\n    let factorsTemp41: number[] = [];\n    let\
    \ factorsTemp42: number[] = [];\n    let factorsTemp43: number[] = [];\n    let\
    \ factorsTemp44: number[] = [];\n    let factorsTemp45: number[] = [];\n    let\
    \ factorsTemp46: number[] = [];\n    let factorsTemp47: number[] = [];\n    let\
    \ factorsTemp48: number[] = [];\n    let factorsTemp49: number[] = [];\n    let\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp9och3168.ts(58,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp9och3168.ts(74,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let factor = 1;\n  while (n > 1) {\n    if\
    \ (n % factor === 0) {\n      factors.push(factor);\n      n /= factor;\n    }\
    \ else {\n      factor *= factor;\n    }\n  }\n  return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffd9001c520\n 1: 0x2b5dcd378727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b5dcdf0d28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b5dcd847f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b5dcd9d9760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b5dcd9e10cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b5dcdbcb7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b5dcd52a7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let factor = 1;\n  let factorization = [];\n  let primeFactorization\
    \ = [];\n  let primeFactor = 1;\n  let primeFactorizationIndex = 0;\n  let factorizationIndex\
    \ = 0;\n  let factorizationIndex2 = 0;\n  let factorizationIndex3 = 0;\n  let\
    \ factorizationIndex4 = 0;\n  let factorizationIndex5 = 0;\n  let factorizationIndex6\
    \ = 0;\n  let factorizationIndex7 = 0;\n  let factorizationIndex8 = 0;\n  let\
    \ factorizationIndex9 = 0;\n  let factorizationIndex10 = 0;\n  let factorizationIndex11\
    \ = 0;\n  let factorizationIndex12 = 0;\n  let factorizationIndex13 = 0;\n  let\
    \ factorizationIndex14 = 0;\n  let factorizationIndex15 = 0;\n  let factorizationIndex16\
    \ = 0;\n  let factorizationIndex17 = 0;\n  let factorizationIndex18 = 0;\n  let\
    \ factorizationIndex19 = 0;\n  let factorizationIndex20 = 0;\n  let factorizationIndex21\
    \ = 0;\n  let factorizationIndex22 = 0;\n  let factorizationIndex23 = 0;\n  let\
    \ factorizationIndex24 = 0;\n  let factorizationIndex25 = 0;\n  let factorizationIndex26\
    \ = 0;\n  let factorizationIndex27 = 0;\n  let factorizationIndex28 = 0;\n  let\
    \ factorizationIndex29 = 0;\n  let factorizationIndex30 = 0;\n  let factorizationIndex31\
    \ = 0;\n  let factorizationIndex32 = 0;\n  let factorizationIndex33 = 0;\n  let\
    \ factorizationIndex34 = 0;\n  let factorizationIndex35 = 0;\n  let factorizationIndex36\
    \ = 0;\n  let factorizationIndex37 = 0;\n  let factorizationIndex38 = 0;\n  let\
    \ factorizationIndex39 = 0;\n  let factorizationIndex40 = 0;\n  let factorizationIndex41\
    \ = 0;\n  let factorizationIndex42 = 0;\n  let factorizationIndex43 = 0;\n  let\
    \ factorizationIndex44 = 0;\n  let factorizationIndex45 = 0;\n  let factorizationIndex46\
    \ = 0;\n  let factorizationIndex47 = 0;\n  let factorizationIndex48 = 0;\n  let\
    \ factorizationIndex49 = 0;\n  let factorizationIndex50 = 0;\n  let factorizationIndex51\
    \ = 0;\n  let factorizationIndex52 = 0;\n  let factorizationIndex53 = 0;\n  let\
    \ factorizationIndex54 = 0;\n  let factorizationIndex55 = 0;\n  let factorizationIndex56\
    \ = 0;\n  let factorizationIndex57 = 0;\n  let factorizationIndex58 = 0;\n  let\
    \ factorizationIndex59 = 0;\n  let factorizationIndex60 = 0;\n  let factorizationIndex61\
    \ = 0;\n  let factorizationIndex62 = 0;\n  let factorizationIndex63 = 0;\n  let\
    \ factorizationIndex64 = 0;\n  let factorizationIndex65 = 0;\n  let factorizationIndex66\
    \ = 0;\n  let factorizationIndex67 = 0;\n  let factorizationIndex68 = 0;\n  let\
    \ factorizationIndex69 = 0;\n  let factorization\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp03pzl7kx.ts(97,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsSum: number[] = [];\n    let factorsSumCount: number[] = [];\n    let\
    \ factorsSumCountSum: number[] = [];\n    let factorsSumCountSumCount: number[]\
    \ = [];\n    let factorsSumCountSumCountSum: number[] = [];\n    let factorsSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSum: number[] = [];\n\
    \    let factorsSumCountSumCountSumCountSumCount: number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCount: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSum: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCount: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSum: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCount\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmphjg7f2vz.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   var factors: number[] = [];\n    for (var i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i == 0) {\n            factors.push(i);\n            factors.push(n\
    \ / i);\n        }\n    }\n    return factors;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpu1bmvk98.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpu1bmvk98.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014181
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n\
    \        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpuq0q_wl_.js:20:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpuq0q_wl_.js:29:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014181
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const primes: number[] = [];\n  let factor\
    \ = 1;\n  let prime = 1;\n\n  while (factor <= n) {\n    if (n % factor === 0)\
    \ {\n      factors.push(factor);\n      while (n % factor === 0) {\n        n\
    \ /= factor;\n        primes.push(prime);\n      }\n    }\n    factor++;\n  }\n\
    \n  return primes;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffcc8faddd0\n 1: 0x2b82b6a5a727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b82b75ef28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b82b6f29f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b82b70bb760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b82b70c30cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b82b72ad7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b82b6c0c7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let primeFactors: number[] = [];\n    let primeFactorsCount:\
    \ number[] = [];\n    let primeFactorsCountMap: Map<number, number> = new Map();\n\
    \    let primeFactorsMap: Map<number, number> = new Map();\n    let isPrime: boolean;\n\
    \    let isPrimeCount: number[] = [];\n    let isPrimeCountMap: Map<number, number>\
    \ = new Map();\n    let isPrimeMap: Map<number, number> = new Map();\n    let\
    \ isPrimeFactor: boolean;\n    let isPrimeFactorCount: number[] = [];\n    let\
    \ isPrimeFactorCountMap: Map<number, number> = new Map();\n    let isPrimeFactorMap:\
    \ Map<number, number> = new Map();\n    let isPrimeFactorsMap: Map<number, number>\
    \ = new Map();\n    let isPrimePrime: boolean;\n    let isPrimePrimeCount: number[]\
    \ = [];\n    let isPrimePrimeCountMap: Map<number, number> = new Map();\n    let\
    \ isPrimePrimeMap: Map<number, number> = new Map();\n    let isPrimePrimeFactor:\
    \ boolean;\n    let isPrimePrimeFactorCount: number[] = [];\n    let isPrimePrimeFactorCountMap:\
    \ Map<number, number> = new Map();\n    let isPrimePrimeFactorMap: Map<number,\
    \ number> = new Map();\n    let isPrimePrimeFactorsMap: Map<number, number> =\
    \ new Map();\n    let isPrimePrimePrime: boolean;\n    let isPrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimeCountMap: Map<number, number> = new\
    \ Map();\n    let isPrimePrimePrimeMap: Map<number, number> = new Map();\n   \
    \ let isPrimePrimePrimeFactor: boolean;\n    let isPrimePrimePrimeFactorCount:\
    \ number[] = [];\n    let isPrimePrimePrimeFactorCountMap: Map<number, number>\
    \ = new Map();\n    let isPrimePrimePrimeFactorMap: Map<number, number> = new\
    \ Map();\n    let isPrimePrimePrimeFactorsMap: Map<number, number> = new Map();\n\
    \    let isPrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimeCountMap: Map<number, number>\
    \ = new Map();\n    let is\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp540n843z.ts(60,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMap2: Map<number, number> = new Map();\n\
    \    let factorsMap3: Map<number, number> = new Map();\n    let factorsMap4: Map<number,\
    \ number> = new Map();\n    let factorsMap5: Map<number, number> = new Map();\n\
    \    let factorsMap6: Map<number, number> = new Map();\n    let factorsMap7: Map<number,\
    \ number> = new Map();\n    let factorsMap8: Map<number, number> = new Map();\n\
    \    let factorsMap9: Map<number, number> = new Map();\n    let factorsMap10:\
    \ Map<number, number> = new Map();\n    let factorsMap11: Map<number, number>\
    \ = new Map();\n    let factorsMap12: Map<number, number> = new Map();\n    let\
    \ factorsMap13: Map<number, number> = new Map();\n    let factorsMap14: Map<number,\
    \ number> = new Map();\n    let factorsMap15: Map<number, number> = new Map();\n\
    \    let factorsMap16: Map<number, number> = new Map();\n    let factorsMap17:\
    \ Map<number, number> = new Map();\n    let factorsMap18: Map<number, number>\
    \ = new Map();\n    let factorsMap19: Map<number, number> = new Map();\n    let\
    \ factorsMap20: Map<number, number> = new Map();\n    let factorsMap21: Map<number,\
    \ number> = new Map();\n    let factorsMap22: Map<number, number> = new Map();\n\
    \    let factorsMap23: Map<number, number> = new Map();\n    let factorsMap24:\
    \ Map<number, number> = new Map();\n    let factorsMap25: Map<number, number>\
    \ = new Map();\n    let factorsMap26: Map<number, number> = new Map();\n    let\
    \ factorsMap27: Map<number, number> = new Map();\n    let factorsMap28: Map<number,\
    \ number> = new Map();\n    let factorsMap29: Map<number, number> = new Map();\n\
    \    let factorsMap30: Map<number, number> = new Map();\n    let factorsMap31:\
    \ Map<number, number> = new Map();\n    let factorsMap32: Map<number, number>\
    \ = new Map();\n    let factorsMap33: Map<number, number> = new Map();\n    let\
    \ factorsMap34: Map<number, number> = new Map();\n    let factorsMap35: Map<number,\
    \ number> = new Map();\n    let factorsMap36: Map<number, number> = new Map();\n\
    \    let factorsMap37: Map<number, number> = new Map();\n    let factorsMap38:\
    \ Map<\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpci96tk02.ts(46,9): error TS1005: ''>'' expected.

    ../../../../../tmp/tmpci96tk02.ts(62,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: -1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factorization: number[] = [];\n    let factor = 1;\n    while (factor\
    \ <= n) {\n        if (n % factor === 0) {\n            factorization.push(factor);\n\
    \            while (n % factor === 0) {\n                n /= factor;\n      \
    \      }\n        }\n        factor++;\n    }\n    return factorization;\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014196
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n = n / i;\n        }\n    }\n    return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpjo6zvqfk.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpjo6zvqfk.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors = [];\n    let factor = 1;\n    while (n > 1) {\n        if (n\
    \ % factor === 0) {\n            factors.push(factor);\n            n /= factor;\n\
    \        } else {\n            factor *= factor;\n        }\n    }\n    return\
    \ factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff9bee6920\n 1: 0x2b687b9d9727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b687c56e28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b687bea8f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b687c03a760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b687c0420cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b687c22c7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b687bb8b7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factorization: number[] = [];\n  const primeFactors = primeFactorization(n);\n\
    \  for (let i = 0; i < primeFactors.length; i++) {\n    const factor = primeFactors[i];\n\
    \    const count = factorization[factor] ? factorization[factor] + 1 : 1;\n  \
    \  factorization[factor] = count;\n  }\n  return factorization;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpep1dsv_1.ts(6,24): error TS2304: Cannot find name
    ''primeFactorization''.

    '
  timestamp: 1660014183
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ primeFactors: number[] = [];\n    let primeFactorsCount: number[] = [];\n  \
    \  let isPrime: boolean;\n    let isPrimeCount: number[] = [];\n    let isPrimeFactor:\
    \ boolean;\n    let isPrimeFactorCount: number[] = [];\n    let isPrimePrime:\
    \ boolean;\n    let isPrimePrimeCount: number[] = [];\n    let isPrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimeCount: number[] = [];\n    let\
    \ isPrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrime: boolean;\n    let\
    \ isPrimePrimePrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n\
    \    let isPrimePrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n   \
    \ let isPrimePrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrime\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp67ruflza.ts(53,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014183
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number[] = [];\n    let factorizationCountMax: number[]\
    \ = [];\n    let factorizationCountMaxIndex: number[] = [];\n    let factorizationCountMaxIndexIndex:\
    \ number[] = [];\n    let factorizationCountMaxIndexMax: number[] = [];\n    let\
    \ factorizationCountMaxIndexMaxIndex: number[] = [];\n    let factorizationCountMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMax: number[] = [];\n\
    \    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndex: number[] = [];\n\
    \    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMax: number[] = [];\n\
    \    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMax: number[] = [];\n\
    \    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax: number[]\
    \ = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax:\
    \ number[] = [];\n    let factorizationCountMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp0kxsk6oo.ts(49,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014183
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const factorsMap: Map<number, number> = new\
    \ Map();\n  const isPrime: (number) => boolean = (n) => {\n    if (n === 1) {\n\
    \      return true;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n  \
    \    if (n % i === 0) {\n        return false;\n      }\n    }\n    return true;\n\
    \  };\n  for (let i = 1; i <= n; i++) {\n    if (isPrime(i)) {\n      factors.push(i);\n\
    \      factorsMap.set(i, 1);\n    }\n  }\n  let factorsCopy = Array.from(factorsMap);\n\
    \  while (factorsCopy.length > 0) {\n    let maxFactor = factorsCopy.sort((a,\
    \ b) => a - b)[0];\n    let maxFactorCount = factorsMap.get(maxFactor);\n    factorsCopy.splice(factorsCopy.indexOf(maxFactor),\
    \ 1);\n    factorsMap.set(maxFactor, maxFactorCount + 1);\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpkmrcragd.ts(6,21): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmpkmrcragd.ts(6,47): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmpkmrcragd.ts(24,27): error TS2339: Property ''from'' does
    not exist on type ''ArrayConstructor''.

    '
  timestamp: 1660014183
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let primeFactors: number[] = [];\n    let primeFactorsCount:\
    \ number[] = [];\n    let primeFactorsCountMap: Map<number, number> = new Map();\n\
    \    let primeFactorsMap: Map<number, number> = new Map();\n    let isPrime: boolean;\n\
    \    let isPrimeMap: Map<number, boolean> = new Map();\n    let isPrimeCount:\
    \ number[] = [];\n    let isPrimeCountMap: Map<number, number> = new Map();\n\
    \    let isPrimeMap2: Map<number, boolean> = new Map();\n    let isPrimeCount2:\
    \ number[] = [];\n    let isPrimeCountMap2: Map<number, number> = new Map();\n\
    \    let isPrimeMap3: Map<number, boolean> = new Map();\n    let isPrimeCount3:\
    \ number[] = [];\n    let isPrimeCountMap3: Map<number, number> = new Map();\n\
    \    let isPrimeMap4: Map<number, boolean> = new Map();\n    let isPrimeCount4:\
    \ number[] = [];\n    let isPrimeCountMap4: Map<number, number> = new Map();\n\
    \    let isPrimeMap5: Map<number, boolean> = new Map();\n    let isPrimeCount5:\
    \ number[] = [];\n    let isPrimeCountMap5: Map<number, number> = new Map();\n\
    \    let isPrimeMap6: Map<number, boolean> = new Map();\n    let isPrimeCount6:\
    \ number[] = [];\n    let isPrimeCountMap6: Map<number, number> = new Map();\n\
    \    let isPrimeMap7: Map<number, boolean> = new Map();\n    let isPrimeCount7:\
    \ number[] = [];\n    let isPrimeCountMap7: Map<number, number> = new Map();\n\
    \    let isPrimeMap8: Map<number, boolean> = new Map();\n    let isPrimeCount8:\
    \ number[] = [];\n    let isPrimeCountMap8: Map<number, number> = new Map();\n\
    \    let isPrimeMap9: Map<number, boolean> = new Map();\n    let isPrimeCount9:\
    \ number[] = [];\n    let isPrimeCountMap9: Map<number, number> = new Map();\n\
    \    let isPrimeMap10: Map<number, boolean> = new Map();\n    let isPrimeCount10:\
    \ number[] = [];\n    let isPrimeCountMap10: Map<number, number> = new Map();\n\
    \    let isPrimeMap11: Map<number, boolean> = new Map();\n    let isPrimeCount11:\
    \ number[]\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmplpikgwjd.ts(62,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014183
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n\n    for (let i = 1; i <=\
    \ n; i++) {\n        let factor = 1;\n        while (n % i === 0) {\n        \
    \    n /= i;\n            factor *= i;\n        }\n        if (factorsCountMap.has(factor))\
    \ {\n            factorsCountMap.set(factor, factorsCountMap.get(factor) + 1);\n\
    \        } else {\n            factorsCountMap.set(factor, 1);\n        }\n  \
    \      factors.push(factor);\n    }\n\n    for (let [factor, count] of factorsCountMap.entries())\
    \ {\n        if (count > 1) {\n            factorsCount.push(factor);\n      \
    \  }\n    }\n\n    return factors;\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpc2ucm6l6.ts(7,26): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmpc2ucm6l6.ts(7,52): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    '
  timestamp: 1660014184
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n\
    \        n /= i;\n      }\n    }\n  }\n  return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmphggh9vws.js:19:12)\n    at Object.<anonymous>\
    \ (/tmp/tmphggh9vws.js:28:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ maxFactor = n;\n    let minFactor = 1;\n    let factor: number[] = [];\n   \
    \ while (maxFactor >= minFactor) {\n        let maxFactorIndex = factorsCount.indexOf(maxFactor);\n\
    \        if (maxFactorIndex === -1) {\n            factorsCount.push(maxFactor);\n\
    \            factors.push(maxFactor);\n        } else {\n            factors[maxFactorIndex]\
    \ += 1;\n        }\n        maxFactor--;\n    }\n    for (let i = 0; i < factorsCount.length;\
    \ i++) {\n        factorsCount[i] = factorsCount[i] / factors.length;\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2,\n  1\n\
    ]\n\nshould loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmp_cd4b_o2.js:29:12)\n\
    \    at Object.<anonymous> (/tmp/tmp_cd4b_o2.js:38:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2, 1 ],\n\
    \  expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMax: number[] = [];\n    let factorsCountMaxIndex: number[] = [];\n\
    \    let factorsCountMaxIndexIndex: number[] = [];\n    let factorsCountMaxIndexValue:\
    \ number[] = [];\n    let factorsCountMaxValue: number[] = [];\n    let factorsCountMaxValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueIndexIndex: number[] = [];\n   \
    \ let factorsCountMaxValueValue: number[] = [];\n    let factorsCountMaxValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueIndex: number[] = [];\n   \
    \ let factorsCountMaxValueValueValue: number[] = [];\n    let factorsCountMaxValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueIndexIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValue: number[] = [];\n    let factorsCountMaxValueValueIndexIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factorsCountMaxValueValueValueIndex: number[] = [];\n    let factorsCountMaxValueValueValueIndex:\
    \ number[] = [];\n    let factorsCountMaxValueValueValueIndex: number[] = [];\n\
    \    let factor\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpg98kelzj.ts(61,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014184
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n\
    \        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpuq0q_wl_.js:20:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpuq0q_wl_.js:29:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArr: number[] = [];\n    let factorsCountArrLen: number[] = [];\n\
    \    let factorsCountArrLenLen: number[] = [];\n    let factorsCountArrLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLen: number[] = [];\n    let\
    \ factorsCountArrLenLenLenLenLen: number[] = [];\n    let factorsCountArrLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLen: number[] = [];\n\
    \    let factorsCountArrLenLenLenLenLenLenLenLen: number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLen: number[] =\
    \ [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLen: number[] =\
    \ [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLen\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpv4d24u9q.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014184
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        while (n % i == 0) {\n            factors.push(i);\n            n /=\
    \ i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n  \
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  let factorization = [];\n\
    \  let primeFactorization = [];\n  let isPrime = true;\n  let isPrimeFactorization\
    \ = true;\n  let isPrimePrimeFactorization = true;\n  let isPrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimeFactorization = true;\n  let isPrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimeFactorization = true;\n  let\
    \ isPrimePrimePrimePrimePrimePrimePrimeFactorization = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpwa30wch1.ts(46,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014184
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ if (n > 1) {\n        factors.push(n);\n    }\n    return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2\n]\n\n\
    should loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmp7yp5jrdw.js:23:12)\n\
    \    at Object.<anonymous> (/tmp/tmp7yp5jrdw.js:31:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2 ],\n \
    \ expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let i = 1;\n  while (n % i === 0) {\n    factors.push(i);\n\
    \    i = i * 2;\n  }\n  if (n !== 1) {\n    factors.push(n);\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  2,\n\
    \  2\n]\n\nshould loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmppkbnxhst.js:19:12)\n\
    \    at Object.<anonymous> (/tmp/tmppkbnxhst.js:28:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 2, 2\
    \ ],\n  expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors = [];\n    let factor = 1;\n    while (n > 1) {\n        if (n\
    \ % factor === 0) {\n            factors.push(factor);\n            n /= factor;\n\
    \        } else {\n            factor *= factor;\n        }\n    }\n    return\
    \ factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff9bee6920\n 1: 0x2b687b9d9727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b687c56e28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b687bea8f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b687c03a760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b687c0420cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b687c22c7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b687bb8b7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountTemp: number[] = [];\n    let factorsCountTemp2: number[] = [];\n\
    \    let factorsCountTemp3: number[] = [];\n    let factorsCountTemp4: number[]\
    \ = [];\n    let factorsCountTemp5: number[] = [];\n    let factorsCountTemp6:\
    \ number[] = [];\n    let factorsCountTemp7: number[] = [];\n    let factorsCountTemp8:\
    \ number[] = [];\n    let factorsCountTemp9: number[] = [];\n    let factorsCountTemp10:\
    \ number[] = [];\n    let factorsCountTemp11: number[] = [];\n    let factorsCountTemp12:\
    \ number[] = [];\n    let factorsCountTemp13: number[] = [];\n    let factorsCountTemp14:\
    \ number[] = [];\n    let factorsCountTemp15: number[] = [];\n    let factorsCountTemp16:\
    \ number[] = [];\n    let factorsCountTemp17: number[] = [];\n    let factorsCountTemp18:\
    \ number[] = [];\n    let factorsCountTemp19: number[] = [];\n    let factorsCountTemp20:\
    \ number[] = [];\n    let factorsCountTemp21: number[] = [];\n    let factorsCountTemp22:\
    \ number[] = [];\n    let factorsCountTemp23: number[] = [];\n    let factorsCountTemp24:\
    \ number[] = [];\n    let factorsCountTemp25: number[] = [];\n    let factorsCountTemp26:\
    \ number[] = [];\n    let factorsCountTemp27: number[] = [];\n    let factorsCountTemp28:\
    \ number[] = [];\n    let factorsCountTemp29: number[] = [];\n    let factorsCountTemp30:\
    \ number[] = [];\n    let factorsCountTemp31: number[] = [];\n    let factorsCountTemp32:\
    \ number[] = [];\n    let factorsCountTemp33: number[] = [];\n    let factorsCountTemp34:\
    \ number[] = [];\n    let factorsCountTemp35: number[] = [];\n    let factorsCountTemp36:\
    \ number[] = [];\n    let factorsCountTemp37: number[] = [];\n    let factorsCountTemp38:\
    \ number[] = [];\n    let factorsCountTemp39: number[] = [];\n    let factorsCountTemp40:\
    \ number[] = [];\n    let factorsCountTemp41: number[] = [];\n    let factorsCountTemp42:\
    \ number[] = [];\n    let factorsCountTemp43: number[] = [];\n    let factorsCountTemp44:\
    \ number[] = [];\n    let factorsCountTemp45: number[] = [];\n    let factorsCountTemp46\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpv5e4hzsw.ts(69,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArr: number[] = [];\n    let factorsCountArrLen: number = 0;\n \
    \   let factorsCountArrMax: number = 0;\n    let factorsCountArrMaxIndex: number\
    \ = 0;\n    let factorsCountArrMaxVal: number = 0;\n    let factorsCountArrMaxIndexVal:\
    \ number = 0;\n    let factorsCountArrMaxVal2: number = 0;\n    let factorsCountArrMaxIndexVal2:\
    \ number = 0;\n    let factorsCountArrMaxVal3: number = 0;\n    let factorsCountArrMaxIndexVal3:\
    \ number = 0;\n    let factorsCountArrMaxVal4: number = 0;\n    let factorsCountArrMaxIndexVal4:\
    \ number = 0;\n    let factorsCountArrMaxVal5: number = 0;\n    let factorsCountArrMaxIndexVal5:\
    \ number = 0;\n    let factorsCountArrMaxVal6: number = 0;\n    let factorsCountArrMaxIndexVal6:\
    \ number = 0;\n    let factorsCountArrMaxVal7: number = 0;\n    let factorsCountArrMaxIndexVal7:\
    \ number = 0;\n    let factorsCountArrMaxVal8: number = 0;\n    let factorsCountArrMaxIndexVal8:\
    \ number = 0;\n    let factorsCountArrMaxVal9: number = 0;\n    let factorsCountArrMaxIndexVal9:\
    \ number = 0;\n    let factorsCountArrMaxVal10: number = 0;\n    let factorsCountArrMaxIndexVal10:\
    \ number = 0;\n    let factorsCountArrMaxVal11: number = 0;\n    let factorsCountArrMaxIndexVal11:\
    \ number = 0;\n    let factorsCountArrMaxVal12: number = 0;\n    let factorsCountArrMaxIndexVal12:\
    \ number = 0;\n    let factorsCountArrMaxVal13: number = 0;\n    let factorsCountArrMaxIndexVal13:\
    \ number = 0;\n    let factorsCountArrMaxVal14: number = 0;\n    let factorsCountArrMaxIndexVal14:\
    \ number = 0;\n    let factorsCountArrMaxVal15: number = 0;\n    let factorsCountArrMaxIndexVal15:\
    \ number = 0;\n    let factorsCountArrMaxVal16: number = 0;\n    let factorsCountArrMaxIndexVal16:\
    \ number = 0;\n    let factorsCountArrMaxVal17: number = 0;\n    let factorsCountArrMaxIndexVal17:\
    \ number = 0;\n    let factorsCountArrMaxVal18: number = 0;\n    let factorsCountArrMaxIndexVal18:\
    \ number = 0;\n    let factorsCountArrMaxVal19: number = 0;\n    let factors\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpp0hsouzc.ts(65,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMax: number = 0;\n    let factorsCountMaxIndex: number = 0;\n  \
    \  let factorsCountMaxIndex2: number = 0;\n    let factorsCountMaxIndex3: number\
    \ = 0;\n    let factorsCountMaxIndex4: number = 0;\n    let factorsCountMaxIndex5:\
    \ number = 0;\n    let factorsCountMaxIndex6: number = 0;\n    let factorsCountMaxIndex7:\
    \ number = 0;\n    let factorsCountMaxIndex8: number = 0;\n    let factorsCountMaxIndex9:\
    \ number = 0;\n    let factorsCountMaxIndex10: number = 0;\n    let factorsCountMaxIndex11:\
    \ number = 0;\n    let factorsCountMaxIndex12: number = 0;\n    let factorsCountMaxIndex13:\
    \ number = 0;\n    let factorsCountMaxIndex14: number = 0;\n    let factorsCountMaxIndex15:\
    \ number = 0;\n    let factorsCountMaxIndex16: number = 0;\n    let factorsCountMaxIndex17:\
    \ number = 0;\n    let factorsCountMaxIndex18: number = 0;\n    let factorsCountMaxIndex19:\
    \ number = 0;\n    let factorsCountMaxIndex20: number = 0;\n    let factorsCountMaxIndex21:\
    \ number = 0;\n    let factorsCountMaxIndex22: number = 0;\n    let factorsCountMaxIndex23:\
    \ number = 0;\n    let factorsCountMaxIndex24: number = 0;\n    let factorsCountMaxIndex25:\
    \ number = 0;\n    let factorsCountMaxIndex26: number = 0;\n    let factorsCountMaxIndex27:\
    \ number = 0;\n    let factorsCountMaxIndex28: number = 0;\n    let factorsCountMaxIndex29:\
    \ number = 0;\n    let factorsCountMaxIndex30: number = 0;\n    let factorsCountMaxIndex31:\
    \ number = 0;\n    let factorsCountMaxIndex32: number = 0;\n    let factorsCountMaxIndex33:\
    \ number = 0;\n    let factorsCountMaxIndex34: number = 0;\n    let factorsCountMaxIndex35:\
    \ number = 0;\n    let factorsCountMaxIndex36: number = 0;\n    let factorsCountMaxIndex37:\
    \ number = 0;\n    let factorsCountMaxIndex38: number = 0;\n    let factorsCountMaxIndex39:\
    \ number = 0;\n    let factorsCountMaxIndex40: number = 0;\n    let factorsCountMaxIndex41:\
    \ number = 0;\n    let factorsCountMaxIndex42: number = 0;\n    let factorsCountMaxIndex43:\
    \ number = 0;\n    let factorsCountMaxIndex44: number = 0;\n    let factorsCountMaxIndex45:\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmphuhrhue9.ts(53,9): error TS1005: '','' expected.

    ../../../../../tmp/tmphuhrhue9.ts(69,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014185
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const primes: number[] = [];\n  const isPrime\
    \ = (n: number): boolean => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \      if (n % i === 0) {\n        return false;\n      }\n    }\n    return true;\n\
    \  };\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (isPrime(i)) {\n  \
    \    primes.push(i);\n    }\n  }\n  for (let i = 0; i < primes.length; i++) {\n\
    \    for (let j = 0; j < primes.length; j++) {\n      if (primes[i] === primes[j])\
    \ {\n        factors.push(primes[i]);\n      }\n    }\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmp_bkc7js4.js:32:12)\n    at Object.<anonymous>\
    \ (/tmp/tmp_bkc7js4.js:41:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArray: number[] = [];\n    let factorsCountArrayIndex: number[]\
    \ = [];\n    let factorsCountArrayIndexIndex: number[] = [];\n    let factorsCountArrayIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndex: number[] = [];\n\
    \    let factorsCountArrayIndexIndexIndexIndexIndex: number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[]\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpbwg33bau.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorization: number[] = [];\n  let factorizationCount:\
    \ number[] = [];\n  let factorizationCountMax: number[] = [];\n  let factorizationCountMaxIndex:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex2: number[] = [];\n  let factorizationCountMaxIndexIndex3:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex4: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex5: number[] = [];\n  let factorizationCountMaxIndexIndex6:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex7: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex8: number[] = [];\n  let factorizationCountMaxIndexIndex9:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex10: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex11: number[] = [];\n  let factorizationCountMaxIndexIndex12:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex13: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex14: number[] = [];\n  let factorizationCountMaxIndexIndex15:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex16: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex17: number[] = [];\n  let factorizationCountMaxIndexIndex18:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex19: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex20: number[] = [];\n  let factorizationCountMaxIndexIndex21:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex22: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex23: number[] = [];\n  let factorizationCountMaxIndexIndex24:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex25: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex26: number[] = [];\n  let factorizationCountMaxIndexIndex27:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex28: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex29: number[] = [];\n  let factorizationCountMaxIndexIndex30:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex31: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex32: number[] = [];\n  let factorizationCountMaxIndexIndex33:\
    \ number[] = [];\n  let factorizationCountMaxIndexIndex34: number[] = [];\n  let\
    \ factorizationCountMaxIndexIndex35: number[] = [];\n  let factorizationCountMaxIndexIndex36:\
    \ number[] = [];\n  let factorizationCount\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp2tc6qhu6.ts(63,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number[] = [];\n    let factorizationCountCount: number[]\
    \ = [];\n    let factorizationCountCountCount: number[] = [];\n    let factorizationCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCount: number[] = [];\n\
    \    let factorizationCountCountCountCountCountCount: number[] = [];\n    let\
    \ factorizationCountCountCountCountCountCountCount: number[] = [];\n    let factorizationCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount:\
    \ number[] = [];\n    let factorizationCountCountCountCountCountCountCountCountCountCountCountCountCountCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmph18hahh3.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factorization: number[] = [];\n  const primeFactors: number[] = [];\n\
    \  let factor = 1;\n  let prime = true;\n  while (factor <= n) {\n    if (n %\
    \ factor === 0) {\n      factorization.push(factor);\n      primeFactors.push(factor);\n\
    \      factor++;\n      prime = false;\n    } else {\n      factor++;\n    }\n\
    \  }\n  if (prime) {\n    factorization.push(factor);\n    primeFactors.push(factor);\n\
    \  }\n  return primeFactors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  2\n\
    ]\n\nshould loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpxjz0xajf.js:29:12)\n\
    \    at Object.<anonymous> (/tmp/tmpxjz0xajf.js:38:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 2 ],\n\
    \  expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMax: number = 0;\n    let factorsCountMaxIndex: number = 0;\n  \
    \  let factorsCountMaxIndex2: number = 0;\n    let factorsCountMaxIndex3: number\
    \ = 0;\n    let factorsCountMaxIndex4: number = 0;\n    let factorsCountMaxIndex5:\
    \ number = 0;\n    let factorsCountMaxIndex6: number = 0;\n    let factorsCountMaxIndex7:\
    \ number = 0;\n    let factorsCountMaxIndex8: number = 0;\n    let factorsCountMaxIndex9:\
    \ number = 0;\n    let factorsCountMaxIndex10: number = 0;\n    let factorsCountMaxIndex11:\
    \ number = 0;\n    let factorsCountMaxIndex12: number = 0;\n    let factorsCountMaxIndex13:\
    \ number = 0;\n    let factorsCountMaxIndex14: number = 0;\n    let factorsCountMaxIndex15:\
    \ number = 0;\n    let factorsCountMaxIndex16: number = 0;\n    let factorsCountMaxIndex17:\
    \ number = 0;\n    let factorsCountMaxIndex18: number = 0;\n    let factorsCountMaxIndex19:\
    \ number = 0;\n    let factorsCountMaxIndex20: number = 0;\n    let factorsCountMaxIndex21:\
    \ number = 0;\n    let factorsCountMaxIndex22: number = 0;\n    let factorsCountMaxIndex23:\
    \ number = 0;\n    let factorsCountMaxIndex24: number = 0;\n    let factorsCountMaxIndex25:\
    \ number = 0;\n    let factorsCountMaxIndex26: number = 0;\n    let factorsCountMaxIndex27:\
    \ number = 0;\n    let factorsCountMaxIndex28: number = 0;\n    let factorsCountMaxIndex29:\
    \ number = 0;\n    let factorsCountMaxIndex30: number = 0;\n    let factorsCountMaxIndex31:\
    \ number = 0;\n    let factorsCountMaxIndex32: number = 0;\n    let factorsCountMaxIndex33:\
    \ number = 0;\n    let factorsCountMaxIndex34: number = 0;\n    let factorsCountMaxIndex35:\
    \ number = 0;\n    let factorsCountMaxIndex36: number = 0;\n    let factorsCountMaxIndex37:\
    \ number = 0;\n    let factorsCountMaxIndex38: number = 0;\n    let factorsCountMaxIndex39:\
    \ number = 0;\n    let factorsCountMaxIndex40: number = 0;\n    let factorsCountMaxIndex41:\
    \ number = 0;\n    let factorsCountMaxIndex42: number = 0;\n    let factorsCountMaxIndex43:\
    \ number = 0;\n    let factorsCountMaxIndex44: number = 0;\n    let factorsCountMaxIndex45:\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmphuhrhue9.ts(53,9): error TS1005: '','' expected.

    ../../../../../tmp/tmphuhrhue9.ts(69,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorization: number[] = [];\n  let factorizationCount:\
    \ number[] = [];\n  let factorizationIndex: number[] = [];\n  let factorizationCountIndex:\
    \ number[] = [];\n  let factorizationIndexCount: number[] = [];\n  let factorizationIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndex: number[] = [];\n  let\
    \ factorizationIndexCountIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n \
    \ let factorizationIndexCountIndexIndexIndexIndex: number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorization\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpf99zl9r5.ts(61,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ isPrime: boolean = false;\n    let isPrimeFactor: boolean = false;\n    let\
    \ factor: number = 0;\n    let primeFactor: number = 0;\n    let primeFactorCount:\
    \ number = 0;\n    let isPrimeFactorCount: number = 0;\n    let isPrimeFactorCount2:\
    \ number = 0;\n    let isPrimeFactorCount3: number = 0;\n    let isPrimeFactorCount4:\
    \ number = 0;\n    let isPrimeFactorCount5: number = 0;\n    let isPrimeFactorCount6:\
    \ number = 0;\n    let isPrimeFactorCount7: number = 0;\n    let isPrimeFactorCount8:\
    \ number = 0;\n    let isPrimeFactorCount9: number = 0;\n    let isPrimeFactorCount10:\
    \ number = 0;\n    let isPrimeFactorCount11: number = 0;\n    let isPrimeFactorCount12:\
    \ number = 0;\n    let isPrimeFactorCount13: number = 0;\n    let isPrimeFactorCount14:\
    \ number = 0;\n    let isPrimeFactorCount15: number = 0;\n    let isPrimeFactorCount16:\
    \ number = 0;\n    let isPrimeFactorCount17: number = 0;\n    let isPrimeFactorCount18:\
    \ number = 0;\n    let isPrimeFactorCount19: number = 0;\n    let isPrimeFactorCount20:\
    \ number = 0;\n    let isPrimeFactorCount21: number = 0;\n    let isPrimeFactorCount22:\
    \ number = 0;\n    let isPrimeFactorCount23: number = 0;\n    let isPrimeFactorCount24:\
    \ number = 0;\n    let isPrimeFactorCount25: number = 0;\n    let isPrimeFactorCount26:\
    \ number = 0;\n    let isPrimeFactorCount27: number = 0;\n    let isPrimeFactorCount28:\
    \ number = 0;\n    let isPrimeFactorCount29: number = 0;\n    let isPrimeFactorCount30:\
    \ number = 0;\n    let isPrimeFactorCount31: number = 0;\n    let isPrimeFactorCount32:\
    \ number = 0;\n    let isPrimeFactorCount33: number = 0;\n    let isPrimeFactorCount34:\
    \ number = 0;\n    let isPrimeFactorCount35: number = 0;\n    let isPrimeFactorCount36:\
    \ number = 0;\n    let isPrimeFactorCount37: number = 0;\n    let isPrimeFactorCount38:\
    \ number = 0;\n    let isPrimeFactorCount39: number = 0;\n    let isPrimeFactorCount40:\
    \ number = 0;\n    let isPrimeFactorCount41: number = 0;\n    let isPrimeFactorCount42:\
    \ number = 0;\n    let isPrime\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpw3crd3du.ts(71,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountIndex: number[] = [];\n    let factorsCountIndexMax: number[] =\
    \ [];\n    let factorsCountIndexMaxIndex: number[] = [];\n    let factorsCountIndexMaxIndexIndex:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex2: number[] = [];\n  \
    \  let factorsCountIndexMaxIndexIndex3: number[] = [];\n    let factorsCountIndexMaxIndexIndex4:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex5: number[] = [];\n  \
    \  let factorsCountIndexMaxIndexIndex6: number[] = [];\n    let factorsCountIndexMaxIndexIndex7:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex8: number[] = [];\n  \
    \  let factorsCountIndexMaxIndexIndex9: number[] = [];\n    let factorsCountIndexMaxIndexIndex10:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex11: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex12: number[] = [];\n    let factorsCountIndexMaxIndexIndex13:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex14: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex15: number[] = [];\n    let factorsCountIndexMaxIndexIndex16:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex17: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex18: number[] = [];\n    let factorsCountIndexMaxIndexIndex19:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex20: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex21: number[] = [];\n    let factorsCountIndexMaxIndexIndex22:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex23: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex24: number[] = [];\n    let factorsCountIndexMaxIndexIndex25:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex26: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex27: number[] = [];\n    let factorsCountIndexMaxIndexIndex28:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex29: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex30: number[] = [];\n    let factorsCountIndexMaxIndexIndex31:\
    \ number[] = [];\n    let factorsCountIndexMaxIndexIndex32: number[] = [];\n \
    \   let factorsCountIndexMaxIndexIndex33: number[] = [];\n    let factorsCountIndexMax\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpv42gobn9.ts(60,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   var factors: number[] = [];\n    var factorsCount: number[] = [];\n    var\
    \ factorsCountMap: Map<number, number> = new Map();\n\n    for (var i = 2; i <=\
    \ Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            factors.push(i);\n\
    \            factorsCount.push(1);\n            factorsCountMap.set(i, factorsCount.length\
    \ - 1);\n        }\n    }\n\n    for (var i = 1; i < factors.length; i++) {\n\
    \        var factorsCount = factorsCountMap.get(factors[i]);\n        if (factorsCount\
    \ === undefined) {\n            factorsCount = 0;\n        }\n        factorsCountMap[factors[i]]\
    \ = factorsCount + 1;\n    }\n\n    return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpi14q93ic.ts(7,26): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmpi14q93ic.ts(7,52): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmpi14q93ic.ts(20,13): error TS2322: Type ''0'' is not assignable
    to type ''number[]''.

    ../../../../../tmp/tmpi14q93ic.ts(22,39): error TS2365: Operator ''+'' cannot
    be applied to types ''number[]'' and ''1''.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ factorization: number[] = [];\n    let factorizationIndex: number[] = [];\n\
    \    let factorizationIndexCount: number[] = [];\n    let factorizationIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCount: number[] = [];\n\
    \    let factorizationIndexCountIndexCountIndex: number[] = [];\n    let factorizationIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndex: number[]\
    \ = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCount: number[]\
    \ = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndex: number[]\
    \ = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n    let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n    let factorizationIndexCountIndex\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmphxutjefk.ts(49,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factorization: number[] = [];\n  let factor = 1;\n  while (n >= 1) {\n\
    \    while (n % factor === 0) {\n      factorization.push(factor);\n      n /=\
    \ factor;\n    }\n    factor++;\n  }\n  return factorization;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffd5570eff0\n 1: 0x2b7d8640e727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b7d86fa328e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b7d868ddf8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b7d86a6f760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b7d86a770cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b7d86c617db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b7d865c07f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014190
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ primeFactors: number[] = [];\n    let primeFactorsCount: number[] = [];\n  \
    \  let isPrime: boolean;\n    let isPrimeCount: number[] = [];\n    let isPrimeFactor:\
    \ boolean;\n    let isPrimeFactorCount: number[] = [];\n    let isPrimePrime:\
    \ boolean;\n    let isPrimePrimeCount: number[] = [];\n    let isPrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimeCount: number[] = [];\n    let\
    \ isPrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrime: boolean;\n  \
    \  let isPrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimeCount: number[]\
    \ = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n \
    \   let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n    let\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount: number[]\
    \ = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp5eezzsaw.ts(51,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number = 0;\n    let factorizationIndex: number = 0;\n \
    \   let factorizationNumber: number = 1;\n    let factorizationNumberIndex: number\
    \ = 0;\n    let factorizationNumberIndexMax: number = factorizationNumber.length\
    \ - 1;\n    let factorizationNumberIndexMin: number = 0;\n    let factorizationNumberIndexMaxMin:\
    \ number = factorizationNumberIndexMax - 1;\n    let factorizationNumberIndexMinMax:\
    \ number = factorizationNumberIndexMin + 1;\n    let factorizationNumberIndexMinMaxMin:\
    \ number = factorizationNumberIndexMinMax + 1;\n    let factorizationNumberIndexMinMaxMinMax:\
    \ number = factorizationNumberIndexMinMaxMin + 1;\n    let factorizationNumberIndexMinMaxMinMaxMin:\
    \ number = factorizationNumberIndexMinMaxMinMax + 1;\n    let factorizationNumberIndexMinMaxMinMaxMin:\
    \ number = factorizationNumberIndexMinMaxMinMaxMin + 1;\n    let factorizationNumberIndexMinMaxMinMaxMinMax:\
    \ number = factorizationNumberIndexMinMaxMinMaxMinMax + 1;\n    let factorizationNumberIndexMinMaxMinMaxMinMaxMin:\
    \ number = factorizationNumberIndexMinMaxMinMaxMinMaxMin + 1;\n    let factorizationNumberIndexMinMaxMinMaxMinMaxMinMax:\
    \ number = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMin + 1;\n    let factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMin:\
    \ number = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMin + 1;\n    let factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMin:\
    \ number = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMin + 1;\n  \
    \  let factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMax: number = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMin\
    \ + 1;\n    let factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMax: number\
    \ = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax;\n    let factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ number = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin + 1;\n\
    \    let factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number\
    \ = factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax;\n    let\
    \ factorizationNumberIndexMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number = factorization\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp86p67uas.ts(45,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014187
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   var factors: number[] = [];\n    var factorsCount: number[] = [];\n    var\
    \ factorsCountMap: number[] = [];\n    var factorsCountMapCount: number[] = [];\n\
    \    var factorsCountMapCountMap: number[] = [];\n    var factorsCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMap: number[] = [];\n  \
    \  var factorsCountMapCountMapCountMapCount: number[] = [];\n    var factorsCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCount: number[]\
    \ = [];\n    var factorsCountMapCountMapCountMapCountMapCountMap: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCount: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCountMap: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCountMap: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCount: number[]\
    \ = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmptesbgo7_.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ if (n > 1) {\n        factors.push(n);\n    }\n    return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2\n]\n\n\
    should loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmp7yp5jrdw.js:23:12)\n\
    \    at Object.<anonymous> (/tmp/tmp7yp5jrdw.js:31:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2 ],\n \
    \ expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n\n    for (let i = 2; i <=\
    \ Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            let factorsCount\
    \ = factorsCountMap.get(i);\n            if (!factorsCount) {\n              \
    \  factorsCount = 1;\n            } else {\n                factorsCount += 1;\n\
    \            }\n            factorsCountMap.set(i, factorsCount);\n          \
    \  factors.push(i);\n        }\n    }\n\n    return factors;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp5ohzcor7.ts(7,26): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmp5ohzcor7.ts(7,52): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n\n    for (let i = 2; i <=\
    \ Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            let factorsCount\
    \ = factorsCountMap.get(i);\n            if (!factorsCount) {\n              \
    \  factorsCount = 1;\n            } else {\n                factorsCount += 1;\n\
    \            }\n            factorsCountMap.set(i, factorsCount);\n          \
    \  factors.push(i);\n        }\n    }\n\n    return factors;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp5ohzcor7.ts(7,26): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmp5ohzcor7.ts(7,52): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: number[] = [];\n    let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCount: number[]\
    \ = [];\n    let factorsMapCountMapCountMap: Map<number, number> = new Map();\n\
    \    let factorsMapCountMapCountMapCount: number[] = [];\n    let factorsMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCount: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp3s2mg143.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArr: number[] = [];\n    let factorsArr: number[] = [];\n    let\
    \ factorsArrCount: number[] = [];\n    let factorsArrCountArr: number[] = [];\n\
    \    let factorsArrCountArr2: number[] = [];\n    let factorsArrCountArr3: number[]\
    \ = [];\n    let factorsArrCountArr4: number[] = [];\n    let factorsArrCountArr5:\
    \ number[] = [];\n    let factorsArrCountArr6: number[] = [];\n    let factorsArrCountArr7:\
    \ number[] = [];\n    let factorsArrCountArr8: number[] = [];\n    let factorsArrCountArr9:\
    \ number[] = [];\n    let factorsArrCountArr10: number[] = [];\n    let factorsArrCountArr11:\
    \ number[] = [];\n    let factorsArrCountArr12: number[] = [];\n    let factorsArrCountArr13:\
    \ number[] = [];\n    let factorsArrCountArr14: number[] = [];\n    let factorsArrCountArr15:\
    \ number[] = [];\n    let factorsArrCountArr16: number[] = [];\n    let factorsArrCountArr17:\
    \ number[] = [];\n    let factorsArrCountArr18: number[] = [];\n    let factorsArrCountArr19:\
    \ number[] = [];\n    let factorsArrCountArr20: number[] = [];\n    let factorsArrCountArr21:\
    \ number[] = [];\n    let factorsArrCountArr22: number[] = [];\n    let factorsArrCountArr23:\
    \ number[] = [];\n    let factorsArrCountArr24: number[] = [];\n    let factorsArrCountArr25:\
    \ number[] = [];\n    let factorsArrCountArr26: number[] = [];\n    let factorsArrCountArr27:\
    \ number[] = [];\n    let factorsArrCountArr28: number[] = [];\n    let factorsArrCountArr29:\
    \ number[] = [];\n    let factorsArrCountArr30: number[] = [];\n    let factorsArrCountArr31:\
    \ number[] = [];\n    let factorsArrCountArr32: number[] = [];\n    let factorsArrCountArr33:\
    \ number[] = [];\n    let factorsArrCountArr34: number[] = [];\n    let factorsArrCountArr35:\
    \ number[] = [];\n    let factorsArrCountArr36: number[] = [];\n    let factorsArrCountArr37:\
    \ number[] = [];\n    let factorsArrCountArr38: number[] = [];\n    let factorsArrCountArr39:\
    \ number[] = [];\n    let factorsArr\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpy7jjxmke.ts(66,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014187
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number[] = [];\n    let factorizationIndex: number[] = [];\n\
    \    let factorizationIndexCount: number[] = [];\n    let factorizationIndexCountMax:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex: number[] = [];\n  \
    \  let factorizationIndexCountMaxIndex2: number[] = [];\n    let factorizationIndexCountMaxIndex3:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex4: number[] = [];\n \
    \   let factorizationIndexCountMaxIndex5: number[] = [];\n    let factorizationIndexCountMaxIndex6:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex7: number[] = [];\n \
    \   let factorizationIndexCountMaxIndex8: number[] = [];\n    let factorizationIndexCountMaxIndex9:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex10: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex11: number[] = [];\n    let factorizationIndexCountMaxIndex12:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex13: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex14: number[] = [];\n    let factorizationIndexCountMaxIndex15:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex16: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex17: number[] = [];\n    let factorizationIndexCountMaxIndex18:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex19: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex20: number[] = [];\n    let factorizationIndexCountMaxIndex21:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex22: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex23: number[] = [];\n    let factorizationIndexCountMaxIndex24:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex25: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex26: number[] = [];\n    let factorizationIndexCountMaxIndex27:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex28: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex29: number[] = [];\n    let factorizationIndexCountMaxIndex30:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex31: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex32: number[] = [];\n    let factorizationIndexCountMaxIndex33:\
    \ number[] = [];\n    let factorizationIndexCountMaxIndex34: number[] = [];\n\
    \    let factorizationIndexCountMaxIndex35: number[] = [];\n    let factorizationIndexCountMaxIndex36\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpcjxioxax.ts(63,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014187
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        if (n % i === 0) {\n            while (n % i === 0) {\n         \
    \       n /= i;\n                factors.push(i);\n            }\n        }\n\
    \    }\n    if (n > 1) {\n        factors.push(n);\n    }\n    return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014187
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ primeFactors: number[] = [];\n    let primeFactorsCount: number[] = [];\n  \
    \  let isPrime: boolean;\n    let isPrimeCount: number[] = [];\n    let isPrimePrime:\
    \ boolean;\n    let isPrimePrimeCount: number[] = [];\n    let isPrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimeCount: number[] = [];\n    let\
    \ isPrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrime: boolean;\n    let\
    \ isPrimePrimePrimePrimePrimePrimeCount: number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n\
    \    let isPrimePrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimeCount: number[] = [];\n   \
    \ let isPrimePrimePrimePrimePrimePrimePrimePrimePrime: boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount:\
    \ number[] = [];\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpaqyvvelw.ts(51,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorization: number[] = [];\n  let factorizationCount:\
    \ number = 0;\n  let factorizationIndex: number = 0;\n  let factorizationLength:\
    \ number = 0;\n  let factorizationMax: number = 0;\n  let factorizationMin: number\
    \ = 0;\n  let factorizationSum: number = 0;\n  let factorizationProduct: number\
    \ = 0;\n  let factorizationProductMax: number = 0;\n  let factorizationProductMin:\
    \ number = 0;\n  let factorizationProductSum: number = 0;\n  let factorizationProductProduct:\
    \ number = 0;\n  let factorizationProductProductMax: number = 0;\n  let factorizationProductProductMin:\
    \ number = 0;\n  let factorizationProductProductSum: number = 0;\n  let factorizationProductProductProduct:\
    \ number = 0;\n  let factorizationProductProductProductMax: number = 0;\n  let\
    \ factorizationProductProductProductMin: number = 0;\n  let factorizationProductProductProductSum:\
    \ number = 0;\n  let factorizationProductProductProductProduct: number = 0;\n\
    \  let factorizationProductProductProductProductMax: number = 0;\n  let factorizationProductProductProductProductMin:\
    \ number = 0;\n  let factorizationProductProductProductProductSum: number = 0;\n\
    \  let factorizationProductProductProductProductProduct: number = 0;\n  let factorizationProductProductProductProductMax:\
    \ number = 0;\n  let factorizationProductProductProductProductMin: number = 0;\n\
    \  let factorizationProductProductProductProductSum: number = 0;\n  let factorizationProductProductProductProductProduct:\
    \ number = 0;\n  let factorizationProductProductProductProductProductMax: number\
    \ = 0;\n  let factorizationProductProductProductProductMin: number = 0;\n  let\
    \ factorizationProductProductProductProductSum: number = 0;\n  let factorizationProductProductProductProductProductProduct:\
    \ number = 0;\n  let factorizationProductProductProductProductProductMax: number\
    \ = 0;\n  let factorizationProductProductProductProductMin: number = 0;\n  let\
    \ factorizationProductProductProductProductSum: number = 0;\n  let factorizationProductProductProductProductProductProduct:\
    \ number = 0;\n  let factorizationProductProductProductProductProductMax: number\
    \ = 0;\n  let factorizationProductProductProductProductMin: number = 0;\n  let\
    \ factorizationProductProductProductProductSum: number = 0;\n  let factorizationProductProductProductProductProductProduct:\
    \ number = 0;\n  let factorizationProductProductProductProductProductMax: number\
    \ = 0;\n  let factorizationProductProductProductProductMin: number = 0;\n  let\
    \ factorizationProductProductProductProductSum: number = 0;\n  let factorizationProductProductProductProductProductProduct:\
    \ number = 0;\n  let factorizationProductProductProductProductProductMax: number\
    \ = 0;\n  let factorizationProductProductProductProductMin: number = 0;\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpf9v2r9ob.ts(69,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014187
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: number[] = [];\n    let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCount: number[]\
    \ = [];\n    let factorsMapCountMapCountMap: Map<number, number> = new Map();\n\
    \    let factorsMapCountMapCountMapCount: number[] = [];\n    let factorsMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCount: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp3s2mg143.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let factor = 1;\n  while (factor <= n) {\n    if (n % factor\
    \ === 0) {\n      factors.push(factor);\n      n = n / factor;\n    } else {\n\
    \      factor++;\n    }\n  }\n  return factors;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fffc3599950\n 1: 0x2b98505a0727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b985113528e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b9850a6ff8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b9850c01760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b9850c090cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b9850df37db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b98507527f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014191
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n\n    for (let i = 1; i <= n; i++) {\n        let factor\
    \ = 1;\n        let factorsCount = 1;\n        let factorsCountMapValue = 1;\n\
    \        let factorsMapValue = 1;\n\n        while (n % i == 0) {\n          \
    \  factor *= i;\n            factorsCount *= i;\n            factorsCountMap.set(factorsCountMapValue,\
    \ factorsCount);\n            factorsMap.set(factorsMapValue, factor);\n     \
    \       factorsCountMapValue += 1;\n            factorsMapValue += 1;\n      \
    \      n /= i;\n        }\n\n        factors.push(factor);\n        factorsCount.push(factorsCount);\n\
    \        factorsCountMap.set(factorsCountMapValue, factorsCount);\n        factorsMap.set(factorsMapValue,\
    \ factor);\n    }\n\n    for (let i = 0; i < factors.length; i++) {\n        let\
    \ factorsCount = factorsCountMap.get(factors[i]);\n        let factor = factorsMap.get(factors[i]);\n\
    \        factorsCountMap.set(factor, factorsCountMap.get(factor) - 1);\n    }\n\
    \n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpazqdyffi.ts(7,26): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmpazqdyffi.ts(7,52): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmpazqdyffi.ts(8,21): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmpazqdyffi.ts(8,47): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmpazqdyffi.ts(27,22): error TS2339: Property ''push'' does
    not exist on type ''number''.

    '
  timestamp: 1660014187
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number[] = [];\n    let factorizationCountMax: number[]\
    \ = [];\n    let factorizationCountMaxIndex: number[] = [];\n    let factorizationCountMaxIndexIndex:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex2: number[] = [];\n \
    \   let factorizationCountMaxIndexIndex3: number[] = [];\n    let factorizationCountMaxIndexIndex4:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex5: number[] = [];\n \
    \   let factorizationCountMaxIndexIndex6: number[] = [];\n    let factorizationCountMaxIndexIndex7:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex8: number[] = [];\n \
    \   let factorizationCountMaxIndexIndex9: number[] = [];\n    let factorizationCountMaxIndexIndex10:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex11: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex12: number[] = [];\n    let factorizationCountMaxIndexIndex13:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex14: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex15: number[] = [];\n    let factorizationCountMaxIndexIndex16:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex17: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex18: number[] = [];\n    let factorizationCountMaxIndexIndex19:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex20: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex21: number[] = [];\n    let factorizationCountMaxIndexIndex22:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex23: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex24: number[] = [];\n    let factorizationCountMaxIndexIndex25:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex26: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex27: number[] = [];\n    let factorizationCountMaxIndexIndex28:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex29: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex30: number[] = [];\n    let factorizationCountMaxIndexIndex31:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex32: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex33: number[] = [];\n    let factorizationCountMaxIndexIndex34:\
    \ number[] = [];\n    let factorizationCountMaxIndexIndex35: number[] = [];\n\
    \    let factorizationCountMaxIndexIndex36: number[] = [];\n    let factorizationCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpi73c87i8.ts(63,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014188
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMap: Map<number, number> = new\
    \ Map();\n  let factorsMapCount: Map<number, number> = new Map();\n  let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCount: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n  let factorsMapCountMapCountMapCount: Map<number, number> = new\
    \ Map();\n  let factorsMapCountMapCountMapCountMap: Map<number, number> = new\
    \ Map();\n  let factorsMapCountMapCountMapCountMapCount: Map<number, number> =\
    \ new Map();\n  let factorsMapCountMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCount: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpd_bzjo07.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014187
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let i = 1;\n  while (n % i === 0) {\n    factors.push(i);\n\
    \    i = i * 2;\n  }\n  if (n > 1) {\n    factors.push(1);\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  2,\n\
    \  1\n]\n\nshould loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpbdmt8hga.js:19:12)\n\
    \    at Object.<anonymous> (/tmp/tmpbdmt8hga.js:28:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 2, 1\
    \ ],\n  expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014188
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArray: number[] = [];\n    let factorsCountArray2: number[] = [];\n\
    \    let factorsCountArray3: number[] = [];\n    let factorsCountArray4: number[]\
    \ = [];\n    let factorsCountArray5: number[] = [];\n    let factorsCountArray6:\
    \ number[] = [];\n    let factorsCountArray7: number[] = [];\n    let factorsCountArray8:\
    \ number[] = [];\n    let factorsCountArray9: number[] = [];\n    let factorsCountArray10:\
    \ number[] = [];\n    let factorsCountArray11: number[] = [];\n    let factorsCountArray12:\
    \ number[] = [];\n    let factorsCountArray13: number[] = [];\n    let factorsCountArray14:\
    \ number[] = [];\n    let factorsCountArray15: number[] = [];\n    let factorsCountArray16:\
    \ number[] = [];\n    let factorsCountArray17: number[] = [];\n    let factorsCountArray18:\
    \ number[] = [];\n    let factorsCountArray19: number[] = [];\n    let factorsCountArray20:\
    \ number[] = [];\n    let factorsCountArray21: number[] = [];\n    let factorsCountArray22:\
    \ number[] = [];\n    let factorsCountArray23: number[] = [];\n    let factorsCountArray24:\
    \ number[] = [];\n    let factorsCountArray25: number[] = [];\n    let factorsCountArray26:\
    \ number[] = [];\n    let factorsCountArray27: number[] = [];\n    let factorsCountArray28:\
    \ number[] = [];\n    let factorsCountArray29: number[] = [];\n    let factorsCountArray30:\
    \ number[] = [];\n    let factorsCountArray31: number[] = [];\n    let factorsCountArray32:\
    \ number[] = [];\n    let factorsCountArray33: number[] = [];\n    let factorsCountArray34:\
    \ number[] = [];\n    let factorsCountArray35: number[] = [];\n    let factorsCountArray36:\
    \ number[] = [];\n    let factorsCountArray37: number[] = [];\n    let factorsCountArray38:\
    \ number[] = [];\n    let factorsCountArray39: number[] = [];\n    let factorsCountArray40:\
    \ number[] = [];\n    let factorsCountArray41: number[] = [];\n    let factorsCountArray42:\
    \ number[] = [];\n    let factorsCountArray43: number[] = [];\n    let factorsCountArray44:\
    \ number[] = [];\n    let factorsCountArray45: number[] = [];\n    let factorsCountArray46\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpajekj82v.ts(69,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014188
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ if (n > 1) {\n        factors.push(n);\n    }\n    return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2\n]\n\n\
    should loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmp7yp5jrdw.js:23:12)\n\
    \    at Object.<anonymous> (/tmp/tmp7yp5jrdw.js:31:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2 ],\n \
    \ expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number[] = [];\n    let factorizationCountMax: number[]\
    \ = [];\n    let factorizationCountMaxIndex: number[] = [];\n    let factorizationCountMaxIndexIndex:\
    \ number[] = [];\n    let factorizationCountMaxIndexValue: number[] = [];\n  \
    \  let factorizationCountMaxIndexValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number[] = [];\n \
    \   let factorizationCountMaxIndexValueValueIndex: number[] = [];\n    let factorizationCountMaxIndexValueValueValue:\
    \ number[] = [];\n    let factorizationCountMaxIndexValueValueIndex: number[]\
    \ = [];\n    let factorizationCountMaxIndexValueValueValue: number\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpw4r8pb4k.ts(60,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014188
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountMax:\
    \ number[] = [];\n  let factorsCountMaxIndex: number[] = [];\n  let factorsCountMaxIndexCount:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMax: number[] = [];\n  let factorsCountMaxIndexCountMaxIndex:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCount: number[] = [];\n\
    \  let factorsCountMaxIndexCountMaxIndexCountMax: number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndex:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCount: number[]\
    \ = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMax: number[]\
    \ = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndex: number[]\
    \ = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCount:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMax:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndex:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCount:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMax:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndex:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCount:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMax:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndex:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCount:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMax:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndexCountMaxIndex:\
    \ number[] = [];\n  let factorsCountMaxIndexCountMaxIndexCountMaxIndexCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpkgami9f7.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014188
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  let factorization: number[]\
    \ = [];\n  while (factor <= n) {\n    if (n % factor === 0) {\n      factors.push(factor);\n\
    \      factor++;\n    } else {\n      factorization[factors.length] = factor;\n\
    \      factor++;\n    }\n  }\n  factors.push(factor);\n  factorization[factors.length]\
    \ = factor;\n  for (let i = 0; i < factors.length; i++) {\n    factorization[i]\
    \ = factors[i];\n  }\n  return factorization;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  2,\n\
    \  3,\n  3\n]\n\nshould loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmp62s1pm4x.js:28:12)\n\
    \    at Object.<anonymous> (/tmp/tmp62s1pm4x.js:37:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 2, 3,\
    \ 3 ],\n  expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014189
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpruerpbt8.js:19:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpruerpbt8.js:28:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpcwnnrrxj.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpcwnnrrxj.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let factor = 1;\n  while (n != 1) {\n    if (n % factor\
    \ == 0) {\n      factors.push(factor);\n      n = n / factor;\n    } else {\n\
    \      factor *= factor;\n    }\n  }\n  return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffef17f1e20\n 1: 0x2b59588e6727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b595947b28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b5958db5f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b5958f47760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b5958f4f0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b59591397db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b5958a987f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  for (let\
    \ i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n\
    \      factorsCount.push(1);\n      while (n % i === 0) {\n        n /= i;\n \
    \       factorsCount[factors.length - 1]++;\n      }\n    }\n  }\n  return [factors,\
    \ factorsCount];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpc9z6w_wv.ts(17,11): error TS2322: Type ''number[]''
    is not assignable to type ''number''.

    ../../../../../tmp/tmpc9z6w_wv.ts(17,20): error TS2322: Type ''number[]'' is not
    assignable to type ''number''.

    '
  timestamp: 1660014188
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  if (n > 1) {\n    factors.push(n);\n  }\n  return factors;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ maxFactor: number = 0;\n    let minFactor: number = 0;\n    let factor: number\
    \ = 0;\n    let factorsCountIndex: number = 0;\n    let factorsCountIndex2: number\
    \ = 0;\n    let factorsCountIndex3: number = 0;\n    let factorsCountIndex4: number\
    \ = 0;\n    let factorsCountIndex5: number = 0;\n    let factorsCountIndex6: number\
    \ = 0;\n    let factorsCountIndex7: number = 0;\n    let factorsCountIndex8: number\
    \ = 0;\n    let factorsCountIndex9: number = 0;\n    let factorsCountIndex10:\
    \ number = 0;\n    let factorsCountIndex11: number = 0;\n    let factorsCountIndex12:\
    \ number = 0;\n    let factorsCountIndex13: number = 0;\n    let factorsCountIndex14:\
    \ number = 0;\n    let factorsCountIndex15: number = 0;\n    let factorsCountIndex16:\
    \ number = 0;\n    let factorsCountIndex17: number = 0;\n    let factorsCountIndex18:\
    \ number = 0;\n    let factorsCountIndex19: number = 0;\n    let factorsCountIndex20:\
    \ number = 0;\n    let factorsCountIndex21: number = 0;\n    let factorsCountIndex22:\
    \ number = 0;\n    let factorsCountIndex23: number = 0;\n    let factorsCountIndex24:\
    \ number = 0;\n    let factorsCountIndex25: number = 0;\n    let factorsCountIndex26:\
    \ number = 0;\n    let factorsCountIndex27: number = 0;\n    let factorsCountIndex28:\
    \ number = 0;\n    let factorsCountIndex29: number = 0;\n    let factorsCountIndex30:\
    \ number = 0;\n    let factorsCountIndex31: number = 0;\n    let factorsCountIndex32:\
    \ number = 0;\n    let factorsCountIndex33: number = 0;\n    let factorsCountIndex34:\
    \ number = 0;\n    let factorsCountIndex35: number = 0;\n    let factorsCountIndex36:\
    \ number = 0;\n    let factorsCountIndex37: number = 0;\n    let factorsCountIndex38:\
    \ number = 0;\n    let factorsCountIndex39: number = 0;\n    let factorsCountIndex40:\
    \ number = 0;\n    let factorsCountIndex41: number = 0;\n    let factorsCountIndex42:\
    \ number = 0;\n    let factorsCountIndex43: number = 0;\n    let factorsCountIndex44:\
    \ number = 0;\n    let factorsCountIndex45: number = 0;\n    let factorsCountIndex46:\
    \ number = 0;\n    let factorsCountIndex47: number = 0;\n    let factorsCountIndex48:\
    \ number = 0;\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpo2z9ht4l.ts(59,9): error TS1005: '','' expected.

    ../../../../../tmp/tmpo2z9ht4l.ts(75,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014189
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let primeFactors = [];\n  let isPrime = true;\n  let isFactor\
    \ = true;\n  let isPrimeFactor = true;\n  let isPrimePrime = true;\n  let isPrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrime = true;\n  let isPrimePrimePrimeFactor = true;\n\
    \  let isPrimePrimePrimePrime = true;\n  let isPrimePrimePrimePrimeFactor = true;\n\
    \  let isPrimePrimePrimePrimePrime = true;\n  let isPrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrime = true;\n  let isPrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrime = true;\n  let isPrimePrimePrimePrimePrimePrimePrime\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimeFactor = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimeFactor = true;\n  let\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = true;\n\
    \  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = true;\n  let\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = true;\n  let isPri\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp552shoeu.ts(52,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014189
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ factorization: number[] = [];\n    let factorizationNumber: number[] = [];\n\
    \    let factorizationNumberCount: number[] = [];\n    let factorizationNumberCountSum:\
    \ number[] = [];\n    let factorizationNumberCountSum2: number[] = [];\n    let\
    \ factorizationNumberCountSum3: number[] = [];\n    let factorizationNumberCountSum4:\
    \ number[] = [];\n    let factorizationNumberCountSum5: number[] = [];\n    let\
    \ factorizationNumberCountSum6: number[] = [];\n    let factorizationNumberCountSum7:\
    \ number[] = [];\n    let factorizationNumberCountSum8: number[] = [];\n    let\
    \ factorizationNumberCountSum9: number[] = [];\n    let factorizationNumberCountSum10:\
    \ number[] = [];\n    let factorizationNumberCountSum11: number[] = [];\n    let\
    \ factorizationNumberCountSum12: number[] = [];\n    let factorizationNumberCountSum13:\
    \ number[] = [];\n    let factorizationNumberCountSum14: number[] = [];\n    let\
    \ factorizationNumberCountSum15: number[] = [];\n    let factorizationNumberCountSum16:\
    \ number[] = [];\n    let factorizationNumberCountSum17: number[] = [];\n    let\
    \ factorizationNumberCountSum18: number[] = [];\n    let factorizationNumberCountSum19:\
    \ number[] = [];\n    let factorizationNumberCountSum20: number[] = [];\n    let\
    \ factorizationNumberCountSum21: number[] = [];\n    let factorizationNumberCountSum22:\
    \ number[] = [];\n    let factorizationNumberCountSum23: number[] = [];\n    let\
    \ factorizationNumberCountSum24: number[] = [];\n    let factorizationNumberCountSum25:\
    \ number[] = [];\n    let factorizationNumberCountSum26: number[] = [];\n    let\
    \ factorizationNumberCountSum27: number[] = [];\n    let factorizationNumberCountSum28:\
    \ number[] = [];\n    let factorizationNumberCountSum29: number[] = [];\n    let\
    \ factorizationNumberCountSum30: number[] = [];\n    let factorizationNumberCountSum31:\
    \ number[] = [];\n    let factorizationNumberCountSum32: number[] = [];\n    let\
    \ factorizationNumberCountSum33: number[] = [];\n    let factorizationNumberCountSum34:\
    \ number[] = [];\n    let factorizationNumberCountSum35: number[] = [];\n    let\
    \ factorizationNumberCountSum36: number[] = [];\n    let factorizationNumberCountSum37:\
    \ number[] = [];\n    let factorizationNumberCountSum38: number[] = [];\n    let\
    \ factorizationNumberCountSum39: number[] = [];\n    let factorizationNumberCountSum40\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpa5_8o0m5.ts(66,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014188
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    if (n % i === 0) {\n      factors.push(i);\n      n = n / i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpizt8t9gl.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpizt8t9gl.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014189
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    let i = 2;\n    while (i <= n) {\n    \
    \    while (n % i === 0) {\n            factors.push(i);\n            n /= i;\n\
    \        }\n        i++;\n    }\n    if (n > 1) {\n        factors.push(n);\n\
    \    }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014189
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: number[] = [];\n    let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap2: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMap3: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap4: Map<number, number> = new Map();\n    let factorsMapCountMap5:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap6: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMap7: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap8: Map<number, number> = new Map();\n    let factorsMapCountMap9:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap10: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap11: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap12: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap13: Map<number, number> = new Map();\n    let factorsMapCountMap14:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap15: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap16: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap17: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap18: Map<number, number> = new Map();\n    let factorsMapCountMap19:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap20: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap21: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap22: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap23: Map<number, number> = new Map();\n    let factorsMapCountMap24:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap25: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap26: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap27: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap28: Map<number, number> = new Map();\n    let factorsMapCountMap29:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap30: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap31: Map<number, number> = new\
    \ Map();\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp4y94vs4a.ts(42,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp4y94vs4a.ts(58,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014178
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let primeFactors: number[] = [];\n  let isPrime:\
    \ boolean;\n  let factor: number[] = [];\n  let factorCount: number[] = [];\n\
    \  let factorsCount: number[] = [];\n  let factorsCount2: number[] = [];\n  let\
    \ factorsCount3: number[] = [];\n  let factorsCount4: number[] = [];\n  let factorsCount5:\
    \ number[] = [];\n  let factorsCount6: number[] = [];\n  let factorsCount7: number[]\
    \ = [];\n  let factorsCount8: number[] = [];\n  let factorsCount9: number[] =\
    \ [];\n  let factorsCount10: number[] = [];\n  let factorsCount11: number[] =\
    \ [];\n  let factorsCount12: number[] = [];\n  let factorsCount13: number[] =\
    \ [];\n  let factorsCount14: number[] = [];\n  let factorsCount15: number[] =\
    \ [];\n  let factorsCount16: number[] = [];\n  let factorsCount17: number[] =\
    \ [];\n  let factorsCount18: number[] = [];\n  let factorsCount19: number[] =\
    \ [];\n  let factorsCount20: number[] = [];\n  let factorsCount21: number[] =\
    \ [];\n  let factorsCount22: number[] = [];\n  let factorsCount23: number[] =\
    \ [];\n  let factorsCount24: number[] = [];\n  let factorsCount25: number[] =\
    \ [];\n  let factorsCount26: number[] = [];\n  let factorsCount27: number[] =\
    \ [];\n  let factorsCount28: number[] = [];\n  let factorsCount29: number[] =\
    \ [];\n  let factorsCount30: number[] = [];\n  let factorsCount31: number[] =\
    \ [];\n  let factorsCount32: number[] = [];\n  let factorsCount33: number[] =\
    \ [];\n  let factorsCount34: number[] = [];\n  let factorsCount35: number[] =\
    \ [];\n  let factorsCount36: number[] = [];\n  let factorsCount37: number[] =\
    \ [];\n  let factorsCount38: number[] = [];\n  let factorsCount39: number[] =\
    \ [];\n  let factorsCount40: number[] = [];\n  let factorsCount41: number[] =\
    \ [];\n  let factorsCount42: number[] = [];\n  let factorsCount43: number[] =\
    \ [];\n  let factorsCount44: number[] = [];\n  let factorsCount45: number[] =\
    \ [];\n  let factorsCount46: number[] = [];\n  let factorsCount47: number[] =\
    \ [];\n  let factorsCount48: number[] = [];\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp2t16_6dd.ts(75,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014189
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ factorsCount: number[] = [];\n    let primeFactorsCount: number[] = [];\n  \
    \  let factorsIndex: number[] = [];\n    let primeFactorsIndex: number[] = [];\n\
    \    let factorsIndexCount: number[] = [];\n    let primeFactorsIndexCount: number[]\
    \ = [];\n    let factorsIndexCountIndex: number[] = [];\n    let primeFactorsIndexCountIndex:\
    \ number[] = [];\n    let factorsIndexCountIndexIndex: number[] = [];\n    let\
    \ primeFactorsIndexCountIndex: number[] = [];\n    let factorsIndexCountIndexIndex:\
    \ number[] = [];\n    let primeFactorsIndexCountIndex: number[] = [];\n    let\
    \ factorsIndexCountIndexIndex: number[] = [];\n    let primeFactorsIndexCountIndex:\
    \ number[] = [];\n    let factorsIndexCountIndexIndex: number[] = [];\n    let\
    \ primeFactorsIndexCountIndex: number[] = [];\n    let factorsIndexCountIndexIndex:\
    \ number[] = [];\n    let primeFactorsIndexCountIndex: number[] = [];\n    let\
    \ factorsIndexCountIndexIndex: number[] = [];\n    let primeFactorsIndexCountIndex:\
    \ number[] = [];\n    let factorsIndexCountIndexIndex: number[] = [];\n    let\
    \ primeFactorsIndexCountIndex: number[] = [];\n    let factorsIndexCountIndexIndex:\
    \ number[] = [];\n    let primeFactorsIndexCountIndex: number[] = [];\n    let\
    \ factorsIndexCountIndexIndex: number[] = [];\n    let primeFactorsIndexCountIndex:\
    \ number[] = [];\n    let factorsIndexCountIndexIndex: number[] = [];\n    let\
    \ primeFactorsIndexCountIndex: number[] = [];\n    let factorsIndexCountIndexIndex:\
    \ number[] = [];\n    let primeFactorsIndexCountIndex: number[] = [];\n    let\
    \ factorsIndexCountIndexIndex: number[] = [];\n    let primeFactorsIndexCountIndex:\
    \ number[] = [];\n    let factorsIndexCountIndexIndex: number[] = [];\n    let\
    \ primeFactorsIndexCountIndex: number[] = [];\n    let factorsIndexCountIndexIndex:\
    \ number[] = [];\n    let primeFactorsIndexCountIndex: number[] = [];\n    let\
    \ factorsIndexCountIndexIndex: number[] = [];\n    let primeFactorsIndexCountIndex:\
    \ number[] = [];\n    let factorsIndexCountIndexIndex: number[] = [];\n    let\
    \ primeFactorsIndexCountIndex: number[] = [];\n    let factorsIndexCountIndexIndex:\
    \ number[] = [];\n    let primeFactorsIndexCountIndex: number[] = [];\n    let\
    \ factorsIndexCountIndexIndex\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp8wxviujo.ts(66,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014189
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMap: Map<number, number> = new\
    \ Map();\n  let factorsMapCount: number[] = [];\n  let factorsMapCountMap: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCount: number[] = [];\n  let factorsMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCount: number[]\
    \ = [];\n  let factorsMapCountMapCountMapCountMap: Map<number, number> = new Map();\n\
    \  let factorsMapCountMapCountMapCountMapCount: number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCount: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpzm9y4mhj.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014189
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factor = 1;\n    let factorCount = 0;\n\
    \    while (n > 1) {\n        if (n % factor === 0) {\n            factors.push(factor);\n\
    \            factorCount++;\n            n /= factor;\n        } else {\n    \
    \        factor *= factor;\n        }\n    }\n    if (n !== 1) {\n        factors.push(1);\n\
    \        factorCount++;\n    }\n    return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff46fef930\n 1: 0x2b0454c85727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b045581a28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b0455154f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b04552e6760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b04552ee0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b04554d87db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b0454e377f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountArr:\
    \ number[] = [];\n  let factorsCountArrIndex: number[] = [];\n  let factorsCountArrIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndex: number[] = [];\n  let\
    \ factorsCountArrIndexIndexIndexIndex: number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndex: number[] =\
    \ [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrIndexIndex\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp8c0rf7t3.ts(49,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014190
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n    \
    \    if (n % i === 0) {\n            let factorsCount = factorsCountMap.get(i);\n\
    \            if (factorsCount === undefined) {\n                factorsCountMap.set(i,\
    \ 1);\n            } else {\n                factorsCountMap.set(i, factorsCount\
    \ + 1);\n            }\n        }\n    }\n\n    for (let [key, value] of factorsCountMap.entries())\
    \ {\n        if (value >= 2) {\n            factors.push(key);\n        }\n  \
    \  }\n\n    for (let [key, value] of factorsMap.entries()) {\n        if (value\
    \ >= 2) {\n            factors.push(key);\n        }\n    }\n\n    return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp3eluxb2o.ts(7,26): error TS2583: Cannot find name
    ''Map''. Do you need to change your target library? Try changing the `lib` compiler
    option to es2015 or later.

    ../../../../../tmp/tmp3eluxb2o.ts(7,52): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmp3eluxb2o.ts(8,21): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    ../../../../../tmp/tmp3eluxb2o.ts(8,47): error TS2583: Cannot find name ''Map''.
    Do you need to change your target library? Try changing the `lib` compiler option
    to es2015 or later.

    '
  timestamp: 1660014190
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors = [];\n    let primes = [];\n    let primeFactors = [];\n    let\
    \ factorization = [];\n    let primeFactorsCount = 0;\n    let factorizationCount\
    \ = 0;\n    let factorizationIndex = 0;\n    let primeFactorsIndex = 0;\n    let\
    \ primeFactorsCountIndex = 0;\n    let factorizationIndexMax = factorization.length\
    \ - 1;\n    let primeFactorsIndexMax = primeFactors.length - 1;\n    let factorizationIndexMin\
    \ = 0;\n    let primeFactorsIndexMin = 0;\n    let factorizationIndexMaxMin =\
    \ factorizationIndexMax - 1;\n    let primeFactorsIndexMaxMin = primeFactorsIndexMax\
    \ - 1;\n    let factorizationIndexMinMax = factorizationIndexMin + 1;\n    let\
    \ primeFactorsIndexMinMax = primeFactorsIndexMin + 1;\n    let factorizationIndexMaxMinMin\
    \ = factorizationIndexMaxMin + 1;\n    let primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMin\
    \ + 1;\n    let factorizationIndexMaxMinMin = factorizationIndexMaxMinMax + 1;\n\
    \    let primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMax + 1;\n    let\
    \ factorizationIndexMaxMinMin = factorizationIndexMaxMinMin + 1;\n    let primeFactorsIndexMaxMinMin\
    \ = primeFactorsIndexMaxMinMin + 1;\n    let factorizationIndexMaxMinMin = factorizationIndexMaxMinMin\
    \ + 1;\n    let primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMin + 1;\n\
    \    let factorizationIndexMaxMinMin = factorizationIndexMaxMinMin + 1;\n    let\
    \ primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMin + 1;\n    let factorizationIndexMaxMinMin\
    \ = factorizationIndexMaxMinMin + 1;\n    let primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMin\
    \ + 1;\n    let factorizationIndexMaxMinMin = factorizationIndexMaxMinMin + 1;\n\
    \    let primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMin + 1;\n    let\
    \ factorizationIndexMaxMinMin = factorizationIndexMaxMinMin + 1;\n    let primeFactorsIndexMaxMinMin\
    \ = primeFactorsIndexMaxMinMin + 1;\n    let factorizationIndexMaxMinMin = factorizationIndexMaxMinMin\
    \ + 1;\n    let primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMin + 1;\n\
    \    let factorizationIndexMaxMinMin = factorizationIndexMaxMinMin + 1;\n    let\
    \ primeFactorsIndexMaxMinMin = primeFactorsIndexMaxMinMin + 1;\n    let factorization\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp8fsre5vn.ts(59,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014190
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  while (n != 1) {\n    while\
    \ (n % factor == 0) {\n      factors.push(factor);\n      n /= factor;\n    }\n\
    \    factor++;\n  }\n  return factors;\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffc3a873300\n 1: 0x2b1c1c890727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b1c1d42528e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b1c1cd5ff8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b1c1cef1760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b1c1cef90cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b1c1d0e37db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b1c1ca427f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factor = 1;\n    let factorization: number[]\
    \ = [];\n    let factorizationCount: number[] = [];\n    while (n != 1) {\n  \
    \      while (n % factor == 0) {\n            factors.push(factor);\n        \
    \    factorization[factor] = factorizationCount[factor] = factorizationCount[factor]\
    \ + 1;\n            n = n / factor;\n        }\n        factor++;\n    }\n   \
    \ for (let i = 0; i < factors.length; i++) {\n        factorizationCount[factors[i]]\
    \ = factorizationCount[factors[i]] + 1;\n    }\n    for (let i = 0; i < factors.length;\
    \ i++) {\n        factorizationCount[factors[i]] = factorizationCount[factors[i]]\
    \ / factorizationCount[factors[i]];\n    }\n    return factorization;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffc839d1cf0\n 1: 0x2aec577aa727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2aec5833f28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2aec57c79f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2aec57e0b760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2aec57e130cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2aec57ffd7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2aec5795c7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014193
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ i: number;\n    let j: number;\n    let factor: number;\n    let factorCount:\
    \ number;\n    let factorCounts: number[] = [];\n    let factorizationCount: number;\n\
    \    let factorizationCounts: number[] = [];\n    let factorizationCountMap: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap2: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap3: Map<number, number> = new Map();\n\
    \    let factorizationCountMap4: Map<number, number> = new Map();\n    let factorizationCountMap5:\
    \ Map<number, number> = new Map();\n    let factorizationCountMap6: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap7: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap8: Map<number, number> = new Map();\n\
    \    let factorizationCountMap9: Map<number, number> = new Map();\n    let factorizationCountMap10:\
    \ Map<number, number> = new Map();\n    let factorizationCountMap11: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap12: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap13: Map<number, number> = new Map();\n\
    \    let factorizationCountMap14: Map<number, number> = new Map();\n    let factorizationCountMap15:\
    \ Map<number, number> = new Map();\n    let factorizationCountMap16: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap17: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap18: Map<number, number> = new Map();\n\
    \    let factorizationCountMap19: Map<number, number> = new Map();\n    let factorizationCountMap20:\
    \ Map<number, number> = new Map();\n    let factorizationCountMap21: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap22: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap23: Map<number, number> = new Map();\n\
    \    let factorizationCountMap24: Map<number, number> = new Map();\n    let factorizationCountMap25:\
    \ Map<number, number> = new Map();\n    let factorizationCountMap26: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap27: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap28: Map<number, number> = new Map();\n\
    \    let factorizationCountMap29: Map<number, number> = new Map();\n    let factorizationCountMap30:\
    \ Map<number, number> = new Map();\n    let factorizationCountMap31: Map<number,\
    \ number> = new Map();\n    let factorizationCountMap32: Map<number, number> =\
    \ new Map();\n    let factorizationCountMap33: Map<number, number> = new Map();\n\
    \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmph9mff7n3.ts(64,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014190
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let primeFactors: number[] = [];\n  let isPrime:\
    \ boolean;\n  let isPrimeCount: number = 0;\n  let isPrimeFactor: boolean;\n \
    \ let isPrimeFactorCount: number = 0;\n  let isPrimeFactorsCount: number = 0;\n\
    \  let isPrimeFactorsCount2: number = 0;\n  let isPrimeFactorsCount3: number =\
    \ 0;\n  let isPrimeFactorsCount4: number = 0;\n  let isPrimeFactorsCount5: number\
    \ = 0;\n  let isPrimeFactorsCount6: number = 0;\n  let isPrimeFactorsCount7: number\
    \ = 0;\n  let isPrimeFactorsCount8: number = 0;\n  let isPrimeFactorsCount9: number\
    \ = 0;\n  let isPrimeFactorsCount10: number = 0;\n  let isPrimeFactorsCount11:\
    \ number = 0;\n  let isPrimeFactorsCount12: number = 0;\n  let isPrimeFactorsCount13:\
    \ number = 0;\n  let isPrimeFactorsCount14: number = 0;\n  let isPrimeFactorsCount15:\
    \ number = 0;\n  let isPrimeFactorsCount16: number = 0;\n  let isPrimeFactorsCount17:\
    \ number = 0;\n  let isPrimeFactorsCount18: number = 0;\n  let isPrimeFactorsCount19:\
    \ number = 0;\n  let isPrimeFactorsCount20: number = 0;\n  let isPrimeFactorsCount21:\
    \ number = 0;\n  let isPrimeFactorsCount22: number = 0;\n  let isPrimeFactorsCount23:\
    \ number = 0;\n  let isPrimeFactorsCount24: number = 0;\n  let isPrimeFactorsCount25:\
    \ number = 0;\n  let isPrimeFactorsCount26: number = 0;\n  let isPrimeFactorsCount27:\
    \ number = 0;\n  let isPrimeFactorsCount28: number = 0;\n  let isPrimeFactorsCount29:\
    \ number = 0;\n  let isPrimeFactorsCount30: number = 0;\n  let isPrimeFactorsCount31:\
    \ number = 0;\n  let isPrimeFactorsCount32: number = 0;\n  let isPrimeFactorsCount33:\
    \ number = 0;\n  let isPrimeFactorsCount34: number = 0;\n  let isPrimeFactorsCount35:\
    \ number = 0;\n  let isPrimeFactorsCount36: number = 0;\n  let isPrimeFactorsCount37:\
    \ number = 0;\n  let isPrimeFactorsCount38: number = 0;\n  let isPrimeFactorsCount39:\
    \ number = 0;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpczes4bk6.ts(67,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014190
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  while (n != 1) {\n    while\
    \ (n % factor == 0) {\n      factors.push(factor);\n      n = n / factor;\n  \
    \  }\n    factor++;\n  }\n  return factors;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffc9508b030\n 1: 0x2aaef9b03727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2aaefa69828e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2aaef9fd2f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2aaefa164760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2aaefa16c0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2aaefa3567db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2aaef9cb57f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMap: Map<number, number> = new\
    \ Map();\n  let factorsMapCount: Map<number, number> = new Map();\n  let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCount: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n  let factorsMapCountMapCountMapCount: Map<number, number> = new\
    \ Map();\n  let factorsMapCountMapCountMapCountMap: Map<number, number> = new\
    \ Map();\n  let factorsMapCountMapCountMapCountMapCount: Map<number, number> =\
    \ new Map();\n  let factorsMapCountMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n  let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n  let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp_kdu46g4.ts(31,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp_kdu46g4.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014191
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ maxFactor: number = 1;\n    let minFactor: number = 1;\n    let maxFactorIndex:\
    \ number = 0;\n    let minFactorIndex: number = 0;\n    for (let i = 2; i <= n;\
    \ i++) {\n        let factor = 1;\n        for (let j = i; j > 1; j--) {\n   \
    \         if (n % j === 0) {\n                factor *= j;\n                factorsCount[factorsCount.length\
    \ - 1]++;\n                n = n / j;\n                break;\n            }\n\
    \        }\n        if (factor > maxFactor) {\n            maxFactor = factor;\n\
    \            maxFactorIndex = factorsCount.length - 1;\n        }\n        if\
    \ (factor < minFactor) {\n            minFactor = factor;\n            minFactorIndex\
    \ = factorsCount.length - 1;\n        }\n        factors.push(factor);\n     \
    \   factorsCount.push(1);\n    }\n    factorsCount.sort((a, b) => a - b);\n  \
    \  for (let i = minFactorIndex; i <= maxFactorIndex; i++) {\n        factors.push(factors[i]);\n\
    \        factorsCount.push(factorsCount[i]);\n    }\n    return factors;\n}\n\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2\n]\n\n\
    should loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmpxj3bui_3.js:43:12)\n\
    \    at Object.<anonymous> (/tmp/tmpxj3bui_3.js:51:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2 ],\n \
    \ expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014191
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsSum: number[] = [];\n    let factorsSumCount: number[] = [];\n    let\
    \ factorsSumCountSum: number[] = [];\n    let factorsSumCountSumCount: number[]\
    \ = [];\n    let factorsSumCountSumCountSum: number[] = [];\n    let factorsSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSum: number[] = [];\n\
    \    let factorsSumCountSumCountSumCountSumCount: number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCount: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSum: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCount: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSum: number[]\
    \ = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount:\
    \ number[] = [];\n    let factorsSumCountSumCountSumCountSumCountSumCount\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmphjg7f2vz.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n = n / i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n \
    \   }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014191
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let factor = 1;\n  while (n != 1) {\n    while\
    \ (n % factor == 0) {\n      factors.push(factor);\n      n = n / factor;\n  \
    \  }\n    factor++;\n  }\n  return factors;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffd43be1170\n 1: 0x2b23e8499727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b23e902e28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b23e8968f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b23e8afa760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b23e8b020cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b23e8cec7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b23e864b7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factor = 1;\n  while (n > 1) {\n    if (n\
    \ % factor === 0) {\n      factors.push(factor);\n      n /= factor;\n    } else\
    \ {\n      factor *= factor;\n    }\n  }\n  return factors;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffd3dd25490\n 1: 0x2abd3c7e3727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2abd3d37828e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2abd3ccb2f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2abd3ce44760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2abd3ce4c0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2abd3d0367db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2abd3c9957f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors = [];\n    let factor = 1;\n    while (n > 1) {\n        if (n\
    \ % factor === 0) {\n            factors.push(factor);\n            n /= factor;\n\
    \        } else {\n            factor *= factor;\n        }\n    }\n    return\
    \ factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff9bee6920\n 1: 0x2b687b9d9727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b687c56e28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b687bea8f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b687c03a760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b687c0420cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b687c22c7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b687bb8b7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let i = 2;\n  while (n % i === 0) {\n    factors.push(i);\n\
    \    n /= i;\n    i++;\n  }\n  if (n !== 1) factors.push(n);\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2,\n  4\n\
    ]\n\nshould loosely deep-equal\n\n[\n  2,\n  2,\n  2\n]\n    at test (/tmp/tmp4erld71b.js:21:12)\n\
    \    at Object.<anonymous> (/tmp/tmp4erld71b.js:28:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2, 4 ],\n\
    \  expected: [ 2, 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014191
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationCount: number = 0;\n    let primeFactors: number[] = [];\n    let\
    \ primeFactorsCount: number = 0;\n    let isPrime: boolean;\n    let isPrimeCount:\
    \ number = 0;\n    let isPrimeFactorization: boolean;\n    let isPrimeFactorizationCount:\
    \ number = 0;\n    let isPrimePrimeFactorization: boolean;\n    let isPrimePrimeFactorizationCount:\
    \ number = 0;\n    let isPrimePrimePrimeFactorization: boolean;\n    let isPrimePrimePrimeFactorizationCount:\
    \ number = 0;\n    let isPrimePrimePrimePrimeFactorization: boolean;\n    let\
    \ isPrimePrimePrimePrimeFactorizationCount: number = 0;\n    let isPrimePrimePrimePrimePrimeFactorization:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimeFactorizationCount: number = 0;\n\
    \    let isPrimePrimePrimePrimePrimePrimeFactorization: boolean;\n    let isPrimePrimePrimePrimePrimePrimeFactorizationCount:\
    \ number = 0;\n    let isPrimePrimePrimePrimePrimePrimePrimeFactorization: boolean;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimeFactorizationCount: number = 0;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization: boolean;\n \
    \   let isPrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount: number =\
    \ 0;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: boolean;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount: number\
    \ = 0;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount:\
    \ number = 0;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ boolean;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount:\
    \ number = 0;\n    let isPrimePrimePrimePrimePrimePrimePrime\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpvlqnysdp.ts(51,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ primeFactors: number[] = [];\n    let isPrime: boolean;\n    let isPrimeFactor:\
    \ boolean;\n    let isPrimeFactorFound: boolean;\n    let isPrimeFactorFoundInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorization: boolean;\n\
    \    let isPrimeFactorFoundInFactorizationInFactorizationInFactorization: boolean;\n\
    \    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorizationInFactorization:\
    \ boolean;\n    let isPrimeFactorFoundInFactorizationInFactorizationInFactorization\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmppgooh5b3.ts(44,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014191
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n\
    \        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpuq0q_wl_.js:20:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpuq0q_wl_.js:29:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014181
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpcwnnrrxj.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpcwnnrrxj.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountMap:\
    \ Map<number, number> = new Map();\n  let factorsCountMapKeys: number[] = [];\n\
    \  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue: number\
    \ = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\n  let factorsCountMapValue:\
    \ number = 0;\n  let factorsCountMapValues: number[] = [];\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpv9fe6dto.ts(70,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let isPrime:\
    \ boolean[] = [];\n  let isPrimeCount: number[] = [];\n  let isPrimeSum: number[]\
    \ = [];\n  let isPrimeSumCount: number[] = [];\n  let isPrimeSumSum: number[]\
    \ = [];\n  let isPrimeSumSumCount: number[] = [];\n  let isPrimeSumSumSum: number[]\
    \ = [];\n  let isPrimeSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumCount: number[] = [];\n  let\
    \ isPrimeSumSumSumSumSumSumSum: number[] = [];\n  let isPrimeSumSumSumSumSumSumCount:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumSum: number[] = [];\n  let isPrimeSumSumSumSumSumSumCount:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumSum: number[] = [];\n  let isPrimeSumSumSumSumSumSumSumCount:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumSumSum: number[] = [];\n  let\
    \ isPrimeSumSumSumSumSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSumSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumSumCount: number[] = [];\n  let\
    \ isPrimeSumSumSumSumSumSumSumSum: number[] = [];\n  let isPrimeSumSumSumSumSumSumSumCount:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumSumSum: number[] = [];\n  let\
    \ isPrimeSumSumSumSumSumSumSumCount: number[] = [];\n  let isPrimeSumSumSumSumSumSumSumSumSum:\
    \ number[] = [];\n  let isPrimeSumSumSumSumSumSumSum\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp2yeii8l5.ts(57,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArr: number[] = [];\n    let factorsCountArrLen: number[] = [];\n\
    \    let factorsCountArrLenLen: number[] = [];\n    let factorsCountArrLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLen: number[] = [];\n    let\
    \ factorsCountArrLenLenLenLenLen: number[] = [];\n    let factorsCountArrLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLen: number[] = [];\n\
    \    let factorsCountArrLenLenLenLenLenLenLenLen: number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLen: number[] =\
    \ [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLen: number[] =\
    \ [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLen: number[]\
    \ = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen:\
    \ number[] = [];\n    let factorsCountArrLenLenLenLenLenLenLenLen\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpv4d24u9q.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: number[] = [];\n    let factorsMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap2: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMap3: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap4: Map<number, number> = new Map();\n    let factorsMapCountMap5:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap6: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMap7: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap8: Map<number, number> = new Map();\n    let factorsMapCountMap9:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap10: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap11: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap12: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap13: Map<number, number> = new Map();\n    let factorsMapCountMap14:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap15: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap16: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap17: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap18: Map<number, number> = new Map();\n    let factorsMapCountMap19:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap20: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap21: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap22: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap23: Map<number, number> = new Map();\n    let factorsMapCountMap24:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap25: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap26: Map<number, number> = new\
    \ Map();\n    let factorsMapCountMap27: Map<number, number> = new Map();\n   \
    \ let factorsMapCountMap28: Map<number, number> = new Map();\n    let factorsMapCountMap29:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMap30: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMap31: Map<number, number> = new\
    \ Map();\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp4y94vs4a.ts(42,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp4y94vs4a.ts(58,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014178
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpz0nl1hza.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationNumber: number[] = [];\n    let factorizationNumberCount: number[]\
    \ = [];\n    let factorizationNumberCountCount: number[] = [];\n    let factorizationNumberCountCount2:\
    \ number[] = [];\n    let factorizationNumberCountCount2: number[] = [];\n   \
    \ let factorizationNumberCountCount3: number[] = [];\n    let factorizationNumberCountCount3:\
    \ number[] = [];\n    let factorizationNumberCountCount4: number[] = [];\n   \
    \ let factorizationNumberCountCount4: number[] = [];\n    let factorizationNumberCountCount5:\
    \ number[] = [];\n    let factorizationNumberCountCount5: number[] = [];\n   \
    \ let factorizationNumberCountCount6: number[] = [];\n    let factorizationNumberCountCount6:\
    \ number[] = [];\n    let factorizationNumberCountCount7: number[] = [];\n   \
    \ let factorizationNumberCountCount7: number[] = [];\n    let factorizationNumberCountCount8:\
    \ number[] = [];\n    let factorizationNumberCountCount8: number[] = [];\n   \
    \ let factorizationNumberCountCount9: number[] = [];\n    let factorizationNumberCountCount9:\
    \ number[] = [];\n    let factorizationNumberCountCount10: number[] = [];\n  \
    \  let factorizationNumberCountCount10: number[] = [];\n    let factorizationNumberCountCount11:\
    \ number[] = [];\n    let factorizationNumberCountCount11: number[] = [];\n  \
    \  let factorizationNumberCountCount12: number[] = [];\n    let factorizationNumberCountCount12:\
    \ number[] = [];\n    let factorizationNumberCountCount13: number[] = [];\n  \
    \  let factorizationNumberCountCount13: number[] = [];\n    let factorizationNumberCountCount14:\
    \ number[] = [];\n    let factorizationNumberCountCount14: number[] = [];\n  \
    \  let factorizationNumberCountCount15: number[] = [];\n    let factorizationNumberCountCount15:\
    \ number[] = [];\n    let factorizationNumberCountCount16: number[] = [];\n  \
    \  let factorizationNumberCountCount16: number[] = [];\n    let factorizationNumberCountCount17:\
    \ number[] = [];\n    let factorizationNumberCountCount17: number[] = [];\n  \
    \  let factorizationNumberCountCount18: number[] = [];\n    let factorizationNumberCountCount18:\
    \ number[] = [];\n    let factorizationNumberCountCount19: number[] = [];\n  \
    \  let factorizationNumberCountCount19: number[] = [];\n    let factorizationNumberCountCount20:\
    \ number[] = [];\n    let factorizationNumberCountCount20: number[] = [];\n  \
    \  let factorizationNumberCountCount21: number[] = [];\n    let factorizationNumberCountCount21\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp_b5ay4yt.ts(66,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorCount: number[] = [];\n    let factorsCount: number[] = [];\n    let factorsCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMap: Map<number, number> =\
    \ new Map();\n    let factorsMap2: Map<number, number> = new Map();\n    let factorsMap3:\
    \ Map<number, number> = new Map();\n    let factorsMap4: Map<number, number> =\
    \ new Map();\n    let factorsMap5: Map<number, number> = new Map();\n    let factorsMap6:\
    \ Map<number, number> = new Map();\n    let factorsMap7: Map<number, number> =\
    \ new Map();\n    let factorsMap8: Map<number, number> = new Map();\n    let factorsMap9:\
    \ Map<number, number> = new Map();\n    let factorsMap10: Map<number, number>\
    \ = new Map();\n    let factorsMap11: Map<number, number> = new Map();\n    let\
    \ factorsMap12: Map<number, number> = new Map();\n    let factorsMap13: Map<number,\
    \ number> = new Map();\n    let factorsMap14: Map<number, number> = new Map();\n\
    \    let factorsMap15: Map<number, number> = new Map();\n    let factorsMap16:\
    \ Map<number, number> = new Map();\n    let factorsMap17: Map<number, number>\
    \ = new Map();\n    let factorsMap18: Map<number, number> = new Map();\n    let\
    \ factorsMap19: Map<number, number> = new Map();\n    let factorsMap20: Map<number,\
    \ number> = new Map();\n    let factorsMap21: Map<number, number> = new Map();\n\
    \    let factorsMap22: Map<number, number> = new Map();\n    let factorsMap23:\
    \ Map<number, number> = new Map();\n    let factorsMap24: Map<number, number>\
    \ = new Map();\n    let factorsMap25: Map<number, number> = new Map();\n    let\
    \ factorsMap26: Map<number, number> = new Map();\n    let factorsMap27: Map<number,\
    \ number> = new Map();\n    let factorsMap28: Map<number, number> = new Map();\n\
    \    let factorsMap29: Map<number, number> = new Map();\n    let factorsMap30:\
    \ Map<number, number> = new Map();\n    let factorsMap31: Map<number, number>\
    \ = new Map();\n    let factorsMap32: Map<number, number> = new Map();\n    let\
    \ factorsMap33: Map<number, number> = new Map();\n    let factorsMap34: Map<number,\
    \ number> = new Map();\n    let factorsMap35: Map<number, number> = new Map();\n\
    \    let factorsMap36: Map<number, number> = new Map();\n    let factorsMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpaqzomopo.ts(63,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountArray:\
    \ number[] = [];\n  let factorsCountArrayIndex: number[] = [];\n  let factorsCountArrayIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndex: number[] = [];\n  let\
    \ factorsCountArrayIndexIndexIndexIndex: number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[]\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpmu0o0iju.ts(48,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            while (n % i === 0) {\n             \
    \   n /= i;\n                factors.push(i);\n            }\n        }\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpu0ub_h6f.js:19:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpu0ub_h6f.js:28:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const factorization: number[][] = [];\n  const\
    \ primeFactors: number[] = [];\n  const isPrime: boolean[] = [];\n  const isPrimeSet:\
    \ boolean[] = [];\n  const isPrimeSet2: boolean[] = [];\n  const isPrimeSet3:\
    \ boolean[] = [];\n  const isPrimeSet4: boolean[] = [];\n  const isPrimeSet5:\
    \ boolean[] = [];\n  const isPrimeSet6: boolean[] = [];\n  const isPrimeSet7:\
    \ boolean[] = [];\n  const isPrimeSet8: boolean[] = [];\n  const isPrimeSet9:\
    \ boolean[] = [];\n  const isPrimeSet10: boolean[] = [];\n  const isPrimeSet11:\
    \ boolean[] = [];\n  const isPrimeSet12: boolean[] = [];\n  const isPrimeSet13:\
    \ boolean[] = [];\n  const isPrimeSet14: boolean[] = [];\n  const isPrimeSet15:\
    \ boolean[] = [];\n  const isPrimeSet16: boolean[] = [];\n  const isPrimeSet17:\
    \ boolean[] = [];\n  const isPrimeSet18: boolean[] = [];\n  const isPrimeSet19:\
    \ boolean[] = [];\n  const isPrimeSet20: boolean[] = [];\n  const isPrimeSet21:\
    \ boolean[] = [];\n  const isPrimeSet22: boolean[] = [];\n  const isPrimeSet23:\
    \ boolean[] = [];\n  const isPrimeSet24: boolean[] = [];\n  const isPrimeSet25:\
    \ boolean[] = [];\n  const isPrimeSet26: boolean[] = [];\n  const isPrimeSet27:\
    \ boolean[] = [];\n  const isPrimeSet28: boolean[] = [];\n  const isPrimeSet29:\
    \ boolean[] = [];\n  const isPrimeSet30: boolean[] = [];\n  const isPrimeSet31:\
    \ boolean[] = [];\n  const isPrimeSet32: boolean[] = [];\n  const isPrimeSet33:\
    \ boolean[] = [];\n  const isPrimeSet34: boolean[] = [];\n  const isPrimeSet35:\
    \ boolean[] = [];\n  const isPrimeSet36: boolean[] = [];\n  const isPrimeSet37:\
    \ boolean[] = [];\n  const isPrimeSet38: boolean[] = [];\n  const isPrimeSet39:\
    \ boolean[] = [];\n  const isPrimeSet40: boolean[] = [];\n  const isPrimeSet41:\
    \ boolean[] = [];\n  const isPrimeSet42: boolean[] = [];\n  const isPrimeSet43:\
    \ boolean[] = [];\n  const isPrimeSet44: boolean[] = [];\n  const isPrimeSet45:\
    \ boolean[] = [];\n  const isPrimeSet46: boolean[] = [];\n  const isPrimeSet47:\
    \ boolean[] = [];\n  const isPrimeSet48: boolean[] = [];\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpepul4p9q.ts(74,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014193
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors = [];\n    let primeFactors = [];\n    let isPrime = true;\n \
    \   let isFactor = false;\n    let isPrimeFactor = false;\n    let isPrimePrime\
    \ = false;\n    let isPrimePrimePrime = false;\n    let isPrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrime = false;\n    let isPrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrime = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrime = false;\n\
    \    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = false;\n    let\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false;\n    let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp93go4x_8.ts(46,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014193
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n    let factorsCountMapValues:\
    \ number[] = [];\n    let factorsCountMapValue: number = 0;\n    let factorsCountMapKeys:\
    \ number[] = [];\n    let factorsCountMapValues: number[] = [];\n    let factorsCountMapValue:\
    \ number = 0;\n    let factorsCountMapKey: number = 0;\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp0j1fijpr.ts(71,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014193
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const factorization = factor(n);\n  for (let\
    \ i = 0; i < factorization.length; i++) {\n    const factor = factorization[i];\n\
    \    if (factor === 1) {\n      factors.push(1);\n    } else {\n      factors.push(factor);\n\
    \    }\n  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpmjks2fmp.ts(6,25): error TS2552: Cannot find name
    ''factor''. Did you mean ''factors''?

    '
  timestamp: 1660014193
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let i = 2;\n  while (i < n) {\n    if (n %\
    \ i === 0) {\n      factors.push(i);\n      n = n / i;\n    } else {\n      i++;\n\
    \    }\n  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpav7l54r0.js:21:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpav7l54r0.js:30:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factor = 1;\n    while (n > 1) {\n  \
    \      if (n % factor === 0) {\n            factors.push(factor);\n          \
    \  n /= factor;\n        } else {\n            factor *= factor;\n        }\n\
    \    }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffcf8bdd960\n 1: 0x2b52b2cf4727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b52b388928e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b52b31c3f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b52b3355760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b52b335d0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b52b35477db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b52b2ea67f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014182
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n = n / i;\n    }\n\
    \  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpk9ysqydn.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpk9ysqydn.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorization: number[] = [];\n  let factor:\
    \ number[] = [];\n  let factorCount: number[] = [];\n  let factorCountIndex: number[]\
    \ = [];\n  let factorCountIndexCount: number[] = [];\n  let factorCountIndexCountIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndex: number[] = [];\n  let\
    \ factorCountIndexCountIndexIndexIndex: number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndex: number[] = [];\n\
    \  let factorCountIndexCountIndexIndexIndexIndexIndexIndex: number[] = [];\n \
    \ let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndex: number[] = [];\n\
    \  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndex: number[] = [];\n\
    \  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndex: number[] = [];\n\
    \  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndex: number[] = [];\n\
    \  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorCountIndexCountIndexIndexIndexIndexIndexIndex\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmprp3o7ars.ts(53,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014194
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const factorization: number[] = [];\n  let\
    \ factor = 1;\n  let factorizationNumber = 0;\n  let factorizationNumberCount\
    \ = 0;\n  let factorizationNumberCountMax = 0;\n  let factorizationNumberCountMaxIndex\
    \ = 0;\n  let factorizationNumberCountMaxIndex2 = 0;\n  let factorizationNumberCountMaxIndex3\
    \ = 0;\n  let factorizationNumberCountMaxIndex4 = 0;\n  let factorizationNumberCountMaxIndex5\
    \ = 0;\n  let factorizationNumberCountMaxIndex6 = 0;\n  let factorizationNumberCountMaxIndex7\
    \ = 0;\n  let factorizationNumberCountMaxIndex8 = 0;\n  let factorizationNumberCountMaxIndex9\
    \ = 0;\n  let factorizationNumberCountMaxIndex10 = 0;\n  let factorizationNumberCountMaxIndex11\
    \ = 0;\n  let factorizationNumberCountMaxIndex12 = 0;\n  let factorizationNumberCountMaxIndex13\
    \ = 0;\n  let factorizationNumberCountMaxIndex14 = 0;\n  let factorizationNumberCountMaxIndex15\
    \ = 0;\n  let factorizationNumberCountMaxIndex16 = 0;\n  let factorizationNumberCountMaxIndex17\
    \ = 0;\n  let factorizationNumberCountMaxIndex18 = 0;\n  let factorizationNumberCountMaxIndex19\
    \ = 0;\n  let factorizationNumberCountMaxIndex20 = 0;\n  let factorizationNumberCountMaxIndex21\
    \ = 0;\n  let factorizationNumberCountMaxIndex22 = 0;\n  let factorizationNumberCountMaxIndex23\
    \ = 0;\n  let factorizationNumberCountMaxIndex24 = 0;\n  let factorizationNumberCountMaxIndex25\
    \ = 0;\n  let factorizationNumberCountMaxIndex26 = 0;\n  let factorizationNumberCountMaxIndex27\
    \ = 0;\n  let factorizationNumberCountMaxIndex28 = 0;\n  let factorizationNumberCountMaxIndex29\
    \ = 0;\n  let factorizationNumberCountMaxIndex30 = 0;\n  let factorizationNumberCountMaxIndex31\
    \ = 0;\n  let factorizationNumberCountMaxIndex32 = 0;\n  let factorizationNumberCountMaxIndex33\
    \ = 0;\n  let factorizationNumberCountMaxIndex34 = 0;\n  let factorizationNumberCountMaxIndex35\
    \ = 0;\n  let factorizationNumberCountMaxIndex36 = 0;\n  let factorizationNumberCountMaxIndex37\
    \ = 0;\n  let factorizationNumberCountMaxIndex38 = 0;\n  let factorizationNumberCountMaxIndex39\
    \ = 0;\n  let factorizationNumberCountMaxIndex40 = 0;\n  let factorizationNumberCountMaxIndex41\
    \ = 0;\n  let factorizationNumberCountMaxIndex42 = 0;\n  let factorizationNumberCountMaxIndex43\
    \ = 0;\n  let factorizationNumberCountMaxIndex44 = 0;\n  let factorizationNumberCountMaxIndex45\
    \ = 0;\n  let factorizationNumberCountMaxIndex46 = 0;\n  let factorizationNumberCountMaxIndex47\
    \ = 0;\n  let factorizationNumberCountMaxIndex\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp6buh6bhe.ts(75,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014194
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let primeFactors: number[] = [];\n  let isPrime:\
    \ boolean;\n  let factor: number[] = [];\n  let factorCount: number = 0;\n  let\
    \ primeFactor: number[] = [];\n  let primeFactorCount: number = 0;\n  for (let\
    \ i = 2; i <= n; i++) {\n    isPrime = true;\n    for (let j = 0; j < primeFactors.length;\
    \ j++) {\n      if (n % primeFactors[j] === 0) {\n        isPrime = false;\n \
    \       break;\n      }\n    }\n    if (isPrime) {\n      primeFactors.push(n\
    \ / i);\n      primeFactorCount++;\n    }\n  }\n  for (let i = 0; i < primeFactors.length;\
    \ i++) {\n    factors.push(primeFactors[i]);\n    factorCount++;\n  }\n  for (let\
    \ i = 0; i < factors.length; i++) {\n    for (let j = 0; j < factorCount; j++)\
    \ {\n      if (factors[i] === factors[j]) {\n        factorCount--;\n      }\n\
    \    }\n  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert =\
    \ require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1\n]\n\n\
    should loosely deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpwpfatdxv.js:41:12)\n\
    \    at Object.<anonymous> (/tmp/tmpwpfatdxv.js:50:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1 ],\n \
    \ expected: [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors = [];\n  let factor = 1;\n  while (n != 1) {\n    while (n % factor\
    \ == 0) {\n      factors.push(factor);\n      n = n / factor;\n    }\n    factor++;\n\
    \  }\n  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff7ae913a0\n 1: 0x2b8fbab9f727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b8fbb73428e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b8fbb06ef8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b8fbb200760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b8fbb2080cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b8fbb3f27db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b8fbad517f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors = [];\n    let factor = 1;\n    while (n > 1) {\n        if (n\
    \ % factor === 0) {\n            factors.push(factor);\n            n /= factor;\n\
    \        } else {\n            factor *= factor;\n        }\n    }\n    return\
    \ factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7fff9bee6920\n 1: 0x2b687b9d9727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b687c56e28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b687bea8f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b687c03a760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b687c0420cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b687c22c7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b687bb8b7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \  return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpcwnnrrxj.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpcwnnrrxj.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ factorizationIndex = 0;\n    let factorizationLength = 0;\n    let factorizationMaxLength\
    \ = 0;\n    let factorizationMaxLengthIndex = 0;\n    let factorizationMaxLengthValue\
    \ = 0;\n    let factorizationMaxLengthValueIndex = 0;\n    let factorizationMaxLengthValueIndex2\
    \ = 0;\n    let factorizationMaxLengthValueIndex2 = 0;\n    let factorizationMaxLengthValueIndex3\
    \ = 0;\n    let factorizationMaxLengthValueIndex4 = 0;\n    let factorizationMaxLengthValueIndex5\
    \ = 0;\n    let factorizationMaxLengthValueIndex6 = 0;\n    let factorizationMaxLengthValueIndex7\
    \ = 0;\n    let factorizationMaxLengthValueIndex8 = 0;\n    let factorizationMaxLengthValueIndex9\
    \ = 0;\n    let factorizationMaxLengthValueIndex10 = 0;\n    let factorizationMaxLengthValueIndex11\
    \ = 0;\n    let factorizationMaxLengthValueIndex12 = 0;\n    let factorizationMaxLengthValueIndex13\
    \ = 0;\n    let factorizationMaxLengthValueIndex14 = 0;\n    let factorizationMaxLengthValueIndex15\
    \ = 0;\n    let factorizationMaxLengthValueIndex16 = 0;\n    let factorizationMaxLengthValueIndex17\
    \ = 0;\n    let factorizationMaxLengthValueIndex18 = 0;\n    let factorizationMaxLengthValueIndex19\
    \ = 0;\n    let factorizationMaxLengthValueIndex20 = 0;\n    let factorizationMaxLengthValueIndex21\
    \ = 0;\n    let factorizationMaxLengthValueIndex22 = 0;\n    let factorizationMaxLengthValueIndex23\
    \ = 0;\n    let factorizationMaxLengthValueIndex24 = 0;\n    let factorizationMaxLengthValueIndex25\
    \ = 0;\n    let factorizationMaxLengthValueIndex26 = 0;\n    let factorizationMaxLengthValueIndex27\
    \ = 0;\n    let factorizationMaxLengthValueIndex28 = 0;\n    let factorizationMaxLengthValueIndex29\
    \ = 0;\n    let factorizationMaxLengthValueIndex30 = 0;\n    let factorizationMaxLengthValueIndex31\
    \ = 0;\n    let factorizationMaxLengthValueIndex32 = 0;\n    let factorizationMaxLengthValueIndex33\
    \ = 0;\n    let factorizationMaxLengthValueIndex34 = 0;\n    let factorizationMaxLengthValueIndex35\
    \ = 0;\n    let factorizationMaxLengthValueIndex36 = 0;\n    let factorizationMaxLengthValueIndex37\
    \ = 0;\n    let factorizationMaxLengthValueIndex38 = 0;\n    let factorizationMaxLengthValueIndex39\
    \ = 0;\n    let factorizationMaxLengthValueIndex40 = 0;\n    let factorizationMaxLengthValueIndex41\
    \ = 0;\n    let factorizationMaxLengthValueIndex42 = 0;\n    let factorizationMaxLengthValueIndex43\
    \ = 0;\n    let factorizationMaxLengthValueIndex44 = 0;\n    let factorizationMaxLengthValueIndex45\
    \ = 0;\n    let factorizationMaxLengthValueIndex46\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpln4rasxj.ts(75,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014194
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ maxFactor: number = 1;\n    let minFactor: number = 1;\n    let factorsCountMax:\
    \ number = 1;\n    let factorsCountMin: number = 1;\n    let factorsCountMaxMin:\
    \ number = 1;\n    let factorsCountMinMax: number = 1;\n    let factorsCountMinMaxMin:\
    \ number = 1;\n    let factorsCountMinMaxMinMax: number = 1;\n    let factorsCountMinMaxMinMaxMin:\
    \ number = 1;\n    let factorsCountMinMaxMinMaxMinMax: number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMin:\
    \ number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMin: number = 1;\n    let\
    \ factorsCountMinMaxMinMaxMinMaxMinMax: number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMax:\
    \ number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMin: number = 1;\n\
    \    let factorsCountMinMaxMinMaxMinMaxMinMaxMin: number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMin: number =\
    \ 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMin: number = 1;\n   \
    \ let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number\
    \ = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: number =\
    \ 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: number = 1;\n\
    \    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number = 1;\n\
    \    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number = 1;\n\
    \    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: number = 1;\n\
    \    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: number\
    \ = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ number = 1;\n    let factorsCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ number = 1;\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmplc8ow_u2.ts(53,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014194
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpz0nl1hza.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            n = n /\
    \ i;\n        }\n    }\n    return factors;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpzedrtm3h.js:17:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpzedrtm3h.js:26:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        if (n % i === 0) {\n            factors.push(i);\n            while\
    \ (n % i === 0) {\n                n /= i;\n                factors.push(i);\n\
    \            }\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n\
    \    }\n    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2,\n  2,\n\
    \  2\n]\n\nshould loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmpeuqklqxy.js:24:12)\n\
    \    at Object.<anonymous> (/tmp/tmpeuqklqxy.js:32:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2, 2, 2\
    \ ],\n  expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014194
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n        while (n % i === 0) {\n            factors.push(i);\n           \
    \ n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n\
    \    return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factor = 1;\n    while (n != 1) {\n \
    \       while (n % factor == 0) {\n            factors.push(factor);\n       \
    \     n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffdccd0e060\n 1: 0x2b7aff975727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b7b0050a28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b7affe44f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b7afffd6760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b7afffde0cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b7b001c87db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b7affb277f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  const primes: number[] = [];\n  for (let i\
    \ = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n\
    \      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n    \
    \  }\n    }\n  }\n  for (let i = factors.length - 1; i >= 0; i--) {\n    if (factors.indexOf(i)\
    \ === -1) {\n      primes.push(factors[i]);\n    }\n  }\n  return primes;\n}\n\
    \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmp316moqx0.js:26:12)\n    at Object.<anonymous>\
    \ (/tmp/tmp316moqx0.js:35:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factorization: number[] = [];\n  let factor: number[] = [];\n  let factorCount:\
    \ number[] = [];\n  let factorsCount: number[] = [];\n  let factorsCountArray:\
    \ number[] = [];\n  let factorsCountArrayIndex: number[] = [];\n  let factorsCountArrayIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndex: number[] = [];\n  let\
    \ factorsCountArrayIndexIndexIndexIndex: number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n  let factorsCountArrayIndex\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpvrhf29ov.ts(51,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   var factors: number[] = [];\n    var factorsCount: number[] = [];\n    var\
    \ factorsCountMap: number[] = [];\n    var factorsCountMapCount: number[] = [];\n\
    \    var factorsCountMapCountMap: number[] = [];\n    var factorsCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMap: number[] = [];\n  \
    \  var factorsCountMapCountMapCountMapCount: number[] = [];\n    var factorsCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCount: number[]\
    \ = [];\n    var factorsCountMapCountMapCountMapCountMapCountMap: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCount: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCountMap: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCountMap: number[] = [];\n\
    \    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCount: number[]\
    \ = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\n    var factorsCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ number[] = [];\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmptesbgo7_.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014186
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primes: number[] = [];\n    let factor:\
    \ number[] = [];\n    let i: number;\n    let j: number;\n    let factorCount:\
    \ number = 0;\n    let primeCount: number = 0;\n    let prime: number[] = [];\n\
    \    let primeFactors: number[] = [];\n    let primeFactorsCount: number = 0;\n\
    \    let factorCount2: number = 0;\n    let factorCount3: number = 0;\n    let\
    \ factorCount4: number = 0;\n    let factorCount5: number = 0;\n    let factorCount6:\
    \ number = 0;\n    let factorCount7: number = 0;\n    let factorCount8: number\
    \ = 0;\n    let factorCount9: number = 0;\n    let factorCount10: number = 0;\n\
    \    let factorCount11: number = 0;\n    let factorCount12: number = 0;\n    let\
    \ factorCount13: number = 0;\n    let factorCount14: number = 0;\n    let factorCount15:\
    \ number = 0;\n    let factorCount16: number = 0;\n    let factorCount17: number\
    \ = 0;\n    let factorCount18: number = 0;\n    let factorCount19: number = 0;\n\
    \    let factorCount20: number = 0;\n    let factorCount21: number = 0;\n    let\
    \ factorCount22: number = 0;\n    let factorCount23: number = 0;\n    let factorCount24:\
    \ number = 0;\n    let factorCount25: number = 0;\n    let factorCount26: number\
    \ = 0;\n    let factorCount27: number = 0;\n    let factorCount28: number = 0;\n\
    \    let factorCount29: number = 0;\n    let factorCount30: number = 0;\n    let\
    \ factorCount31: number = 0;\n    let factorCount32: number = 0;\n    let factorCount33:\
    \ number = 0;\n    let factorCount34: number = 0;\n    let factorCount35: number\
    \ = 0;\n    let factorCount36: number = 0;\n    let factorCount37: number = 0;\n\
    \    let factorCount38: number = 0;\n    let factorCount39: number = 0;\n    let\
    \ factorCount40: number = 0;\n    let factorCount41: number = 0;\n    let factorCount42:\
    \ number = 0;\n    let factorCount43: number = 0;\n    let factorCount44: number\
    \ = 0;\n    let factorCount45: number = 0;\n    let factorCount46: number = 0;\n\
    \    let factorCount47: number = 0;\n    let factorCount48: number = 0;\n    let\
    \ factorCount49: number = 0;\n    let factorCount50: number = 0;\n    let factorCount51:\
    \ number = 0;\n    let factorCount52: number = 0;\n    let factorCount53: number\
    \ = 0;\n    let factorCount54: number = 0;\n    let factorCount55: number = 0;\n\
    \    let factorCount56: number = 0;\n    let factorCount57: number = 0;\n    let\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp99gbyaqo.ts(72,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp99gbyaqo.ts(88,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ return factors;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely\
    \ deep-equal\n\n[\n  2\n]\n    at test (/tmp/tmpruerpbt8.js:19:12)\n    at Object.<anonymous>\
    \ (/tmp/tmpruerpbt8.js:28:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected:\
    \ [ 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014179
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let i = 2;\n  while (n >= i) {\n    if (n %\
    \ i === 0) {\n      factors.push(i);\n      n /= i;\n    }\n    i++;\n  }\n  if\
    \ (n > 1) {\n    factors.push(1);\n  }\n  return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2,\n  1\n\
    ]\n\nshould loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmpcnfdhnkp.js:23:12)\n\
    \    at Object.<anonymous> (/tmp/tmpcnfdhnkp.js:31:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2, 1 ],\n\
    \  expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp45zh6hzx.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014181
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factor = 1;\n    let factorization: number[]\
    \ = [];\n    let primeFactorization: number[] = [];\n    let primeFactor = 1;\n\
    \    let primeFactorizationIndex = 0;\n    let primeFactorizationIndex2 = 0;\n\
    \    let primeFactorizationIndex3 = 0;\n    let primeFactorizationIndex4 = 0;\n\
    \    let primeFactorizationIndex5 = 0;\n    let primeFactorizationIndex6 = 0;\n\
    \    let primeFactorizationIndex7 = 0;\n    let primeFactorizationIndex8 = 0;\n\
    \    let primeFactorizationIndex9 = 0;\n    let primeFactorizationIndex10 = 0;\n\
    \    let primeFactorizationIndex11 = 0;\n    let primeFactorizationIndex12 = 0;\n\
    \    let primeFactorizationIndex13 = 0;\n    let primeFactorizationIndex14 = 0;\n\
    \    let primeFactorizationIndex15 = 0;\n    let primeFactorizationIndex16 = 0;\n\
    \    let primeFactorizationIndex17 = 0;\n    let primeFactorizationIndex18 = 0;\n\
    \    let primeFactorizationIndex19 = 0;\n    let primeFactorizationIndex20 = 0;\n\
    \    let primeFactorizationIndex21 = 0;\n    let primeFactorizationIndex22 = 0;\n\
    \    let primeFactorizationIndex23 = 0;\n    let primeFactorizationIndex24 = 0;\n\
    \    let primeFactorizationIndex25 = 0;\n    let primeFactorizationIndex26 = 0;\n\
    \    let primeFactorizationIndex27 = 0;\n    let primeFactorizationIndex28 = 0;\n\
    \    let primeFactorizationIndex29 = 0;\n    let primeFactorizationIndex30 = 0;\n\
    \    let primeFactorizationIndex31 = 0;\n    let primeFactorizationIndex32 = 0;\n\
    \    let primeFactorizationIndex33 = 0;\n    let primeFactorizationIndex34 = 0;\n\
    \    let primeFactorizationIndex35 = 0;\n    let primeFactorizationIndex36 = 0;\n\
    \    let primeFactorizationIndex37 = 0;\n    let primeFactorizationIndex38 = 0;\n\
    \    let primeFactorizationIndex39 = 0;\n    let primeFactorizationIndex40 = 0;\n\
    \    let primeFactorizationIndex41 = 0;\n    let primeFactorizationIndex42 = 0;\n\
    \    let primeFactorizationIndex43 = 0;\n    let primeFactorizationIndex44 = 0;\n\
    \    let primeFactorizationIndex45 = 0;\n    let primeFactorizationIndex46 = 0;\n\
    \    let primeFactorizationIndex47 = 0;\n    let primeFactorizationIndex48 = 0;\n\
    \    let primeFactorizationIndex49 = 0;\n    let primeFactorizationIndex50 = 0;\n\
    \    let primeFactorizationIndex51 = 0;\n    let primeFactorizationIndex52 = 0;\n\
    \    let primeFactorizationIndex53 = 0;\n    let primeFactorizationIndex54 = 0;\n\
    \    let primeFactorizationIndex55 = 0;\n    let primeFactorizationIndex56 = 0;\n\
    \    let primeFactorizationIndex57 = 0;\n    let primeFactorizationIndex58 = 0;\n\
    \    let primeFactorizationIndex59 = 0;\n    let primeFactorizationIndex60 = 0;\n\
    \    let primeFactorization\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpvnykhnbj.ts(87,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let primeFactors: number[] = [];\n    let\
    \ isPrime: boolean;\n    let isPrimeFactor: boolean;\n    let isPrimeFactorFound:\
    \ boolean;\n    let isPrimeFactorFoundInFactorization: boolean;\n    let isPrimeFactorFoundInFactorizationArray:\
    \ number[] = [];\n    let isPrimeFactorFoundInFactorizationArrayIndex: number\
    \ = 0;\n    let isPrimeFactorFoundInFactorizationArrayLength: number = 0;\n  \
    \  let isPrimeFactorFoundInFactorizationArrayMax: number = 0;\n    let isPrimeFactorFoundInFactorizationArrayMin:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySum: number = 0;\n\
    \    let isPrimeFactorFoundInFactorizationArraySumOfSquares: number = 0;\n   \
    \ let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquares: number = 0;\n\
    \    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares:\
    \ number = 0;\n    let isPrimeFactorFoundInFactorizationArraySumOfSquaresOfSquaresOfSquaresOfSquares\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpykjsuhqm.ts(45,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: -5
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factors: number[] = [];\n  let factor = 1;\n  while (n > 1) {\n    if\
    \ (n % factor === 0) {\n      factors.push(factor);\n      n /= factor;\n    }\
    \ else {\n      factor *= factor;\n    }\n  }\n  return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: Exception
  stderr: "\n\n#\n# Fatal error in , line 0\n# Fatal JavaScript invalid size error\
    \ 169220804\n#\n#\n#\n#FailureMessage Object: 0x7ffd9001c520\n 1: 0x2b5dcd378727\
    \  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n 2: 0x2b5dcdf0d28e\
    \ V8_Fatal(char const*, ...) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 3: 0x2b5dcd847f8b  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 4: 0x2b5dcd9d9760  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 5: 0x2b5dcd9e10cd  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 6: 0x2b5dcdbcb7db v8::internal::Runtime_GrowArrayElements(int, unsigned long*,\
    \ v8::internal::Isolate*) [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n\
    \ 7: 0x2b5dcd52a7f9  [/home/a.guha/.conda/envs/polyglot/bin/../lib/libnode.so.108]\n"
  stdout: ''
  timestamp: 1660014185
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsIndex: number[] = [];\n    let factorsIndexCount: number[] = [];\n  \
    \  let factorsIndexCountMax: number[] = [];\n    let factorsIndexCountMaxIndex:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex: number[] = [];\n   \
    \ let factorsIndexCountMaxIndexIndex2: number[] = [];\n    let factorsIndexCountMaxIndexIndex3:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex4: number[] = [];\n  \
    \  let factorsIndexCountMaxIndexIndex5: number[] = [];\n    let factorsIndexCountMaxIndexIndex6:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex7: number[] = [];\n  \
    \  let factorsIndexCountMaxIndexIndex8: number[] = [];\n    let factorsIndexCountMaxIndexIndex9:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex10: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex11: number[] = [];\n    let factorsIndexCountMaxIndexIndex12:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex13: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex14: number[] = [];\n    let factorsIndexCountMaxIndexIndex15:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex16: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex17: number[] = [];\n    let factorsIndexCountMaxIndexIndex18:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex19: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex20: number[] = [];\n    let factorsIndexCountMaxIndexIndex21:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex22: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex23: number[] = [];\n    let factorsIndexCountMaxIndexIndex24:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex25: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex26: number[] = [];\n    let factorsIndexCountMaxIndexIndex27:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex28: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex29: number[] = [];\n    let factorsIndexCountMaxIndexIndex30:\
    \ number[] = [];\n    let factorsIndexCountMaxIndexIndex31: number[] = [];\n \
    \   let factorsIndexCountMaxIndexIndex32: number[] = [];\n    let factorsIndexCountMaxIndexIndex33:\
    \ number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpweo8peon.ts(60,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ let factors: number[] = [];\n  let factorization: number[] = [];\n  let factorizationIndex:\
    \ number[] = [];\n  let factorizationIndexCount: number[] = [];\n  let factorizationIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexCount: number[] = [];\n  let\
    \ factorizationIndexCountIndexCountIndex: number[] = [];\n  let factorizationIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCount: number[]\
    \ = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndex: number[]\
    \ = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount:\
    \ number[] = [];\n  let factorizationIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpx_ghdc33.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCount: Map<number, number> = new Map();\n\
    \    let factorsMapCountMap: Map<number, number> = new Map();\n    let factorsMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMap: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCount: Map<number, number>\
    \ = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap: Map<number,\
    \ number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCount:\
    \ Map<number, number> = new Map();\n    let factorsMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\n\
    declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpz0nl1hza.ts(47,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014192
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArr: number[] = [];\n    let factorsArr: number[] = [];\n    let\
    \ factorsArr2: number[] = [];\n    let factorsArr3: number[] = [];\n    let factorsArr4:\
    \ number[] = [];\n    let factorsArr5: number[] = [];\n    let factorsArr6: number[]\
    \ = [];\n    let factorsArr7: number[] = [];\n    let factorsArr8: number[] =\
    \ [];\n    let factorsArr9: number[] = [];\n    let factorsArr10: number[] = [];\n\
    \    let factorsArr11: number[] = [];\n    let factorsArr12: number[] = [];\n\
    \    let factorsArr13: number[] = [];\n    let factorsArr14: number[] = [];\n\
    \    let factorsArr15: number[] = [];\n    let factorsArr16: number[] = [];\n\
    \    let factorsArr17: number[] = [];\n    let factorsArr18: number[] = [];\n\
    \    let factorsArr19: number[] = [];\n    let factorsArr20: number[] = [];\n\
    \    let factorsArr21: number[] = [];\n    let factorsArr22: number[] = [];\n\
    \    let factorsArr23: number[] = [];\n    let factorsArr24: number[] = [];\n\
    \    let factorsArr25: number[] = [];\n    let factorsArr26: number[] = [];\n\
    \    let factorsArr27: number[] = [];\n    let factorsArr28: number[] = [];\n\
    \    let factorsArr29: number[] = [];\n    let factorsArr30: number[] = [];\n\
    \    let factorsArr31: number[] = [];\n    let factorsArr32: number[] = [];\n\
    \    let factorsArr33: number[] = [];\n    let factorsArr34: number[] = [];\n\
    \    let factorsArr35: number[] = [];\n    let factorsArr36: number[] = [];\n\
    \    let factorsArr37: number[] = [];\n    let factorsArr38: number[] = [];\n\
    \    let factorsArr39: number[] = [];\n    let factorsArr40: number[] = [];\n\
    \    let factorsArr41: number[] = [];\n    let factorsArr42: number[] = [];\n\
    \    let factorsArr43: number[] = [];\n    let factorsArr44: number[] = [];\n\
    \    let factorsArr45: number[] = [];\n    let factorsArr46: number[] = [];\n\
    \    let factorsArr47: number[] = [];\n    let factorsArr48: number[] = [];\n\
    \    let factorsArr49: number[] = [];\n    let \ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n\
    \  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n\
    \  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpbmek5py8.ts(58,9): error TS1005: '','' expected.

    ../../../../../tmp/tmpbmek5py8.ts(74,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014195
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \ const factorization: number[] = [];\n  let i = 1;\n  while (n >= i) {\n    const\
    \ factors: number[] = [];\n    while (n % i === 0) {\n      factors.push(i);\n\
    \      n = n / i;\n    }\n    factorization.push(factors);\n    i++;\n  }\n  return\
    \ factorization;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpfyxr55_y.ts(13,24): error TS2345: Argument of type
    ''number[]'' is not assignable to parameter of type ''number''.

    '
  timestamp: 1660014195
- exit_code: 1
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n\
    \        if (n % i === 0) {\n            factors.push(i);\n            while (n\
    \ % i === 0) {\n                n /= i;\n            }\n        }\n    }\n   \
    \ if (n > 1) {\n        factors.push(n);\n    }\n    return factors;\n}\n\ndeclare\
    \ var require: any;\nconst assert = require('node:assert');\n\n\nfunction test()\
    \ {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  2\n]\n\n\
    should loosely deep-equal\n\n[\n  2,\n  2\n]\n    at test (/tmp/tmp7yp5jrdw.js:23:12)\n\
    \    at Object.<anonymous> (/tmp/tmp7yp5jrdw.js:31:1)\n    at Module._compile\
    \ (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n\
    \    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 2 ],\n \
    \ expected: [ 2, 2 ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1660014184
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountMap: Map<number, number> = new Map();\n    let factorsMap: Map<number,\
    \ number> = new Map();\n    let factorsMap2: Map<number, number> = new Map();\n\
    \    let factorsMap3: Map<number, number> = new Map();\n    let factorsMap4: Map<number,\
    \ number> = new Map();\n    let factorsMap5: Map<number, number> = new Map();\n\
    \    let factorsMap6: Map<number, number> = new Map();\n    let factorsMap7: Map<number,\
    \ number> = new Map();\n    let factorsMap8: Map<number, number> = new Map();\n\
    \    let factorsMap9: Map<number, number> = new Map();\n    let factorsMap10:\
    \ Map<number, number> = new Map();\n    let factorsMap11: Map<number, number>\
    \ = new Map();\n    let factorsMap12: Map<number, number> = new Map();\n    let\
    \ factorsMap13: Map<number, number> = new Map();\n    let factorsMap14: Map<number,\
    \ number> = new Map();\n    let factorsMap15: Map<number, number> = new Map();\n\
    \    let factorsMap16: Map<number, number> = new Map();\n    let factorsMap17:\
    \ Map<number, number> = new Map();\n    let factorsMap18: Map<number, number>\
    \ = new Map();\n    let factorsMap19: Map<number, number> = new Map();\n    let\
    \ factorsMap20: Map<number, number> = new Map();\n    let factorsMap21: Map<number,\
    \ number> = new Map();\n    let factorsMap22: Map<number, number> = new Map();\n\
    \    let factorsMap23: Map<number, number> = new Map();\n    let factorsMap24:\
    \ Map<number, number> = new Map();\n    let factorsMap25: Map<number, number>\
    \ = new Map();\n    let factorsMap26: Map<number, number> = new Map();\n    let\
    \ factorsMap27: Map<number, number> = new Map();\n    let factorsMap28: Map<number,\
    \ number> = new Map();\n    let factorsMap29: Map<number, number> = new Map();\n\
    \    let factorsMap30: Map<number, number> = new Map();\n    let factorsMap31:\
    \ Map<number, number> = new Map();\n    let factorsMap32: Map<number, number>\
    \ = new Map();\n    let factorsMap33: Map<number, number> = new Map();\n    let\
    \ factorsMap34: Map<number, number> = new Map();\n    let factorsMap35: Map<number,\
    \ number> = new Map();\n    let factorsMap36: Map<number, number> = new Map();\n\
    \    let factorsMap37: Map<number, number> = new Map();\n    let factorsMap38:\
    \ Map<\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\n\
    function test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
    \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2,\
    \ 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
    \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
    \ 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpci96tk02.ts(46,9): error TS1005: ''>'' expected.

    ../../../../../tmp/tmpci96tk02.ts(62,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014179
- exit_code: 0
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   const factors: number[] = [];\n    let i = 2;\n    while (i <= n) {\n    \
    \    while (n % i === 0) {\n            factors.push(i);\n            n /= i;\n\
    \        }\n        i++;\n    }\n    return factors;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014196
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorsCount: number[] = [];\n    let\
    \ factorsCountArr: number[] = [];\n    let factorsCountArrIndex: number[] = [];\n\
    \    let factorsCountArrIndexIndex: number[] = [];\n    let factorsCountArrIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndex: number[] = [];\n\
    \    let factorsCountArrIndexIndexIndexIndexIndex: number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let factorsCountArrIndexIndexIndexIndex\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpj7hu6tya.ts(49,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014196
- exit_code: 2
  program: "//Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n// Input number should be equal\
    \ to the product of all factors\nfunction factorize(n: number): number[] {\n \
    \   let factors: number[] = [];\n    let factorization: number[] = [];\n    let\
    \ primeFactors: number[] = [];\n    let primeFactorsCount: number[] = [];\n  \
    \  let factorizationCount: number[] = [];\n    let factorizationCountMax: number[]\
    \ = [];\n    let factorizationCountMaxIndex: number[] = [];\n    let factorizationCountMaxIndex2:\
    \ number[] = [];\n    let factorizationCountMaxIndex3: number[] = [];\n    let\
    \ factorizationCountMaxIndex4: number[] = [];\n    let factorizationCountMaxIndex5:\
    \ number[] = [];\n    let factorizationCountMaxIndex6: number[] = [];\n    let\
    \ factorizationCountMaxIndex7: number[] = [];\n    let factorizationCountMaxIndex8:\
    \ number[] = [];\n    let factorizationCountMaxIndex9: number[] = [];\n    let\
    \ factorizationCountMaxIndex10: number[] = [];\n    let factorizationCountMaxIndex11:\
    \ number[] = [];\n    let factorizationCountMaxIndex12: number[] = [];\n    let\
    \ factorizationCountMaxIndex13: number[] = [];\n    let factorizationCountMaxIndex14:\
    \ number[] = [];\n    let factorizationCountMaxIndex15: number[] = [];\n    let\
    \ factorizationCountMaxIndex16: number[] = [];\n    let factorizationCountMaxIndex17:\
    \ number[] = [];\n    let factorizationCountMaxIndex18: number[] = [];\n    let\
    \ factorizationCountMaxIndex19: number[] = [];\n    let factorizationCountMaxIndex20:\
    \ number[] = [];\n    let factorizationCountMaxIndex21: number[] = [];\n    let\
    \ factorizationCountMaxIndex22: number[] = [];\n    let factorizationCountMaxIndex23:\
    \ number[] = [];\n    let factorizationCountMaxIndex24: number[] = [];\n    let\
    \ factorizationCountMaxIndex25: number[] = [];\n    let factorizationCountMaxIndex26:\
    \ number[] = [];\n    let factorizationCountMaxIndex27: number[] = [];\n    let\
    \ factorizationCountMaxIndex28: number[] = [];\n    let factorizationCountMaxIndex29:\
    \ number[] = [];\n    let factorizationCountMaxIndex30: number[] = [];\n    let\
    \ factorizationCountMaxIndex31: number[] = [];\n    let factorizationCountMaxIndex32:\
    \ number[] = [];\n    let factorizationCountMaxIndex33: number[] = [];\n    let\
    \ factorizationCountMaxIndex34: number[] = [];\n    let factorizationCountMaxIndex35:\
    \ number[] = [];\n    let factorizationCountMaxIndex36: number[] = [];\n    let\
    \ factorizationCountMaxIndex37: number[] = [];\n    let factorizationCountMaxIndex38:\
    \ number[] = [];\n    let factorizationCountMaxIndex39: number\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
    \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
    \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
    \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n\
    \  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpa7sqtumf.ts(66,8): error TS1005: ''}'' expected.

    '
  timestamp: 1660014196
