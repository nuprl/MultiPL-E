{
  "name": "mbpp_299_max_aggregate",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to calculate the maximum aggregate from the list of tuples.\n    def maxAggregate(stdata : List[Either[String, Long]]) : Either[String, Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxAggregate((List[Either[String, Long]]((\"Juan Whelan\", 90l), (\"Sabah Colley\", 88l), (\"Peter Nichols\", 7l), (\"Juan Whelan\", 122l), (\"Sabah Colley\", 84l)))).equals((\"Juan Whelan\", 212l)));\n    assert(maxAggregate((List[Either[String, Long]]((\"Juan Whelan\", 50l), (\"Sabah Colley\", 48l), (\"Peter Nichols\", 37l), (\"Juan Whelan\", 22l), (\"Sabah Colley\", 14l)))).equals((\"Juan Whelan\", 72l)));\n    assert(maxAggregate((List[Either[String, Long]]((\"Juan Whelan\", 10l), (\"Sabah Colley\", 20l), (\"Peter Nichols\", 30l), (\"Juan Whelan\", 40l), (\"Sabah Colley\", 50l)))).equals((\"Sabah Colley\", 70l)));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val data = stdata.map(x => x match {\n            case Left(x) => Left(x)\n            case Right(x) => Right(x)\n        })\n        val lefts = data.filter(x => x match {\n            case Left(x) => true\n            case Right(x) => false\n        })\n        val rights = data.filter(x => x match {\n            case Left(x) => false\n            case Right(x) => true\n        })\n        if (lefts.length > 0) {\n            return lefts.head\n        }\n        else {\n            return Right(rights.map(x => x match {\n                case Right(x) => x\n            }).max)\n        }",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.isEmpty) Left(\"No data\")\n        else Right(data.max)",
    "        val l = stdata.filter(_.isRight).map(_.right.get)\n        if (l.isEmpty) Left(\"No numeric data\")\n        else Right(l.max)",
    "        val data = stdata.map(x => x match {\n            case Left(s) => Left(s)\n            case Right(l) => Right(l)\n        })\n        val lefts = data.filter(x => x match {\n            case Left(s) => true\n            case Right(l) => false\n        })\n        if (lefts.length > 0) {\n            lefts(0)\n        } else {\n            val rights = data.filter(x => x match {\n                case Left(s) => false\n                case Right(l) => true\n            })\n            Right(rights.map(x => x match {\n                case Left(s) => 0\n                case Right(l) => l\n            }).reduceLeft(_ + _))\n        }",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.isEmpty) Left(\"No data\")\n        else Right(data.max)",
    "        val data = stdata.map(x => x match {\n            case Left(s) => Left(s)\n            case Right(l) => Right(l)\n        })\n        val l = data.filter(x => x match {\n            case Left(s) => false\n            case Right(l) => true\n        })\n        val s = data.filter(x => x match {\n            case Left(s) => true\n            case Right(l) => false\n        })\n        if (l.length == 0) {\n            Left(\"No data\")\n        } else if (s.length == 0) {\n            Right(l.map(x => x match {\n                case Left(s) => 0\n                case Right(l) => l\n            }).max)\n        } else {\n            Left(\"Mixed data\")\n        }",
    "        val (lefts, rights) = stdata.partition(_.isLeft)\n        if (lefts.isEmpty) {\n            val max = rights.map(_.right.get).max\n            Right(max)\n        } else {\n            Left(lefts.map(_.left.get).mkString(\",\"))\n        }",
    "        val (strs, longs) = stdata.partition(_.isLeft)\n        if (strs.isEmpty) Right(longs.map(_.right.get).max)\n        else Left(strs.map(_.left.get).mkString(\",\"))",
    "        val data = stdata.map(x => x match {\n            case Left(s) => Left(s)\n            case Right(l) => Right(l)\n        })\n        val lefts = data.filter(x => x match {\n            case Left(s) => true\n            case Right(l) => false\n        })\n        if (lefts.size > 0) {\n            return lefts.head\n        }\n        val rights = data.filter(x => x match {\n            case Left(s) => false\n            case Right(l) => true\n        })\n        if (rights.size == 0) {\n            return Left(\"No data\")\n        }\n        val sum = rights.map(x => x match {\n            case Left(s) => 0\n            case Right(l) => l\n        }).sum\n        val max = rights.map(x => x match {\n            case Left(s) => 0\n            case Right(l) => l\n        }).max\n        val min = rights.map(x => x match {\n            case Left(s) => 0\n            case Right(l) => l\n        }).min\n        val avg = sum / rights.size\n        val maxAggregate = max + min + avg\n        return Right(maxAggregate)",
    "        val (strs, lngs) = stdata.partition(_.isLeft)\n        if (strs.isEmpty) Right(lngs.map(_.right.get).max)\n        else Left(strs.map(_.left.get).mkString(\",\"))",
    "        val (strs, longs) = stdata.partition(_.isLeft)\n        if (strs.isEmpty) {\n            Right(longs.map(_.right.get).max)\n        } else {\n            Left(strs.map(_.left.get).mkString(\",\"))\n        }",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.size == 0) Left(\"No data\")\n        else Right(data.max)",
    "        val data = stdata.map(x => x match {\n            case Left(s) => Left(s)\n            case Right(l) => Right(l)\n        })\n        val lefts = data.filter(x => x match {\n            case Left(s) => true\n            case Right(l) => false\n        })\n        if (lefts.length > 0) {\n            return lefts(0)\n        }\n        val rights = data.filter(x => x match {\n            case Left(s) => false\n            case Right(l) => true\n        })\n        if (rights.length == 0) {\n            return Left(\"No data\")\n        }\n        val max = rights.map(x => x match {\n            case Left(s) => 0\n            case Right(l) => l\n        }).max\n        return Right(max)",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.isEmpty) Left(\"No data\")\n        else Right(data.max)",
    "        val data = stdata.map(x => x match {\n            case Left(s) => Left(s)\n            case Right(l) => Right(l)\n        })\n        val lefts = data.filter(x => x.isLeft)\n        if (lefts.size > 0) {\n            return lefts.head\n        }\n        val rights = data.filter(x => x.isRight)\n        val rights2 = rights.map(x => x match {\n            case Left(s) => 0\n            case Right(l) => l\n        })\n        val max = rights2.max\n        return Right(max)",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.isEmpty) Left(\"No data\")\n        else Right(data.max)",
    "        var max = 0L\n        var max_index = 0\n        var max_index_count = 0\n        var max_index_sum = 0L\n        var index = 0\n        var count = 0\n        var sum = 0L\n        for (e <- stdata) {\n            e match {\n                case Left(s) => {\n                    if (count > max_index_count) {\n                        max_index_count = count\n                        max_index_sum = sum\n                        max_index = index\n                    }\n                    count = 0\n                    sum = 0L\n                    index += 1\n                }\n                case Right(l) => {\n                    count += 1\n                    sum += l\n                }\n            }\n        }\n        if (count > max_index_count) {\n            max_index_count = count\n            max_index_sum = sum\n            max_index = index\n        }\n        if (max_index_count == 0) Left(\"No data\")\n        else Right(max_index_sum)",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.isEmpty) Left(\"No data\")\n        else Right(data.max)",
    "        val data = stdata.filter(_.isRight).map(_.right.get)\n        if (data.isEmpty) Left(\"No data\") else Right(data.max)",
    "        val (strs, nums) = stdata.partition(_.isLeft)\n        if (strs.length > 0) Left(strs.map(_.left.get).mkString(\",\"))\n        else Right(nums.map(_.right.get).sum)"
  ]
}