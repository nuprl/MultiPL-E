{
  "name": "mbpp_12_sort_matrix",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a given matrix in ascending order according to the sum of its rows.\n    def sortMatrix(M : List[List[Long]]) : List[List[Long]] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortMatrix((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong, 5l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong)))).equals((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong, 5l.toLong)))));\n    assert(sortMatrix((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](-2l.toLong, 4l.toLong, -5l.toLong), List[Long](1l.toLong, -1l.toLong, 1l.toLong)))).equals((List[List[Long]](List[Long](-2l.toLong, 4l.toLong, -5l.toLong), List[Long](1l.toLong, -1l.toLong, 1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong)))));\n    assert(sortMatrix((List[List[Long]](List[Long](5l.toLong, 8l.toLong, 9l.toLong), List[Long](6l.toLong, 4l.toLong, 3l.toLong), List[Long](2l.toLong, 1l.toLong, 4l.toLong)))).equals((List[List[Long]](List[Long](2l.toLong, 1l.toLong, 4l.toLong), List[Long](6l.toLong, 4l.toLong, 3l.toLong), List[Long](5l.toLong, 8l.toLong, 9l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(l => l.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        M.zip(sums).sortBy(_._2).map(_._1)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => (row, row.sum)).sortBy(_._2)\n        sums.map(_._1)",
    "        M.sortBy(x => x.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.sortWith((row1, row2) => rowSums(M.indexOf(row1)) < rowSums(M.indexOf(row2)))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        def sumRow(row : List[Long]) : Long = row.foldLeft(0L)(_ + _)\n        M.sortWith((row1, row2) => sumRow(row1) < sumRow(row2))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sorted = rowSums.sorted\n        val sortedIndices = sorted.map(sum => rowSums.indexOf(sum))\n        val sortedMatrix = sortedIndices.map(i => M(i))\n        sortedMatrix",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(row => row.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sorted = M.sortWith((x, y) => x.sum < y.sum)\n        sorted",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedRowIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedRowIndices.map(i => M(i))",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => sums(M.indexOf(row)))",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedRowIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedRowIndices.map(i => M(i))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sum = M.map(row => row.sum)\n        val sorted = sum.sorted\n        val indices = sum.map(s => sorted.indexOf(s))\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until M.length) result += M(indices(i))\n        result.toList",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => (x.sum < y.sum))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((r1, r2) => r1.sum < r2.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sorted = M.sortWith((x, y) => x.sum < y.sum)\n        sorted",
    "        M.sortWith((x, y) => (x.sum < y.sum))",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => sums(M.indexOf(row)))",
    "        val rowSums = M.map(row => row.sum)\n        val sortedRowIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedRowIndices.map(i => M(i))",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.zip(rowSums).sortBy(_._2).map(_._1)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => (row, row.sum)).sortBy(_._2)\n        sums.map(_._1)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(x => x.sum)\n        M.sortWith((x, y) => sums(M.indexOf(x)) < sums(M.indexOf(y)))",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(x => x.sum)\n        val sorted = sums.sorted\n        val sortedM = M.sortWith((x, y) => x.sum < y.sum)\n        sortedM",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sorted = rowSums.sorted\n        val sortedRows = sorted.map(sum => M(rowSums.indexOf(sum)))\n        sortedRows",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => (x.sum < y.sum))",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        M.zip(sums).sortBy(_._2).map(_._1)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sorted = M.sortBy(_.sum)\n        sorted",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.zip(rowSums).sortBy(_._2).map(_._1)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.sortBy(row => rowSums(M.indexOf(row)))",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)"
  ]
}