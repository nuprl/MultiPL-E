{
  "name": "mbpp_12_sort_matrix",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a given matrix in ascending order according to the sum of its rows.\n    def sortMatrix(M : List[List[Long]]) : List[List[Long]] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortMatrix((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong, 5l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong)))).equals((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong, 5l.toLong)))));\n    assert(sortMatrix((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](-2l.toLong, 4l.toLong, -5l.toLong), List[Long](1l.toLong, -1l.toLong, 1l.toLong)))).equals((List[List[Long]](List[Long](-2l.toLong, 4l.toLong, -5l.toLong), List[Long](1l.toLong, -1l.toLong, 1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong)))));\n    assert(sortMatrix((List[List[Long]](List[Long](5l.toLong, 8l.toLong, 9l.toLong), List[Long](6l.toLong, 4l.toLong, 3l.toLong), List[Long](2l.toLong, 1l.toLong, 4l.toLong)))).equals((List[List[Long]](List[Long](2l.toLong, 1l.toLong, 4l.toLong), List[Long](6l.toLong, 4l.toLong, 3l.toLong), List[Long](5l.toLong, 8l.toLong, 9l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(l => l.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        M.zip(sums).sortBy(_._2).map(_._1)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => (row, row.sum)).sortBy(_._2)\n        sums.map(_._1)",
    "        M.sortBy(x => x.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.sortWith((row1, row2) => rowSums(M.indexOf(row1)) < rowSums(M.indexOf(row2)))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        def sumRow(row : List[Long]) : Long = row.foldLeft(0L)(_ + _)\n        M.sortWith((row1, row2) => sumRow(row1) < sumRow(row2))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)"
  ]
}