{
  "name": "mbpp_141_pancake_sort",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a list of elements.\n    def pancakeSort(nums : List[Long]) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pancakeSort((List[Long](15l.toLong, 79l.toLong, 25l.toLong, 38l.toLong, 69l.toLong))).equals((List[Long](15l.toLong, 25l.toLong, 38l.toLong, 69l.toLong, 79l.toLong))));\n    assert(pancakeSort((List[Long](98l.toLong, 12l.toLong, 54l.toLong, 36l.toLong, 85l.toLong))).equals((List[Long](12l.toLong, 36l.toLong, 54l.toLong, 85l.toLong, 98l.toLong))));\n    assert(pancakeSort((List[Long](41l.toLong, 42l.toLong, 32l.toLong, 12l.toLong, 23l.toLong))).equals((List[Long](12l.toLong, 23l.toLong, 32l.toLong, 41l.toLong, 42l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) return nums\n            val max = findMax(nums, k)\n            val nums1 = flip(nums, max + 1)\n            val nums2 = flip(nums1, k)\n            sort(nums2, k - 1)\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 1 by -1) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1)\n            result += (current.length - i)\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.take(current.length - i).reverse ++ current.drop(current.length - i)\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 to k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            result += (index + 1).toLong\n            result += (n - i).toLong\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (left, right) = nums.splitAt(k)\n            right.reverse ::: left\n        }\n        def solve(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.max\n                val index = map(max)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, k)\n                solve(nums2, k - 1)\n            }\n        }\n        solve(nums, n)",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1).toLong\n            result += (current.length).toLong\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        if (nums.length == 1) return nums\n        val max = nums.max\n        val maxIndex = nums.indexOf(max)\n        val newNums = nums.take(maxIndex).reverse ::: nums.drop(maxIndex)\n        val newNums2 = newNums.take(newNums.length - 1).reverse ::: newNums.drop(newNums.length - 1)\n        return newNums2.head :: pancakeSort(newNums2.tail)",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length)\n            current = current.slice(0, index).reverse ::: current.slice(index + 1, current.length)\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                sort(flip(nums, max + 1), max)\n                sort(flip(nums, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        def swap(nums : List[Long], i : Int, j : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(i)\n            val (c, d) = b.splitAt(j - i + 1)\n            a ::: c.reverse ::: d\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.take(k).zipWithIndex.maxBy(_._1)\n                val nums1 = swap(nums, max._2, k - 1)\n                val nums2 = swap(nums1, 0, k - 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(n - i - 1))\n            if (index != n - i - 1) {\n                result = (n - index) :: result\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val result = ListBuffer[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1).toLong\n                result += (i + 1).toLong\n            }\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val max = result.max\n            val index = result.indexOf(max)\n            if (index != 0) {\n                result = result.take(index + 1).reverse ++ result.drop(index + 1)\n            }\n            result = result.take(nums.length - i).reverse ++ result.drop(nums.length - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ index.toLong\n                result = result :+ (nums.length - i).toLong\n            }\n            nums.slice(0, index + 1).reverse ++ nums.slice(index + 1, nums.length)\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += index + 1\n            result += current.length\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        def reverse(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.indexOf(nums.take(k).max)\n                val nums1 = reverse(nums, max + 1)\n                val nums2 = reverse(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result += index + 1\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result += 1\n            current = current.take(1).reverse ++ current.drop(1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                result = (i + 1) :: result\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = maxIndex + 1 :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = current.length :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            val flipped = current.take(index + 1).reverse ++ current.drop(index + 1)\n            result = (index + 1) :: result\n            current = flipped.take(i + 1).reverse ++ flipped.drop(i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result += (index + 1).toLong\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result += (n - i).toLong\n            current = current.take(n - i).reverse ++ current.drop(n - i)\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map += (nums(i) -> i)\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            val index = map(sorted(i))\n            if (index != i) {\n                if (index != 0) {\n                    result = index + 1 :: result\n                    val temp = nums.slice(0, index + 1).reverse\n                    for (j <- 0 to index) nums(j) = temp(j)\n                }\n                result = (n - i) :: result\n                val temp = nums.slice(0, n - i).reverse\n                for (j <- 0 until n - i) nums(j) = temp(j)\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            result = result :+ (current.length - i)\n            current = current.take(index).reverse ::: current.drop(index)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums2.length)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val max = result.zipWithIndex.maxBy(_._1)._2\n            if (max != result.length - 1 - i) {\n                result = result.take(max + 1).reverse ++ result.drop(max + 1)\n                result = result.take(result.length - i).reverse ++ result.drop(result.length - i)\n            }\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = (0, nums(0))\n            for (i <- 1 until nums.length) {\n                if (nums(i) > max._2) {\n                    max = (i, nums(i))\n                }\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val (i, _) = findMax(nums)\n                val nums2 = flip(nums, i + 1)\n                val nums3 = flip(nums2, k)\n                sort(nums3, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            val flip = current.take(index + 1).reverse\n            current = flip ::: current.drop(index + 1)\n            result = (index + 1) :: result\n            val flip2 = current.take(i + 1).reverse\n            current = flip2 ::: current.drop(i + 1)\n            result = (i + 1) :: result\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            var index = 0\n            for (i <- 0 until k) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            index\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val index = findMax(nums, k)\n                val flipped = flip(nums, index + 1)\n                val flipped2 = flip(flipped, k)\n                sort(flipped2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = result.slice(0, i + 1).max\n            val maxIndex = result.indexOf(max)\n            result = result.slice(0, maxIndex).reverse ++ result.slice(maxIndex, i + 1)\n            result = result.slice(0, i + 1).reverse ++ result.slice(i + 1, result.length)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val n = nums.length\n        var result = List[Long]()\n        var nums2 = nums\n        for (i <- 0 until n) {\n            val maxIndex = nums2.indexOf(nums2.max)\n            if (maxIndex != 0) {\n                result = (maxIndex + 1) :: result\n                nums2 = nums2.take(maxIndex + 1).reverse ::: nums2.drop(maxIndex + 1)\n            }\n            result = (n - i) :: result\n            nums2 = nums2.take(n - i).reverse ::: nums2.drop(n - i)\n        }\n        result",
    "        def swap(nums : List[Long], i : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(i)\n            b.reverse ::: a\n        }\n        def sort(nums : List[Long], i : Int) : List[Long] = {\n            if (i == nums.length) nums\n            else {\n                val max = nums.indexOf(nums.max)\n                val nums2 = swap(nums, max + 1)\n                val nums3 = swap(nums2, i + 1)\n                sort(nums3, i + 1)\n            }\n        }\n        sort(nums, 0)",
    "        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.isEmpty) result\n            else {\n                val maxIndex = nums.indexOf(nums.max)\n                val max = nums(maxIndex)\n                val (left, right) = nums.splitAt(maxIndex + 1)\n                val newNums = (right.reverse ::: left.reverse).reverse.tail\n                sort(newNums, max :: result)\n            }\n        }\n        sort(nums, Nil)",
    "        def reverse(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.take(k).max\n                val maxIndex = nums.take(k).indexOf(max)\n                val nums1 = reverse(nums, maxIndex + 1)\n                val nums2 = reverse(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        var sorted = false\n        while (!sorted) {\n            var max = nums.max\n            var index = nums.indexOf(max)\n            result = max :: result\n            nums = nums.take(index).reverse ::: nums.drop(index + 1)\n            result = nums.length.toLong :: result\n            nums = nums.reverse\n            sorted = nums.sorted == nums\n        }\n        result",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1).toLong\n                result += (i + 1).toLong\n            }\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        def pancakeSort(nums : List[Long], acc : List[Long]) : List[Long] = {\n            if (nums.isEmpty) acc\n            else {\n                val max = nums.max\n                val maxIndex = nums.indexOf(max)\n                val (first, second) = nums.splitAt(maxIndex + 1)\n                pancakeSort(second.tail.reverse ::: first.reverse, max :: acc)\n            }\n        }\n        pancakeSort(nums, Nil)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        if (nums.length == 0) return List[Long]()\n        val maxIndex = nums.zipWithIndex.maxBy(_._1)._2\n        val max = nums(maxIndex)\n        val (first, second) = nums.splitAt(maxIndex + 1)\n        pancakeSort(second.tail) ::: List(second.length.toLong, first.length.toLong)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != 0) {\n                result += index + 1\n                nums.take(index + 1).reverse.foreach(x => result += x)\n            }\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(i))\n            if (index == i) {\n                current = current.slice(i + 1, n) ::: current.slice(0, i + 1)\n                result = (n - i) :: result\n            }\n            else {\n                current = current.slice(index + 1, n) ::: current.slice(0, index + 1)\n                result = (n - index) :: result\n                current = current.slice(i + 1, n) ::: current.slice(0, i + 1)\n                result = (n - i) :: result\n            }\n        }\n        result",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 1 by -1) {\n            val max = nums.slice(0, i + 1).max\n            val maxIndex = nums.slice(0, i + 1).indexOf(max)\n            if (maxIndex != i) {\n                result += maxIndex + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val n = nums.length\n        var result = List[Long]()\n        for (i <- n - 1 to 1 by -1) {\n            val max = nums.indexOf(nums.max)\n            if (max != i) {\n                result = result :+ (max + 1).toLong\n                result = result :+ (i + 1).toLong\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val index = list.indexOf(sorted(i))\n            result = (index + 1) :: result\n            list = list.take(index).reverse ::: list.drop(index)\n            result = (i + 1) :: result\n            list = list.take(i + 1).reverse ::: list.drop(i + 1)\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = nums.head\n            var index = 0\n            for (i <- 1 until k) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            index\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val index = findMax(nums, k)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def pancakeSort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.isEmpty) result\n            else {\n                val max = nums.max\n                val maxIndex = nums.indexOf(max)\n                val (first, second) = nums.splitAt(maxIndex + 1)\n                pancakeSort(second.reverse.tail, max :: result)\n            }\n        }\n        pancakeSort(nums, List())",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        var nums2 = nums\n        for (i <- n - 1 to 1 by -1) {\n            val max = nums2.indexOf(nums2.max)\n            if (max != i) {\n                if (max != 0) {\n                    result += (max + 1)\n                    nums2 = nums2.take(max + 1).reverse ++ nums2.drop(max + 1)\n                }\n                result += (i + 1)\n                nums2 = nums2.take(i + 1).reverse ++ nums2.drop(i + 1)\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != i) {\n                result = result :+ (index + 1)\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = result :+ (i + 1)\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        nums.sortWith(_ > _)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = (i + 1) :: result\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        if (nums.length == 1) return nums\n        var max = nums.max\n        var index = nums.indexOf(max)\n        var result = List[Long]()\n        result = result :+ max\n        var nums2 = nums.take(index).reverse ::: nums.drop(index + 1)\n        result = result ::: pancakeSort(nums2)\n        return result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length).toLong\n            current = current.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                if (index != 0) {\n                    result += (index + 1).toLong\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                }\n                result += (i + 1).toLong\n                nums.take(i + 1).reverse.foreach(println)\n                nums.take(i + 1).reverse.foreach(println)\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += (maxIndex + 1)\n            result += (current.length)\n            current = current.take(maxIndex).reverse ++ current.drop(maxIndex + 1)\n            current = current.take(current.length - 1).reverse\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        nums.sortWith(_ > _)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            }\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val maxIndex = nums.indexOf(nums.max)\n                val nums1 = flip(nums, maxIndex + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = maxIndex + 1 :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = current.length :: result\n            current = current.reverse\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            result = result :+ (current.length)\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += (maxIndex + 1).toLong\n            result += (current.length).toLong\n            current = current.take(maxIndex).reverse ++ current.drop(maxIndex + 1)\n            current = current.take(current.length - 1).reverse ++ current.drop(current.length - 1)\n        }\n        result.toList",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = result.indexOf(result.max)\n            result = result.take(maxIndex + 1).reverse ::: result.drop(maxIndex + 1)\n            result = result.take(i + 1).reverse ::: result.drop(i + 1)\n        }\n        result",
    "        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = result.slice(0, i + 1).max\n            val maxIndex = result.indexOf(max)\n            if (maxIndex != i) {\n                result = result.slice(0, maxIndex + 1).reverse ++ result.slice(maxIndex + 1, i + 1)\n                result = result.slice(0, i + 1).reverse ++ result.slice(i + 1, result.length)\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = HashMap[Long, Int]()\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = (i + 1) :: result\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums2 = flip(nums, max + 1)\n                val nums3 = flip(nums2, k)\n                sort(nums3, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = result.indexOf(result.max)\n            result = result.take(maxIndex + 1).reverse ++ result.drop(maxIndex + 1)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (list.length - i)\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            list = list.take(list.length - i).reverse ::: list.drop(list.length - i)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            val max = nums.max\n            val index = nums.indexOf(max)\n            (index, max)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 1) result\n            else {\n                val (index, max) = findMax(nums)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, result :+ nums2.length)\n            }\n        }\n        sort(nums, Nil)",
    "        val sorted = nums.sorted\n        val n = nums.length\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val n = nums.length\n        var result = List[Long]()\n        var nums1 = nums\n        for (i <- 1 to n) {\n            val max = nums1.max\n            val index = nums1.indexOf(max)\n            result = (index + 1) :: result\n            result = (n - i + 1) :: result\n            nums1 = nums1.take(index).reverse ::: nums1.drop(index + 1)\n            nums1 = nums1.take(n - i).reverse ::: nums1.drop(n - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- nums.length to 1 by -1) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1)\n            result += i\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.take(i).reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = result :+ (current.length - i)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- nums.length - 1 to 0 by -1) {\n            val maxIndex = nums2.indexOf(nums2.max)\n            if (maxIndex != i) {\n                result = result :+ (maxIndex + 1).toLong\n                nums2 = nums2.take(maxIndex + 1).reverse ::: nums2.drop(maxIndex + 1)\n                result = result :+ (i + 1).toLong\n                nums2 = nums2.take(i + 1).reverse ::: nums2.drop(i + 1)\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            result += (index + 1)\n            result += (i + 1)\n            nums.slice(0, index + 1).reverse.foreach(println)\n            nums.slice(index + 1, nums.length).foreach(println)\n            nums.slice(0, index + 1).reverse.foreach(println)\n            nums.slice(index + 1, nums.length).foreach(println)\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n                result = (i + 1) :: result\n                current = current.take(i + 1).reverse ++ current.drop(i + 1)\n            }\n        }\n        result",
    "        val n = nums.length\n        var result = nums\n        for (i <- 0 until n) {\n            val max = result.zipWithIndex.maxBy(_._1)\n            result = max._2 :: result.take(max._2).reverse ::: result.drop(max._2 + 1)\n            result = result.take(n - i).reverse ::: result.drop(n - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length).toLong\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var index = 0\n            var max = nums(0)\n            for (i <- 1 until k) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            index\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val index = findMax(nums, k)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = result :+ maxIndex.toLong + 1\n            result = result :+ (nums2.length - maxIndex).toLong\n            nums2 = nums2.take(maxIndex).reverse ::: nums2.drop(maxIndex + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 to k) if (nums(i) > nums(max)) max = i\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = findMax(result, i + 1)\n            if (max != i) {\n                result = flip(result, max + 1)\n                result = flip(result, i + 1)\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length)\n            current = current.reverse\n        }\n        result",
    "        val n = nums.size\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(n - i - 1))\n            if (index != n - i - 1) {\n                result = (n - index) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = (n - i) :: result\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        if (nums.length == 0) return List()\n        var max = nums.max\n        var index = nums.indexOf(max)\n        var result = List(index + 1, nums.length)\n        pancakeSort(nums.slice(0, index).reverse ++ nums.slice(index + 1, nums.length).reverse)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def pancakeSort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.take(k).max\n                val maxIndex = nums.take(k).indexOf(max)\n                val nums1 = flip(nums, maxIndex + 1)\n                val nums2 = flip(nums1, k)\n                pancakeSort(nums2, k - 1)\n            }\n        }\n        pancakeSort(nums, nums.length)",
    "        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val max = list.max\n            val index = list.indexOf(max)\n            if (index != 0) {\n                result = result :+ (index + 1)\n                list = list.take(index).reverse ::: list.drop(index)\n            }\n            result = result :+ (list.length - i)\n            list = list.take(list.length - i - 1).reverse ::: list.drop(list.length - i - 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        var i = 0\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1)\n            result += (current.length)\n            current = current.take(index).reverse ++ current.drop(index)\n            current = current.take(current.length - 1).reverse ++ current.drop(current.length - 1)\n        }\n        result.toList",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = max :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            result = current.length.toLong :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val n = nums.length\n        val result = new Array[Long](n)\n        var i = 0\n        for (num <- nums) {\n            result(n - i - 1) = num\n            i += 1\n        }\n        result.toList",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- 0 until nums.length) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums.length - i)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.take(nums.length - i).reverse ::: nums2.drop(nums.length - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += maxIndex + 1\n            result += max\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- 0 until nums.length) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums.length - i)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = 0\n            var maxIndex = 0\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    maxIndex = i\n                }\n            }\n            (maxIndex, max)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val (maxIndex, max) = findMax(nums)\n                val nums1 = flip(nums, maxIndex + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, max :: result)\n            }\n        }\n        sort(nums, List())",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length)\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.reverse\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- nums.length - 1 to 0 by -1) {\n            val maxIndex = nums.indexOf(nums.max)\n            if (maxIndex != i) {\n                result = result :+ (maxIndex + 1).toLong\n                result = result :+ (i + 1).toLong\n                val newNums = nums.take(maxIndex + 1).reverse ::: nums.drop(maxIndex + 1)\n                result = result ::: pancakeSort(newNums.take(i + 1).reverse ::: newNums.drop(i + 1))\n            }\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (left, right) = nums.splitAt(k)\n            right.reverse ::: left\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                val flipped2 = flip(flipped, k)\n                sort(flipped2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        var nums2 = nums\n        for (i <- n - 1 to 1 by -1) {\n            val maxIndex = nums2.indexOf(nums2.max)\n            if (maxIndex != i) {\n                if (maxIndex != 0) {\n                    result += maxIndex + 1\n                    nums2 = nums2.take(maxIndex + 1).reverse ++ nums2.drop(maxIndex + 1)\n                }\n                result += i + 1\n                nums2 = nums2.take(i + 1).reverse ++ nums2.drop(i + 1)\n            }\n        }\n        result.toList",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = max :: result\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            result = nums2.length.toLong :: result\n            nums2 = nums2.reverse\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1)\n            current = current.take(index).reverse ++ current.drop(index)\n            result += (current.length)\n            current = current.reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i).toLong\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            val flipped = current.take(maxIndex + 1).reverse ++ current.drop(maxIndex + 1)\n            result = maxIndex + 1 :: result\n            current = flipped.reverse ++ flipped.drop(1)\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : (Int, Long) = {\n            var max = (0, nums(0))\n            for (i <- 1 until k) {\n                if (nums(i) > max._2) max = (i, nums(i))\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max._1 + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = nums.zipWithIndex.toMap\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 0 by -1) {\n            val index = map(sorted(i))\n            if (index != i) {\n                if (index != 0) {\n                    result += index + 1\n                    val newNums = nums.take(index + 1).reverse ++ nums.drop(index + 1)\n                    val newMap = newNums.zipWithIndex.toMap\n                    nums.clear\n                    nums ++= newNums\n                    map.clear\n                    map ++= newMap\n                }\n                result += i + 1\n                val newNums = nums.take(i + 1).reverse ++ nums.drop(i + 1)\n                val newMap = newNums.zipWithIndex.toMap\n                nums.clear\n                nums ++= newNums\n                map.clear\n                map ++= newMap\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            val max = nums.max\n            (nums.indexOf(max), max)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 1) result\n            else {\n                val (index, max) = findMax(nums)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, nums2.head :: result)\n            }\n        }\n        sort(nums, List())",
    "        var result = List[Long]()\n        for (i <- nums.length - 1 to 0 by -1) {\n            val maxIndex = nums.indexOf(nums.max)\n            val maxValue = nums(maxIndex)\n            if (maxIndex != i) {\n                result = maxIndex + 1 :: result\n                result = i + 1 :: result\n            }\n            nums.patch(0, List(maxValue), maxIndex + 1)\n        }\n        result",
    "        val n = nums.length\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            val maxIndex = nums.indexOf(nums.max)\n            val maxValue = nums(maxIndex)\n            result = result :+ maxValue\n            nums.slice(0, maxIndex + 1).reverse\n            nums.slice(maxIndex + 1, n).reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        val n = nums.length\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i).reverse ++ current.drop(current.length - i)\n        }\n        result",
    "        if (nums.length == 0) return List()\n        var max = nums.max\n        var maxIndex = nums.indexOf(max)\n        var newNums = nums.take(maxIndex + 1).reverse ++ nums.drop(maxIndex + 1)\n        return pancakeSort(newNums.drop(1)) :+ max",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = Long.MinValue\n            var index = -1\n            for (i <- 0 until k) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            index\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val index = findMax(nums, k)\n                val flipped = flip(nums, index + 1)\n                sort(flip(flipped, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        if (nums.length == 1) return nums\n        var max = nums.max\n        var index = nums.indexOf(max)\n        var result = List[Long]()\n        result = result :+ max\n        var newNums = nums.slice(0, index).reverse ::: nums.slice(index + 1, nums.length)\n        result = result ::: pancakeSort(newNums)\n        return result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                if (index != 0) {\n                    result = index + 1 :: result\n                    nums.take(index + 1).reverse.foreach(x => nums.remove(nums.indexOf(x)))\n                    nums.insert(0, sorted(i))\n                }\n                result = i + 1 :: result\n                nums.take(i + 1).reverse.foreach(x => nums.remove(nums.indexOf(x)))\n                nums.insert(0, sorted(i))\n            }\n        }\n        result",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val max = result.max\n            val index = result.indexOf(max)\n            result = result.take(index).reverse ++ result.drop(index)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        var result = List[Long]()\n        var list = nums\n        var max = nums.max\n        while (list.length > 0) {\n            var index = list.indexOf(max)\n            list = list.take(index).reverse ::: list.drop(index)\n            result = max :: result\n            list = list.tail\n            max = list.max\n        }\n        result",
    "        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = result.slice(0, i + 1).max\n            val maxIndex = result.indexOf(max)\n            result = result.slice(0, maxIndex).reverse ++ result.slice(maxIndex, i + 1)\n            result = result.slice(0, i + 1).reverse ++ result.slice(i + 1, result.length)\n        }\n        result",
    "        var result = nums\n        for (i <- nums.length - 1 to 0 by -1) {\n            val max = result.max\n            val maxIndex = result.indexOf(max)\n            result = result.take(maxIndex).reverse ++ result.drop(maxIndex)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            val reversed = current.take(index + 1).reverse\n            result = result :+ (index + 1).toLong\n            current = reversed ::: current.drop(index + 1)\n            val reversed2 = current.take(i + 1).reverse\n            result = result :+ (i + 1).toLong\n            current = reversed2 ::: current.drop(i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n to 1 by -1) {\n            val maxIndex = nums.indexOf(nums.max)\n            if (maxIndex != i - 1) {\n                if (maxIndex != 0) {\n                    result += maxIndex + 1\n                    nums.take(maxIndex + 1).reverse.foreach(println)\n                }\n                result += i\n                nums.take(i).reverse.foreach(println)\n            }\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = Long.MinValue\n            var index = -1\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            (index, max)\n        }\n        def helper(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 1) result\n            else {\n                val (index, max) = findMax(nums)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, nums1.length)\n                helper(nums2.tail, nums2.length :: result)\n            }\n        }\n        helper(nums, Nil)",
    "        if (nums.length == 1) return nums\n        var max = nums.max\n        var index = nums.indexOf(max)\n        var result = List[Long]()\n        result = result :+ max\n        var left = nums.slice(0, index)\n        var right = nums.slice(index + 1, nums.length)\n        result = result ::: pancakeSort(left.reverse ::: right)\n        return result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                sort(flip(flipped, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1)\n            current = current.take(index).reverse ++ current.drop(index)\n            result += (current.length)\n            current = current.reverse\n        }\n        result.toList",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- 0 until nums.length) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1) :+ (nums.length - i)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.take(nums.length - i).reverse ::: nums2.drop(nums.length - i)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ++ nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = nums(0)\n            var maxIndex = 0\n            for (i <- 1 until k) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    maxIndex = i\n                }\n            }\n            maxIndex\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val maxIndex = findMax(nums, k)\n                val nums1 = flip(nums, maxIndex + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        if (nums.length == 0) return nums\n        val max = nums.max\n        val index = nums.indexOf(max)\n        val first = nums.take(index + 1).reverse\n        val second = nums.drop(index + 1)\n        pancakeSort(first ::: second.reverse)",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != n - i - 1) {\n                result += (index + 1).toLong\n                result += (n - i).toLong\n            }\n        }\n        result.toList",
    "        var result = List[Long]()\n        var current = nums\n        while (current.size > 0) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = result :+ maxIndex.toLong + 1\n            result = result :+ (current.size).toLong\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.reverse\n        }\n        result.reverse",
    "        def reverse(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def helper(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.isEmpty) result\n            else {\n                val max = nums.max\n                val index = nums.indexOf(max)\n                val newNums = reverse(nums, index + 1)\n                val newNums2 = reverse(newNums, newNums.length)\n                helper(newNums2.tail, result :+ max)\n            }\n        }\n        helper(nums, Nil)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length).toLong\n            current = current.reverse\n        }\n        result",
    "        val n = nums.length\n        val result = new Array[Long](n)\n        for (i <- 0 until n) {\n            var max = 0\n            for (j <- 0 until n - i) {\n                if (nums(j) > nums(max)) max = j\n            }\n            result(i) = max + 1\n            for (j <- 0 to max / 2) {\n                val temp = nums(j)\n                nums(j) = nums(max - j)\n                nums(max - j) = temp\n            }\n            for (j <- 0 to (n - i - 1) / 2) {\n                val temp = nums(j)\n                nums(j) = nums(n - i - 1 - j)\n                nums(n - i - 1 - j) = temp\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length - i) :: result\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (list.length - i)\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            list = list.take(list.length - i).reverse ::: list.drop(list.length - i)\n        }\n        result",
    "        if (nums.length == 1) nums\n        else {\n            val max = nums.max\n            val maxIndex = nums.indexOf(max)\n            val firstPart = nums.take(maxIndex + 1).reverse\n            val secondPart = nums.drop(maxIndex + 1)\n            pancakeSort(firstPart ++ secondPart)\n        }",
    "        def sort(nums : List[Long]) : List[Long] = {\n            if (nums.length == 1) nums\n            else {\n                val max = nums.max\n                val maxIndex = nums.indexOf(max)\n                val (first, second) = nums.splitAt(maxIndex + 1)\n                val reversedFirst = first.reverse\n                val reversedSecond = second.reverse\n                val reversed = reversedFirst ::: reversedSecond\n                val (first2, second2) = reversed.splitAt(reversed.length - 1)\n                val reversedFirst2 = first2.reverse\n                val reversedSecond2 = second2.reverse\n                val reversed2 = reversedFirst2 ::: reversedSecond2\n                sort(reversed2.tail)\n            }\n        }\n        sort(nums)",
    "        var result = List[Long]()\n        var nums1 = nums\n        while (nums1.length > 0) {\n            val max = nums1.max\n            val maxIndex = nums1.indexOf(max)\n            result = max :: result\n            nums1 = nums1.take(maxIndex).reverse ::: nums1.drop(maxIndex + 1)\n            result = (nums1.length) :: result\n            nums1 = nums1.reverse\n        }\n        result.reverse",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = Map[Long, Int]()\n        for (i <- 0 until n) {\n            map(sorted(i)) = i\n        }\n        val result = ListBuffer[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(0))\n            if (index != 0) {\n                result += (index + 1)\n                current = current.slice(0, index + 1).reverse ++ current.slice(index + 1, n)\n            }\n            result += (n - i)\n            current = current.slice(0, n - i).reverse ++ current.slice(n - i, n)\n        }\n        result.toList",
    "        var result = nums\n        var i = 0\n        while (i < nums.length) {\n            var max = 0\n            var maxIndex = 0\n            for (j <- 0 to nums.length - i - 1) {\n                if (result(j) > max) {\n                    max = result(j)\n                    maxIndex = j\n                }\n            }\n            result = result.take(maxIndex).reverse ++ result.drop(maxIndex)\n            result = result.take(nums.length - i).reverse ++ result.drop(nums.length - i)\n            i += 1\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                result = result :+ (i + 1).toLong\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length - i)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until sorted.length) map += (sorted(i) -> i)\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = map(nums(i))\n            if (index != i) {\n                if (index != 0) {\n                    result = (index + 1) :: result\n                    nums.slice(0, index + 1).reverse\n                }\n                result = (i + 1) :: result\n                nums.slice(0, i + 1).reverse\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index == i) {\n                result = result :+ 1\n            } else {\n                result = result :+ (index + 1) :+ (i + 1)\n            }\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            current = current.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        val result = new Array[Long](n)\n        for (i <- 0 until n) result(i) = nums(i)\n        var count = 0\n        for (i <- 0 until n) {\n            val j = map(result(i))\n            if (j != i) {\n                count += 1\n                flip(result, j)\n                flip(result, i)\n            }\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) if (nums(i) > nums(max)) max = i\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                val flipped2 = flip(flipped, k)\n                sort(flipped2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val max = nums.max\n                val maxIndex = nums.indexOf(max)\n                val newNums = nums.take(maxIndex).reverse ::: nums.drop(maxIndex)\n                val newResult = result ::: List(maxIndex + 1)\n                sort(newNums.drop(1), newResult)\n            }\n        }\n        sort(nums, List())",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map += (sorted(i) -> i)\n        val result = new ArrayBuffer[Long]\n        for (i <- 0 until n) {\n            val x = nums(i)\n            val j = map(x)\n            if (j == i) continue\n            if (j != 0) {\n                result += (j + 1)\n                nums.slice(0, j + 1).reverse.copyToArray(nums, 0)\n            }\n            result += (i + 1)\n            nums.slice(0, i + 1).reverse.copyToArray(nums, 0)\n        }\n        result.toList",
    "        if (nums.length == 1) return nums\n        var maxIndex = 0\n        for (i <- 1 until nums.length) if (nums(i) > nums(maxIndex)) maxIndex = i\n        var result = List[Long]()\n        if (maxIndex != nums.length - 1) {\n            result = pancakeSort(nums.take(maxIndex + 1).reverse) ++ pancakeSort(nums.drop(maxIndex + 1))\n        } else {\n            result = pancakeSort(nums.dropRight(1)) ++ List(nums.last)\n        }\n        result",
    "        // First, find the largest element in the list.\n        val max = nums.max\n        // Then, find the index of that element.\n        val index = nums.indexOf(max)\n        // Then, flip the list up to that index.\n        val flipped = nums.take(index + 1).reverse ++ nums.drop(index + 1)\n        // Then, flip the entire list.\n        val sorted = flipped.reverse\n        // Then, recurse.\n        if (sorted == nums) sorted\n        else pancakeSort(sorted.dropRight(1)) :+ sorted.last",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1).toLong\n            result += (current.length).toLong\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.take(current.length - 1).reverse ++ current.drop(current.length - 1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = maxIndex + 1 :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = current.size :: result\n            current = current.reverse\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- nums.length - 1 to 0 by -1) {\n            val max = nums.indexOf(nums.max)\n            if (max != i) {\n                result = result :+ (max + 1).toLong\n                result = result :+ (i + 1).toLong\n            }\n            nums.take(max + 1).reverse ++ nums.drop(max + 1)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            result = result :+ (current.length).toLong\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != 0) {\n                result = (index + 1) :: result\n                nums.take(index + 1).reverse.foreach(x => nums.remove(nums.indexOf(x)))\n                nums.insert(0, sorted(i))\n            }\n        }\n        result",
    "        var result = nums\n        for (i <- 0 until result.length) {\n            var maxIndex = 0\n            for (j <- 0 to i) {\n                if (result(j) > result(maxIndex)) maxIndex = j\n            }\n            result = result.take(maxIndex).reverse ::: result.drop(maxIndex)\n            result = result.take(i + 1).reverse ::: result.drop(i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.indices) {\n            val index = current.indexOf(sorted(i))\n            val (first, second) = current.splitAt(index + 1)\n            current = second.reverse ::: first\n            result = (index + 1) :: result\n            result = (i + 1) :: result\n        }\n        result.reverse",
    "        var result = List[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1).toLong\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            result = result :+ (list.length).toLong\n            list = list.reverse\n        }\n        result",
    "        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = result.slice(0, i + 1).max\n            val maxIndex = result.indexOf(max)\n            result = result.slice(0, maxIndex).reverse ::: result.slice(maxIndex, i + 1)\n            result = result.slice(0, i + 1).reverse ::: result.slice(i + 1, result.length)\n        }\n        result",
    "        var result = List[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = max :: result\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            result = list.head :: result\n            list = list.tail\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = max :: result\n            nums2 = nums2.slice(0, maxIndex).reverse ::: nums2.slice(maxIndex + 1, nums2.length)\n            result = nums2.length.toLong :: result\n            nums2 = nums2.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = (index + 1) :: result\n                current = current.slice(0, index + 1).reverse ::: current.slice(index + 1, n)\n            }\n            result = (n - i) :: result\n            current = current.slice(0, n - i).reverse ::: current.slice(n - i, n)\n        }\n        result.reverse",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val (left, right) = current.splitAt(current.indexOf(sorted(i)) + 1)\n            result = (left.length) :: result\n            current = left.reverse ::: right\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        def reverse(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b ::: a\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.take(k).zipWithIndex.maxBy(_._1)._2\n                val nums1 = reverse(nums, max + 1)\n                val nums2 = reverse(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = HashMap[Long, Int]()\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val x = current(i)\n            val index = map(x)\n            if (index != i) {\n                if (index != 0) {\n                    result = index + 1 :: result\n                    current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                }\n                result = i + 1 :: result\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1).toLong\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            result = result :+ (nums2.length).toLong\n            nums2 = nums2.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ++ nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : (Int, Long) = {\n            var max = (0, nums(0))\n            for (i <- 1 until k) {\n                if (nums(i) > max._2) max = (i, nums(i))\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max._1 + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val sortedIndex = nums.map(x => sorted.indexOf(x))\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = sortedIndex.indexOf(i)\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 1 to n) {\n            val index = current.indexOf(sorted(n - i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (n - i + 1) :: result\n            current = current.take(n - i + 1).reverse ::: current.drop(n - i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            if (nums(i) != sorted(i)) {\n                val index = nums.indexOf(sorted(i))\n                result = result :+ (index + 1).toLong\n                result = result :+ (i + 1).toLong\n            }\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- nums.length - 1 to 0 by -1) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1).toLong\n            result = result :+ (i + 1).toLong\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.take(i + 1).reverse ::: nums2.drop(i + 1)\n        }\n        result",
    "        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.isEmpty) result\n            else {\n                val max = nums.max\n                val index = nums.indexOf(max)\n                val (first, second) = nums.splitAt(index + 1)\n                sort(second.tail, max :: result)\n            }\n        }\n        sort(nums, Nil)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- nums.length - 1 to 0 by -1) {\n            val max = nums.slice(0, i + 1).max\n            val maxIndex = nums.slice(0, i + 1).indexOf(max)\n            result = result :+ (maxIndex + 1)\n            result = result :+ (i + 1)\n            nums.slice(0, maxIndex + 1).reverse\n            nums.slice(maxIndex + 1, i + 1).reverse\n            nums.slice(i + 1, nums.length).reverse\n        }\n        result",
    "        var result = nums\n        for (i <- nums.length - 1 to 0 by -1) {\n            val max = result.slice(0, i + 1).max\n            val maxIndex = result.indexOf(max)\n            if (maxIndex != i) {\n                result = result.slice(0, maxIndex + 1).reverse ::: result.slice(maxIndex + 1, result.length)\n                result = result.slice(0, i + 1).reverse ::: result.slice(i + 1, result.length)\n            }\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = max :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse"
  ]
}