{
  "name": "mbpp_141_pancake_sort",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a list of elements.\n    def pancakeSort(nums : List[Long]) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pancakeSort((List[Long](15l.toLong, 79l.toLong, 25l.toLong, 38l.toLong, 69l.toLong))).equals((List[Long](15l.toLong, 25l.toLong, 38l.toLong, 69l.toLong, 79l.toLong))));\n    assert(pancakeSort((List[Long](98l.toLong, 12l.toLong, 54l.toLong, 36l.toLong, 85l.toLong))).equals((List[Long](12l.toLong, 36l.toLong, 54l.toLong, 85l.toLong, 98l.toLong))));\n    assert(pancakeSort((List[Long](41l.toLong, 42l.toLong, 32l.toLong, 12l.toLong, 23l.toLong))).equals((List[Long](12l.toLong, 23l.toLong, 32l.toLong, 41l.toLong, 42l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) return nums\n            val max = findMax(nums, k)\n            val nums1 = flip(nums, max + 1)\n            val nums2 = flip(nums1, k)\n            sort(nums2, k - 1)\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 1 by -1) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1)\n            result += (current.length - i)\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.take(current.length - i).reverse ++ current.drop(current.length - i)\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 to k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            result += (index + 1).toLong\n            result += (n - i).toLong\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (left, right) = nums.splitAt(k)\n            right.reverse ::: left\n        }\n        def solve(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.max\n                val index = map(max)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, k)\n                solve(nums2, k - 1)\n            }\n        }\n        solve(nums, n)",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1).toLong\n            result += (current.length).toLong\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        if (nums.length == 1) return nums\n        val max = nums.max\n        val maxIndex = nums.indexOf(max)\n        val newNums = nums.take(maxIndex).reverse ::: nums.drop(maxIndex)\n        val newNums2 = newNums.take(newNums.length - 1).reverse ::: newNums.drop(newNums.length - 1)\n        return newNums2.head :: pancakeSort(newNums2.tail)",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length)\n            current = current.slice(0, index).reverse ::: current.slice(index + 1, current.length)\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                sort(flip(nums, max + 1), max)\n                sort(flip(nums, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        def swap(nums : List[Long], i : Int, j : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(i)\n            val (c, d) = b.splitAt(j - i + 1)\n            a ::: c.reverse ::: d\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.take(k).zipWithIndex.maxBy(_._1)\n                val nums1 = swap(nums, max._2, k - 1)\n                val nums2 = swap(nums1, 0, k - 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(n - i - 1))\n            if (index != n - i - 1) {\n                result = (n - index) :: result\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val result = ListBuffer[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1).toLong\n                result += (i + 1).toLong\n            }\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val max = result.max\n            val index = result.indexOf(max)\n            if (index != 0) {\n                result = result.take(index + 1).reverse ++ result.drop(index + 1)\n            }\n            result = result.take(nums.length - i).reverse ++ result.drop(nums.length - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ index.toLong\n                result = result :+ (nums.length - i).toLong\n            }\n            nums.slice(0, index + 1).reverse ++ nums.slice(index + 1, nums.length)\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += index + 1\n            result += current.length\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result"
  ]
}