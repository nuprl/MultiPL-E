{
  "name": "mbpp_272_rear_extract",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    def rearExtract(test_list : List[Either[String, Long]]) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(rearExtract((List[Either[String, Long]]((1l, \"Rash\", 21l), (2l, \"Varsha\", 20l), (3l, \"Kil\", 19l)))).equals((List[Long](21l.toLong, 20l.toLong, 19l.toLong))));\n    assert(rearExtract((List[Either[String, Long]]((1l, \"Sai\", 36l), (2l, \"Ayesha\", 25l), (3l, \"Salman\", 45l)))).equals((List[Long](36l.toLong, 25l.toLong, 45l.toLong))));\n    assert(rearExtract((List[Either[String, Long]]((1l, \"Sudeep\", 14l), (2l, \"Vandana\", 36l), (3l, \"Dawood\", 56l)))).equals((List[Long](14l.toLong, 36l.toLong, 56l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        test_list.map(x => x.right.getOrElse(0))",
    "        var result = List[Long]()\n        for (tuple <- test_list) {\n            tuple match {\n                case Left(x) => result = result :+ x.toLong\n                case Right(x) => result = result :+ x\n            }\n        }\n        return result",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x match {\n            case Right(x) => x\n            case Left(x) => -1\n        })",
    "        test_list.map(x => x.right.get)",
    "        var result = List[Long]()\n        for (i <- test_list) {\n            i match {\n                case Left(s) => result = result :+ 0\n                case Right(l) => result = result :+ l\n            }\n        }\n        return result",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x match {\n            case Left(s) => 0\n            case Right(l) => l\n        })",
    "        test_list.map(x => x.right.getOrElse(0))",
    "        test_list.map(x => x.right.getOrElse(0L))",
    "        test_list.map(x => x.right.getOrElse(0))",
    "        test_list.filter(_.isRight).map(_.right.get)",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x match {\n            case Right(y) => y\n            case Left(y) => 0\n        })",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x.right.get)"
  ]
}