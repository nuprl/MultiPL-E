{
  "name": "mbpp_123_amicable_numbers_sum",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sum all amicable numbers from 1 to a specified number.\n    def amicableNumbersSum(limit : Long) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(amicableNumbersSum((999l)) == (504l));\n    assert(amicableNumbersSum((9999l)) == (31626l));\n    assert(amicableNumbersSum((99l)) == (0l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var sum = 0L\n        for (i <- 1L to limit) {\n            val a = sumOfDivisors(i)\n            if (a != i && sumOfDivisors(a) == i) sum += i\n        }\n        sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- 2 * i to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val j = divisors(i)\n            if (j <= limit.toInt && i == divisors(j) && i != j) {\n                sum += i\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val a = sumOfDivisors(i)\n            if (a != i && sumOfDivisors(a) == i) sum += i\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val d = divisors(i).sum\n            if (d != i && divisors(d).sum == i) sum += i\n        }\n        sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            if (divisors(i) > i && divisors(i) <= limit.toInt && divisors(divisors(i)) == i) {\n                sum += divisors(i) + i\n            }\n        }\n        sum",
    "        val divisors = new Array[Long](limit.toInt + 1)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val j = divisors(i)\n            if (j <= limit.toInt && divisors(j) == i && i != j) sum += i\n        }\n        sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            if (divisors(i) < limit.toInt && divisors(divisors(i)) == i && i != divisors(i)) {\n                sum += i\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val sumOfDivisors = divisors(i).sum\n            if (sumOfDivisors != i && divisors(sumOfDivisors).sum == i) {\n                sum += i\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val divisors = divisors(i)\n            val divisorsSum = divisors.sum\n            if (i != divisorsSum) {\n                val divisorsSumDivisors = divisors(divisorsSum.toInt)\n                if (divisorsSumDivisors.sum == i) {\n                    sum += i\n                    sum += divisorsSum\n                }\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 1L to limit) {\n            val a = sumOfDivisors(i)\n            if (a != i && sumOfDivisors(a) == i) sum += i\n        }\n        sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val j = divisors(i)\n            if (j <= limit.toInt && j != i && divisors(j) == i) {\n                sum += i\n            }\n        }\n        sum",
    "        val d = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                d(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            if (d(i) != i && d(i) <= limit.toInt && d(d(i)) == i) {\n                sum += i\n            }\n        }\n        sum",
    "        val factors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                factors(j) += i\n            }\n        }\n        (1 to limit.toInt).filter(i => factors(i) != i && factors(factors(i)) == i).sum",
    "        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val a = sumOfDivisors(i)\n            if (a != i && sumOfDivisors(a) == i) sum += i\n        }\n        sum",
    "        val factors = Array.fill(limit.toInt + 1)(List[Int]())\n        for (i <- 1 to limit.toInt) {\n            for (j <- i to limit.toInt by i) {\n                factors(j) = i :: factors(j)\n            }\n        }\n        factors.map(x => x.sum).zipWithIndex.filter(x => x._1 < limit && x._1 != x._2 && factors(x._1).sum == x._2).map(x => x._2).sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val j = divisors(i)\n            if (j <= limit.toInt && divisors(j) == i && i != j) {\n                sum += i\n            }\n        }\n        sum",
    "        val primes = Prime.primes(limit.toInt)\n        val primeSet = primes.toSet\n        val primeFactorization = new PrimeFactorization(primes)\n        val divisors = new Array[Long](limit.toInt + 1)\n        for (i <- 1 to limit.toInt) {\n            divisors(i) = primeFactorization.divisors(i).sum\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            val j = divisors(i)\n            if (i != j && j <= limit.toInt && divisors(j) == i) {\n                sum += i\n            }\n        }\n        sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            if (divisors(i) > i && divisors(i) <= limit.toInt && divisors(divisors(i)) == i) {\n                sum += i\n            }\n        }\n        sum",
    "        val divisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i * 2 to limit.toInt by i) {\n                divisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            if (divisors(i) > i && divisors(i) <= limit.toInt && divisors(divisors(i)) == i) {\n                sum += i + divisors(i)\n            }\n        }\n        sum",
    "        val sumOfDivisors = Array.fill(limit.toInt + 1)(0)\n        for (i <- 1 to limit.toInt) {\n            for (j <- i to limit.toInt by i) {\n                sumOfDivisors(j) += i\n            }\n        }\n        var sum = 0L\n        for (i <- 1 to limit.toInt) {\n            if (sumOfDivisors(i) <= limit.toInt && sumOfDivisors(i) != i && sumOfDivisors(sumOfDivisors(i)) == i) {\n                sum += i\n            }\n        }\n        sum"
  ]
}