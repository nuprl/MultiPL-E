{
  "name": "mbpp_633_pair_xor_Sum",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    def pairXorSum(arr : List[Long], n : Long) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pairXorSum((List[Long](5l.toLong, 9l.toLong, 7l.toLong, 6l.toLong)), (4l)) == (47l));\n    assert(pairXorSum((List[Long](7l.toLong, 3l.toLong, 5l.toLong)), (3l)) == (12l));\n    assert(pairXorSum((List[Long](7l.toLong, 3l.toLong)), (2l)) == (4l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val count = Array.fill(64)(0)\n        for (i <- 0 until n) {\n            var x = arr(i.toInt)\n            var j = 0\n            while (x > 0) {\n                count(j) += (x & 1)\n                j += 1\n                x >>= 1\n            }\n        }\n        var result : Long = 0\n        for (i <- 0 until 64) {\n            result += (count(i) * (n - count(i)) * pow(2, i).toLong)\n        }\n        result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 to n - 1) {\n            for (j <- i + 1 to n - 1) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        return sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val xors = arr.map(x => x ^ n)\n        xors.foldLeft(0L)(_ + _)",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val xor = Array.fill[Long](100000)(0)\n        for (i <- 0 until n.toInt) {\n            val a = arr(i).toInt\n            for (j <- 0 until 32) {\n                val b = (1 << j)\n                if ((a & b) != 0) xor(j) += 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 32) {\n            val x = xor(i)\n            ans += (x * (n - x) * 2)\n        }\n        ans",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 to n - 1) {\n            for (j <- i + 1 to n - 1) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (k <- m.keys) {\n            val v = m(k)\n            sum += k * (v * (v - 1) / 2)\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var result : Long = 0\n        for ((key, value) <- m) {\n            result += key * value * (value - 1) / 2\n        }\n        result",
    "        var result = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                result += (arr(i) ^ arr(j))\n            }\n        }\n        result",
    "        var sum = 0L\n        for (i <- 0L until n) {\n            for (j <- i + 1L until n) {\n                sum += (arr(i.toInt) ^ arr(j.toInt))\n            }\n        }\n        sum",
    "        val xor = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n            xor(i) = arr(i)\n            for (j <- 0 until i) {\n                xor(i) ^= arr(j)\n            }\n        }\n        xor.sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for (i <- m.keys) {\n            val c = m(i)\n            sum += (c * (c - 1) / 2) * i\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val map = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (map.contains(xor)) map(xor) += 1\n                else map(xor) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- map.keys) {\n            val count = map(x)\n            sum += (count * (count - 1) / 2) * x\n        }\n        sum",
    "        val m = arr.map(x => x.toInt).toArray\n        val c = Array.fill(100000)(0)\n        for (i <- 0 until n.toInt) {\n            c(m(i)) += 1\n        }\n        var ans = 0L\n        for (i <- 0 until 100000) {\n            ans += (c(i) * (c(i) - 1) / 2) * i\n        }\n        ans",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val xorSum = new Array[Long](n.toInt)\n        var i = 0\n        while (i < n) {\n            var j = 0\n            while (j < n) {\n                xorSum(i) += arr(i) ^ arr(j)\n                j += 1\n            }\n            i += 1\n        }\n        var sum = 0L\n        i = 0\n        while (i < n) {\n            sum += xorSum(i)\n            i += 1\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val c = m(x)\n            sum += x * c * (c - 1) / 2\n        }\n        sum",
    "        val map = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            if (map.contains(arr(i))) map(arr(i)) += 1\n            else map(arr(i)) = 1\n        }\n        var result = 0L\n        for (i <- 0 until n.toInt) {\n            val x = arr(i)\n            val y = x ^ 2\n            if (map.contains(y)) {\n                result += map(y)\n                if (x == y) result -= 1\n            }\n        }\n        result",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i+1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = arr.map(x => x % n).groupBy(x => x).map(x => (x._1, x._2.length)).toList\n        val s = m.map(x => (x._1, x._2 * (x._2 - 1) / 2)).map(x => x._1 * x._2).sum\n        val t = m.map(x => (x._1, x._2 * (x._2 - 1) * (x._2 - 2) / 6)).map(x => x._1 * x._2).sum\n        s + t",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val mod = 1000000007L\n        val count = new Array[Long](64)\n        for (i <- 0 until n.toInt) {\n            var x = arr(i)\n            var j = 0\n            while (x > 0) {\n                count(j) += x & 1\n                x >>= 1\n                j += 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans = (ans + ((count(i) * (n - count(i))) % mod * pow(2, i).toLong) % mod) % mod\n        }\n        ans",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val m = arr.map(x => x % n).groupBy(x => x).map(x => (x._1, x._2.length))\n        val sum = m.map(x => (x._2 * (x._2 - 1) / 2) % n).sum\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- arr) {\n            if (m.contains(i)) m(i) += 1\n            else m(i) = 1\n        }\n        var sum = 0L\n        for (i <- m.keys) {\n            val x = m(i)\n            sum += (x * (x - 1) / 2) * i\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n                if (i != j) {\n                    val x = arr(i) ^ arr(j)\n                    if (m.contains(x)) m(x) += 1\n                    else m(x) = 1\n                }\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += (v * (v - 1) / 2) * k\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val dp = Array.ofDim[Long](n.toInt + 1, n.toInt + 1)\n        for (i <- 0 to n.toInt) {\n            for (j <- 0 to n.toInt) {\n                if (i == 0) dp(i)(j) = arr(j)\n                else if (j == 0) dp(i)(j) = arr(i)\n                else dp(i)(j) = dp(i - 1)(j) ^ dp(i)(j - 1)\n            }\n        }\n        var sum = 0L\n        for (i <- 0 to n.toInt) {\n            for (j <- 0 to n.toInt) {\n                sum += dp(i)(j)\n            }\n        }\n        sum",
    "        val mod = 1000000007L\n        val count = Array.fill(64)(0L)\n        for (i <- 0 until n.toInt) {\n            var x = arr(i)\n            var j = 0\n            while (x > 0) {\n                count(j) += x & 1\n                x >>= 1\n                j += 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans = (ans + (count(i) * (n - count(i)) * 2 % mod) % mod) % mod\n        }\n        ans",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += (v * (v - 1) / 2) * k\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n                if (i != j) {\n                    val x = arr(i) ^ arr(j)\n                    if (m.contains(x)) m(x) += 1\n                    else m(x) = 1\n                }\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += k * v * (v - 1) / 2\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0L until n) {\n            for (j <- i + 1L until n) {\n                sum += (arr(i.toInt) ^ arr(j.toInt))\n            }\n        }\n        sum",
    "        var result = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                result += arr(i) ^ arr(j)\n            }\n        }\n        result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        return sum",
    "        val count = Array.fill(64)(0)\n        for (i <- 0 until n) {\n            var x = arr(i.toInt)\n            var j = 0\n            while (x > 0) {\n                count(j) += (x & 1)\n                j += 1\n                x >>= 1\n            }\n        }\n        var result = 0L\n        for (i <- 0 until 64) {\n            result += (count(i) * (n - count(i)) * pow(2, i).toLong)\n        }\n        result",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for ((x, c) <- m) {\n            sum += x * c * (c - 1) / 2\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        val sum = arr.foldLeft(0L)((acc, x) => acc + x)\n        val sumXor = arr.foldLeft(0L)((acc, x) => acc ^ x)\n        val xorSum = (sum * n) ^ sumXor\n        xorSum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]()\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            var x = arr(i)\n            for (j <- 0 until 32) {\n                val b = (x >> j) & 1\n                if (b == 1) {\n                    if (m.contains(j)) {\n                        sum += m(j)\n                    }\n                }\n                else {\n                    if (m.contains(j)) {\n                        sum += n - m(j)\n                    }\n                    else {\n                        sum += n\n                    }\n                }\n            }\n            for (j <- 0 until 32) {\n                val b = (x >> j) & 1\n                if (b == 1) {\n                    if (m.contains(j)) {\n                        m(j) += 1\n                    }\n                    else {\n                        m(j) = 1\n                    }\n                }\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var result : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                result += (arr(i) ^ arr(j))\n            }\n        }\n        return result",
    "        val m = arr.map(x => x % n).toSet\n        val s = m.size\n        val r = m.foldLeft(0L)((a, b) => a ^ b)\n        val t = (1L << (s - 1)) - 1\n        val u = (1L << s) - 1\n        val v = (1L << (s - 1))\n        val w = (1L << (s - 2))\n        val x = (1L << (s - 3))\n        val y = (1L << (s - 4))\n        val z = (1L << (s - 5))\n        val aa = (1L << (s - 6))\n        val bb = (1L << (s - 7))\n        val cc = (1L << (s - 8))\n        val dd = (1L << (s - 9))\n        val ee = (1L << (s - 10))\n        val ff = (1L << (s - 11))\n        val gg = (1L << (s - 12))\n        val hh = (1L << (s - 13))\n        val ii = (1L << (s - 14))\n        val jj = (1L << (s - 15))\n        val kk = (1L << (s - 16))\n        val ll = (1L << (s - 17))\n        val mm = (1L << (s - 18))\n        val nn = (1L << (s - 19))\n        val oo = (1L << (s - 20))\n        val pp = (1L << (s - 21))\n        val qq = (1L << (s - 22))\n        val rr = (1L << (s - 23))\n        val ss = (1L << (s - 24))\n        val tt = (1L << (s - 25))\n        val uu = (1L << (s - 26))\n        val vv = (1L << (s - 27))\n        val ww = (1L << (s - 28))\n        val xx = (1L << (s - 29))\n        val yy = (1L << (s - 30",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val c = m(x)\n            sum += (c * (c - 1) / 2) * x\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            val x = arr(i)\n            for (j <- 0 until n.toInt) {\n                val y = arr(j)\n                val z = x ^ y\n                if (m.contains(z)) m(z) += 1\n                else m(z) = 1\n            }\n        }\n        var result = 0L\n        for (i <- m.keys) {\n            val x = m(i)\n            result += i * x * (x - 1) / 2\n        }\n        result",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += (v * (v - 1) / 2) * k\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        // Write your code here\n        val xor = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n            xor(i) = arr(i)\n            for (j <- 0 until i) {\n                xor(i) = xor(i) ^ arr(j)\n            }\n        }\n        xor.sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        val m = arr.map(x => x % n).groupBy(x => x).mapValues(x => x.length).map(x => x._1 * (x._2 * (x._2 - 1) / 2)).sum\n        m % n",
    "        val count = Array.fill(64)(0)\n        for (i <- 0 until n) {\n            var j = 0\n            var num = arr(i.toInt)\n            while (num > 0) {\n                count(j) += (num & 1)\n                j += 1\n                num >>= 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans += ((count(i) * (n - count(i))) % 1000000007 * (1L << i)) % 1000000007\n            ans %= 1000000007\n        }\n        ans",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n                if (i != j) {\n                    val xor = arr(i) ^ arr(j)\n                    m(xor) = m.getOrElse(xor, 0) + 1\n                }\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += k * v * (v - 1) / 2\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val count = Array.fill(64)(0)\n        for (i <- 0 until n) {\n            var x = arr(i)\n            var j = 0\n            while (x > 0) {\n                count(j) += (x & 1)\n                x >>= 1\n                j += 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans += (count(i) * (n - count(i)) * pow(2, i).toLong)\n        }\n        ans",
    "        val m = new HashMap[Long, Long]\n        for (x <- arr) {\n            if (m.contains(x)) m(x) += 1\n            else m(x) = 1\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val y = x ^ n\n            if (m.contains(y)) {\n                sum += m(x) * m(y)\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += (k * v * (v - 1)) / 2\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val c = m(x)\n            sum += x * c * (c - 1) / 2\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val c = m(x)\n            sum += (c * (c - 1) / 2) * x\n        }\n        sum",
    "        val count = new Array[Long](64)\n        for (i <- 0 until n) {\n            var x = arr(i.toInt)\n            var j = 0\n            while (x > 0) {\n                count(j) += x & 1\n                x >>= 1\n                j += 1\n            }\n        }\n        var result = 0L\n        for (i <- 0 until 64) {\n            result += count(i) * (n - count(i)) * pow(2, i).toLong\n        }\n        result",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for ((xor, count) <- m) {\n            sum += xor * count * (count - 1) / 2\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val y = m(x)\n            sum += x * y * (y - 1) / 2\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var result = 0L\n        for ((k, v) <- m) {\n            result += k * v * (v - 1) / 2\n        }\n        result",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                m(arr(i) ^ arr(j)) = m.getOrElse(arr(i) ^ arr(j), 0) + 1\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += k * v * (v - 1) / 2\n        }\n        sum",
    "        val xorSum = new Array[Long](32)\n        for (i <- 0 until n) {\n            var x = arr(i.toInt)\n            var j = 0\n            while (x > 0) {\n                xorSum(j) += x % 2\n                x /= 2\n                j += 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 32) {\n            ans += (xorSum(i) * (n - xorSum(i)) * pow(2, i)).toLong\n        }\n        ans",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        val xor = Array.ofDim[Long](n.toInt + 1)\n        for (i <- 0 to n.toInt) xor(i) = i ^ (i + 1)\n        var sum = 0L\n        for (i <- 0 until n.toInt) sum += arr(i) * xor(i + 1)\n        sum",
    "        var sum = 0L\n        for (i <- 0L until n) {\n            for (j <- i + 1L until n) {\n                sum += (arr(i.toInt) ^ arr(j.toInt))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (x <- m.keys) {\n            val c = m(x)\n            sum += x * c * (c - 1) / 2\n        }\n        sum",
    "        val mod = 1000000007\n        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n                sum %= mod\n            }\n        }\n        return sum",
    "        val xor = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n            xor(i) = arr(i)\n            for (j <- 0 until i) {\n                xor(i) ^= arr(j)\n            }\n        }\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                sum += xor(i) ^ xor(j)\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            val x = arr(i)\n            for (j <- 0 until n.toInt) {\n                val y = arr(j)\n                val z = x ^ y\n                if (m.contains(z)) m(z) += 1\n                else m(z) = 1\n            }\n        }\n        var sum = 0L\n        for (i <- m.keys) {\n            val c = m(i)\n            sum += (c * (c - 1) / 2) * i\n        }\n        sum",
    "        val p = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n            p(i) = arr(i)\n            for (j <- 0 until i) {\n                p(i) ^= arr(j)\n            }\n        }\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until i) {\n                sum += p(i) ^ p(j)\n            }\n        }\n        sum",
    "        var result : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                result += arr(i) ^ arr(j)\n            }\n        }\n        result",
    "        val dp = Array.ofDim[Long](64)\n        for (i <- 0 until n) {\n            var x = arr(i.toInt)\n            var j = 0\n            while (x > 0) {\n                if (x % 2 == 1) dp(j) += 1\n                x /= 2\n                j += 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans += (dp(i) * (n - dp(i)) * pow(2, i).toLong)\n        }\n        ans",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val xor = Array.ofDim[Long](n.toInt + 1)\n        for (i <- 0 until n.toInt) {\n            xor(i + 1) = xor(i) ^ arr(i)\n        }\n        var result : Long = 0\n        for (i <- 0 until n.toInt) {\n            result += (arr(i) * (n - i) * (i + 1) - (xor(n.toInt) ^ xor(i)) * (i + 1))\n        }\n        result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val xors = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) xors(i) = arr(i)\n        for (i <- 1 until n.toInt) xors(i) ^= xors(i - 1)\n        var ans = 0L\n        for (i <- 0 until n.toInt) ans += xors(i) * (n - i) - (xors(i) ^ xors(n.toInt - 1)) * (i + 1)\n        ans",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var res = 0L\n        for (x <- m.keys) {\n            val cnt = m(x)\n            res += (cnt * (cnt - 1) / 2) * x\n        }\n        res",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val xor = Array.ofDim[Long](n.toInt + 1)\n        for (i <- 0 until n.toInt) {\n            xor(i + 1) = xor(i) ^ arr(i)\n        }\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += xor(i) * (n - i) + xor(i + 1) * i\n        }\n        sum",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n                if (i != j) {\n                    val xor = arr(i) ^ arr(j)\n                    m(xor) = m.getOrElse(xor, 0) + 1\n                }\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += k * v\n        }\n        sum",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var result : Long = 0\n        for ((key, value) <- m) {\n            result += key * value * (value - 1) / 2\n        }\n        result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for ((k, v) <- m) {\n            sum += (v * (v - 1) / 2) * k\n        }\n        sum",
    "        var result : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                result += (arr(i) ^ arr(j))\n            }\n        }\n        return result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            m(arr(i)) = m.getOrElse(arr(i), 0) + 1\n        }\n        var sum = 0L\n        for (i <- m.keys) {\n            val x = m(i)\n            sum += x * (x - 1) / 2 * i\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0L until n) {\n            for (j <- i + 1L until n) {\n                sum += (arr(i.toInt) ^ arr(j.toInt))\n            }\n        }\n        sum",
    "        // Write your code here\n        val m = arr.map(x => x % n).groupBy(x => x).mapValues(_.size).mapValues(x => x * (x - 1) / 2).values.sum\n        m * n",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val mod = 1000000007L\n        val xorSum = arr.map(x => (1L << x).toLong).sum\n        val result = (xorSum * (n * (n - 1) / 2)) % mod\n        return result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val xorSum = arr.foldLeft(0L)((acc, x) => acc + x)\n        val result = (n * (n - 1) / 2) * xorSum\n        result",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val xor = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n            xor(i) = arr(i)\n            for (j <- 0 until i) {\n                xor(i) ^= arr(j)\n            }\n        }\n        xor.sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (x <- arr) {\n            if (m.contains(x)) m(x) += 1\n            else m(x) = 1\n        }\n        var result = 0L\n        for (x <- m.keys) {\n            val y = x ^ n\n            if (m.contains(y)) result += m(x) * m(y)\n        }\n        result",
    "        val mod = 1000000007L\n        val xorSum = arr.foldLeft(0L)((acc, x) => (acc + x) % mod)\n        val xorSumSq = (xorSum * xorSum) % mod\n        val xorSumSqMod = (xorSumSq * n) % mod\n        val xorSumSqMod2 = (xorSumSqMod * 2) % mod\n        xorSumSqMod2",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val sum = arr.map(x => x * n - x * (x - 1) / 2).sum\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n) {\n            val x = arr(i.toInt)\n            for (j <- 0 until n) {\n                val y = arr(j.toInt)\n                val z = x ^ y\n                if (m.contains(z)) m(z) += 1\n                else m(z) = 1\n            }\n        }\n        var sum = 0L\n        for (i <- m.keys) {\n            val c = m(i)\n            sum += (c * (c - 1) / 2) * i\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]()\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val xor = arr(i) ^ arr(j)\n                if (m.contains(xor)) m(xor) += 1\n                else m(xor) = 1\n            }\n        }\n        var sum = 0L\n        for (xor <- m.keys) {\n            val count = m(xor)\n            sum += (count * (count - 1) / 2) * xor\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        sum",
    "        val counts = new Array[Long](64)\n        for (i <- 0 until n) {\n            var num = arr(i.toInt)\n            var j = 0\n            while (num > 0) {\n                if ((num & 1) == 1) counts(j) += 1\n                j += 1\n                num >>= 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans += (counts(i) * (n - counts(i)) * 2)\n            ans %= 1000000007\n        }\n        ans",
    "        var result : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                result += (arr(i) ^ arr(j))\n            }\n        }\n        return result",
    "        val m = new HashMap[Long, Long]\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                val x = arr(i) ^ arr(j)\n                if (m.contains(x)) m(x) += 1\n                else m(x) = 1\n            }\n        }\n        var sum = 0L\n        for (k <- m.keys) {\n            val v = m(k)\n            sum += k * v * (v - 1) / 2\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val m = new HashMap[Long, Long]\n        for (i <- arr) {\n            if (m.contains(i)) m(i) += 1\n            else m(i) = 1\n        }\n        var sum = 0L\n        for (i <- m.keys) {\n            val x = m(i)\n            sum += (x * (x - 1) / 2) * i\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        return sum",
    "        var sum : Long = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += arr(i) ^ arr(j)\n            }\n        }\n        return sum",
    "        var sum = 0L\n        for (i <- 0L until n) {\n            for (j <- i + 1L until n) {\n                sum += (arr(i.toInt) ^ arr(j.toInt))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        var sum = 0L\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                sum += (arr(i) ^ arr(j))\n            }\n        }\n        sum",
    "        val count = Array.fill(64)(0)\n        for (i <- 0 until n) {\n            var x = arr(i.toInt)\n            var j = 0\n            while (x > 0) {\n                count(j) += (x & 1)\n                j += 1\n                x >>= 1\n            }\n        }\n        var ans = 0L\n        for (i <- 0 until 64) {\n            ans += (count(i) * (n - count(i)) * pow(2, i).toLong)\n        }\n        ans"
  ]
}