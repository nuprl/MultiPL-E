{
  "name": "mbpp_265_list_split",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n    def listSplit(S : Any, step : Long) : Any = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(listSplit((Any(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\")), (3l)).equals((Any(List[String](\"a\", \"d\", \"g\", \"j\", \"m\"), List[String](\"b\", \"e\", \"h\", \"k\", \"n\"), List[String](\"c\", \"f\", \"i\", \"l\")))));\n    assert(listSplit((Any(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong, 13l.toLong, 14l.toLong)), (3l)).equals((Any(List[Long](1l.toLong, 4l.toLong, 7l.toLong, 10l.toLong, 13l.toLong), List[Long](2l.toLong, 5l.toLong, 8l.toLong, 11l.toLong, 14l.toLong), List[Long](3l.toLong, 6l.toLong, 9l.toLong, 12l.toLong)))));\n    assert(listSplit((Any(\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\")), (2l)).equals((Any(List[String](\"python\", \"C\", \"DBMS\"), List[String](\"java\", \"C++\", \"SQL\")))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var result = List[Any]()\n        var i = 0\n        while (i < S.length) {\n            result = result :+ S.slice(i, i + step)\n            i += step\n        }\n        result",
    "        val N = S.asInstanceOf[List[Any]].length\n        val result = new ArrayBuffer[Any]\n        for (i <- 0 to N - 1 by step.toInt) {\n            val temp = new ArrayBuffer[Any]\n            for (j <- i to min(i + step - 1, N - 1)) {\n                temp += S.asInstanceOf[List[Any]](j)\n            }\n            result += temp.toList\n        }\n        result.toList",
    "        var result = List[Any]()\n        for (i <- 0 until S.length by step.toInt) {\n            result = result :+ S.slice(i, i + step.toInt)\n        }\n        return result",
    "        val l = S.asInstanceOf[List[Any]]\n        val n = l.length\n        val m = n / step\n        val r = n % step\n        val result = new ArrayBuffer[List[Any]]\n        for (i <- 0 until m) {\n            result += l.slice(i * step.toInt, (i + 1) * step.toInt)\n        }\n        if (r != 0) result += l.slice(m * step.toInt, n)\n        result.toList",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        for (i <- 0 to list.length - 1 by step.toInt) {\n            val sublist = new ListBuffer[Any]\n            for (j <- i until min(i + step, list.length)) {\n                sublist += list(j)\n            }\n            result += sublist.toList\n        }\n        result.toList",
    "        var result = List[Any]()\n        var temp = List[Any]()\n        var i = 0\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i == step) {\n                result = result :+ temp\n                temp = List[Any]()\n                i = 0\n            }\n            temp = temp :+ x\n            i += 1\n        }\n        if (temp.length > 0) result = result :+ temp\n        return result",
    "        var res = List[Any]()\n        var i = 0\n        while (i < S.length) {\n            res = res :+ S.slice(i, i + step)\n            i += step\n        }\n        res",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        for (i <- 0 until list.length by step.toInt) {\n            result += list.slice(i, min(i + step, list.length))\n        }\n        result.toList",
    "        S match {\n            case S : List[Any] => {\n                var result = new ListBuffer[Any]\n                var i = 0\n                while (i < S.length) {\n                    result += S.slice(i, i + step)\n                    i += step\n                }\n                result.toList\n            }\n            case _ => S\n        }",
    "        var result = List[Any]()\n        var temp = List[Any]()\n        var i = 0\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i % step == 0 && i != 0) {\n                result = temp :: result\n                temp = List[Any]()\n            }\n            temp = x :: temp\n            i += 1\n        }\n        result = temp :: result\n        result.reverse",
    "        var result = List[Any]()\n        var i = 0\n        while (i < S.length) {\n            result = result :+ S.slice(i, i + step)\n            i += step\n        }\n        return result",
    "        var result = List[Any]()\n        var i = 0\n        var temp = List[Any]()\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i == step) {\n                result = result :+ temp\n                temp = List[Any]()\n                i = 0\n            }\n            temp = temp :+ x\n            i += 1\n        }\n        result = result :+ temp\n        result",
    "        var result = List[Any]()\n        var temp = List[Any]()\n        var i = 0\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i % step == 0 && i != 0) {\n                result = result :+ temp\n                temp = List[Any]()\n            }\n            temp = temp :+ x\n            i += 1\n        }\n        result = result :+ temp\n        return result",
    "        if (step == 0) {\n            return List(S)\n        }\n        var result = List[Any]()\n        var current = List[Any]()\n        var count = 0\n        for (i <- S.asInstanceOf[List[Any]]) {\n            if (count == step) {\n                result = result :+ current\n                current = List[Any]()\n                count = 0\n            }\n            current = current :+ i\n            count += 1\n        }\n        if (current.length != 0) {\n            result = result :+ current\n        }\n        return result",
    "        var result = List[Any]()\n        var i = 0\n        var j = 0\n        while (i < S.length) {\n            var temp = List[Any]()\n            while (j < step && i < S.length) {\n                temp = temp :+ S(i)\n                i += 1\n                j += 1\n            }\n            result = result :+ temp\n            j = 0\n        }\n        result",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        var i = 0\n        var j = 0\n        while (i < list.length) {\n            val subList = new ListBuffer[Any]\n            while (j < step && i < list.length) {\n                subList += list(i)\n                i += 1\n                j += 1\n            }\n            j = 0\n            result += subList.toList\n        }\n        result.toList",
    "        var result = List[Any]()\n        var i = 0\n        var temp = List[Any]()\n        for (i <- 0 to S.asInstanceOf[List[Any]].length - 1) {\n            temp = temp :+ S.asInstanceOf[List[Any]].apply(i)\n            if (i % step == step - 1) {\n                result = result :+ temp\n                temp = List[Any]()\n            }\n        }\n        if (temp.length > 0) result = result :+ temp\n        return result",
    "        var result = List[Any]()\n        var i = 0\n        var j = 0\n        while (i < S.length) {\n            var temp = List[Any]()\n            while (j < step && i < S.length) {\n                temp = temp :+ S(i)\n                i += 1\n                j += 1\n            }\n            result = result :+ temp\n            j = 0\n        }\n        result",
    "        var result = List[Any]()\n        var i = 0\n        while (i < S.length) {\n            result = result :+ S.slice(i, i + step)\n            i += step\n        }\n        result",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        for (i <- 0 until list.length by step.toInt) {\n            result += list.slice(i, i + step.toInt)\n        }\n        result.toList"
  ]
}