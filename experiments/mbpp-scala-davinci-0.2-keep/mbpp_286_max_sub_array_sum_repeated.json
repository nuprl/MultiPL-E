{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n    def maxSubArraySumRepeated(a : List[Long], n : Long, k : Long) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxSubArraySumRepeated((List[Long](10l.toLong, 20l.toLong, -30l.toLong, -1l.toLong)), (4l), (3l)) == (30l));\n    assert(maxSubArraySumRepeated((List[Long](-1l.toLong, 10l.toLong, 20l.toLong)), (3l), (2l)) == (59l));\n    assert(maxSubArraySumRepeated((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)), (3l), (3l)) == (-1l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k",
    "        val m = a.length\n        val sum = Array.fill(m)(0L)\n        sum(0) = a(0)\n        for (i <- 1 until m) sum(i) = sum(i - 1) + a(i)\n        var max = sum(m - 1)\n        for (i <- 0 until m) {\n            val j = (i + m - 1) % m\n            val s = sum(j) - (if (i == 0) 0 else sum(i - 1))\n            val t = s * k\n            val u = if (i == 0) sum(m - 1) else sum(i - 1)\n            val v = if (j == m - 1) sum(m - 1) else sum(j + 1)\n            val w = (u + v) * (k - 1)\n            max = max(max, t + w)\n        }\n        max",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumWithRepeated = maxSum - (a.sum - max)\n            maxSumWithRepeated\n        } else max",
    "        var sum = 0L\n        var maxSum = 0L\n        for (i <- 0 until n) {\n            sum += a(i)\n        }\n        var maxSumSoFar = 0L\n        for (i <- 0 until n) {\n            maxSumSoFar += a(i)\n            if (maxSumSoFar < 0) maxSumSoFar = 0\n            else if (maxSumSoFar > maxSum) maxSum = maxSumSoFar\n        }\n        var sumSoFar = 0L\n        for (i <- 0 until n) {\n            sumSoFar += a(i)\n            if (sumSoFar < 0) sumSoFar = 0\n        }\n        if (k == 1) return maxSum\n        var ans = max(sum * k, maxSum)\n        if (sum > 0) {\n            ans = max(ans, sumSoFar + sum * (k - 2))\n        }\n        return ans",
    "        val sum = a.sum\n        val maxSum = max(a.max, sum * k)\n        val minSum = min(a.min, sum * k)\n        val maxSumRepeated = max(maxSum, (sum * (k - 2) + max(a.max, a.min * k)))\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => if (x < 0) 0 else x).sum - maxSum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max\n        else {\n            val maxSubArraySum = maxSubArraySum(a)\n            val maxSubArraySumRepeated = maxSubArraySum * k\n            val maxSubArraySumRepeatedWithOverlap = maxSubArraySumRepeated + (sum * (k - 1))\n            max(maxSubArraySumRepeated, maxSubArraySumRepeatedWithOverlap)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => max(0, x)).sum - maxSum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSubArraySum = maxSubArraySum(a)\n            if (maxSubArraySum > 0) maxSubArraySum + (k - 1) * sum\n            else max\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = a.scanLeft(0L)(_ + _).tail\n        val suffixSum = a.scanRight(0L)(_ + _).init\n        val maxPrefixSum = prefixSum.max\n        val maxSuffixSum = suffixSum.max\n        val maxPrefixSuffixSum = (0 until n.toInt).map(i => prefixSum(i) + suffixSum(i) - a(i)).max\n        val maxPrefixSuffixSumRepeated = max(maxPrefixSuffixSum, maxPrefixSum + maxSuffixSum + (k - 2) * sum, maxPrefixSum + maxSuffixSum + (k - 2) * maxSum)\n        max(maxSumRepeated, maxPrefixSuffixSumRepeated)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum < 0) maxSum\n        else if (k == 1) maxSubArraySum(a, n)\n        else {\n            val maxSumRepeated = maxSubArraySum(a, n)\n            val maxSumRepeated2 = maxSubArraySum(a, n)\n            val maxSumRepeated3 = maxSubArraySum(a, n)\n            val maxSumRepeated4 = maxSubArraySum(a, n)\n            val maxSumRepeated5 = maxSubArraySum(a, n)\n            val maxSumRepeated6 = maxSubArraySum(a, n)\n            val maxSumRepeated7 = maxSubArraySum(a, n)\n            val maxSumRepeated8 = maxSubArraySum(a, n)\n            val maxSumRepeated9 = maxSubArraySum(a, n)\n            val maxSumRepeated10 = maxSubArraySum(a, n)\n            val maxSumRepeated11 = maxSubArraySum(a, n)\n            val maxSumRepeated12 = maxSubArraySum(a, n)\n            val maxSumRepeated13 = maxSubArraySum(a, n)\n            val maxSumRepeated14 = maxSubArraySum(a, n)\n            val maxSumRepeated15 = maxSubArraySum(a, n)\n            val maxSumRepeated16 = maxSubArraySum(a, n)\n            val maxSumRepeated17 = maxSubArraySum(a, n)\n            val maxSumRepeated18 = maxSubArraySum(a, n)\n            val maxSumRepeated19 = maxSubArraySum(a, n)\n            val maxSumRepeated20 = maxSubArraySum(a, n)\n            val maxSumRepeated21 = maxSubArraySum(a, n)\n            val maxSumRepeated22 = maxSubArraySum(a, n)\n            val maxSumRepeated23 = maxSubArraySum(a, n)\n            val maxSumRepeated24 = maxSubArraySum(a, n)\n            val maxSumRepeated25 = maxSubArraySum(a, n)\n            val maxSumRepeated26 = maxSubArraySum",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumNonRepeated = max(maxSum, maxSubArraySum(a))\n        max(maxSumRepeated, maxSumNonRepeated)",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max else {\n            val maxSum = a.map(x => x * k).sum\n            val maxSumRepeated = a.map(x => x * (k - 1)).sum\n            val maxSumRepeated2 = a.map(x => x * (k - 2)).sum\n            val maxSumRepeated3 = a.map(x => x * (k - 3)).sum\n            val maxSumRepeated4 = a.map(x => x * (k - 4)).sum\n            val maxSumRepeated5 = a.map(x => x * (k - 5)).sum\n            val maxSumRepeated6 = a.map(x => x * (k - 6)).sum\n            val maxSumRepeated7 = a.map(x => x * (k - 7)).sum\n            val maxSumRepeated8 = a.map(x => x * (k - 8)).sum\n            val maxSumRepeated9 = a.map(x => x * (k - 9)).sum\n            val maxSumRepeated10 = a.map(x => x * (k - 10)).sum\n            val maxSumRepeated11 = a.map(x => x * (k - 11)).sum\n            val maxSumRepeated12 = a.map(x => x * (k - 12)).sum\n            val maxSumRepeated13 = a.map(x => x * (k - 13)).sum\n            val maxSumRepeated14 = a.map(x => x * (k - 14)).sum\n            val maxSumRepeated15 = a.map(x => x * (k - 15)).sum\n            val maxSumRepeated16 = a.map(x => x * (k - 16)).sum\n            val maxSumRepeated17 = a.map(x => x * (k - 17)).sum\n            val maxSumRepeated18 = a.map(x => x * (k - 18)).sum\n            val maxSumRepeated19 = a.map(x => x * (k - 19)).sum\n            val maxSumRepeated20 = a.map(x => x * (k - 20)).sum\n            val maxSumRepeated21 =",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val result = (sum * k) - (a.map(x => sum - x).min)\n            if (result > maxSum) result else maxSum\n        } else maxSum",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val maxSum = a.foldLeft(0L)((x, y) => max(x, x + y))\n        val minSum = a.foldLeft(0L)((x, y) => min(x, x + y))\n        if (maxSum <= 0) maxSum\n        else if (minSum >= 0) sum * k\n        else {\n            val maxPrefix = a.foldLeft(0L)((x, y) => max(x, x + y))\n            val maxSuffix = a.foldLeft(0L)((x, y) => max(x, x + y))\n            max(maxPrefix + maxSuffix, max(maxSubArraySumRepeated(a, n, k - 1), maxSubArraySumRepeated(a, n, k - 2) + sum * 2))\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            if (max > 0) maxSum\n            else max(maxSum, max * k + maxSubArraySum(a, n))\n        } else max * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - a.map(x => if (x < 0) x else 0).sum\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumSubArray = maxSubArraySum(a, n)\n        max(maxSumRepeated, maxSumSubArray)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) (sum * k) max ((sum * (k - 1)) + max)\n        else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSubArraySum = maxSubArraySum(a)\n            val maxSubArraySumRepeated = maxSubArraySum * k + (sum * (k - 1))\n            val maxSubArraySumRepeated2 = maxSubArraySumRepeated + maxSubArraySum(a.map(x => x + sum))\n            val maxSubArraySumRepeated3 = maxSubArraySumRepeated2 + maxSubArraySum(a.map(x => x + sum * 2))\n            val maxSubArraySumRepeated4 = maxSubArraySumRepeated3 + maxSubArraySum(a.map(x => x + sum * 3))\n            val maxSubArraySumRepeated5 = maxSubArraySumRepeated4 + maxSubArraySum(a.map(x => x + sum * 4))\n            val maxSubArraySumRepeated6 = maxSubArraySumRepeated5 + maxSubArraySum(a.map(x => x + sum * 5))\n            val maxSubArraySumRepeated7 = maxSubArraySumRepeated6 + maxSubArraySum(a.map(x => x + sum * 6))\n            val maxSubArraySumRepeated8 = maxSubArraySumRepeated7 + maxSubArraySum(a.map(x => x + sum * 7))\n            val maxSubArraySumRepeated9 = maxSubArraySumRepeated8 + maxSubArraySum(a.map(x => x + sum * 8))\n            val maxSubArraySumRepeated10 = maxSubArraySumRepeated9 + maxSubArraySum(a.map(x => x + sum * 9))\n            val maxSubArraySumRepeated11 = maxSubArraySumRepeated10 + maxSubArraySum(a.map(x => x + sum * 10))\n            val maxSubArraySumRepeated12 = maxSubArraySumRepeated11 + maxSubArraySum(a.map(x => x + sum * 11))\n            val maxSubArraySumRepeated13 = maxSubArraySumRepeated12 + maxSubArraySum(a.map(x => x + sum * 12))\n            val maxSubArraySumRepeated14 = max",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefixSum = a.scanLeft(0L)(_ + _).max\n            val maxSuffixSum = a.scanRight(0L)(_ + _).max\n            val maxPrefixSuffixSum = maxPrefixSum + maxSuffixSum\n            val maxPrefixSuffixSumRepeated = maxPrefixSuffixSum + (k - 2) * sum\n            max(maxSum, maxPrefixSuffixSumRepeated)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val max = a.map(x => x * k).max\n            val min = a.map(x => x * k).min\n            val maxSum = if (max > 0) max else 0\n            val minSum = if (min < 0) min else 0\n            val sum = a.sum\n            val maxSumRepeated = if (sum > 0) sum * (k - 2) + maxSum else maxSum\n            max(maxSumRepeated, maxSum)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            if (max > 0) maxSum\n            else maxSum - (max * (k - 1))\n        } else {\n            val maxSum = max * k\n            if (sum < 0) maxSum\n            else maxSum - (sum * (k - 1))\n        }",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap += a(i)\n            a(i) = -a(i)\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_wrap + max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max * k",
    "        val sum = a.sum\n        val max = a.max\n        val maxSum = max * k\n        if (maxSum > sum * k) maxSum else sum * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumSubArray = maxSubArraySum(a)\n        val maxSumSubArrayRepeated = max(maxSumSubArray, maxSumSubArray + (sum * (k - 1)))\n        max(maxSumRepeated, maxSumSubArrayRepeated)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) sum * k\n        else max(sum * (k - 1) + maxSum, maxSum)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        val maxSum = max * k\n        val maxSumRepeated = if (maxSum > sum) maxSum else sum\n        val maxSumContiguous = maxSubArraySum(a, n)\n        val maxSumContiguousRepeated = maxSubArraySumRepeated(a, n, k)\n        val maxSumContiguousRepeated2 = maxSubArraySumRepeated2(a, n, k)\n        val maxSumContiguousRepeated3 = maxSubArraySumRepeated3(a, n, k)\n        val maxSumContiguousRepeated4 = maxSubArraySumRepeated4(a, n, k)\n        val maxSumContiguousRepeated5 = maxSubArraySumRepeated5(a, n, k)\n        val maxSumContiguousRepeated6 = maxSubArraySumRepeated6(a, n, k)\n        val maxSumContiguousRepeated7 = maxSubArraySumRepeated7(a, n, k)\n        val maxSumContiguousRepeated8 = maxSubArraySumRepeated8(a, n, k)\n        val maxSumContiguousRepeated9 = maxSubArraySumRepeated9(a, n, k)\n        val maxSumContiguousRepeated10 = maxSubArraySumRepeated10(a, n, k)\n        val maxSumContiguousRepeated11 = maxSubArraySumRepeated11(a, n, k)\n        val maxSumContiguousRepeated12 = maxSubArraySumRepeated12(a, n, k)\n        val maxSumContiguousRepeated13 = maxSubArraySumRepeated13(a, n, k)\n        val maxSumContiguousRepeated14 = maxSubArraySumRepeated14(a, n, k)\n        val maxSumContiguousRepeated15 = maxSubArraySumRepeated15(a, n, k)\n        val maxSumContiguousRepeated16 = maxSubArraySumRepeated16(a, n, k)\n        val maxSumContiguousRepeated17 = maxSubArraySumRepeated17(a, n, k)\n        val maxSumContiguousRepeated18 = maxSubArraySumRepeated18(a, n, k)\n        val",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => max(x, 0)).sum - maxSum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = a.scanLeft(0L)(_ + _).tail\n        val suffixSum = a.scanRight(0L)(_ + _).init\n        val prefixMax = prefixSum.scanLeft(0L)((x, y) => max(x, y)).tail\n        val suffixMax = suffixSum.scanRight(0L)((x, y) => max(x, y)).init\n        val maxPrefixSuffixSum = (prefixMax zip suffixMax).map(x => x._1 + x._2).max\n        max(maxPrefixSuffixSum, maxSumRepeated)",
    "        val sums = new Array[Long](n.toInt)\n        var maxSum = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            sums(i) = a(i)\n            maxSum = max(maxSum, sums(i))\n        }\n        for (i <- 1 until k.toInt) {\n            var currSum = 0L\n            var currMax = Long.MinValue\n            for (j <- 0 until n.toInt) {\n                currSum += a(j)\n                currMax = max(currMax, currSum)\n                sums(j) += currSum\n                maxSum = max(maxSum, sums(j))\n            }\n        }\n        maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedMod = maxSumRepeated % n\n            val maxSumRepeatedMod2 = maxSumRepeatedMod + (n * (k - 1))\n            val maxSumRepeatedMod3 = maxSumRepeatedMod2 % n\n            val maxSumRepeatedMod4 = maxSumRepeatedMod3 + (n * (k - 1))\n            val maxSumRepeatedMod5 = maxSumRepeatedMod4 % n\n            val maxSumRepeatedMod6 = maxSumRepeatedMod5 + (n * (k - 1))\n            val maxSumRepeatedMod7 = maxSumRepeatedMod6 % n\n            val maxSumRepeatedMod8 = maxSumRepeatedMod7 + (n * (k - 1))\n            val maxSumRepeatedMod9 = maxSumRepeatedMod8 % n\n            val maxSumRepeatedMod10 = maxSumRepeatedMod9 + (n * (k - 1))\n            val maxSumRepeatedMod11 = maxSumRepeatedMod10 % n\n            val maxSumRepeatedMod12 = maxSumRepeatedMod11 + (n * (k - 1))\n            val maxSumRepeatedMod13 = maxSumRepeatedMod12 % n\n            val maxSumRepeatedMod14 = maxSumRepeatedMod13 + (n * (k - 1))\n            val maxSumRepeatedMod15 = maxSumRepeatedMod14 % n\n            val maxSumRepeatedMod16 = maxSumRepeatedMod15 + (n * (k - 1))\n            val maxSumRepeatedMod17 = maxSumRepeatedMod16 % n\n            val maxSumRepeatedMod18 = maxSumRepeatedMod17 + (n * (k - 1))\n            val maxSumRepeatedMod19 = maxSumRepeatedMod18 % n\n            val maxSumRepeatedMod20 = maxSumRepeatedMod19 + (n * (k - 1))\n            val maxSumRepeatedMod21 = maxSumRepeatedMod20 % n\n            val maxSumRepeatedMod22 = maxSumRepeatedMod21 + (n * (k - 1))\n            val maxSumRepe",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else {\n            val maxSumRepeated = max(maxSum * k, sum * k - (a.map(x => max(0, x)).sum * (k - 1)))\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n))\n        maxSumRepeated2",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else {\n            val maxSum = maxSubArraySum(a)\n            val maxSumRepeated = maxSubArraySumRepeated(a, n, k - 1)\n            max(maxSum, maxSumRepeated, maxSum + (k - 2) * sum)\n        }",
    "        val sum = a.sum\n        var max = 0L\n        for (i <- 0 until a.length) {\n            var cur = 0L\n            for (j <- i until a.length) {\n                cur += a(j)\n                max = max max (cur + (k - 1) * sum)\n            }\n        }\n        max",
    "        var sum = 0L\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        var start = 0L\n        var end = 0L\n        var s = 0L\n        var i = 0L\n        for (i <- 0L until n) {\n            max_ending_here += a(i.toInt)\n            if (max_ending_here < 0) {\n                max_ending_here = 0\n                s = i + 1\n            }\n            if (max_so_far < max_ending_here) {\n                max_so_far = max_ending_here\n                start = s\n                end = i\n            }\n        }\n        if (k == 1) return max_so_far\n        var max_wrap = 0L\n        for (i <- 0L until n) {\n            max_wrap += a(i.toInt)\n            a(i.toInt) = -a(i.toInt)\n        }\n        max_wrap = max_wrap + maxSubArraySumRepeated(a, n, 1)\n        if (max_wrap > max_so_far) {\n            var max_wrap_start = n - end - 1\n            var max_wrap_end = n - start - 1\n            return max_wrap\n        }\n        return max_so_far",
    "        val sum = a.sum\n        val maxSum = max(sum * k, maxSubArraySum(a))\n        val maxPrefixSum = maxSubArraySum(a.scanLeft(0L)(_ + _).tail)\n        val maxSuffixSum = maxSubArraySum(a.scanRight(0L)(_ + _).init)\n        max(maxSum, maxPrefixSum + (sum * (k - 2)) + maxSuffixSum)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else if (k == 1) maxSubArraySum(a, n)\n        else if (sum <= 0) max(maxSubArraySum(a, n), maxSubArraySumRepeated(a, n, k - 1))\n        else sum * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n))\n        maxSumRepeated2",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumNonRepeated = maxSubArraySum(a, n)\n        max(maxSumRepeated, maxSumNonRepeated)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (k * a.min)\n            max(maxSumRepeatedWithMod, maxSum)\n        } else {\n            maxSum\n        }",
    "        var max_so_far = a.head\n        var max_ending_here = a.head\n        for (i <- 1 until n) {\n            max_ending_here = max(a(i), max_ending_here + a(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap += a(i)\n            a(i) = -a(i)\n        }\n        max_wrap = max_wrap + maxSubArraySumRepeated(a, n, k)\n        max(max_so_far, max_wrap)",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((x, y) => max(x, y))\n        if (max <= 0) return max * k\n        val maxSum = maxSubArraySum(a)\n        val minSum = minSubArraySum(a)\n        val maxSumRepeated = max(maxSum * k, sum * k - minSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1) - maxSum)\n            max(maxSumRepeated, maxSumRepeatedWithMod)\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val m = a.map(x => x * k).toArray\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until m.length) {\n            max_ending_here = max(m(i), max_ending_here + m(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1) - maxSum)\n            max(maxSumRepeated, maxSumRepeatedWithMod)\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => if (x < 0) 0 else x).sum - maxSum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSubArraySum(a)\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        }",
    "        val sums = Array.fill(n.toInt)(0L)\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            sums(i) = sum\n        }\n        var max = 0L\n        for (i <- 0 until n.toInt) {\n            var sum = 0L\n            for (j <- i until n.toInt) {\n                sum += sums(j) - (if (i == 0) 0 else sums(i - 1))\n                max = max max sum\n            }\n        }\n        max * k - (sums(n.toInt - 1) * (k - 1))",
    "        val prefix = Array.fill(n.toInt)(0L)\n        prefix(0) = a(0)\n        for (i <- 1 until n.toInt) prefix(i) = prefix(i - 1) + a(i)\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = prefix(j) - prefix(i) + a(i) * (k - 2)\n                max = max max sum\n            }\n        }\n        max",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = a.scanLeft(0L)(_ + _).tail\n        val suffixSum = a.scanRight(0L)(_ + _).init\n        val prefixSumRepeated = prefixSum.scanLeft(0L)(_ + _).tail\n        val suffixSumRepeated = suffixSum.scanRight(0L)(_ + _).init\n        val maxPrefixSum = prefixSum.max\n        val maxSuffixSum = suffixSum.max\n        val maxPrefixSumRepeated = max(maxPrefixSum, prefixSumRepeated.max)\n        val maxSuffixSumRepeated = max(maxSuffixSum, suffixSumRepeated.max)\n        val maxMiddleSumRepeated = max(maxPrefixSumRepeated + maxSuffixSumRepeated, maxSumRepeated)\n        maxMiddleSumRepeated",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = max(sum * k, max + sum * (k - 2))\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => min(x, 0)).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefix = maxPrefixSum(a)\n            val maxSuffix = maxSuffixSum(a)\n            val maxPrefixSuffix = maxPrefix.zip(maxSuffix).map(x => x._1 + x._2)\n            val maxPrefixSuffixSum = maxPrefixSuffix.max\n            val maxPrefixSuffixSumRepeated = maxPrefixSuffixSum + (k - 2) * sum\n            List(maxSum, maxPrefixSuffixSumRepeated).max\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum > 0) {\n            val maxSumRepeated = maxSum * k\n            val maxSumRepeatedMod = maxSumRepeated % sum\n            if (maxSumRepeatedMod > 0) maxSumRepeatedMod else sum\n        } else maxSum",
    "        // Find the maximum sum of a subarray in the original array.\n        val maxSubArraySum = a.foldLeft((0L, 0L))((acc, x) => {\n            val newSum = acc._2 + x\n            if (newSum > 0) (max(acc._1, newSum), newSum)\n            else (max(acc._1, x), x)\n        })._1\n        // If the maximum sum is negative, then the maximum sum of a subarray in the modified array is the maximum element in the original array.\n        if (maxSubArraySum <= 0) a.max\n        // Otherwise, the maximum sum of a subarray in the modified array is the maximum sum of a subarray in the original array plus the maximum sum of a subarray in the original array multiplied by (k - 1).\n        else maxSubArraySum + maxSubArraySum * (k - 1)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumNonRepeated = maxSubArraySum(a, n)\n            max(maxSumRepeated, maxSumNonRepeated)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumPrefix = maxSubArraySum(a, n)\n            val maxSumSuffix = maxSubArraySum(a.reverse, n)\n            val maxSumMiddle = sum * (k - 2) + maxSumPrefix + maxSumSuffix\n            List(maxSumRepeated, maxSumPrefix, maxSumSuffix, maxSumMiddle).max\n        }",
    "        val b = a.map(x => x * k)\n        val sum = b.sum\n        val max = b.max\n        val min = b.min\n        val maxSum = max(sum - min, max)\n        maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum < 0) return maxSum * k\n        val maxPrefix = a.scanLeft(0L)(_ + _).drop(1).max\n        val maxSuffix = a.scanRight(0L)(_ + _).dropRight(1).max\n        val maxMiddle = sum * (k - 2) + maxPrefix + maxSuffix\n        max(max(maxPrefix, maxSuffix), maxMiddle)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = (sum * (k - 1)) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = max(sum * k, maxSubArraySum(a, n))\n        val prefixSum = a.scanLeft(0L)(_ + _)\n        val prefixSumRepeated = prefixSum.map(x => x + sum * (k - 1))\n        val maxPrefixSum = prefixSumRepeated.max\n        val maxSuffixSum = prefixSumRepeated.map(x => x - sum).max\n        max(maxSum, maxPrefixSum + maxSuffixSum)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(maxSum, (sum * k) - (a.map(x => if (x < 0) x else 0).sum))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated + maxSubArraySum(a.map(x => x * (k - 1) + x))\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        maxSumRepeated",
    "        val prefixSum = new Array[Long](a.length)\n        prefixSum(0) = a(0)\n        for (i <- 1 until a.length) {\n            prefixSum(i) = prefixSum(i - 1) + a(i)\n        }\n        var maxSum = Long.MinValue\n        for (i <- 0 until a.length) {\n            val sum = prefixSum(i) + (k - 1) * prefixSum(a.length - 1)\n            maxSum = max(maxSum, sum)\n        }\n        maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max else max(sum * k, maxSubArraySum(a, n))",
    "        val sum = a.sum\n        val maxSubArraySum = maxSubArraySum(a)\n        val maxSubArraySumRepeated = max(maxSubArraySum, sum * k - maxSubArraySum)\n        maxSubArraySumRepeated",
    "        val m = a.length\n        val sum = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val dp = Array.fill(m)(0L)\n        var maxSum = 0L\n        for (i <- 0 until m) {\n            dp(i) = a(i)\n            if (dp(i) > maxSum) maxSum = dp(i)\n            for (j <- i + 1 until m) {\n                dp(j) = dp(j - 1) + a(j)\n                if (dp(j) > maxSum) maxSum = dp(j)\n            }\n        }\n        var result = maxSum\n        for (i <- 0 until m) {\n            var current = maxSum\n            for (j <- 0 until m) {\n                if (i == j) current = max(current, dp(j) + (k - 2) * sum)\n                else current = max(current, dp(j) + (k - 1) * sum)\n            }\n            result = max(result, current)\n        }\n        result",
    "        var sum : Long = 0\n        var max : Long = Long.MinValue\n        var i : Long = 0\n        var j : Long = 0\n        while (i < n) {\n            sum += a(i.toInt)\n            i += 1\n        }\n        max = max(max, sum)\n        while (j < n) {\n            sum += (k - 1) * a(j.toInt)\n            max = max(max, sum)\n            j += 1\n        }\n        return max",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val maxSum = a.foldLeft(0L)((max, x) => max max (max + x))\n        val minSum = a.foldLeft(0L)((min, x) => min min (min + x))\n        if (maxSum <= 0) return maxSum * k\n        if (minSum >= 0) return sum * k\n        val maxPrefix = a.foldLeft(0L)((max, x) => (max + x) max max)\n        val maxSuffix = a.foldLeft(0L)((max, x) => (max + x) max max)\n        val maxPrefixSum = maxPrefix * (k - 1)\n        val maxSuffixSum = maxSuffix * (k - 1)\n        val maxMiddleSum = (sum * (k - 2)) max 0\n        maxPrefixSum + maxMiddleSum + maxSuffixSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSubArraySum = maxSubArraySum(a, n)\n            max(maxSubArraySum, maxSubArraySum + (k - 2) * sum, maxSubArraySum + (k - 1) * sum)\n        } else {\n            max(maxSum, maxSum + (k - 1) * sum)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n))\n        maxSumRepeated2",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) (sum * k) max (maxSubArraySum(a) + maxSubArraySum(a, n - 1))\n        else maxSum",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((m, x) => max(m, x))\n        val min = a.foldLeft(0L)((m, x) => min(m, x))\n        if (max < 0) max\n        else if (min > 0) sum * k\n        else {\n            val prefix = a.foldLeft(0L)((m, x) => max(m + x, 0))\n            val suffix = a.foldLeft(0L)((m, x) => max(m + x, 0))\n            max(prefix + suffix + (k - 2) * sum, prefix + sum * (k - 1))\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else if (sum <= 0) sum * k\n        else {\n            val m = a.map(x => x % sum).toArray\n            val p = new Array[Long](n.toInt)\n            p(0) = m(0)\n            for (i <- 1 until n.toInt) p(i) = (p(i - 1) + m(i)) % sum\n            val q = new Array[Long](n.toInt)\n            q(0) = m(0)\n            for (i <- 1 until n.toInt) q(i) = (q(i - 1) + p(i)) % sum\n            val r = new Array[Long](n.toInt)\n            for (i <- 0 until n.toInt) r(i) = q(i)\n            for (i <- 0 until n.toInt) r(i) = (r(i) + (k - 1) * p(i)) % sum\n            val s = new Array[Long](n.toInt)\n            for (i <- 0 until n.toInt) s(i) = r(i)\n            for (i <- 1 until n.toInt) s(i) = max(s(i), s(i - 1))\n            val t = new Array[Long](n.toInt)\n            for (i <- 0 until n.toInt) t(i) = r(i)\n            for (i <- n.toInt - 2 to 0 by -1) t(i) = max(t(i), t(i + 1))\n            var ans = 0L\n            for (i <- 0 until n.toInt) ans = max(ans, max(s(i), t(i)))\n            ans\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => if (x < 0) x else 0).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else if (k == 1) maxSubArraySum(a, n)\n        else if (sum <= 0) max(maxSubArraySum(a, n), sum * k)\n        else sum * k",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max\n        else if (sum < 0) sum * k\n        else {\n            val prefix = a.scanLeft(0L)(_ + _).init\n            val suffix = a.scanRight(0L)(_ + _).tail\n            val maxPrefix = prefix.max\n            val maxSuffix = suffix.max\n            val maxMiddle = (0L /: a)((acc, x) => acc + x max 0) * k\n            val maxPrefixSuffix = (0L /: prefix)((acc, x) => acc + x max 0) + (0L /: suffix)((acc, x) => acc + x max 0)\n            List(maxPrefixSuffix, maxMiddle, maxPrefix + maxSuffix + sum * (k - 2)).max\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n))\n        maxSumRepeated2",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) (sum * k) max (maxSubArraySum(a) + maxSubArraySum(a.reverse))\n        else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (k == 1) maxSum\n        else if (sum > 0) sum * k\n        else max(maxSum, maxSubArraySumRepeated(a, n, k - 1))",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxPrefixSum = a.scanLeft(0L)(_ + _).max\n        val maxSuffixSum = a.scanRight(0L)(_ + _).max\n        val maxSubArraySum = a.scanLeft(0L)(_ + _).zip(a.scanRight(0L)(_ + _)).map(x => x._1 + x._2).max\n        val maxSubArraySumRepeated = if (k == 1) maxSubArraySum else {\n            val maxSubArraySumRepeated1 = if (maxSubArraySum > 0) maxSubArraySum * k else maxSubArraySum\n            val maxSubArraySumRepeated2 = if (maxPrefixSum + maxSuffixSum > 0) (maxPrefixSum + maxSuffixSum) * (k - 1) + maxSubArraySum else maxSubArraySum\n            val maxSubArraySumRepeated3 = if (sum > 0) sum * (k - 2) + maxPrefixSum + maxSuffixSum else maxSubArraySum\n            val maxSubArraySumRepeated4 = if (sum > 0) sum * (k - 2) + maxSubArraySum else maxSubArraySum\n            List(maxSubArraySumRepeated1, maxSubArraySumRepeated2, maxSubArraySumRepeated3, maxSubArraySumRepeated4).max\n        }\n        maxSubArraySumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1))\n            val maxSumRepeatedWithModWithMax = max(maxSumRepeatedWithMod, maxSum)\n            maxSumRepeatedWithModWithMax\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max else max(sum * k, maxSubArraySum(a, n))",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) maxSum\n        else {\n            val maxSumEndingHere = new Array[Long](n.toInt)\n            val maxSumSoFar = new Array[Long](n.toInt)\n            maxSumEndingHere(0) = a(0)\n            maxSumSoFar(0) = a(0)\n            for (i <- 1 until n.toInt) {\n                maxSumEndingHere(i) = max(a(i), maxSumEndingHere(i - 1) + a(i))\n                maxSumSoFar(i) = max(maxSumSoFar(i - 1), maxSumEndingHere(i))\n            }\n            val maxSumEndingHereRev = new Array[Long](n.toInt)\n            val maxSumSoFarRev = new Array[Long](n.toInt)\n            maxSumEndingHereRev(n.toInt - 1) = a(n.toInt - 1)\n            maxSumSoFarRev(n.toInt - 1) = a(n.toInt - 1)\n            for (i <- n.toInt - 2 to 0 by -1) {\n                maxSumEndingHereRev(i) = max(a(i), maxSumEndingHereRev(i + 1) + a(i))\n                maxSumSoFarRev(i) = max(maxSumSoFarRev(i + 1), maxSumEndingHereRev(i))\n            }\n            var maxSum = maxSumSoFar(n.toInt - 1)\n            for (i <- 0 until n.toInt - 1) {\n                maxSum = max(maxSum, maxSumSoFar(i) + maxSumSoFarRev(i + 1))\n            }\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefixSum = a.scanLeft(0L)(_ + _).drop(1).max\n            val maxSuffixSum = a.scanRight(0L)(_ + _).dropRight(1).max\n            val maxPrefixSuffixSum = maxPrefixSum + maxSuffixSum\n            val maxPrefixSuffixSumRepeated = maxPrefixSuffixSum + (k - 2) * sum\n            List(maxSum, maxPrefixSuffixSumRepeated, maxPrefixSuffixSum).max\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumWithoutLast = (sum * (k - 1)) + max\n            max(maxSum, maxSumWithoutLast)\n        } else max",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0)\n            sum * k\n        else if (max < 0)\n            max\n        else {\n            var maxSum = 0L\n            var currSum = 0L\n            for (i <- 0 until n.toInt) {\n                currSum += a(i)\n                if (currSum < 0)\n                    currSum = 0\n                else if (currSum > maxSum)\n                    maxSum = currSum\n            }\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = (maxSum * k) + (sum * (k - 1))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else {\n            val maxSum = maxSubArraySum(a)\n            val maxSumRepeated = maxSum * k\n            val maxSumCircular = maxSumRepeated + sum * (k - 1)\n            max(maxSumCircular, maxSumRepeated)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSum2 = max + maxSubArraySumRepeated(a.map(x => x - max), n, k - 1)\n            max(maxSum, maxSum2)\n        }\n        else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) maxSum\n        else {\n            val maxSumRepeated = maxSubArraySumRepeated(a, n, k - 1)\n            val maxSumNonRepeated = maxSubArraySumNonRepeated(a, n)\n            max(maxSumRepeated, maxSumNonRepeated)\n        }",
    "        val prefixSum = new Array[Long](n.toInt)\n        prefixSum(0) = a(0)\n        for (i <- 1 until n.toInt) prefixSum(i) = prefixSum(i - 1) + a(i)\n        var maxSum = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = prefixSum(j) - prefixSum(i) + a(i)\n                if (sum > maxSum) maxSum = sum\n            }\n        }\n        maxSum * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            maxSumRepeated max maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCyclic = max(maxSubArraySumCyclic(a), maxSumRepeated)\n            max(maxSum, maxSumCyclic)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = maxSum + (sum * (k - 1))\n            val maxSumRepeated2 = sum * k\n            max(maxSumRepeated, maxSumRepeated2)\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated + maxSubArraySum(a, n)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSum2 = a.map(x => x * k).max\n        val maxSum3 = a.map(x => x * (k - 1)).max\n        val maxSum4 = a.map(x => x * (k - 2)).max\n        val maxSum5 = a.map(x => x * (k - 3)).max\n        val maxSum6 = a.map(x => x * (k - 4)).max\n        val maxSum7 = a.map(x => x * (k - 5)).max\n        val maxSum8 = a.map(x => x * (k - 6)).max\n        val maxSum9 = a.map(x => x * (k - 7)).max\n        val maxSum10 = a.map(x => x * (k - 8)).max\n        val maxSum11 = a.map(x => x * (k - 9)).max\n        val maxSum12 = a.map(x => x * (k - 10)).max\n        val maxSum13 = a.map(x => x * (k - 11)).max\n        val maxSum14 = a.map(x => x * (k - 12)).max\n        val maxSum15 = a.map(x => x * (k - 13)).max\n        val maxSum16 = a.map(x => x * (k - 14)).max\n        val maxSum17 = a.map(x => x * (k - 15)).max\n        val maxSum18 = a.map(x => x * (k - 16)).max\n        val maxSum19 = a.map(x => x * (k - 17)).max\n        val maxSum20 = a.map(x => x * (k - 18)).max\n        val maxSum21 = a.map(x => x * (k - 19)).max\n        val maxSum22 = a.map(x => x * (k - 20)).max\n        val maxSum23 = a.map(x => x * (k - 21)).max\n        val maxSum24 = a.map(x => x * (k - 22)).max\n        val maxSum25 = a.map(x => x *",
    "        val s = a.sum\n        val m = a.map(x => x * k - s).max\n        val b = a.map(x => x * k - s).scanLeft(0L)(_ + _).tail\n        val c = b.map(x => x + s).max\n        max(m, c)",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = a.scanLeft(0L)(_ + _).tail\n        val suffixSum = a.scanRight(0L)(_ + _).init\n        val prefixSumRepeated = prefixSum.scanLeft(0L)(_ + _).tail\n        val suffixSumRepeated = suffixSum.scanRight(0L)(_ + _).init\n        val prefixSumRepeatedMax = prefixSumRepeated.max\n        val suffixSumRepeatedMax = suffixSumRepeated.max\n        val prefixSumRepeatedMaxIndex = prefixSumRepeated.indexOf(prefixSumRepeatedMax)\n        val suffixSumRepeatedMaxIndex = suffixSumRepeated.indexOf(suffixSumRepeatedMax)\n        val prefixSumRepeatedMaxIndexNext = (prefixSumRepeatedMaxIndex + 1) % n\n        val suffixSumRepeatedMaxIndexNext = (suffixSumRepeatedMaxIndex + 1) % n\n        val prefixSumRepeatedMaxIndexNextValue = prefixSumRepeated(prefixSumRepeatedMaxIndexNext)\n        val suffixSumRepeatedMaxIndexNextValue = suffixSumRepeated(suffixSumRepeatedMaxIndexNext)\n        val prefixSumRepeatedMaxIndexNextValueRepeated = prefixSumRepeatedMaxIndexNextValue + (k - 1) * sum\n        val suffixSumRepeatedMaxIndexNextValueRepeated = suffixSumRepeatedMaxIndexNextValue + (k - 1) * sum\n        val maxSumRepeated2 = max(maxSumRepeated, prefixSumRepeatedMaxIndexNextValueRepeated, suffixSumRepeatedMaxIndexNextValueRepeated)\n        maxSumRepeated2",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) return max * k\n        val maxSum = a.scanLeft(0L)(_ + _).drop(1).max\n        val maxPrefix = a.scanLeft(0L)(_ + _).drop(1).takeWhile(_ < 0).sum\n        val maxSuffix = a.scanRight(0L)(_ + _).drop(1).takeWhile(_ < 0).sum\n        val maxPrefixSuffix = maxPrefix + maxSuffix\n        val maxPrefixSuffixSum = sum * (k - 2) + maxPrefixSuffix\n        val maxPrefixSum = maxPrefix + sum * (k - 1)\n        val maxSuffixSum = maxSuffix + sum * (k - 1)\n        val maxSumRepeated = max(maxSum, maxPrefixSuffixSum, maxPrefixSum, maxSuffixSum)\n        maxSumRepeated",
    "        val b = a.map(x => x * k)\n        val c = b.scanLeft(0L)(_ + _).tail\n        val d = c.sliding(2).map(x => x(1) - x(0)).toList\n        val e = d.scanLeft(0L)(_ + _).tail\n        val f = e.sliding(2).map(x => x(1) - x(0)).toList\n        val g = f.scanLeft(0L)(_ + _).tail\n        val h = g.sliding(2).map(x => x(1) - x(0)).toList\n        val i = h.scanLeft(0L)(_ + _).tail\n        val j = i.sliding(2).map(x => x(1) - x(0)).toList\n        val k = j.scanLeft(0L)(_ + _).tail\n        val l = k.sliding(2).map(x => x(1) - x(0)).toList\n        val m = l.scanLeft(0L)(_ + _).tail\n        val n = m.sliding(2).map(x => x(1) - x(0)).toList\n        val o = n.scanLeft(0L)(_ + _).tail\n        val p = o.sliding(2).map(x => x(1) - x(0)).toList\n        val q = p.scanLeft(0L)(_ + _).tail\n        val r = q.sliding(2).map(x => x(1) - x(0)).toList\n        val s = r.scanLeft(0L)(_ + _).tail\n        val t = s.sliding(2).map(x => x(1) - x(0)).toList\n        val u = t.scanLeft(0L)(_ + _).tail\n        val v = u.sliding(2).map(x => x(1) - x(0)).toList\n        val w = v.scanLeft(0L)(_ + _).tail\n        val x = w.sliding(2).map(x => x(1) - x(0)).toList\n       ",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max else max(sum * k, maxSubArraySum(a, n))",
    "        var sum = 0L\n        for (i <- 0 until n.toInt) sum += a(i)\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n.toInt) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n.toInt) {\n            max_wrap += a(i)\n            a(i) = -a(i)\n        }\n        max_wrap = max_wrap + maxSubArraySumRepeated(a, n, k)\n        max(max_so_far, max_wrap)",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until b.length) {\n            max_ending_here = max(b(i), max_ending_here + b(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1) - maxSum)\n            maxSumRepeatedWithMod\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxSumWithoutMiddle = maxSum - sum\n            maxSumWithoutMiddle max max\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else if (sum <= 0) sum * k\n        else {\n            val prefix = a.scanLeft(0L)(_ + _).tail\n            val suffix = a.scanRight(0L)(_ + _).init\n            val maxPrefix = prefix.max\n            val maxSuffix = suffix.max\n            val maxMiddle = (0L /: (prefix zip suffix))((m, p) => max(m, p._1 + p._2))\n            val maxSingle = max(maxPrefix + maxSuffix, maxMiddle)\n            val maxDouble = max(maxPrefix + maxSuffix + sum, maxMiddle + sum)\n            if (k == 1) maxSingle\n            else if (k == 2) maxDouble\n            else max(maxDouble, maxSingle + (k - 2) * sum)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max * k\n        else {\n            val maxSum = (n * k) * max\n            val minSum = (n * k) * a.min\n            val sumRepeated = sum * k\n            val sumRepeatedMod = sumRepeated % n\n            val sumRepeatedDiv = sumRepeated / n\n            val maxSumRepeated = max(sumRepeatedMod, sumRepeatedDiv)\n            max(maxSumRepeated, max(maxSum, minSum))\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        if (k == 1) return max_so_far\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap += a(i)\n            a(i) = -a(i)\n        }\n        max_wrap = max_wrap + maxSubArraySumRepeated(a, n, k - 2)\n        return max(max_wrap, max_so_far)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (k == 1) maxSubArraySum(a, n)\n        else if (k == 2) max(maxSubArraySum(a, n), maxSubArraySum(a, n) + sum)\n        else {\n            val sum2 = sum * (k - 2)\n            val max2 = maxSubArraySum(a, n)\n            max(max2, max2 + sum2)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => if (x < 0) x else 0).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val s = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val dp = Array.fill(n.toInt)(0L)\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            dp(i) = sum\n        }\n        var result = 0L\n        for (i <- 0 until n.toInt) {\n            result = max(result, dp(i))\n            for (j <- i + 1 until n.toInt) {\n                result = max(result, dp(j) - dp(i))\n            }\n        }\n        result + (k - 2) * s",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => x % n)\n        val d = c.map(x => x - n)\n        val e = d.map(x => abs(x))\n        val f = e.map(x => x % n)\n        val g = f.map(x => x - n)\n        val h = g.map(x => abs(x))\n        val i = h.map(x => x % n)\n        val j = i.map(x => x - n)\n        val k = j.map(x => abs(x))\n        val l = k.map(x => x % n)\n        val m = l.map(x => x - n)\n        val o = m.map(x => abs(x))\n        val p = o.map(x => x % n)\n        val q = p.map(x => x - n)\n        val r = q.map(x => abs(x))\n        val s = r.map(x => x % n)\n        val t = s.map(x => x - n)\n        val u = t.map(x => abs(x))\n        val v = u.map(x => x % n)\n        val w = v.map(x => x - n)\n        val x = w.map(x => abs(x))\n        val y = x.map(x => x % n)\n        val z = y.map(x => x - n)\n        val aa = z.map(x => abs(x))\n        val ab = aa.map(x => x % n)\n        val ac = ab.map(x => x - n)\n        val ad = ac.map(x => abs(x))\n        val ae = ad.map(x => x % n)\n        val af = ae.map(x => x - n)\n        val ag = af.map(x => abs(x))\n        val ah = ag.map(x => x % n)\n        val ai = ah.map(x => x - n)\n        val aj = ai.map(x",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefixSum = a.scanLeft(0L)(_ + _).drop(1).max\n            val maxSuffixSum = a.scanRight(0L)(_ + _).dropRight(1).max\n            val maxPrefixSuffixSum = maxPrefixSum + maxSuffixSum\n            val maxPrefixSuffixSumRepeated = maxPrefixSuffixSum + (k - 2) * sum\n            List(maxSum, maxPrefixSuffixSumRepeated, maxPrefixSum, maxSuffixSum).max\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefixSum = a.scanLeft(0L)(_ + _).max\n            val maxSuffixSum = a.scanRight(0L)(_ + _).max\n            val maxMiddleSum = maxPrefixSum + maxSuffixSum\n            max(maxSum, max(maxMiddleSum, maxPrefixSum + maxSuffixSum * (k - 2)))\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxSumRepeated = maxSum - sum + max\n            max(maxSum, maxSumRepeated)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSubArraySum = maxSubArraySum(a, n)\n            max(maxSubArraySum, maxSubArraySum + (k - 2) * sum, maxSubArraySum + (k - 1) * sum)\n        } else {\n            max(maxSum, maxSum + (k - 1) * sum)\n        }",
    "        val sum = a.sum\n        val maxSum = a.map(abs(_)).max\n        if (sum >= 0) sum * k\n        else if (k == 1) maxSum\n        else {\n            val maxPrefix = a.scanLeft(0L)(_ + _).init.max\n            val maxSuffix = a.scanRight(0L)(_ + _).init.max\n            max(maxPrefix + maxSuffix + (k - 2) * sum, maxSum)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => max(x, 0)).sum - maxSum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxSumWithoutMiddle = maxSum - sum\n            val maxSumWithMiddle = maxSumWithoutMiddle + max\n            max(maxSumWithoutMiddle, maxSumWithMiddle)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = (sum * k) max (sum * (k - 2) + maxSum)\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else if (sum <= 0) sum * k\n        else {\n            val maxSubArraySum = maxSubArraySum(a, n)\n            val maxSubArraySumRepeated = maxSubArraySum * k\n            val maxSubArraySumRepeatedWithOverlap = maxSubArraySumRepeated + (sum * (k - 1))\n            max(maxSubArraySumRepeated, maxSubArraySumRepeatedWithOverlap)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n            maxSumRepeated\n        } else maxSum",
    "        var max_so_far = 0L\n        var max_ending_here = 0L\n        var max_element = a.max\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i.toInt)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        if (max_so_far == 0) return max_element\n        max_so_far * k - (a.map(x => x * x).sum - max_so_far)",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((x, y) => max(x, y))\n        if (max <= 0) return max * k\n        val maxSum = maxSubArraySum(a, n)\n        val maxPrefixSum = maxPrefixSumRepeated(a, n, k)\n        val maxSuffixSum = maxSuffixSumRepeated(a, n, k)\n        val ans = max(maxSum, maxPrefixSum + maxSuffixSum + sum * (k - 2))\n        ans",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumSubarray = maxSubArraySum(a, n)\n        val maxSumSubarrayRepeated = max(maxSumSubarray, maxSumSubarray + (sum * (k - 2)))\n        max(maxSumRepeated, maxSumSubarrayRepeated)",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) return maxSum * k\n        val maxSumRepeated = max(sum * k, sum * (k - 1) + maxSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(maxSum, sum * k)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n) * k)\n        maxSumRepeated2",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => min(x, 0)).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = max * k\n            val maxSumRepeated = maxSum + (sum * (k - 1))\n            maxSumRepeated\n        } else {\n            max\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = a.scanLeft(0L)(_ + _).tail\n        val suffixSum = a.scanRight(0L)(_ + _).init\n        val prefixSumRepeated = prefixSum.scanLeft(0L)(_ + _).tail\n        val suffixSumRepeated = suffixSum.scanRight(0L)(_ + _).init\n        val prefixSumRepeatedMax = prefixSumRepeated.max\n        val suffixSumRepeatedMax = suffixSumRepeated.max\n        val maxSumRepeated2 = max(maxSumRepeated, prefixSumRepeatedMax + suffixSumRepeatedMax)\n        val prefixSumRepeatedMax2 = prefixSumRepeated.drop(1).max\n        val suffixSumRepeatedMax2 = suffixSumRepeated.drop(1).max\n        val maxSumRepeated3 = max(maxSumRepeated2, prefixSumRepeatedMax2 + suffixSumRepeatedMax2)\n        maxSumRepeated3",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val sum2 = sum * k\n            val max2 = max * k\n            val max3 = max * (k - 2)\n            val max4 = max * (k - 1)\n            val max5 = max * (k - 3)\n            val max6 = max * (k - 4)\n            val max7 = max * (k - 5)\n            val max8 = max * (k - 6)\n            val max9 = max * (k - 7)\n            val max10 = max * (k - 8)\n            val max11 = max * (k - 9)\n            val max12 = max * (k - 10)\n            val max13 = max * (k - 11)\n            val max14 = max * (k - 12)\n            val max15 = max * (k - 13)\n            val max16 = max * (k - 14)\n            val max17 = max * (k - 15)\n            val max18 = max * (k - 16)\n            val max19 = max * (k - 17)\n            val max20 = max * (k - 18)\n            val max21 = max * (k - 19)\n            val max22 = max * (k - 20)\n            val max23 = max * (k - 21)\n            val max24 = max * (k - 22)\n            val max25 = max * (k - 23)\n            val max26 = max * (k - 24)\n            val max27 = max * (k - 25)\n            val max28 = max * (k - 26)\n            val max29 = max * (k - 27)\n            val max30 = max * (k - 28)\n            val max31 = max * (k - 29)\n            val max32 = max * (k - 30)\n            val max33 = max * (k - 31)\n            val max34 = max * (k - 32)\n            val max35 = max * (k - 33)\n            val max36 = max * (k - 34)\n            val max37 = max * (k - 35)\n            val max38 = max * (k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum < 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val aa = a.map(x => x * k)\n        val s = aa.sum\n        val m = aa.max\n        if (m > 0) {\n            val x = maxSubArraySum(aa, n)\n            if (x > 0) max(x, s - x) else s\n        } else m",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = (sum * (k - 1)) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else {\n            maxSum\n        }",
    "        val sums = new Array[Long](a.length)\n        sums(0) = a(0)\n        for (i <- 1 until a.length) sums(i) = sums(i - 1) + a(i)\n        var max = sums(0)\n        for (i <- 0 until a.length) {\n            for (j <- i until a.length) {\n                val sum = sums(j) - sums(i) + a(i) * (k - 2)\n                if (sum > max) max = sum\n            }\n        }\n        max",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefix = a.scanLeft(0L)(_ + _).drop(1).max\n            val maxSuffix = a.scanRight(0L)(_ + _).dropRight(1).max\n            val maxMiddle = maxPrefix + maxSuffix\n            List(maxSum, maxMiddle, max).max\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1) - maxSum)\n            max(maxSumRepeated, maxSumRepeatedWithMod)\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else sum * k - (a.map(x => if (x < 0) x else 0).sum)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) return maxSum * k\n        val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n        maxSumRepeated",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max(b(i).toLong, max_ending_here + b(i).toLong)\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSubArraySum = maxSubArraySum(a, n)\n        if (maxSum <= 0) maxSubArraySum\n        else if (maxSubArraySum <= 0) maxSum * k\n        else {\n            val maxPrefixSum = maxPrefixSumRepeated(a, n, k)\n            val maxSuffixSum = maxSuffixSumRepeated(a, n, k)\n            val maxMiddleSum = maxSubArraySumRepeated(a, n, k - 2)\n            max(maxPrefixSum, max(maxSuffixSum, max(maxMiddleSum, maxSubArraySum)))\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = Array.fill(n.toInt)(0L)\n        val suffixSum = Array.fill(n.toInt)(0L)\n        val maxPrefixSum = Array.fill(n.toInt)(0L)\n        val maxSuffixSum = Array.fill(n.toInt)(0L)\n        prefixSum(0) = a(0)\n        maxPrefixSum(0) = a(0)\n        for (i <- 1 until n.toInt) {\n            prefixSum(i) = prefixSum(i - 1) + a(i)\n            maxPrefixSum(i) = max(maxPrefixSum(i - 1), prefixSum(i))\n        }\n        suffixSum(n.toInt - 1) = a(n.toInt - 1)\n        maxSuffixSum(n.toInt - 1) = a(n.toInt - 1)\n        for (i <- n.toInt - 2 to 0 by -1) {\n            suffixSum(i) = suffixSum(i + 1) + a(i)\n            maxSuffixSum(i) = max(maxSuffixSum(i + 1), suffixSum(i))\n        }\n        var result = maxSumRepeated\n        for (i <- 0 until n.toInt) {\n            val left = maxPrefixSum(i)\n            val right = maxSuffixSum(i)\n            val middle = if (i == 0) 0 else prefixSum(i - 1)\n            val sum = left + right + middle\n            result = max(result, sum)\n        }\n        result",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) return maxSum * k\n        val maxSumRepeated = max(sum * k, maxSum + (sum * (k - 1)))\n        val prefixSum = Array.fill(n.toInt)(0L)\n        val suffixSum = Array.fill(n.toInt)(0L)\n        prefixSum(0) = a(0)\n        suffixSum(n.toInt - 1) = a(n.toInt - 1)\n        for (i <- 1 until n.toInt) {\n            prefixSum(i) = prefixSum(i - 1) + a(i)\n            suffixSum(n.toInt - 1 - i) = suffixSum(n.toInt - i) + a(n.toInt - 1 - i)\n        }\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            max = max(max, prefixSum(i), suffixSum(i))\n        }\n        max(maxSumRepeated, max)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else {\n            maxSum\n        }",
    "        val sums = new Array[Long](n.toInt)\n        sums(0) = a(0)\n        for (i <- 1 until n.toInt) sums(i) = sums(i - 1) + a(i)\n        var max = sums(0)\n        for (i <- 0 until n.toInt) {\n            val sum = sums(i) + k * sums(n.toInt - 1) - sums(i)\n            if (sum > max) max = sum\n        }\n        max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum > 0) {\n            val maxSumRepeated = maxSum * k\n            if (sum > 0) maxSumRepeated + (k - 1) * sum\n            else maxSumRepeated\n        }\n        else {\n            val maxSumRepeated = maxSum * k\n            if (sum > 0) maxSumRepeated + (k - 1) * sum\n            else maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(maxSum, sum * k)\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) return maxSum * k\n        val maxSumRepeated = max(sum * k, maxSum + (sum * (k - 1)))\n        val prefixSum = Array.fill(n.toInt)(0L)\n        val suffixSum = Array.fill(n.toInt)(0L)\n        prefixSum(0) = a(0)\n        suffixSum(n.toInt - 1) = a(n.toInt - 1)\n        for (i <- 1 until n.toInt) {\n            prefixSum(i) = prefixSum(i - 1) + a(i)\n            suffixSum(n.toInt - i - 1) = suffixSum(n.toInt - i) + a(n.toInt - i - 1)\n        }\n        var result = maxSumRepeated\n        for (i <- 0 until n.toInt) {\n            val maxPrefixSum = if (i == 0) 0 else prefixSum(i - 1)\n            val maxSuffixSum = if (i == n.toInt - 1) 0 else suffixSum(i + 1)\n            result = max(result, maxPrefixSum + maxSuffixSum)\n        }\n        result",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumIndex = a.indexOf(maxSum)\n        val maxSumLeft = a.take(maxSumIndex).sum\n        val maxSumRight = a.drop(maxSumIndex + 1).sum\n        val maxSumLeftRepeated = maxSumLeft + (k - 2) * sum + maxSumRight\n        val maxSumRightRepeated = maxSumRight + (k - 2) * sum + maxSumLeft\n        val maxSumRepeated = maxSum + (k - 1) * sum\n        val maxSumRepeated2 = maxSum + (k - 2) * sum\n        val maxSumRepeated3 = maxSum + (k - 3) * sum\n        val maxSumRepeated4 = maxSum + (k - 4) * sum\n        val maxSumRepeated5 = maxSum + (k - 5) * sum\n        val maxSumRepeated6 = maxSum + (k - 6) * sum\n        val maxSumRepeated7 = maxSum + (k - 7) * sum\n        val maxSumRepeated8 = maxSum + (k - 8) * sum\n        val maxSumRepeated9 = maxSum + (k - 9) * sum\n        val maxSumRepeated10 = maxSum + (k - 10) * sum\n        val maxSumRepeated11 = maxSum + (k - 11) * sum\n        val maxSumRepeated12 = maxSum + (k - 12) * sum\n        val maxSumRepeated13 = maxSum + (k - 13) * sum\n        val maxSumRepeated14 = maxSum + (k - 14) * sum\n        val maxSumRepeated15 = maxSum + (k - 15) * sum\n        val maxSumRepeated16 = maxSum + (k - 16) * sum\n        val maxSumRepeated17 = maxSum + (k - 17) * sum\n        val maxSumRepeated18 = maxSum + (k - 18) * sum\n        val maxSumRepeated19 = maxSum + (k - 19) * sum\n        val maxSumRepeated20 = maxSum + (k - 20) * sum\n        val maxSumRepeated21 = maxSum + (k - 21) * sum",
    "        var sum = 0L\n        for (i <- 0 until n.toInt) sum += a(i)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n.toInt) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n.toInt) {\n            max_wrap += a(i)\n            a(i) = -a(i)\n        }\n        for (i <- 0 until n.toInt) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_wrap = max_wrap + max_wrap\n        if (k > 1) {\n            val temp = max(max_so_far, max_wrap)\n            val ans = max(temp, sum * (k - 2) + temp)\n            ans\n        } else {\n            max(max_so_far, max_wrap)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefixSum = maxPrefixSumRepeated(a, n, k)\n            val maxSuffixSum = maxSuffixSumRepeated(a, n, k)\n            val maxPrefixSuffixSum = maxPrefixSuffixSumRepeated(a, n, k)\n            max(maxSum, max(maxPrefixSum, max(maxSuffixSum, maxPrefixSuffixSum)))\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSubArraySum = a.scanLeft(0L)((sum, x) => sum + x).drop(1).max\n        val maxSubArraySumRepeated = max(maxSubArraySum, maxSubArraySum + (k - 2) * sum)\n        max(maxSumRepeated, maxSubArraySumRepeated)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        }\n        else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1) - maxSum)\n            maxSumRepeatedWithMod\n        } else maxSum",
    "        val prefix = a.scanLeft(0L)(_ + _).tail\n        val suffix = a.scanRight(0L)(_ + _).init\n        val maxPrefix = prefix.scanLeft(0L)((x, y) => max(x, y)).tail\n        val maxSuffix = suffix.scanRight(0L)((x, y) => max(x, y)).init\n        val maxPrefixSuffix = maxPrefix.zip(maxSuffix).map(x => x._1 + x._2)\n        val maxPrefixSuffixSum = maxPrefixSuffix.max\n        val maxPrefixSum = maxPrefix.max\n        val maxSuffixSum = maxSuffix.max\n        val maxSum = maxPrefixSuffixSum + maxPrefixSum * (k - 2) + maxSuffixSum\n        val sum = prefix.last\n        val maxSumRepeated = max(maxSum, sum * k)\n        maxSumRepeated",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            if (max > 0) maxSum\n            else maxSum - (max * (k - 1))\n        } else {\n            val maxSum = max * k\n            if (sum < 0) maxSum\n            else maxSum - (sum * (k - 1))\n        }",
    "        val sum = a.sum\n        val maxSum = max(sum * k, maxSubArraySum(a))\n        maxSum",
    "        val sums = new Array[Long](n.toInt)\n        var max = Long.MinValue\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            sums(i) = sum\n            max = max max sum\n        }\n        if (k == 1) return max\n        var max_so_far = max\n        var max_ending_here = 0L\n        for (i <- 0 until n.toInt) {\n            max_ending_here += a(i)\n            max_so_far = max_so_far max max_ending_here\n            max_ending_here = max_ending_here max 0\n        }\n        var sum_of_all = sums(n.toInt - 1)\n        var min_sum_ending_here = 0L\n        var min_sum_so_far = Long.MaxValue\n        for (i <- 0 until n.toInt) {\n            min_sum_ending_here += a(i)\n            min_sum_so_far = min_sum_so_far min min_sum_ending_here\n            min_sum_ending_here = min_sum_ending_here min 0\n        }\n        var max_sum = max_so_far\n        if (k == 2) return max_sum\n        for (i <- 0 until n.toInt) {\n            max_sum = max_sum max (sum_of_all - min_sum_so_far + a(i))\n        }\n        max_sum",
    "        val sums = new Array[Long](n.toInt)\n        sums(0) = a(0)\n        for (i <- 1 until n.toInt) sums(i) = sums(i - 1) + a(i)\n        var max = sums(0)\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = sums(j) - sums(i) + a(i) * (k - 2)\n                if (i > 0) sum += sums(i - 1)\n                max = max max sum\n            }\n        }\n        max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) sum * k\n        else max(sum * k, maxSum + sum * (k - 1))",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + (sum * (k - 1)))\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else {\n            val maxSum = a.scanLeft(0L)(_ + _).drop(1).max\n            val maxSumRepeated = maxSum * (k - 1) + maxSum + sum * (k - 2)\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = (sum * k) max (maxSum + sum * (k - 2))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.map(abs(_)).max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = (sum * (k - 1)) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k - 1) - maxSum)\n            maxSumRepeatedWithMod\n        } else maxSum",
    "        val sums = new Array[Long](n.toInt)\n        sums(0) = a(0)\n        for (i <- 1 until n.toInt) {\n            sums(i) = sums(i - 1) + a(i)\n        }\n        val maxSum = sums.max\n        val minSum = sums.min\n        val maxSumRepeated = max(maxSum * k, sums(n.toInt - 1) * k - (minSum * (k - 1)))\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum < 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val prefixSum = new Array[Long](n.toInt)\n        prefixSum(0) = a(0)\n        for (i <- 1 until n.toInt) prefixSum(i) = prefixSum(i - 1) + a(i)\n        var maxSum = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = prefixSum(j) - prefixSum(i) + a(i)\n                maxSum = max(maxSum, sum)\n            }\n        }\n        maxSum * k - (prefixSum(n.toInt - 1) * k - prefixSum(n.toInt - 1))"
  ]
}