{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12wz0lwr.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12wz0lwr.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmp12wz0lwr.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp12wz0lwr.scala:15:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (x, y, z) = heap.dequeue\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp12wz0lwr.scala:15:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (x,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb4q1gpz4.scala:16)\n\tat Problem.main(tmpb4q1gpz4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmw4gip2u.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmw4gip2u.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpmw4gip2u.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmw4gip2u.scala:15:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (x, y, z) = heap.dequeue\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmw4gip2u.scala:15:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (x,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue(List(nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            result += heap.dequeue\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp44nx8vt7.scala:20)\n\tat Problem.main(tmp44nx8vt7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        for (i <- 0 until k.toInt if heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val x = index / nums2.length\n            val y = index % nums2.length\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_9949yi5.scala:17:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            result += List(nums1(x), nums2(y))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_9949yi5.scala:17:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            result += List(nums1(x), nums2(y))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (y : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, (i, j)) = pq.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpga8cvmag.scala:9:49 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                                 ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                 Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                                 Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpga8cvmag.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpga8cvmag.scala:16:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until n) {\n            heap.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < m) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5o15k5hu.scala:22)\n\tat Problem.main(tmp5o15k5hu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9bhv519x.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9bhv519x.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9bhv519x.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            pq.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (sum, index) = pq.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) pq.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2vl166q.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2vl166q.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2vl166q.scala:16:56 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) pq.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), i * nums2.length + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2vl166q.scala:16:67 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) pq.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), i * nums2.length + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val pair = List(nums1(i), nums2(j))\n                if (pq.size < k) pq.enqueue(pair)\n                else if (pq.head.sum > pair.sum) {\n                    pq.dequeue\n                    pq.enqueue(pair)\n                }\n            }\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqopzuf3j.scala:22)\n\tat Problem.main(tmpqopzuf3j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (a : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (b : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i1, i2, _) = heap.dequeue\n            result += List(nums1(i1.toInt), nums2(i2.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpo7hlz9fc.scala:23)\n\tat Problem.main(tmpo7hlz9fc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp57mkbo_w.scala:16)\n\tat Problem.main(tmp57mkbo_w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, n)) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, n * m)) {\n            val (sum, x, y) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y < m - 1) heap.enqueue((nums1(x.toInt) + nums2(y.toInt + 1), x, y + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx4v7csfq.scala:9:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, n)) heap.enqueue((nums1(i) + nums2(\u001b[31m0\u001b[0m), i, \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx4v7csfq.scala:11:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, n * m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (pq.size < k) pq.enqueue((nums1(i) + nums2(j), (i, j)))\n                else {\n                    if (nums1(i) + nums2(j) < pq.head._1) {\n                        pq.dequeue\n                        pq.enqueue((nums1(i) + nums2(j), (i, j)))\n                    }\n                }\n            }\n        }\n        pq.map(x => List(nums1(x._2._1), nums2(x._2._2))).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy_ze5kr1.scala:9:66 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                \u001b[33mif\u001b[0m (pq.size < k) pq.enqueue((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                  ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                      Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                                      Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy_ze5kr1.scala:13:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                        pq.enqueue((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (Int, Int)\n\u001b[31m   |\u001b[0m                                                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_ze5kr1.scala:18:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        pq.map(\u001b[36mx\u001b[0m => List(nums1(x._2._1), nums2(x._2._2))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_ze5kr1.scala:18:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        pq.map(\u001b[36mx\u001b[0m => List(nums1(x._2._1), nums2(x._2._2))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, num1, num2) = heap.dequeue\n            result = List(num1, num2) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyz3r6k52.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyz3r6k52.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(num1, num2) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (num1 : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyz3r6k52.scala:16:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(num1, num2) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (num2 : Any)\n\u001b[31m   |\u001b[0m                                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val q = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                q.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (q.isEmpty) return result.toList\n            val (sum, x, y) = q.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7f_4f9.scala:9:26 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                q.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                          Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                          Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7f_4f9.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7f_4f9.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, i, j) = heap.dequeue\n            result = List(i, j) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe3x_3vts.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe3x_3vts.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(i, j) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (i : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe3x_3vts.scala:16:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(i, j) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (j : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i, j + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1h32i2x4.scala:9:51 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                                   ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                   Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                                   Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1h32i2x4.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1h32i2x4.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1h32i2x4.scala:16:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), (i, j + \u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val q = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                q.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (q.isEmpty) return result\n            val (sum, i, j) = q.dequeue\n            result = List(i, j) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptzsffonh.scala:9:26 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                q.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                          Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                          Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptzsffonh.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(i, j) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (i : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptzsffonh.scala:16:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(i, j) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (j : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7lfv7twz.scala:10:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7lfv7twz.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                 Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7lfv7twz.scala:17:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        heap.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1m5idfkw.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1m5idfkw.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (a : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1m5idfkw.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (b : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap += ((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk2sex_8a.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk2sex_8a.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpk2sex_8a.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk2sex_8a.scala:14:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (x, y, _) = heap.dequeue\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk2sex_8a.scala:14:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (x,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result.append(List(pair._1, pair._2))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplx6ml3s9.scala:21)\n\tat Problem.main(tmplx6ml3s9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap.enqueue((nums1(i), nums2(0), nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k.toInt && heap.nonEmpty) {\n            val (x, y, _) = heap.dequeue\n            result += List(x, y)\n            if (y != nums2.last) {\n                val index = nums2.indexOf(y)\n                heap.enqueue((x, nums2(index + 1), x + nums2(index + 1)))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfa23_qjh.scala:22)\n\tat Problem.main(tmpfa23_qjh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb4q1gpz4.scala:16)\n\tat Problem.main(tmpb4q1gpz4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppuf518i4.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._1))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuf518i4.scala:6:76 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._1))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                          ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _1 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmppuf518i4.scala:6:79 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._1))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                               ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, product) = heap.dequeue\n            result = List(List(sum, product)) ::: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123033,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9jju9pyu.scala:21)\n\tat Problem.main(tmp9jju9pyu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length.toInt), nums2(index % nums2.length.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph6f2xdb6.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(index / nums2.length.toInt), nums2(index % nums2.length.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph6f2xdb6.scala:15:68 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(index / nums2.length.toInt), nums2(index % nums2.length.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap += ((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8m83ke7.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8m83ke7.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8m83ke7.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8m83ke7.scala:16:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap += ((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), i * nums2.length + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8m83ke7.scala:16:65 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j +",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3_9vl5ss.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3_9vl5ss.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3_9vl5ss.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pairs = for (i <- nums1; j <- nums2) yield (i, j)\n        pairs.sortBy(x => x._1 + x._2).take(k.toInt).map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result.append(List(i, j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9jmaij84.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp9jmaij84.scala:16:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.append(List(i, j))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g7yqc_a.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g7yqc_a.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g7yqc_a.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdlh_zhkw.scala:21)\n\tat Problem.main(tmpdlh_zhkw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0L until min(k, heap.size)) {\n            val (a, b, _) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnsb8g3m6.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnsb8g3m6.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnsb8g3m6.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnsb8g3m6.scala:14:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (a, b, _) = heap.dequeue\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnsb8g3m6.scala:14:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (a,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0din4k_8.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0din4k_8.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0din4k_8.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result.append(List(i, j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123042,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph7vyxcfk.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmph7vyxcfk.scala:16:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.append(List(i, j))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123042,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp945xpa6r.scala:10:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                             Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp945xpa6r.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp945xpa6r.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result.append(List(pair._1, pair._2))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplx6ml3s9.scala:21)\n\tat Problem.main(tmplx6ml3s9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, first, second) = heap.dequeue\n            result += List(first, second)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp89qycqep.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp89qycqep.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(first, second)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (first : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp89qycqep.scala:16:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(first, second)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (second : Any)\n\u001b[31m   |\u001b[0m                                  Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val n = nums1.size\n        val m = nums2.size\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(n, k.toInt)) {\n            pq.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.size < k && !pq.isEmpty) {\n            val (sum, i, j) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j < m - 1) pq.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9d0n65a5.scala:21)\n\tat Problem.main(tmp9d0n65a5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprkc00gli.scala:21)\n\tat Problem.main(tmprkc00gli.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result.append(List(i, j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123042,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa0i1qjpt.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpa0i1qjpt.scala:16:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.append(List(i, j))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0L until min(k, heap.size)) {\n            val (sum, x, y) = heap.dequeue\n            result = List(x, y) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphuptkpyf.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphuptkpyf.scala:15:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result = List(x, y) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (x : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphuptkpyf.scala:15:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result = List(x, y) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (y : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                pq.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqu60_0aj.scala:23)\n\tat Problem.main(tmpqu60_0aj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_9f6fyz.scala:9:47 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap += ((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                               ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                               Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                               Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_9f6fyz.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_9f6fyz.scala:16:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i * nums2.length) + j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuur57xk_.scala:8:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuur57xk_.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuur57xk_.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuur57xk_.scala:16:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), (i * nums2.length) + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuur57xk_.scala:16:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, a, b) = heap.dequeue\n            result = List(a, b) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit4g52dz.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit4g52dz.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(a, b) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (a : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit4g52dz.scala:16:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(a, b) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (b : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue(List(nums1(i), nums2(j)))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123046,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpthy2rkx_.scala:16)\n\tat Problem.main(tmpthy2rkx_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (a : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (b : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.size)) {\n            val (sum, index) = pq.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoytuzfvl.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoytuzfvl.scala:8:34 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until min(k, nums2.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                                  ^\u001b[0m\n\u001b[31m  |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m  |\u001b[0m                                  Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoytuzfvl.scala:13:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, pq.size)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoytuzfvl.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoytuzfvl.scala:15:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n\u001b[31m\u001b[31m   |\u001b[0m                       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmvq1k4e1.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, \u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, \u001b[1m\u001b[32mLong\u001b[0m)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmvq1k4e1.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmvq1k4e1.scala:16:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt if !heap.isEmpty) {\n            val (sum, x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpops22ny2.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpops22ny2.scala:15:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result.append(List(x, y))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < k) pq.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa4l_9ap4.scala:10:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (pq.size < k) pq.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa4l_9ap4.scala:13:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    pq.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                               Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa4l_9ap4.scala:17:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        pq.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                pq.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.length).toInt) {\n            val (a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdppn_xak.scala:20)\n\tat Problem.main(tmpdppn_xak.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9bhv519x.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9bhv519x.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9bhv519x.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val queue = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                queue.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (queue.isEmpty) return result.toList\n            val (sum, x, y) = queue.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcv04n6ki.scala:9:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                queue.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                              Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcv04n6ki.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcv04n6ki.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ArrayBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue()\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i * nums2.length) + (j + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprdlw0c55.scala:8:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprdlw0c55.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprdlw0c55.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprdlw0c55.scala:16:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), (i * nums2.length) + (j + \u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprdlw0c55.scala:16:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            val (i, j) = (index / nums2.length, index % nums2.length)\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5bs3zsg1.scala:14:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5bs3zsg1.scala:14:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5bs3zsg1.scala:15:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), i * nums2.length + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5bs3zsg1.scala:15:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), i * nums2.length + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation av",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            pq += ((i, 0, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until min(k, nums1.length * nums2.length).toInt) {\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) {\n                pq += ((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123047,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm7h0qlk1.scala:21)\n\tat Problem.main(tmpm7h0qlk1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9k8w84m1.scala:10:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9k8w84m1.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                 Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9k8w84m1.scala:17:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        while (!heap.isEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result.append(List(i, j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123053,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo3r5xgwc.scala:10:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                             Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpo3r5xgwc.scala:16:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.append(List(i, j))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue(List(nums1(i), nums2(j)))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4te0hrpf.scala:16)\n\tat Problem.main(tmp4te0hrpf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        var result = List[List[Long]]()\n        var pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        for (i <- 0 until k) {\n            if (pq.isEmpty) return result\n            val (x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123055,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpck_h4iji.scala:13:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_9f6fyz.scala:9:47 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap += ((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                               ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                               Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                               Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_9f6fyz.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_9f6fyz.scala:16:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2gkh6j8h.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2gkh6j8h.scala:13:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        pq.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpowex7oc3.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpowex7oc3.scala:16:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < k) pq.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqgs8ayua.scala:10:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (pq.size < k) pq.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqgs8ayua.scala:13:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    pq.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                               Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqgs8ayua.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        pq.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val sorted = (for (i <- nums1; j <- nums2) yield (i + j, List(i, j))).sortBy(_._1).take(k.toInt)\n        sorted.map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123058,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkkyqywui.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkkyqywui.scala:8:34 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until min(k, nums2.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                                  ^\u001b[0m\n\u001b[31m  |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m  |\u001b[0m                                  Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkkyqywui.scala:13:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length * nums2.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkkyqywui.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkkyqywui.scala:15:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n\u001b[31m\u001b[31m   |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp573ourmn.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp573ourmn.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp573ourmn.scala:14:52 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) pq.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pairs = nums1.flatMap(x => nums2.map(y => List(x, y))).sortWith((x, y) => x(0) + x(1) < y(0) + y(1))\n        pairs.take(k.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123058,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i), nums2(0)))\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (x, y) = heap.dequeue\n            result = List(x, y) :: result\n            if (y != nums2.last) heap.enqueue((x, nums2(nums2.indexOf(y) + 1)))\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkbvxeb7_.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkbvxeb7_.scala:11:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length * nums2.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6sfhs6sk.scala:16)\n\tat Problem.main(tmp6sfhs6sk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) {\n                heap += ((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123058,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb0yz_rrh.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb0yz_rrh.scala:6:86 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                    ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb0yz_rrh.scala:6:89 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                         ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb0yz_rrh.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (nums1(i), nums2(j))))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (x, y)) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123058,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6v8c9m3g.scala:9:51 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), (nums1(i), nums2(j))))\n\u001b[31m\u001b[31m  |\u001b[0m                                                   ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                   Found:    (Long, Long)\n\u001b[31m  |\u001b[0m                                                   Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp6v8c9m3g.scala:16:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.append(List(x, y))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb4q1gpz4.scala:16)\n\tat Problem.main(tmpb4q1gpz4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            heap.enqueue((i.toLong, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (i1, i2, sum) = heap.dequeue\n            result += List(nums1(i1.toInt), nums2(i2.toInt))\n            if (i2 + 1 < nums2.length) heap.enqueue((i1, i2 + 1, nums1(i1.toInt) + nums2(i2.toInt + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9_s2bxsh.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue(List(i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0kuzv1_l.scala:16)\n\tat Problem.main(tmp0kuzv1_l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y < nums2.length - 1) {\n                heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz1afowjk.scala:11:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length * nums2.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        var result = List[List[Long]]()\n        if (nums1.length == 0 || nums2.length == 0) return result\n        var heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        for (i <- 0 until min(k, nums1.length * nums2.length).toInt) {\n            val (sum, i, j) = heap.dequeue\n            result = List(nums1(i.toInt), nums2(j.toInt)) :: result\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpi4su604u.scala:18)\n\tat Problem.main(tmpi4su604u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0qcp1ehm.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0qcp1ehm.scala:13:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (heap.size < k) heap.enqueue((nums1(i), nums2(j)))\n                else {\n                    val (a, b) = heap.head\n                    if (nums1(i) + nums2(j) < a + b) {\n                        heap.dequeue\n                        heap.enqueue((nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvj5gegn2.scala:22)\n\tat Problem.main(tmpvj5gegn2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result += List(pair._1, pair._2)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhda6x06.scala:21)\n\tat Problem.main(tmpqhda6x06.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var res = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return res\n            val (sum, x, y) = pq.dequeue\n            res = List(x, y) :: res\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq5c53u_t.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq5c53u_t.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            res = List(x, y) :: res\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (x : Any)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq5c53u_t.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            res = List(x, y) :: res\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (y : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._1, x._2)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123061,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpla51g36t.scala:16)\n\tat Problem.main(tmpla51g36t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < k.toInt) pq.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123065,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqoa51dbc.scala:10:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (pq.size < k.toInt) pq.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqoa51dbc.scala:13:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    pq.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                               Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqoa51dbc.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        pq.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        var result = List[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result = List(nums1(i), nums2(0)) :: result\n            if (nums2.length > 1) heap += ((nums1(i) + nums2(1), i))\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123069,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4k93zxz9.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4k93zxz9.scala:13:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = List(nums1(i), nums2(\u001b[31m0\u001b[0m)) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4k93zxz9.scala:14:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap += ((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = pq.dequeue\n            result += List(nums1(index), nums2(i / nums1.length))\n            if (i / nums1.length + 1 < nums2.length) {\n                pq.enqueue((nums1(index) + nums2(i / nums1.length + 1), index))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz4bm_1ul.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz4bm_1ul.scala:11:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length * nums2.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz4bm_1ul.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(index), nums2(i / nums1.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz4bm_1ul.scala:15:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                pq.enqueue((nums1(index) + nums2(i / nums1.length + \u001b[31m1\u001b[0m), index))\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3_9vl5ss.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3_9vl5ss.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3_9vl5ss.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk30ulxxc.scala:10:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                             Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk30ulxxc.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk30ulxxc.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        var result = List[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result = List(nums1(i), nums2(0)) :: result\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxnoszn1a.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxnoszn1a.scala:13:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = List(nums1(i), nums2(\u001b[31m0\u001b[0m)) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxnoszn1a.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8i4a9bnj.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8i4a9bnj.scala:13:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        pq.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i + j, i, j))\n                else {\n                    val (sum, i1, j1) = heap.head\n                    if (i + j < sum) {\n                        heap.dequeue\n                        heap.enqueue((i + j, i, j))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmmkxodkc.scala:9:48 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                \u001b[33mif\u001b[0m (heap.size < k) heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                              Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                                              Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpmmkxodkc.scala:12:30 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                    \u001b[33mif\u001b[0m (i + j < sum) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((sum : Any))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmmkxodkc.scala:14:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                        heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                     Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmmkxodkc.scala:19:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        heap.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (a, b, c) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4ofml0el.scala:21)\n\tat Problem.main(tmp4ofml0el.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123069,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcl8dpq_j.scala:9:51 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                                   ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                   Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                                   Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcl8dpq_j.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcl8dpq_j.scala:16:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0L until min(k, pq.size)) {\n            val (a, b, c) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpv6kdg90k.scala:20)\n\tat Problem.main(tmpv6kdg90k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by((_ : (Long, Long, Long))._3).reverse)\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7qk7_zh4.scala:23)\n\tat Problem.main(tmp7qk7_zh4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- 0 until nums1.length) {\n            pq.enqueue((i.toLong, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (i, j, _) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) {\n                pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123073,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2i8cub7l.scala:21)\n\tat Problem.main(tmp2i8cub7l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        var result = List[List[Long]]()\n        var queue = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                queue.enqueue((i, j))\n            }\n        }\n        for (i <- 1 to k.toInt) {\n            if (queue.isEmpty) return result\n            val (a, b) = queue.dequeue\n            result = List(a, b) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpaiwhbhvs.scala:21)\n\tat Problem.main(tmpaiwhbhvs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                pq.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (pq.nonEmpty && result.length < k) {\n            val (sum, index) = pq.dequeue\n            val i = index / nums2.length.toInt\n            val j = index % nums2.length.toInt\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo3xzyljf.scala:17:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo3xzyljf.scala:17:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkrgh038s.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkrgh038s.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpkrgh038s.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9k8w84m1.scala:10:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9k8w84m1.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                 Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9k8w84m1.scala:17:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppldg17ho.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppldg17ho.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppldg17ho.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pairs = for (i <- nums1; j <- nums2) yield (i, j)\n        pairs.sortWith((a, b) => a._1 + a._2 < b._1 + b._2).take(k.toInt).map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123074,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7ymrpf4l.scala:23)\n\tat Problem.main(tmp7ymrpf4l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, _) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpey40m6xp.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpey40m6xp.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpey40m6xp.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpey40m6xp.scala:15:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (a, b, _) = heap.dequeue\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpey40m6xp.scala:15:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (a,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123073,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp50wiv4q1.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp50wiv4q1.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(x, y) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (x : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp50wiv4q1.scala:16:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(x, y) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (y : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcxnrq3g4.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcxnrq3g4.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcxnrq3g4.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123074,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpksetreaw.scala:21)\n\tat Problem.main(tmpksetreaw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123074,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyrip6dzz.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyrip6dzz.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyrip6dzz.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123077,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3s2bq7oc.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._1 + x._2))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3s2bq7oc.scala:6:80 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._1 + x._2))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                              ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _1 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3s2bq7oc.scala:6:90 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._1 + x._2))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123080,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnrthmb0b.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnrthmb0b.scala:6:82 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _3 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnrthmb0b.scala:6:85 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._3))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mBigDecimal\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnrthmb0b.scala:15:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m (x, y, _) = heap.dequeue\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnrthmb0b.scala:15:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ArrayBuffer[List[Long]]()\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(index) + nums2(1), index))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdj08oqsg.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdj08oqsg.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdj08oqsg.scala:14:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result += List(nums1(index), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdj08oqsg.scala:15:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(index) + nums2(\u001b[31m1\u001b[0m), index))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.length)) {\n            val (sum, x, y) = pq.dequeue\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfp8k2vy0.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfp8k2vy0.scala:8:34 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until min(k, nums2.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                                  ^\u001b[0m\n\u001b[31m  |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m  |\u001b[0m                                  Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfp8k2vy0.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((nums1(i) + nums2(j), i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, \u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, \u001b[1m\u001b[32mLong\u001b[0m)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfp8k2vy0.scala:13:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, pq.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfp8k2vy0.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(x), nums2(y))\n\u001b[31m\u001b[31m   |\u001b[0m                   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp89kwfqqe.scala:20)\n\tat Problem.main(tmp89kwfqqe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (i, j, _) = pq.dequeue\n            result.append(List(nums1(i.toInt), nums2(j.toInt)))\n            if (j + 1 < nums2.length) pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb3y45rub.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result.prepend(List(nums1(i), nums2(j)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnovt3iyv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, \u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, \u001b[1m\u001b[32mLong\u001b[0m)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnovt3iyv.scala:16:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.prepend(List(nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnovt3iyv.scala:16:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result.prepend(List(nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptkzd6di_.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptkzd6di_.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptkzd6di_.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt if !heap.isEmpty) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123086,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2jdkqpr_.scala:20)\n\tat Problem.main(tmp2jdkqpr_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i, j, _) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123086,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp61qsuc0a.scala:23)\n\tat Problem.main(tmp61qsuc0a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (x <- nums1) {\n            for (y <- nums2) {\n                heap.enqueue((x + y, x, y))\n            }\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp277uel1x.scala:10:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                heap.enqueue((x + y, x, y))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                             Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp277uel1x.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp277uel1x.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd86ojkp.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i), nums2(j)))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123086,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4vhvkvr_.scala:16)\n\tat Problem.main(tmp4vhvkvr_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i, j + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123086,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3ggt8z1t.scala:9:51 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n\u001b[31m\u001b[31m  |\u001b[0m                                                   ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                   Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                                                   Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3ggt8z1t.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3ggt8z1t.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3ggt8z1t.scala:16:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), (i, j + \u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(nums1(x._2 / nums2.length), nums2(x._2 % nums2.length))).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4_e59fh.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(nums1(x._2 / nums2.length), nums2(x._2 % nums2.length))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4_e59fh.scala:13:61 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(nums1(x._2 / nums2.length), nums2(x._2 % nums2.length))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i, j))\n                else {\n                    val (a, b) = heap.head\n                    if (i + j < a + b) {\n                        heap.dequeue\n                        heap.enqueue((i, j))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123086,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxso4xrdc.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._1 + x._2))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxso4xrdc.scala:6:80 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._1 + x._2))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                              ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _1 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxso4xrdc.scala:6:90 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(\u001b[36mx\u001b[0m => x._1 + x._2))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxso4xrdc.scala:11:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                    \u001b[33mval\u001b[0m (a, b) = heap.head\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxso4xrdc.scala:11:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k.toInt) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvxs_d_jz.scala:10:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                \u001b[33mif\u001b[0m (heap.size < k.toInt) heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                            Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvxs_d_jz.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    heap.enqueue((sum, nums1(i), nums2(j)))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                 Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvxs_d_jz.scala:17:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue()\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        while (heap.nonEmpty) {\n            val (sum, x, y) = heap.dequeue()\n            result.append(List(x, y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbfc0hpqm.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._1))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbfc0hpqm.scala:6:76 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._1))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                          ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                           value _1 is not a member of Any\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbfc0hpqm.scala:6:79 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)]()(Ordering.by(-_._1))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                               ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbfc0hpqm.scala:19:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m (sum, x, y) = heap.dequeue()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbfc0hpqm.scala:19:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m (sum, x, y) = heap.dequeue()\n\u001b[31m\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (a : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfpu3wip.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(a, b)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (b : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i + j, i * j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._1))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123087,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpn0q0l5qx.scala:16)\n\tat Problem.main(tmpn0q0l5qx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123087,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfrvutiut.scala:21)\n\tat Problem.main(tmpfrvutiut.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0qcp1ehm.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0qcp1ehm.scala:13:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_jrpfxrw.scala:14:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap.enqueue((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123087,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfcj4vas9.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfcj4vas9.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(nums1(x._2), nums2(x._3))).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123088,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp579sk2g7.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((nums1(i) + nums2(j), i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, \u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, \u001b[1m\u001b[32mLong\u001b[0m)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp579sk2g7.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        pq.map(\u001b[36mx\u001b[0m => List(nums1(x._2), nums2(x._3))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Long\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp579sk2g7.scala:13:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        pq.map(\u001b[36mx\u001b[0m => List(nums1(x._2), nums2(x._3))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i + j, i * j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._1)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123089,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6mpggoo1.scala:16)\n\tat Problem.main(tmp6mpggoo1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123093,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp799kvto9.scala:23)\n\tat Problem.main(tmp799kvto9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            val (i, j) = (index / nums2.length, index % nums2.length)\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123094,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2n924wco.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2n924wco.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2n924wco.scala:15:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2n924wco.scala:16:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < nums2.length) heap.enqueue((nums1(i) + nums2(j + \u001b[31m1\u001b[0m), i * nums2.length + j + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2n924wco.scala:16:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (j + \u001b[31m1\u001b[0m < num",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) for (j <- nums2) heap.enqueue((i + j, i, j))\n        var result = List[List[Long]]()\n        for (i <- 0 until min(k, heap.size)) {\n            val (sum, i, j) = heap.dequeue\n            result = List(i, j) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123094,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkyw66m7v.scala:7:55 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- nums1) \u001b[33mfor\u001b[0m (j <- nums2) heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                                                       ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                              Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                                              Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkyw66m7v.scala:9:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, heap.size)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkyw66m7v.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            result = List(i, j) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (i : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkyw66m7v.scala:11:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            result = List(i, j) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (j : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result\n            val (i1, i2, sum) = heap.dequeue\n            result = List(nums1(i1.toInt), nums2(i2.toInt)) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123095,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxq3zfkmb.scala:13:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(nums1(x._2), nums2(x._3))).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123096,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzcxx5_9g.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, \u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, \u001b[1m\u001b[32mLong\u001b[0m)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzcxx5_9g.scala:13:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(nums1(x._2), nums2(x._3))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzcxx5_9g.scala:13:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(nums1(x._2), nums2(x._3))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, _) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123097,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpz9rer3_q.scala:23)\n\tat Problem.main(tmpz9rer3_q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            val (sum, x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123095,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyfn9c3jo.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpyfn9c3jo.scala:15:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result.append(List(x, y))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[Long]*): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0m (elem: List[Long]): (result : scala.collection.mutable.ListBuffer[List[Long]])\n\u001b[31m   |\u001b[0mmatch arguments (List[Any])\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => -x._3))\n        for (i <- 0 until nums1.length) {\n            pq.enqueue((i.toLong, 0.toLong, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until k) {\n            if (pq.isEmpty) return result.toList\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123095,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw7hpgda0.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp57mkbo_w.scala:16)\n\tat Problem.main(tmp57mkbo_w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, x, y) = heap.dequeue\n            result = List(x, y) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123097,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc4v5p2l6.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc4v5p2l6.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(x, y) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (x : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc4v5p2l6.scala:16:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(x, y) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (y : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val queue = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                queue.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0L until k) {\n            if (queue.isEmpty) return result.toList\n            val (x, y) = queue.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123098,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmph60eyjpv.scala:21)\n\tat Problem.main(tmph60eyjpv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp48daxwpv.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp48daxwpv.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp48daxwpv.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pairs = for (i <- nums1; j <- nums2) yield List(i, j)\n        pairs.sortBy(x => x(0) + x(1)).take(k.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (heap.size < k) heap.enqueue(List(nums1(i), nums2(j)))\n                else {\n                    val sum = nums1(i) + nums2(j)\n                    if (sum < heap.head(0) + heap.head(1)) {\n                        heap.dequeue\n                        heap.enqueue(List(nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123098,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfphoumwo.scala:22)\n\tat Problem.main(tmpfphoumwo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0qcp1ehm.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0qcp1ehm.scala:13:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i), nums2(0)))\n        }\n        while (k > 0 && !heap.isEmpty) {\n            val (x, y) = heap.dequeue\n            result = result :+ List(x, y)\n            k -= 1\n            if (y != nums2.last) {\n                heap.enqueue((x, nums2(nums2.indexOf(y) + 1)))\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123097,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_jurkxbd.scala:14:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            k -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean k.!=?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap += ((nums1(i) + nums2(1), i))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqamaivf8.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqamaivf8.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += List(nums1(i), nums2(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqamaivf8.scala:14:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (nums2.length > \u001b[31m1\u001b[0m) heap += ((nums1(i) + nums2(\u001b[31m1\u001b[0m), i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        while (heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp42j_80_w.scala:10:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), i, j))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (Long, \u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m)\n\u001b[31m   |\u001b[0m                             Required: (Long, \u001b[1m\u001b[32mLong\u001b[0m)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp42j_80_w.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Any)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp42j_80_w.scala:16:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Any)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphx00j42o.scala:16)\n\tat Problem.main(tmphx00j42o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyx7g03fn.scala:18:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyx7g03fn.scala:18:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            result += List(nums1(i), nums2(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (j : Long)\n\u001b[31m   |\u001b[0m                                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8i4a9bnj.scala:9:27 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                pq.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                           Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                           Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8i4a9bnj.scala:13:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        pq.toList.map(\u001b[36mx\u001b[0m => List(x._2, x._3))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val result = new ListBuffer[List[Long]]\n        var i = 0\n        var j = 0\n        while (i < nums1.length && j < nums2.length && result.length < k) {\n            val sum = nums1(i) + nums2(j)\n            if (i + 1 < nums1.length && nums1(i + 1) + nums2(j) < sum) i += 1\n            else if (j + 1 < nums2.length && nums1(i) + nums2(j + 1) < sum) j += 1\n            else {\n                result += List(nums1(i), nums2(j))\n                if (i + 1 < nums1.length && j + 1 < nums2.length) {\n                    if (nums1(i + 1) + nums2(j) < nums1(i) + nums2(j + 1)) i += 1\n                    else j += 1\n                }\n                else if (i + 1 < nums1.length) i += 1\n                else j += 1\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpj7sz7a0s.scala:28)\n\tat Problem.main(tmpj7sz7a0s.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- 0 until nums1.length) {\n            pq += ((0, i, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k) {\n            if (pq.isEmpty) return result.toList\n            val (j, i, sum) = pq.dequeue\n            result += List(nums1(i), nums2(j.toInt))\n            if (j < nums2.length - 1) pq += ((j + 1, i, nums1(i) + nums2(j.toInt + 1)))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9mt409j9.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9mt409j9.scala:14:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result += List(nums1(i), nums2(j.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9mt409j9.scala:15:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (j < nums2.length - \u001b[31m1\u001b[0m) pq += ((j + \u001b[31m1\u001b[0m, i, nums1(i) + nums2(j.toInt + \u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(heap.size, k.toInt)) {\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbgiw0uvm.scala:20)\n\tat Problem.main(tmpbgiw0uvm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val n1 = nums1.length\n        val n2 = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, n1)) {\n            heap.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < n2) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt0as1eao.scala:9:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, n1)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnclbq2nf.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnclbq2nf.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (x : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnclbq2nf.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(x, y)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (y : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, num1, num2) = heap.dequeue\n            result += List(num1, num2)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb74nbdss.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb74nbdss.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(num1, num2)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (num1 : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb74nbdss.scala:16:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(num1, num2)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (num2 : Any)\n\u001b[31m   |\u001b[0m                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Any)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dot8z0s.scala:16:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result += List(i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (j : Any)\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, _) = heap.dequeue\n            result.append(List(a, b))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkgditmxu.scala:23)\n\tat Problem.main(tmpkgditmxu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1665510142,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb4q1gpz4.scala:16)\n\tat Problem.main(tmpb4q1gpz4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (pq.size < k) pq.enqueue(List(nums1(i), nums2(j)))\n                else {\n                    val sum = nums1(i) + nums2(j)\n                    if (sum < pq.head(0) + pq.head(1)) {\n                        pq.dequeue\n                        pq.enqueue(List(nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmps9bght5l.scala:22)\n\tat Problem.main(tmps9bght5l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, a, b) = heap.dequeue\n            result = List(a, b) :: result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit4g52dz.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit4g52dz.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(a, b) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (a : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit4g52dz.scala:16:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            result = List(a, b) :: result\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (b : Any)\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new BinaryHeap[(Long, Long, Long)](k.toInt)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.add((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            val (sum, x, y) = heap.remove\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq94mcpj2.scala:6:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mBinaryHeap\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)](k.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: type BinaryHeap\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq94mcpj2.scala:14:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (sum, x, y) = heap.remove\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq94mcpj2.scala:14:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (sum, x, y) = heap.remove\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq94mcpj2.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m (sum, x, y) = heap.remove\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq += ((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.size)) {\n            val (x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp91an2gk1.scala:7:30 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, nums1.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                              ^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    (k : Long)\n\u001b[31m  |\u001b[0m                              Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp91an2gk1.scala:8:34 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until min(k, nums2.length)) {\n\u001b[31m\u001b[31m  |\u001b[0m                                  ^\u001b[0m\n\u001b[31m  |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m  |\u001b[0m                                  Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp91an2gk1.scala:13:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until min(k, pq.size)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
      "timestamp": 1666123044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu318bykv.scala:9:29 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m                heap.enqueue((i + j, i, j))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Found:    (Long, Long\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m  |\u001b[0m                             Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu318bykv.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        heap.map(\u001b[36mx\u001b[0m => List(x._2, x._3)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value _3 is not a member of (Long, Long) - did you mean x._1?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}