{
  "name": "mbpp_308_large_product",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2dtaqcjy.scala:9:33 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.takeRight(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedMapRev = nums1SortedMap.map(_.swap)\n        val nums2SortedMapRev = nums2SortedMap.map(_.swap)\n        val nums1SortedMapRevSet = nums1SortedMapRev.keySet\n        val nums2SortedMapRevSet = nums2SortedMapRev.keySet\n        val nums1SortedMapRevList = nums1SortedMapRev.toList\n        val nums2SortedMapRevList = nums2SortedMapRev.toList\n        val nums1SortedMapRevListSorted = nums1SortedMapRevList.sortWith(_._1 > _._1)\n        val nums2SortedMapRevListSorted = nums2SortedMapRevList.sortWith(_._1 > _._1)\n        val nums1SortedMapRevListSortedMap = nums1SortedMapRevListSorted.toMap\n        val nums2SortedMapRevListSortedMap = nums2SortedMapRevListSorted.toMap\n        val nums1SortedMapRevListSortedMapSet = nums1SortedMapRevListSortedMap.keySet\n        val nums2SortedMapRevListSortedMapSet = nums2SortedMapRevListSortedMap.keySet\n        val nums1SortedMapRevListSortedMapSetList = nums1SortedMapRevListSortedMapSet.toList\n        val nums2SortedMapRevListSortedMapSetList = nums2SortedMapRevListSortedMapSet.toList\n        val nums1SortedMapRevListS\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5sy8rjir.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5sy8rjir.scala:27:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) {\n                    pq.enqueue((sorted1(i), sorted2(j), product))\n                } else if (pq.head._3 < product) {\n                    pq.dequeue\n                    pq.enqueue((sorted1(i), sorted2(j), product))\n                }\n            }\n        }\n        pq.map(_._3).toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510030,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0s3d7i92.scala:23)\n\tat Problem.main(tmp0s3d7i92.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySorted = nums1SortedReversedSetArray.sorted\n        val nums2SortedReversedSetArraySorted = nums2SortedReversedSetArray.sorted\n        val nums1SortedReversedSetArraySortedSize = nums1SortedReversedSetArraySorted.size\n        val nums2SortedReversedSetArraySortedSize = nums2SortedReversedSetArraySorted.size\n        val nums1SortedReversedSetArraySortedReversed = nums1SortedReversedSetArraySorted.reverse\n        val nums2SortedReversedSetArraySortedReversed = nums2SortedReversedSetArraySorted.reverse\n        val nums1SortedReversedSetArraySortedReversedSize = nums1SortedReversedSetArraySortedReversed.size\n        val nums2SortedReversedSetArraySortedRevers\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw5g9oat4.scala:26:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw5g9oat4.scala:26:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val products = new ArrayBuffer[Long]()\n        for (i <- 0 until nums1Sorted.length; j <- 0 until nums2Sorted.length) {\n            products += nums1Sorted(i) * nums2Sorted(j)\n        }\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyhsogfrx.scala:12:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        products.sortWith(_ > _).take(N.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    scala.collection.mutable.ArrayBuffer[Long]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySorted = nums1SortedReversedSetArray.sorted\n        val nums2SortedReversedSetArraySorted = nums2SortedReversedSetArray.sorted\n        val nums1SortedReversedSetArraySortedReversed = nums1SortedReversedSetArraySorted.reverse\n        val nums2SortedReversedSetArraySortedReversed = nums2SortedReversedSetArraySorted.reverse\n        val nums1SortedReversedSetArraySortedReversedSize = nums1SortedReversedSetArraySortedReversed.size\n        val nums2SortedReversedSetArraySortedReversedSize = nums2SortedReversedSetArraySortedReversed.size\n        val nums1SortedReversedSetArraySortedReversedMap = nums1SortedReversedSetArraySortedReversed.zipWithIndex.toMap\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsmiu6ou6.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val max1 = sorted1(0)\n        val max2 = sorted2(0)\n        val max = max1 * max2\n        val min1 = sorted1(sorted1.length - 1)\n        val min2 = sorted2(sorted2.length - 1)\n        val min = min1 * min2\n        val result = new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        var count = 0\n        while (count < N) {\n            val product = sorted1(i) * sorted2(j)\n            if (product == max) {\n                result += product\n                count += 1\n                i += 1\n                j += 1\n            } else if (product > max) {\n                result += product\n                count += 1\n                i += 1\n                j += 1\n            } else if (product < max) {\n                if (sorted1(i) > sorted2(j)) {\n                    i += 1\n                } else {\n                    j += 1\n                }\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "java.lang.IndexOutOfBoundsException: 6\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.largeProduct(tmp3vn996qa.scala:19)\n\tat Problem$.main(tmp3vn996qa.scala:41)\n\tat Problem.main(tmp3vn996qa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122856,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqv4nmc.scala:9:33 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.takeRight(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse\n        products.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(product)\n                else if (product > pq.head) {\n                    pq.dequeue\n                    pq.enqueue(product)\n                }\n            }\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0au6tas5.scala:22)\n\tat Problem.main(tmp0au6tas5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk7id0_t_.scala:7:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 to nums1.length - 1; j <- 0 to nums2.length - 1) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122857,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp65wxpojp.scala:9:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122856,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqv4nmc.scala:9:33 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.takeRight(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1Set = nums1Sorted.toSet\n        val nums2Set = nums2Sorted.toSet\n        val nums1Map = nums1Sorted.zipWithIndex.toMap\n        val nums2Map = nums2Sorted.zipWithIndex.toMap\n        val nums1Index = nums1Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums2Index = nums2Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums1IndexReverse = nums1Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums2IndexReverse = nums2Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums1IndexReverseMap = nums1Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums2IndexReverseMap = nums2Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums1IndexMap = nums1Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums2IndexMap = nums2Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums1IndexReverseSet = nums1Sorted.zipWithIndex.map(x => (x._2, x._1)).toSet\n        val nums2IndexReverseSet = nums2Sorted.zipWithIndex.map(x => (x._2, x._1)).toSet\n        val nums1IndexSet = nums1Sorted.zipWithIndex.map(x => (x._1, x._2)).toSet\n        val nums2IndexSet = nums2Sorted\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122857,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1i8d_280.scala:24:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue((product, sorted1(i)))\n                else if (product > pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((product, sorted1(i)))\n                }\n            }\n        }\n        pq.toList.map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpz0nhv5mv.scala:22)\n\tat Problem.main(tmpz0nhv5mv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        val set = new HashSet[(Int, Int)]()\n        pq.enqueue((sorted1.last * sorted2.last, sorted1.length - 1, sorted2.length - 1))\n        set.add((sorted1.length - 1, sorted2.length - 1))\n        var result = List[Long]()\n        while (result.length < N) {\n            val (product, i, j) = pq.dequeue\n            result = result :+ product\n            if (i - 1 >= 0 && !set.contains((i - 1, j))) {\n                pq.enqueue((sorted1(i - 1) * sorted2(j), i - 1, j))\n                set.add((i - 1, j))\n            }\n            if (j - 1 >= 0 && !set.contains((i, j - 1))) {\n                pq.enqueue((sorted1(i) * sorted2(j - 1), i, j - 1))\n                set.add((i, j - 1))\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq += ((product, i, j))\n                else if (product > pq.head._1) {\n                    pq.dequeue\n                    pq += ((product, i, j))\n                }\n            }\n        }\n        pq.map(_._1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt2u0nmwp.scala:22)\n\tat Problem.main(tmpt2u0nmwp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpozs4q2cv.scala:9:37 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sortWith(_ > _).take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse.take(N.toInt)\n        nums\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val pq = new PriorityQueue[Long]()\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val p = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(p)\n                else if (pq.head < p) {\n                    pq.dequeue\n                    pq.enqueue(p)\n                }\n            }\n        }\n        pq.toList.sortWith(_ > _)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprvxpisbr.scala:22)\n\tat Problem.main(tmprvxpisbr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                val p = i * j\n                if (pq.size < N) pq.enqueue(p)\n                else if (pq.head < p) {\n                    pq.dequeue\n                    pq.enqueue(p)\n                }\n            }\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx0du2f9h.scala:20)\n\tat Problem.main(tmpx0du2f9h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        var products = new ArrayBuffer[Long]\n        for (num1 <- nums1; num2 <- nums2) products += num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122857,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdo2gda5i.scala:8:37 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        products.sortWith(_ > _).take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    scala.collection.mutable.ArrayBuffer[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) {\n            val product = sorted1(i) * sorted2(j)\n            if (heap.size < N) heap += product\n            else if (heap.head < product) {\n                heap.dequeue\n                heap += product\n            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41u1abf3.scala:8:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()(Ordering.by(-_))\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41u1abf3.scala:8:65 -------------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()(Ordering.by(-_))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                 ^^\u001b[0m\n\u001b[31m  |\u001b[0mvalue unary_- is not a member of Any, but could be made available as an extension method.\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m  |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m  |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m  |\u001b[0m\n\u001b[31m\u001b[31m-- Error: /tmp/tmp41u1abf3.scala:8:68 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mheap\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()(Ordering.by(-_))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m  |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[S] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mby\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1Max = nums1Sorted.last\n        val nums2Max = nums2Sorted.last\n        val nums1Min = nums1Sorted.head\n        val nums2Min = nums2Sorted.head\n        val nums1MaxIndex = nums1.indexOf(nums1Max)\n        val nums2MaxIndex = nums2.indexOf(nums2Max)\n        val nums1MinIndex = nums1.indexOf(nums1Min)\n        val nums2MinIndex = nums2.indexOf(nums2Min)\n        val nums1MaxIndex2 = nums1.lastIndexOf(nums1Max)\n        val nums2MaxIndex2 = nums2.lastIndexOf(nums2Max)\n        val nums1MinIndex2 = nums1.lastIndexOf(nums1Min)\n        val nums2MinIndex2 = nums2.lastIndexOf(nums2Min)\n        val nums1MaxIndex3 = nums1.indexWhere(_ == nums1Max)\n        val nums2MaxIndex3 = nums2.indexWhere(_ == nums2Max)\n        val nums1MinIndex3 = nums1.indexWhere(_ == nums1Min)\n        val nums2MinIndex3 = nums2.indexWhere(_ == nums2Min)\n        val nums1MaxIndex4 = nums1.lastIndexWhere(_ == nums1Max)\n        val nums2MaxIndex4 = nums2.lastIndexWhere(_ == nums2Max)\n        val nums1MinIndex4 = nums1.lastIndexWhere(_ == nums1Min)\n        val nums2MinIndex4 = nums2.lastIndexWhere(_ == nums2Min)\n        val nums1MaxIndex5 = nums1.indexOf(nums1Max, nums1MaxIndex + 1)\n        val nums2MaxIndex5 = nums2.indexOf(nums2Max, nums2MaxIndex +\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122857,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpcl5l0g49.scala:29:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums2MaxIndex5\u001b[0m = nums2.indexOf(nums2Max, nums2MaxIndex +\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcl5l0g49.scala:30:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse.take(N.toInt)\n        nums\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk929f_bn.scala:9:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedRev = nums1Sorted.reverse\n        val nums2SortedRev = nums2Sorted.reverse\n        val nums1SortedRevIndex = nums1SortedRev.zipWithIndex.toMap\n        val nums2SortedRevIndex = nums2SortedRev.zipWithIndex.toMap\n        val nums1SortedRevIndexed = nums1SortedRev.zipWithIndex\n        val nums2SortedRevIndexed = nums2SortedRev.zipWithIndex\n        val nums1SortedRevIndexedSorted = nums1SortedRevIndexed.sortBy(_._1)\n        val nums2SortedRevIndexedSorted = nums2SortedRevIndexed.sortBy(_._1)\n        val nums1SortedRevIndexedSortedRev = nums1SortedRevIndexedSorted.reverse\n        val nums2SortedRevIndexedSortedRev = nums2SortedRevIndexedSorted.reverse\n        val nums1SortedRevIndexedSortedRevIndex = nums1SortedRevIndexedSortedRev.zipWithIndex.toMap\n        val nums2SortedRevIndexedSortedRevIndex = nums2SortedRevIndexedSortedRev.zipWithIndex.toMap\n        val nums1SortedRevIndexedSortedRevIndexed = nums1SortedRevIndexedSortedRev.zipWithIndex\n        val nums2SortedRevIndexedSortedRevIndexed = nums2SortedRevIndexedSortedRev.zipWithIndex\n        val nums1SortedRevIndexedSortedRevIndexedSorted = nums1SortedRevIndexedSortedRevIndexed.sortBy(_._1._1)\n        val nums2SortedRevIndexedSortedRevIndexedSorted = nums2SortedRevIndexedSortedRevIndexed.sortBy(_._1._1)\n        val nums1SortedRevIndexedSortedRevIndexedSortedRev = nums1SortedRevIndexedSorted\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphlbp8_vn.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedMapReverse = nums1SortedMap.map(_.swap)\n        val nums2SortedMapReverse = nums2SortedMap.map(_.swap)\n        val nums1SortedMapReverseSet = nums1SortedMapReverse.keySet\n        val nums2SortedMapReverseSet = nums2SortedMapReverse.keySet\n        val nums1SortedMapReverseList = nums1SortedMapReverse.toList\n        val nums2SortedMapReverseList = nums2SortedMapReverse.toList\n        val nums1SortedMapReverseListSorted = nums1SortedMapReverseList.sortWith(_._1 > _._1)\n        val nums2SortedMapReverseListSorted = nums2SortedMapReverseList.sortWith(_._1 > _._1)\n        val nums1SortedMapReverseListSortedMap = nums1SortedMapReverseListSorted.toMap\n        val nums2SortedMapReverseListSortedMap = nums2SortedMapReverseListSorted.toMap\n        val nums1SortedMapReverseListSortedMapReverse = nums1SortedMapReverseListSortedMap.map(_.swap)\n        val nums2SortedMapReverseListSortedMapReverse = nums2SortedMapReverseListSortedMap.map(_.swap)\n        val nums1SortedMapReverseListSortedMapReverseSet\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122857,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmph2_0a9lg.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2_0a9lg.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for(x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122858,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = new Array[Long](nums1.length * nums2.length)\n        for (i <- 0 until nums1.length; j <- 0 until nums2.length) {\n            products(i * nums2.length + j) = nums1(i) * nums2(j)\n        }\n        products.sorted.reverse.take(N.toInt).toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt).toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkdnwvy9u.scala:10)\n\tat Problem.main(tmpkdnwvy9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2dtaqcjy.scala:9:33 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.takeRight(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val heap = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        heap.enqueue((sorted1(0) * sorted2(0), 0, 0))\n        val result = new ListBuffer[Long]()\n        for (i <- 1 to N.toInt) {\n            val (product, index1, index2) = heap.dequeue\n            result += product\n            if (index1 + 1 < sorted1.length) heap.enqueue((sorted1(index1 + 1) * sorted2(index2), index1 + 1, index2))\n            if (index2 + 1 < sorted2.length) heap.enqueue((sorted1(index1) * sorted2(index2 + 1), index1, index2 + 1))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxbv6p6dx.scala:20)\n\tat Problem.main(tmpxbv6p6dx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for {\n            i <- nums1\n            j <- nums2\n        } yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpycuhtlbt.scala:13)\n\tat Problem.main(tmpycuhtlbt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk7id0_t_.scala:7:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe12abytc.scala:10)\n\tat Problem.main(tmpe12abytc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe12abytc.scala:10)\n\tat Problem.main(tmpe12abytc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue((product, sorted1(i)))\n                else if (product > pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((product, sorted1(i)))\n                }\n            }\n        }\n        pq.map(_._1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe45qflv1.scala:22)\n\tat Problem.main(tmpe45qflv1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for {\n            num1 <- nums1\n            num2 <- nums2\n        } yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122862,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjb0jld4e.scala:9:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse.take(N.toInt)\n        nums\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122859,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk929f_bn.scala:9:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmperadgios.scala:10)\n\tat Problem.main(tmperadgios.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.takeRight(N.toInt).toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb07eyiod.scala:10)\n\tat Problem.main(tmpb07eyiod.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpozs4q2cv.scala:9:37 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sortWith(_ > _).take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until nums1.length; j <- 0 until nums2.length) {\n            pq += nums1(i) * nums2(j)\n            if (pq.size > N) pq.dequeue\n        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122862,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpv5b_v27d.scala:14)\n\tat Problem.main(tmpv5b_v27d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk929f_bn.scala:9:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (a <- nums1; b <- nums2) yield a * b\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122862,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122862,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122856,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqv4nmc.scala:9:33 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        products.sorted.takeRight(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1Set = nums1Sorted.toSet\n        val nums2Set = nums2Sorted.toSet\n        val nums1Map = nums1Sorted.zipWithIndex.toMap\n        val nums2Map = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedWithIndex = nums1Sorted.zipWithIndex\n        val nums2SortedWithIndex = nums2Sorted.zipWithIndex\n        val result = new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        while (result.length < N) {\n            val num1 = nums1Sorted(i)\n            val num2 = nums2Sorted(j)\n            val product = num1 * num2\n            if (result.length == 0 || result.last != product) {\n                result += product\n                if (result.length == N) return result.toList\n            }\n            if (num1 > num2) {\n                if (i < nums1.length - 1) i += 1\n                else j += 1\n            } else if (num1 < num2) {\n                if (j < nums2.length - 1) j += 1\n                else i += 1\n            } else {\n                val i1 = nums1Map(num1)\n                val i2 = nums2Map(num2)\n                if (i1 < nums1.length - 1 && i2 < nums2.length - 1) {\n                    if (nums1Sorted(i1 + 1) > nums2Sorted(i2 + 1)) i += 1\n                    else j += 1\n                } else if (i1 < nums1.length - 1) i += 1\n                else if (i2 < nums2.length - 1) j += 1\n                else {\n                    i += 1\n                    j += 1\n                }\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122863,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpn65oh8oo.scala:48)\n\tat Problem.main(tmpn65oh8oo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedIndex = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedIndex = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedIndexReverse = nums1SortedIndex.map(_.swap)\n        val nums2SortedIndexReverse = nums2SortedIndex.map(_.swap)\n        val nums1SortedIndexReverseSet = nums1SortedIndexReverse.toSet\n        val nums2SortedIndexReverseSet = nums2SortedIndexReverse.toSet\n        val nums1SortedIndexReverseMap = nums1SortedIndexReverse.toMap\n        val nums2SortedIndexReverseMap = nums2SortedIndexReverse.toMap\n        val nums1SortedIndexReverseMapReverse = nums1SortedIndexReverseMap.map(_.swap)\n        val nums2SortedIndexReverseMapReverse = nums2SortedIndexReverseMap.map(_.swap)\n        val nums1SortedIndexReverseMapReverseSet = nums1SortedIndexReverseMapReverse.toSet\n        val nums2SortedIndexReverseMapReverseSet = nums2SortedIndexReverseMapReverse.toSet\n        val nums1SortedIndexReverseMapReverseMap = nums1SortedIndexReverseMapReverse.toMap\n        val nums2SortedIndexReverseMapReverseMap = nums2SortedIndex\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122862,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp05uazayp.scala:26:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk7id0_t_.scala:7:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        products.sorted.reverse.take(N.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    IndexedSeq[Long]\n\u001b[31m  |\u001b[0m        Required: List[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for(num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122846,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpo85cm8al.scala:10)\n\tat Problem.main(tmpo85cm8al.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReverse = nums1Sorted.reverse\n        val nums2SortedReverse = nums2Sorted.reverse\n        val nums1SortedReverseSet = nums1SortedReverse.toSet\n        val nums2SortedReverseSet = nums2SortedReverse.toSet\n        val nums1SortedReverseSetSize = nums1SortedReverseSet.size\n        val nums2SortedReverseSetSize = nums2SortedReverseSet.size\n        val nums1SortedReverseSetSizeMinusOne = nums1SortedReverseSetSize - 1\n        val nums2SortedReverseSetSizeMinusOne = nums2SortedReverseSetSize - 1\n        val nums1SortedReverseSetSizeMinusOneDouble = nums1SortedReverseSetSizeMinusOne.toDouble\n        val nums2SortedReverseSetSizeMinusOneDouble = nums2SortedReverseSetSizeMinusOne.toDouble\n        val nums1SortedReverseSetSizeMinusOneDoubleSqrt = sqrt(nums1SortedReverseSetSizeMinusOneDouble)\n        val nums2SortedReverseSetSizeMinusOneDoubleSqrt = sqrt(nums2SortedReverseSetSizeMinusOneDouble)\n        val nums1SortedReverseSetSizeMinusOneDoubleSqrtCeil = ceil(nums1SortedReverseSetSizeMinusOneDoubleSqrt)\n        val nums2SortedReverseSetSizeMinusOneDoubleSqrtCeil = ceil(nums2SortedReverseSetSizeMinusOneDoubleSqrt)\n        val nums1SortedReverseSetSizeMinusOneDoubleSqrtCeilInt = nums1SortedReverseSetSizeMinusOneDoubleSqrtCeil.toInt\n        val num\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122862,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw1giz7k3.scala:24:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw1giz7k3.scala:24:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510026,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu18sem4.scala:10)\n\tat Problem.main(tmptu18sem4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val result = new ListBuffer[Long]\n        var i = sorted1.length - 1\n        var j = sorted2.length - 1\n        while (result.length < N) {\n            if (sorted1(i) * sorted2(j) > sorted1(i - 1) * sorted2(j - 1)) {\n                result += sorted1(i) * sorted2(j)\n                i -= 1\n            } else {\n                result += sorted1(i - 1) * sorted2(j - 1)\n                i -= 1\n                j -= 1\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122863,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnuuxybfu.scala:24)\n\tat Problem.main(tmpnuuxybfu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1665510025,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqkzvfoej.scala:10)\n\tat Problem.main(tmpqkzvfoej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}