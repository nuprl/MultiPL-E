{
  "name": "mbpp_260_newman_prime",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the nth newman\u2013shanks\u2013williams prime number.\n    def newmanPrime(n : Long) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(newmanPrime((3l)) == (7l));\n    assert(newmanPrime((4l)) == (17l));\n    assert(newmanPrime((5l)) == (41l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextNewmanPrime(p)\n            count += 1\n        }\n        p",
    "        var i = 1L\n        var count = 0L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(10)) {\n                var j = i - 1\n                var flag = true\n                while (j > 1 && flag) {\n                    if (BigInt(i).modPow(j, i * i) == 1) flag = false\n                    j -= 1\n                }\n                if (flag) count += 1\n            }\n        }\n        i",
    "        var p = 2L;\n        var i = 0L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        def isPrime(n : Long) : Boolean = {\n            if (n < 2) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var i = 1\n        var count = 0\n        while (count < n) {\n            i += 2\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n        }\n        return i",
    "        var i = 0\n        var p = 1\n        while (i < n) {\n            p += 2\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var count = 0;\n        var i = 2;\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1;\n            i += 1;\n        }\n        return i - 1;",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var i = 0\n        var p = 2L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 5 == 1) i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isPrime(2 * p + 1)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            val m = n - 1\n            val s = m.toBinaryString.count(_ == '1')\n            val d = m / pow(2, s).toLong\n            for (a <- 2 to min(n - 1, 100)) {\n                if (BigInt(a).modPow(d, n) != 1) {\n                    var found = false\n                    for (r <- 0 until s) {\n                        if (BigInt(a).modPow(d * pow(2, r).toLong, n) == n - 1) {\n                            found = true\n                            break\n                        }\n                    }\n                    if (!found) return false\n                }\n            }\n            return true\n        }\n        var count = 0\n        var i = 2\n        while (count < n) {\n            if (isPrime(i) && isNewmanPrime(i)) count += 1\n            i += 1\n        }\n        return i - 1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                val sqrt = sqrt(i).toLong\n                var j = 1L\n                var flag = true\n                while (j <= sqrt && flag) {\n                    if (i % j == 0) {\n                        val k = i / j\n                        if ((j + k) % 2 == 0) {\n                            flag = false\n                        }\n                    }\n                    j += 1\n                }\n                if (flag) {\n                    count += 1\n                }\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var i = 1L\n        var count = 0L\n        while (count < n) {\n            i += 1\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n        }\n        return 2 * i + 1",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        var p = 5;\n        while (primes.length < n) {\n            var isPrime = true;\n            for (prime <- primes) {\n                if (p % prime == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) primes += p;\n            p += 2;\n        }\n        primes(n.toInt - 1);",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 1\n        while (primes.length < n) {\n            val p = primes(i)\n            val q = primes(i - 1)\n            val candidate = (p * p * 2) - (q * q)\n            if (isPrime(candidate)) primes += candidate\n            i += 1\n        }\n        primes.last",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && (i - 1) % (2 * i - 1) == 0) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        var p = 2L;\n        var q = 2L;\n        var i = 0;\n        while (i < n) {\n            p = 2 * q + 1;\n            q = 2 * p + 1;\n            i += 2;\n        }\n        if (i == n) p else q",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        primes += 5\n        var i = 0\n        var p = primes(i)\n        while (primes.length < n) {\n            i += 1\n            p = primes(i)\n            var q = p\n            while (q < p * p) {\n                q *= p\n            }\n            primes += q + 1\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L; var i = 0L\n        while (i < n) {\n            p = p + 1\n            if (isPrime(p)) {\n                var k = 1L\n                while (isPrime(p + 2 * k * k)) k += 1\n                if (p + 2 * k * k == p) i += 1\n            }\n        }\n        p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = p + 1\n            if (BigInt(p).isProbablePrime(100)) {\n                i = i + 1\n            }\n        }\n        p",
    "        var p = 2L; var q = 1L; var i = 1L; var k = 1L\n        while (i < n) {\n            k += 1\n            if (p % q == 0) {\n                p += 1\n                q = 1\n            } else {\n                q += 1\n                if (p % q == 0) {\n                    p += 1\n                    q = 1\n                } else {\n                    i += 1\n                    p += 2\n                    q = 1\n                }\n            }\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i)) {\n                if (isPrime((i - 1) / 2)) {\n                    count += 1\n                    if (count == n) return i\n                }\n            }\n            i += 1\n        }\n        return -1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                if (BigInt(i - 1).isProbablePrime(10)) {\n                    if (BigInt(i + 1).isProbablePrime(10)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i)) {\n                if (isPrime(2 * i + 1)) {\n                    count += 1\n                    if (count == n) return i\n                }\n            }\n            i += 1\n        }\n        return -1",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var i = 1L\n        var p = 2L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 3L\n        var i = 1L\n        while (i < n) {\n            p = p + 2 * (p - 1)\n            if (BigInt(p).isProbablePrime(100)) i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextNewmanPrime(p)\n            count += 1\n        }\n        return p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 2\n        var p = 5\n        while (i <= n) {\n            var isPrime = true\n            for (j <- 0 until primes.length) {\n                if (p % primes(j) == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) {\n                primes += p\n                i += 1\n            }\n            p += 2\n        }\n        primes(n - 1)",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 5\n        while (primes.length < n) {\n            var isPrime = true\n            for (p <- primes) {\n                if (i % p == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) primes += i\n            i += 2\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p += 2 * (pow(2, p) - 1)\n            if (BigInt(p).isProbablePrime(100)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = p * 2 + 1\n            if (BigInt(p).isProbablePrime(100)) i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = p + 2 * (pow(2, p) - 1).toLong\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var i = 1L\n        var count = 0L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) count += 1\n        }\n        return i",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) {\n                i += 1\n            }\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(1)) {\n                val x = (i - 1) / 2\n                if (BigInt(x).isProbablePrime(1)) count += 1\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while(i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        return p",
    "        var p = 2L;\n        var c = 0L;\n        while (c < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) c += 1;\n        }\n        return p;",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n % 2 == 0) return false\n            if (isPrime(n)) return true\n            if (isPrime(n - 2)) return true\n            return false\n        }\n        var count = 0\n        var i = 1\n        while (count < n) {\n            i += 2\n            if (isNewmanPrime(i)) count += 1\n        }\n        return i",
    "        var p = 2L;\n        var count = 0L;\n        while (count < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) count += 1;\n        }\n        p",
    "        var i = 1L;\n        var count = 0L;\n        while (count < n) {\n            i += 2;\n            if (isNewmanPrime(i)) count += 1;\n        }\n        return i;",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                var j = 1L\n                var isPrime = true\n                while (j * j <= i) {\n                    if (i % j == 0) {\n                        if ((j + 1) % 4 == 0) {\n                            isPrime = false\n                        }\n                    }\n                    j += 1\n                }\n                if (isPrime) {\n                    count += 1\n                }\n            }\n        }\n        i",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2; primes += 3; primes += 5; primes += 7; primes += 11; primes += 13; primes += 17; primes += 19; primes += 23; primes += 29;\n        var i = 0;\n        while (primes.length < n) {\n            var p = primes(i);\n            var q = primes(i + 1);\n            var x = p * q;\n            var y = x - 1;\n            var z = x + 1;\n            var a = y / p;\n            var b = y / q;\n            var c = z / p;\n            var d = z / q;\n            var e = a * b;\n            var f = c * d;\n            var g = e * f;\n            var h = g + 1;\n            var j = h.toLong;\n            var k = sqrt(j).toLong;\n            var l = primes.length;\n            var m = 0;\n            while (m < l) {\n                if (j % primes(m) == 0) {\n                    m = l;\n                }\n                else {\n                    m += 1;\n                }\n            }\n            if (m == l) {\n                primes += j;\n                i += 1;\n            }\n        }\n        primes(n.toInt - 1);",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2; primes += 3; primes += 5; primes += 7; primes += 11; primes += 13; primes += 17;\n        var i = 19;\n        while (primes.length < n) {\n            var isPrime = true;\n            for (p <- primes) {\n                if (i % p == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) primes += i;\n            i += 2;\n        }\n        primes(n.toInt - 1);",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                var j = 1L\n                var isPrime = true\n                while (j * j <= i) {\n                    if (i % j == 0) {\n                        if ((j + 1) % 4 == 0 || (i / j + 1) % 4 == 0) {\n                            isPrime = false\n                            j = i\n                        }\n                    }\n                    j += 1\n                }\n                if (isPrime) count += 1\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 1L\n        var count = 0L\n        while (count < n) {\n            p += 2\n            if (BigInt(p).isProbablePrime(100)) count += 1\n        }\n        p",
    "        var p = 1L\n        var count = 0L\n        while (count < n) {\n            p += 2\n            if (isPrime(p) && isPrime((p - 1) / 2)) count += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = 2 * i + 1\n                if (BigInt(p).isProbablePrime(100)) {\n                    count += 1\n                }\n            }\n        }\n        2 * i + 1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(100)) count += 1\n            }\n        }\n        i",
    "        var p = 2L;\n        var count = 0L;\n        while (count < n) {\n            p = nextPrime(p);\n            if (isNewmanPrime(p)) count += 1;\n        }\n        return p;",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L;\n        var i = 1L;\n        while (i <= n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        var i = 0;\n        var p = 2;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) {\n                i += 1;\n            }\n        }\n        return p;",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (isPrime(i) && isPrime(2 * i + 1)) {\n                count += 1\n            }\n        }\n        i",
    "        val primes = ArrayBuffer[Long]()\n        var i = 1L\n        while (primes.size < n) {\n            if (BigInt(i).isProbablePrime(10)) primes += i\n            i += 1\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var i = 0\n        var p = 2L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var i = 1L; var p = 1L; var q = 1L; var r = 1L\n        while (i < n) {\n            p = p + 2 * q + 2 * r\n            q = p + 2 * q + 2 * r\n            r = p + q + 2 * r\n            i += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        val primes = new ArrayBuffer[Long](); primes += 2; primes += 3; primes += 5; primes += 7\n        def isPrime(n : Long) : Boolean = {\n            val limit = sqrt(n).toLong;\n            primes.takeWhile(p => p <= limit).forall(p => n % p != 0)\n        }\n        def nextPrime(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p)) {\n                p += 2;\n            }\n            p\n        }\n        def nextNewmanPrime(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p) || !isPrime((p - 1) / 2)) {\n                p += 2;\n            }\n            p\n        }\n        def nextNewmanPrime2(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p) || !isPrime((p - 1) / 2)) {\n                p += 2;\n            }\n            p\n        }\n        def nextNewmanPrime3(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p) || !isPrime((p - 1) / 2)) {\n                p += 2;\n            }\n            p\n        }\n        def nextNewmanPrime4(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p) || !isPrime((p - 1) / 2)) {\n                p += 2;\n            }\n            p\n        }\n        def nextNewmanPrime5(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p) || !isPrime((p - 1) / 2)) {\n                p += 2;\n            }\n            p\n        }\n        def nextNewmanPrime6(n : Long) : Long = {\n            var p = n + 2;\n            while (!isPrime(p) || !isPrime((p - 1) / 2)) {\n                p += 2;\n            }\n            p\n        }",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime((i - 1) / 2)) {\n                count += 1\n            }\n            i += 1\n        }\n        return (i - 1)",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) count += 1\n        }\n        i",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 2\n        while (primes.length < n) {\n            var p = primes(i - 1)\n            var q = primes(i - 2)\n            var x = 6 * p - q - 1\n            while (!isPrime(x)) x += 2\n            primes += x\n            i += 1\n        }\n        primes(n - 1)",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (BigInt(i).isProbablePrime(10)) {\n                count += 1\n                if (count == n) return i\n            }\n            i += 1\n        }\n        return -1",
    "        var p = 2L;\n        var i = 0L;\n        while (i < n) {\n            p = p + 1;\n            if (isPrime(p)) {\n                var q = (p - 1) / 2;\n                if (isPrime(q)) {\n                    i = i + 1;\n                }\n            }\n        }\n        return p;",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        if (n == 1) 2 else {\n            var p = 3L\n            var i = 2L\n            while (i < n) {\n                p = p + 2\n                if (BigInt(p).isProbablePrime(10)) i = i + 1\n            }\n            p\n        }",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) count += 1\n        }\n        i",
    "        var p = 2L; var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(100)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(100)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var a = 1L\n        var b = 1L\n        var c = 1L\n        var d = 1L\n        var e = 1L\n        var f = 1L\n        var g = 1L\n        var h = 1L\n        var i = 1L\n        var j = 1L\n        var k = 1L\n        var l = 1L\n        var m = 1L\n        var o = 1L\n        var p = 1L\n        var q = 1L\n        var r = 1L\n        var s = 1L\n        var t = 1L\n        var u = 1L\n        var v = 1L\n        var w = 1L\n        var x = 1L\n        var y = 1L\n        var z = 1L\n        var aa = 1L\n        var bb = 1L\n        var cc = 1L\n        var dd = 1L\n        var ee = 1L\n        var ff = 1L\n        var gg = 1L\n        var hh = 1L\n        var ii = 1L\n        var jj = 1L\n        var kk = 1L\n        var ll = 1L\n        var mm = 1L\n        var oo = 1L\n        var pp = 1L\n        var qq = 1L\n        var rr = 1L\n        var ss = 1L\n        var tt = 1L\n        var uu = 1L\n        var vv = 1L\n        var ww = 1L\n        var xx = 1L\n        var yy = 1L\n        var zz = 1L\n        var aaa = 1L\n        var bbb = 1L\n        var ccc = 1L\n        var ddd = 1L\n        var eee = 1L\n        var fff = 1L\n        var ggg = 1L\n        var hhh = 1L\n        var iii = 1L\n        var jjj = 1L\n        var kkk = 1L\n        var lll = 1L\n        var mmm = 1L\n        var ooo = 1L\n        var ppp = 1L\n        var qqq = 1L\n        var rrr = 1L\n        var sss = 1L\n        var",
    "        var p = 2L;\n        var count = 0L;\n        while (count < n) {\n            p = nextNewmanPrime(p);\n            count += 1;\n        }\n        return p;",
    "        var primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        var i = 1;\n        while (primes.length < n) {\n            val p = primes(i);\n            val q = primes(i - 1);\n            val r = p * q;\n            val s = p * p;\n            val t = 2 * p * q;\n            val u = p * p * q;\n            val v = p * p * p;\n            val w = p * p * p * q;\n            val x = p * p * p * p;\n            primes += r + s + t + u + v + w + x;\n            i += 1;\n        }\n        primes(n.toInt - 1);",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (i % 2 == 0 || i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                if (i % 2 == 0) {\n                    if (i % 4 == 1) count += 1\n                } else if (i % 3 == 0) {\n                    if (i % 9 == 1) count += 1\n                } else if (i % 5 == 0) {\n                    if (i % 25 == 1) count += 1\n                } else if (i % 7 == 0) {\n                    if (i % 49 == 1) count += 1\n                }\n            } else count += 1\n        }\n        i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 1L\n        var count = 0L\n        while (count < n) {\n            p += 2\n            if (BigInt(p).isProbablePrime(10)) {\n                val m = (p - 1) / 2\n                if (BigInt(m).isProbablePrime(10)) {\n                    count += 1\n                }\n            }\n        }\n        p",
    "        var p = 2L\n        var c = 0L\n        while (c < n) {\n            p = p + 1\n            if (BigInt(p).isProbablePrime(10)) {\n                var k = 1\n                while (BigInt(pow(2, k).toLong - 1).isProbablePrime(10)) {\n                    if (BigInt(pow(2, k).toLong * (pow(2, k).toLong - 1)).isProbablePrime(10)) {\n                        c = c + 1\n                    }\n                    k = k + 1\n                }\n            }\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        return i - 1",
    "        var p = 2L; var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var i = 1;\n        var p = 2;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) {\n                count += 1\n            }\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) count += 1\n        }\n        i",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = p + 1\n            if (BigInt(p).isProbablePrime(10)) {\n                i = i + 1\n            }\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n % 2 == 0) return false\n            if (n % 3 == 0) return false\n            if (n % 5 == 0) return false\n            if (n % 7 == 0) return false\n            if (n % 11 == 0) return false\n            if (n % 13 == 0) return false\n            if (n % 17 == 0) return false\n            if (n % 19 == 0) return false\n            if (n % 23 == 0) return false\n            if (n % 29 == 0) return false\n            if (n % 31 == 0) return false\n            if (n % 37 == 0) return false\n            if (n % 41 == 0) return false\n            if (n % 43 == 0) return false\n            if (n % 47 == 0) return false\n            if (n % 53 == 0) return false\n            if (n % 59 == 0) return false\n            if (n % 61 == 0) return false\n            if (n % 67 == 0) return false\n            if (n % 71 == 0) return false\n            if (n % 73 == 0) return false\n            if (n % 79 == 0) return false\n            if (n % 83 == 0) return false\n            if (n % 89 == 0) return false\n            if (n % 97 == 0) return false\n            if (n % 101 == 0) return false\n            if (n % 103 == 0) return false\n            if (n % 107 == 0) return false\n            if (n % 109 == 0) return false\n            if (n % 113 == 0) return false\n            if (n % 127 == 0) return false\n            if (n % 131 == 0) return false\n            if (n % 137 == 0) return false\n            if (n % 139 == 0) return false\n",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 3\n        while (primes.length < n) {\n            i += 2\n            var isPrime = true\n            for (p <- primes) {\n                if (p * p > i) break\n                if (i % p == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) primes += i\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var i = 0\n        var p = 2L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L;\n        var count = 0L;\n        while (count < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) count += 1;\n        }\n        return p;",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false;\n            if (n == 2) return true;\n            if (n % 2 == 0) return false;\n            var i = 3;\n            while (i <= sqrt(n)) {\n                if (n % i == 0) return false;\n                i += 2;\n            }\n            return true;\n        }\n        var i = 1;\n        var count = 0;\n        while (count < n) {\n            i += 2;\n            if (isPrime(i)) {\n                var j = 1;\n                while (isPrime(i + 2 * j * j)) {\n                    j += 1;\n                }\n                if (i + 2 * j * j == i + 1) count += 1;\n            }\n        }\n        return i;",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = i\n                val q = (1 to p.toInt).filter(x => BigInt(x).isProbablePrime(100)).filter(x => (p - 1) % x == 0).last\n                if (q == 2) count += 1\n            }\n        }\n        i",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 2\n        while (primes.length < n) {\n            val p = primes(i - 1)\n            val q = primes(i - 2)\n            val candidate = p * q - 1\n            if (isPrime(candidate)) {\n                primes += candidate\n                i += 1\n            }\n        }\n        primes(n - 1)",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        var i = 0\n        var p = 2L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = 6 * i + 5\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) {\n                i += 1\n            }\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        var p = 2L;\n        var count = 0L;\n        while (count < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) count += 1;\n        }\n        return p;",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = p + 1\n            if (isPrime(p)) {\n                val q = (p - 1) / 2\n                if (isPrime(q)) count = count + 1\n            }\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var i = 0; var p = 0L; var q = 0L; var r = 0L; var s = 0L; var t = 0L; var u = 0L; var v = 0L; var w = 0L; var x = 0L; var y = 0L; var z = 0L\n        while (i < n) {\n            p += 1; q = p * p; r = q * q; s = r * r; t = s * s; u = t * t; v = u * u; w = v * v; x = w * w; y = x * x; z = y * y\n            if (p == 2 || p == 3 || p == 5 || p == 7 || p == 11 || p == 13 || p == 17 || p == 19 || p == 23 || p == 29 || p == 31 || p == 37 || p == 41 || p == 43 || p == 47 || p == 53 || p == 59 || p == 61 || p == 67 || p == 71 || p == 73 || p == 79 || p == 83 || p == 89 || p == 97 || p == 101 || p == 103 || p == 107 || p == 109 || p == 113 || p == 127 || p == 131 || p == 137 || p == 139 || p == 149 || p == 151 || p == 157 || p == 163 || p == 167 || p == 173 || p == 179 || p == 181 || p == 191 || p == 193 || p == 197 || p == 199 || p == 211 || p == 223 || p == 227 || p == 229 || p == 233 || p == 239 || p == 241 || p == 251 || p == 257 || p == 263 || p == 269 || p == 271 || p == 277 || p == 281 || p == 283 || p == 293 || p == 307 || p == 311 || p == 313 || p == 317 || p == 331 || p == 337 || p == 347 || p == 349 || p == 353 || p == 359 || p == 367 || p == 373 || p == 379 || p == 383 || p == 389 || p == 397 || p == 401 || p == 409 || p == 419 || p == 421 || p == 431 || p == 433 || p == 439 || p == 443 || p == 449 || p == 457 || p == 461 || p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                val p = (i - 1) / 2\n                val q = (i + 1) / 2\n                if (BigInt(p).isProbablePrime(10) && BigInt(q).isProbablePrime(10)) count += 1\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        var primes = new ArrayBuffer[Long]()\n        primes += 2\n        primes += 3\n        primes += 5\n        primes += 7\n        primes += 11\n        primes += 13\n        primes += 17\n        primes += 19\n        primes += 23\n        primes += 29\n        primes += 31\n        primes += 37\n        primes += 41\n        primes += 43\n        primes += 47\n        primes += 53\n        primes += 59\n        primes += 61\n        primes += 67\n        primes += 71\n        primes += 73\n        primes += 79\n        primes += 83\n        primes += 89\n        primes += 97\n        primes += 101\n        primes += 103\n        primes += 107\n        primes += 109\n        primes += 113\n        primes += 127\n        primes += 131\n        primes += 137\n        primes += 139\n        primes += 149\n        primes += 151\n        primes += 157\n        primes += 163\n        primes += 167\n        primes += 173\n        primes += 179\n        primes += 181\n        primes += 191\n        primes += 193\n        primes += 197\n        primes += 199\n        primes += 211\n        primes += 223\n        primes += 227\n        primes += 229\n        primes += 233\n        primes += 239\n        primes += 241\n        primes += 251\n        primes += 257\n        primes += 263\n        primes += 269\n        primes += 271\n        primes += 277\n        primes += 281\n        primes += 283\n        primes += 293\n        primes += 307\n        primes += 311\n        primes += 313\n        primes += 317\n        primes += 331\n        primes += 337\n        primes += 347\n        primes += 349\n        primes += 353\n        primes += 359\n        primes += 367\n        primes += 373\n        primes += 379\n        primes += 383\n        primes += 389\n        primes += 397\n        primes += 401\n        primes += 409\n        primes += 419\n        primes += 421\n        primes += 4",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        var p = 2L\n        while (primes.length < n) {\n            var isPrime = true\n            for (i <- primes) {\n                if (p % i == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) primes += p\n            p += 1\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L; var i = 1L\n        while (i <= n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        return p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (isPrime(p * p - 2)) i += 1;\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) i += 1\n        }\n        p",
    "        var p = 1L\n        var count = 0L\n        while (count < n) {\n            p += 2\n            if (isPrime(p) && isPrime((p - 1) / 2)) count += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(100)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(100)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(100)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(100)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(100)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(100)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = ArrayBuffer[Long]()\n        var i = 2L\n        while (primes.length < n) {\n            if (isPrime(i)) {\n                primes += i\n            }\n            i += 1\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        return p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        return p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3L to sqrt(n).toLong by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n            i += 1\n        }\n        return i - 1",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        return i - 1",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = p * 2 + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n <= 3) return true\n            if (n % 2 == 0 || n % 3 == 0) return false\n            var i = 5\n            while (i * i <= n) {\n                if (n % i == 0 || n % (i + 2) == 0) return false\n                i += 6\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n == 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            if (isPrime(n)) return true\n            val p = n - 1\n            val s = (p - 1).toBinaryString.reverse.indexOf('1')\n            val d = (p - 1) / pow(2, s).toLong\n            val a = 2\n            val x = pow(a, d) % n\n            if (x == 1 || x == n - 1) return true\n            for (r <- 1 to s - 1) {\n                val x = pow(x, 2) % n\n                if (x == 1) return false\n                if (x == n - 1) return true\n            }\n            return false\n        }\n        var i = 1\n        var count = 0\n        while (count < n) {\n            i += 1\n            if (isNewmanPrime(i)) count += 1\n        }\n        return i",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var i = 1L\n        var p = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = p + 2L * (p - 1L)\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var prime = 2L\n        var count = 0L\n        while (count < n) {\n            prime = prime.nextPrime\n            if (prime % 5 == 3) count += 1\n        }\n        prime",
    "        var i = 1L\n        var p = 1L\n        while (i <= n) {\n            p += 2 * p + 1\n            if (p % 3 == 0) p += 2\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        def isNewman(n : Long) : Boolean = {\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            val a = sqrt(n).toInt\n            for (i <- 3 to a by 2) {\n                if (n % i == 0) return false\n            }\n            for (i <- 3 to a by 2) {\n                if (isPrime(i) && isPrime(n / i)) return false\n            }\n            return true\n        }\n        var count = 0\n        var i = 2\n        while (count < n) {\n            if (isNewman(i)) count += 1\n            i += 1\n        }\n        return i - 1",
    "        var a = 1L\n        var b = 1L\n        var c = 1L\n        var d = 1L\n        var e = 1L\n        var f = 1L\n        var g = 1L\n        var h = 1L\n        var i = 1L\n        var j = 1L\n        var k = 1L\n        var l = 1L\n        var m = 1L\n        var n = 1L\n        var o = 1L\n        var p = 1L\n        var q = 1L\n        var r = 1L\n        var s = 1L\n        var t = 1L\n        var u = 1L\n        var v = 1L\n        var w = 1L\n        var x = 1L\n        var y = 1L\n        var z = 1L\n        var aa = 1L\n        var bb = 1L\n        var cc = 1L\n        var dd = 1L\n        var ee = 1L\n        var ff = 1L\n        var gg = 1L\n        var hh = 1L\n        var ii = 1L\n        var jj = 1L\n        var kk = 1L\n        var ll = 1L\n        var mm = 1L\n        var nn = 1L\n        var oo = 1L\n        var pp = 1L\n        var qq = 1L\n        var rr = 1L\n        var ss = 1L\n        var tt = 1L\n        var uu = 1L\n        var vv = 1L\n        var ww = 1L\n        var xx = 1L\n        var yy = 1L\n        var zz = 1L\n        var aaa = 1L\n        var bbb = 1L\n        var ccc = 1L\n        var ddd = 1L\n        var eee = 1L\n        var fff = 1L\n        var ggg = 1L\n        var hhh = 1L\n        var iii = 1L\n        var jjj = 1L\n        var kkk = 1L\n        var lll = 1L\n        var mmm = 1L\n        var nnn = 1L\n        var ooo = 1L\n        var ppp = 1L\n        var q",
    "        var p = 1L\n        var count = 0L\n        while (count < n) {\n            p += 2\n            if (BigInt(p).isProbablePrime(10)) {\n                var q = (p - 1) / 2\n                if (BigInt(q).isProbablePrime(10)) {\n                    count += 1\n                }\n            }\n        }\n        return p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 5 == 1) i += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var primes = new ListBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        var i = 5;\n        while (primes.length < n) {\n            var isPrime = true;\n            for (p <- primes) {\n                if (i % p == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) primes += i;\n            i += 2;\n        }\n        primes(n.toInt - 1);",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n % 2 == 0) return false\n            if (n % 3 == 0) return false\n            if (n % 5 == 0) return false\n            if (n % 7 == 0) return false\n            if (n % 11 == 0) return false\n            if (n % 13 == 0) return false\n            if (n % 17 == 0) return false\n            if (n % 19 == 0) return false\n            if (n % 23 == 0) return false\n            if (n % 29 == 0) return false\n            if (n % 31 == 0) return false\n            if (n % 37 == 0) return false\n            if (n % 41 == 0) return false\n            if (n % 43 == 0) return false\n            if (n % 47 == 0) return false\n            if (n % 53 == 0) return false\n            if (n % 59 == 0) return false\n            if (n % 61 == 0) return false\n            if (n % 67 == 0) return false\n            if (n % 71 == 0) return false\n            if (n % 73 == 0) return false\n            if (n % 79 == 0) return false\n            if (n % 83 == 0) return false\n            if (n % 89 == 0) return false\n            if (n % 97 == 0) return false\n            if (n % 101 == 0) return false\n            if (n % 103 == 0) return false\n            if (n % 107 == 0) return false\n            if (n % 109 == 0) return false\n            if (n % 113 == 0) return false\n            if (n % 127 == 0) return false\n            if (n % 131 == 0) return false\n            if (n % 137 == 0) return false\n            if (n % 139 == 0) return false\n"
  ]
}