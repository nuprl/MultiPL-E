{
  "name": "mbpp_255_combinations_colors",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.\n    def combinationsColors(l : List[String], n : Long) : List[String] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(combinationsColors((List[String](\"Red\", \"Green\", \"Blue\")), (1l)).equals((List[String]((\"Red\"), (\"Green\"), (\"Blue\")))));\n    assert(combinationsColors((List[String](\"Red\", \"Green\", \"Blue\")), (2l)).equals((List[String]((\"Red\", \"Red\"), (\"Red\", \"Green\"), (\"Red\", \"Blue\"), (\"Green\", \"Green\"), (\"Green\", \"Blue\"), (\"Blue\", \"Blue\")))));\n    assert(combinationsColors((List[String](\"Red\", \"Green\", \"Blue\")), (3l)).equals((List[String]((\"Red\", \"Red\", \"Red\"), (\"Red\", \"Red\", \"Green\"), (\"Red\", \"Red\", \"Blue\"), (\"Red\", \"Green\", \"Green\"), (\"Red\", \"Green\", \"Blue\"), (\"Red\", \"Blue\", \"Blue\"), (\"Green\", \"Green\", \"Green\"), (\"Green\", \"Green\", \"Blue\"), (\"Green\", \"Blue\", \"Blue\"), (\"Blue\", \"Blue\", \"Blue\")))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var result = List[String]()\n        for (i <- 0 until l.length) {\n            for (j <- 0 until l.length) {\n                for (k <- 0 until l.length) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- l) {\n                result = result ++ combinationsColors(l, n - 1).map(x => i + x)\n            }\n            result\n        }",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) return List(\"\")\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                result = result ::: combinationsColors(l, n - 1).map(x => l(i) + x)\n            }\n            return result\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 0) List(\"\")\n        else for (x <- l; y <- combinationsColors(l, n - 1)) yield x + y",
    "        var result = List[String]()\n        for (i <- 0 until l.length) {\n            for (j <- 0 until l.length) {\n                for (k <- 0 until l.length) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        var result = List[String]()\n        def combinationsColorsHelper(l : List[String], n : Long, current : String) : Unit = {\n            if (n == 0) {\n                result = current :: result\n                return\n            }\n            for (i <- 0 until l.length) {\n                combinationsColorsHelper(l, n - 1, l(i) + current)\n            }\n        }\n        combinationsColorsHelper(l, n, \"\")\n        result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        if (n == 0) {\n            List(\"\")\n        } else {\n            for (i <- 0 until l.length; j <- combinationsColors(l, n - 1)) yield l(i) + j\n        }.toList",
    "        val result = new ListBuffer[String]\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result += l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result.toList",
    "        if (n == 0) List(\"\")\n        else {\n            val c = combinationsColors(l, n - 1)\n            for (x <- l; y <- c) yield x + y\n        }",
    "        if (n == 1) {\n            l\n        } else {\n            l.flatMap(x => combinationsColors(l, n - 1).map(y => x + y))\n        }",
    "        if (n == 0) return List(\"\")\n        if (l.length == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l.drop(i), n - 1)\n            for (s <- sub) {\n                result += l(i) + s\n            }\n        }\n        result.toList",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to n - 1) {\n                result = result :+ l(i)\n            }\n        }\n        result",
    "        val result = new ListBuffer[String]\n        def combinationsColors(l : List[String], n : Long, current : String) {\n            if (n == 0) {\n                result += current\n                return\n            }\n            for (i <- 0 until l.length) {\n                combinationsColors(l, n - 1, current + l(i))\n            }\n        }\n        combinationsColors(l, n, \"\")\n        result.toList",
    "        val combinations = ListBuffer[String]()\n        def combinationsColorsRec(l : List[String], n : Long, current : String) : Unit = {\n            if (n == 0) combinations += current\n            else {\n                for (i <- 0 until l.length) {\n                    combinationsColorsRec(l, n - 1, current + l(i))\n                }\n            }\n        }\n        combinationsColorsRec(l, n, \"\")\n        combinations.toList",
    "        if (n == 0) List(\"\")\n        else {\n            val sub = combinationsColors(l, n - 1)\n            for (e <- l; s <- sub) yield e + s\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val sub = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until sub.length) {\n                    result = result :+ l(i) + sub(j)\n                }\n            }\n            result\n        }",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l.drop(i), n - 1)\n            for (j <- 0 until subResult.length) {\n                result = (l(i) + subResult(j)) :: result\n            }\n        }\n        return result",
    "        val colors = List(\"red\", \"blue\", \"green\")\n        val combinations = ListBuffer[String]()\n        for (i <- 0 to colors.length - 1) {\n            for (j <- 0 to colors.length - 1) {\n                for (k <- 0 to colors.length - 1) {\n                    combinations += colors(i) + colors(j) + colors(k)\n                }\n            }\n        }\n        combinations.toList",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l, n - 1)\n            for (j <- 0 until sub.length) {\n                result = result :+ l(i) + sub(j)\n            }\n        }\n        return result",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else combinationsColors(l, n - 1).map(l.head + _) ::: combinationsColors(l.tail, n)",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- acc; y <- l) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        val colors = List(\"red\", \"blue\", \"green\")\n        val combinations = ListBuffer[String]()\n        def combinationsColors(l : List[String], n : Long, current : String) : Unit = {\n            if (n == 0) {\n                combinations += current\n                return\n            }\n            for (i <- 0 until l.length) {\n                combinationsColors(l, n - 1, current + l(i))\n            }\n        }\n        combinationsColors(l, n, \"\")\n        combinations.toList",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- acc; y <- l) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        val colors = List(\"red\", \"green\", \"blue\")\n        val combinations = ListBuffer[String]()\n        for (i <- 0 until pow(colors.length, n).toInt) {\n            val combination = ListBuffer[String]()\n            var index = i\n            for (j <- 0 until n) {\n                combination += colors(index % colors.length)\n                index /= colors.length\n            }\n            combinations += combination.reverse.mkString(\"\")\n        }\n        combinations.toList",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- l) {\n                for (j <- combinationsColors(l, n - 1)) {\n                    result = result :+ i + j\n                }\n            }\n            result\n        }",
    "        var result : List[String] = List()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) Nil\n        else combinationsColors(l.tail, n - 1).map(l.head + _) ::: combinationsColors(l.tail, n)",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, List(\"\"))",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) return List(\"\")\n        if (l.length == 0) return List()\n        val x = combinationsColors(l, n - 1)\n        val y = combinationsColors(l.tail, n)\n        (for (i <- x; j <- y) yield i + l.head + j) ::: y",
    "        def combinationsColorsRec(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsRec(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsRec(l, n, l)",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val sub = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until sub.length) result += l(i) + sub(j)\n            }\n            result.toList\n        }",
    "        var result = List[String]()\n        for (i <- 0 until l.length) {\n            for (j <- 0 until l.length) {\n                for (k <- 0 until l.length) {\n                    result = result :+ (l(i) + l(j) + l(k))\n                }\n            }\n        }\n        return result",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else {\n            val l2 = combinationsColors(l.tail, n - 1)\n            l2.map(l.head + _) ::: l2\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- acc; y <- l) yield y + x\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 1) l\n        else {\n            val l2 = combinationsColors(l, n - 1)\n            for (x <- l; y <- l2) yield x + y\n        }",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 1) l\n        else {\n            val temp = combinationsColors(l, n - 1)\n            temp.flatMap(x => l.map(y => x + y))\n        }",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val temp = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until temp.length) result += (l(i) + temp(j))\n            }\n            result.toList\n        }",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else {\n            val x = combinationsColors(l.tail, n - 1)\n            x.map(l.head + _) ::: combinationsColors(l.tail, n)\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (c <- l; a <- acc) yield c + a\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        val colors = List(\"red\", \"blue\", \"green\", \"yellow\", \"orange\", \"purple\", \"black\", \"white\")\n        var result = List[String]()\n        for (i <- 0 to colors.length - 1) {\n            for (j <- 0 to colors.length - 1) {\n                for (k <- 0 to colors.length - 1) {\n                    result = result :+ colors(i) + colors(j) + colors(k)\n                }\n            }\n        }\n        result",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val temp = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until temp.length) {\n                    result = result :+ l(i) + temp(j)\n                }\n            }\n            result\n        }",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else {\n            val x = combinationsColors(l.tail, n)\n            val y = combinationsColors(l.tail, n - 1).map(l.head + _)\n            x ::: y\n        }",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l, n - 1)\n            for (j <- 0 until subResult.length) {\n                result += l(i) + subResult(j)\n            }\n        }\n        return result.toList",
    "        if (n == 1) l\n        else {\n            val l2 = combinationsColors(l, n - 1)\n            for (x <- l; y <- l2) yield x + y\n        }",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else {\n            val x = combinationsColors(l.tail, n - 1)\n            x.map(l.head + _) ::: combinationsColors(l.tail, n)\n        }",
    "        var res = List[String]()\n        for (i <- 0 to l.length - 1) {\n            var temp = l(i)\n            for (j <- 0 to n - 2) {\n                temp += \" \" + l(i)\n            }\n            res = temp :: res\n        }\n        return res",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val temp = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until temp.length) result += l(i) + temp(j)\n            }\n            result.toList\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- acc; y <- l) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        val list = l.combinations(n.toInt).toList\n        val list2 = list.map(x => x.mkString(\"\"))\n        list2",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until subResult.length) {\n                    result = (l(i) + subResult(j)) :: result\n                }\n            }\n            result\n        }",
    "        if (n == 0) return List(\"\")\n        if (l.isEmpty) return List()\n        val x = combinationsColors(l.tail, n - 1).map(l.head + _)\n        val y = combinationsColors(l.tail, n)\n        x ::: y",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l.drop(i), n - 1)\n            for (j <- 0 until subResult.length) {\n                result += l(i) + subResult(j)\n            }\n        }\n        return result.toList",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.drop(i), n - 1)\n                for (j <- 0 until subResult.length) result += l(i) + subResult(j)\n            }\n            result.toList\n        }",
    "        if (n == 0) return List(\"\")\n        if (l.isEmpty) return List()\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l.drop(i), n - 1)\n            for (j <- 0 until subResult.length) {\n                result += (l(i) + subResult(j))\n            }\n        }\n        result.toList",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 1) l.map(x => acc.map(y => y + x)).flatten\n            else {\n                val newAcc = acc.map(x => l.map(y => x + y)).flatten\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, List(\"\"))",
    "        if (n == 0) List(\"\")\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until subResult.length) {\n                    result = result :+ (l(i) + subResult(j))\n                }\n            }\n            result\n        }",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 1) l\n        else {\n            val temp = combinationsColors(l, n - 1)\n            for (x <- l; y <- temp) yield x + y\n        }",
    "        if (n == 0) return List(\"\")\n        if (l.length == 0) return List(\"\")\n        val x = combinationsColors(l.tail, n - 1)\n        val y = combinationsColors(l.tail, n)\n        (for (i <- x; j <- y) yield i + l.head + j) ::: y",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l, n - 1)\n            for (s <- sub) {\n                result += (l(i) + s)\n            }\n        }\n        return result.toList",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l, n - 1)\n            for (j <- 0 until subResult.length) {\n                result += l(i) + subResult(j)\n            }\n        }\n        return result.toList",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) return List(\"\")\n        if (l.isEmpty) return List()\n        val x = combinationsColors(l.tail, n - 1)\n        val y = combinationsColors(l.tail, n)\n        x.map(l.head + _) ::: y",
    "        if (n == 0) List(\"\")\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else {\n            val x = combinationsColors(l.tail, n)\n            val y = combinationsColors(l.tail, n - 1).map(l.head + _)\n            x ::: y\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                var result = List[String]()\n                for (i <- l) {\n                    result = result ::: combinationsColors(l, n - 1, acc ::: List(i))\n                }\n                result\n            }\n        }\n        combinationsColors(l, n, List())",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val temp = combinationsColors(l, n - 1)\n            for (j <- 0 until temp.length) {\n                result = result :+ l(i) + temp(j)\n            }\n        }\n        return result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                for (i <- l) {\n                    combinationsColorsHelper(l, n - 1, acc :+ i)\n                }\n            }\n        }\n        combinationsColorsHelper(l, n, List())",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val sub = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until sub.length) {\n                    result += l(i) + sub(j)\n                }\n            }\n            result.toList\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 0) List(\"\")\n        else if (l.length == 0) List(\"\")\n        else {\n            val x = combinationsColors(l.tail, n - 1)\n            x.map(l.head + _) ::: x\n        }",
    "        // This is a recursive function.\n        // The base case is when n is 1.\n        if (n == 1) {\n            // Return a list of tuples of length 1, where each tuple contains one element of the list.\n            return l.map(x => x)\n        }\n        // The recursive case is when n is greater than 1.\n        else {\n            // Return a list of tuples of length n, where each tuple contains n elements of the list.\n            return l.flatMap(x => combinationsColors(l, n - 1).map(y => x + y))\n        }",
    "        if (n == 0) List(\"\")\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        def combinationsColors(l : List[String], n : Long, result : List[String]) : List[String] = {\n            if (n == 0) result\n            else {\n                val newResult = for (x <- l; y <- result) yield x + y\n                combinationsColors(l, n - 1, newResult)\n            }\n        }\n        combinationsColors(l, n, List(\"\"))",
    "        if (n == 1) l\n        else {\n            val temp = combinationsColors(l, n - 1)\n            temp.flatMap(x => l.map(y => x + y))\n        }",
    "        if (n == 0) List(\"\")\n        else if (n == 1) l\n        else {\n            val res = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val sub = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until sub.length) {\n                    res += l(i) + sub(j)\n                }\n            }\n            res.toList\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                var newAcc = acc\n                for (i <- l) {\n                    newAcc = combinationsColorsHelper(l, n - 1, i :: acc)\n                }\n                newAcc\n            }\n        }\n        combinationsColorsHelper(l, n, List())",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                for (i <- l) {\n                    combinationsColorsHelper(l, n - 1, acc :+ i)\n                }\n                acc\n            }\n        }\n        combinationsColorsHelper(l, n, List())",
    "        if (n == 0) {\n            List(\"\")\n        } else {\n            for (x <- l; y <- combinationsColors(l, n - 1)) yield x + y\n        }",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) List(\"\")\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.drop(i), n - 1)\n                for (j <- 0 until subResult.length) {\n                    result = (l(i) + subResult(j)) :: result\n                }\n            }\n            result\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 1) {\n            l\n        } else {\n            var result = List[String]()\n            for (i <- l) {\n                for (j <- combinationsColors(l, n - 1)) {\n                    result = result :+ i + j\n                }\n            }\n            result\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else if (l.isEmpty) acc\n            else combinationsColorsHelper(l.tail, n, acc :+ l.head) ::: combinationsColorsHelper(l, n - 1, acc)\n        }\n        combinationsColorsHelper(l, n, List())",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 0) {\n            return List(\"\")\n        }\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            for (j <- combinationsColors(l, n - 1)) {\n                result = (l(i) + j) :: result\n            }\n        }\n        return result",
    "        if (n == 0) return List(\"\")\n        if (l.isEmpty) return List()\n        val x = combinationsColors(l, n - 1)\n        val y = combinationsColors(l.tail, n)\n        x.map(l.head + _) ::: y",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to n - 1) {\n                result = result :+ l(i)\n            }\n        }\n        result",
    "        if (n == 0) List(\"\")\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        if (n == 0) List(\"\")\n        else if (l.length == 0) List(\"\")\n        else {\n            val x = combinationsColors(l.tail, n - 1)\n            val y = combinationsColors(l.tail, n)\n            (for (i <- x) yield l.head + i) ::: y\n        }",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.drop(i), n - 1)\n                for (j <- 0 until subResult.length) result += (l(i) + subResult(j))\n            }\n            result.toList\n        }",
    "        if (n == 1) l\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until subResult.length) {\n                    result += (l(i) + subResult(j))\n                }\n            }\n            result.toList\n        }",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l, n - 1)\n            for (s <- sub) {\n                result += (l(i) + s)\n            }\n        }\n        return result.toList",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, List(\"\"))",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 0) List(\"\")\n        else {\n            val x = combinationsColors(l, n - 1)\n            x.flatMap(a => l.map(b => a + b))\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            for {\n                i <- l\n                j <- combinationsColors(l, n - 1)\n            } yield i + j\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- acc; y <- l) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) Nil\n        else combinationsColors(l.tail, n - 1).map(l.head + _) ::: combinationsColors(l.tail, n)",
    "        if (n == 1) l\n        else {\n            val temp = combinationsColors(l, n - 1)\n            for (i <- l; j <- temp) yield i + j\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            val combinations = combinationsColors(l, n - 1)\n            for (i <- l; j <- combinations) yield i + j\n        }",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l.slice(i, l.length), n - 1)\n            for (j <- 0 until subResult.length) {\n                result = result :+ (l(i) + subResult(j))\n            }\n        }\n        return result",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        val result = new ListBuffer[String]\n        def combinations(l : List[String], n : Long, current : String) : Unit = {\n            if (n == 0) result += current\n            else {\n                for (i <- 0 until l.length) {\n                    combinations(l, n - 1, current + l(i))\n                }\n            }\n        }\n        combinations(l, n, \"\")\n        result.toList",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- l) {\n            var temp = combinationsColors(l, n - 1)\n            for (j <- temp) {\n                result = (i + j) :: result\n            }\n        }\n        return result",
    "        if (n == 0) List(\"\")\n        else {\n            for {\n                i <- l\n                j <- combinationsColors(l, n - 1)\n            } yield i + j\n        }",
    "        if (n == 1) l\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val acc2 = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, acc2)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else if (l.length == 0) acc\n            else combinationsColorsHelper(l.tail, n, acc ::: combinationsColors(l, n - 1).map(x => l.head + x))\n        }\n        combinationsColorsHelper(l, n, List())",
    "        val combinations = new ListBuffer[String]\n        def combinationsColors(l : List[String], n : Long, current : String) : Unit = {\n            if (n == 0) {\n                combinations += current\n                return\n            }\n            for (i <- 0 until l.length) {\n                combinationsColors(l, n - 1, current + l(i))\n            }\n        }\n        combinationsColors(l, n, \"\")\n        combinations.toList",
    "        def combinationsColorsRec(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsRec(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsRec(l, n, l)",
    "        if (n == 0) return List(\"\")\n        if (l.length == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l.slice(i, l.length), n - 1)\n            for (s <- sub) {\n                result = result :+ (l(i) + s)\n            }\n        }\n        return result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                l match {\n                    case Nil => acc\n                    case h :: t => combinationsColorsHelper(t, n - 1, acc :+ h)\n                }\n            }\n        }\n        combinationsColorsHelper(l, n, List())",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, List(\"\"))",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l.slice(i, l.length), n - 1)\n            for (j <- 0 until subResult.length) {\n                result = result :+ l(i) + subResult(j)\n            }\n        }\n        return result",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l.slice(i, l.length), n - 1)\n            for (s <- sub) result += (l(i) + s)\n        }\n        result.toList",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 0) return List(\"\")\n        else {\n            var result = List[String]()\n            for (i <- l) {\n                for (j <- combinationsColors(l, n - 1)) {\n                    result = (i + j) :: result\n                }\n            }\n            return result\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ (l(i) + l(j) + l(k))\n                }\n            }\n        }\n        return result",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                for (i <- l) {\n                    combinationsColors(l, n - 1, i :: acc)\n                }\n            }\n        }\n        combinationsColors(l, n, List())",
    "        if (n == 0) return List(\"\")\n        var result = List[String]()\n        for (i <- 0 until l.length) {\n            val sub = combinationsColors(l, n - 1)\n            for (j <- 0 until sub.length) {\n                result = result :+ (l(i) + sub(j))\n            }\n        }\n        return result",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.size) {\n                val subResult = combinationsColors(l.slice(i, l.size), n - 1)\n                for (j <- 0 until subResult.size) {\n                    result = result :+ l(i) + subResult(j)\n                }\n            }\n            result\n        }",
    "        val res = new ListBuffer[String]\n        def recur(l : List[String], n : Long, s : String) {\n            if (n == 0) res += s\n            else {\n                for (i <- 0 until l.length) {\n                    recur(l, n - 1, s + l(i))\n                }\n            }\n        }\n        recur(l, n, \"\")\n        res.toList",
    "        if (n == 1) l\n        else {\n            val l2 = combinationsColors(l, n - 1)\n            for (x <- l; y <- l2) yield x + y\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 0) return List(\"\")\n        if (l.isEmpty) return List(\"\")\n        val x = combinationsColors(l.tail, n - 1)\n        val y = combinationsColors(l.tail, n)\n        (for (i <- x; j <- l) yield i + j) ::: y",
    "        if (n == 0) List(\"\")\n        else {\n            val x = combinationsColors(l, n - 1)\n            for (e <- l; c <- x) yield e + c\n        }",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l, n - 1)\n            for (j <- 0 until subResult.length) {\n                result += l(i) + subResult(j)\n            }\n        }\n        return result.toList",
    "        if (n == 0) return List(\"\")\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val sub = combinationsColors(l, n - 1)\n                for (s <- sub) {\n                    result += l(i) + s\n                }\n            }\n            return result.toList\n        }",
    "        if (n == 0) List(\"\")\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        if (n == 0) return List(\"\")\n        val result = new ListBuffer[String]\n        for (i <- 0 until l.length) {\n            val subResult = combinationsColors(l, n - 1)\n            for (j <- 0 until subResult.length) {\n                result += l(i) + subResult(j)\n            }\n        }\n        return result.toList",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result = result :+ l(i) + l(j) + l(k)\n                }\n            }\n        }\n        return result",
    "        if (n == 0) List(\"\")\n        else if (l.length == 0) Nil\n        else combinationsColors(l.tail, n - 1).map(l.head + _) ::: combinationsColors(l.tail, n)",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else if (l.isEmpty) acc\n            else combinationsColors(l.tail, n - 1, acc :+ l.head) ::: combinationsColors(l, n, acc)\n        }\n        combinationsColors(l, n, List())",
    "        if (n == 1) l\n        else l.flatMap(x => combinationsColors(l, n - 1).map(x + _))",
    "        val combinations = new ListBuffer[String]\n        def combinationsColorsHelper(l : List[String], n : Long, current : String) : Unit = {\n            if (n == 0) {\n                combinations += current\n                return\n            }\n            for (i <- 0 until l.length) {\n                combinationsColorsHelper(l, n - 1, current + l(i))\n            }\n        }\n        combinationsColorsHelper(l, n, \"\")\n        combinations.toList",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 0) return List(\"\")\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until subResult.length) {\n                    result = result :+ (l(i) + subResult(j))\n                }\n            }\n            return result\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            val x = combinationsColors(l, n - 1)\n            x.flatMap(a => l.map(b => a + b))\n        }",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- l) {\n                for (j <- combinationsColors(l, n - 1)) {\n                    result = result :+ (i + j)\n                }\n            }\n            result\n        }",
    "        if (n == 1) l\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val sub = combinationsColors(l.slice(i, l.length), n - 1)\n                for (j <- 0 until sub.length) {\n                    result = (l(i) + sub(j)) :: result\n                }\n            }\n            result\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            l.flatMap(x => combinationsColors(l, n - 1).map(y => x + y))\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            val combinations = combinationsColors(l, n - 1)\n            for (x <- l; y <- combinations) yield x + y\n        }",
    "        if (n == 0) {\n            List(\"\")\n        } else {\n            l.flatMap(x => combinationsColors(l, n - 1).map(y => x + y))\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            var result = List[String]()\n            for (i <- l) {\n                for (j <- combinationsColors(l, n - 1)) {\n                    result = (i + j) :: result\n                }\n            }\n            result\n        }",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else combinationsColors(l.tail, n - 1).map(l.head + _) ::: combinationsColors(l.tail, n)",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 1) {\n                acc ++ l\n            } else {\n                var newAcc = acc\n                for (e <- l) {\n                    newAcc = combinationsColors(l, n - 1, acc.map(x => x + e))\n                }\n                newAcc\n            }\n        }\n        combinationsColors(l, n, List())",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (e <- l; a <- acc) yield e + a\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        var result = List[String]()\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to n - 1) {\n                result = result :+ l(i)\n            }\n        }\n        result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, List(\"\"))",
    "        if (n == 1) l\n        else {\n            val temp = combinationsColors(l, n - 1)\n            for (i <- l; j <- temp) yield i + j\n        }",
    "        if (n == 0) List(\"\")\n        else {\n            var result = List[String]()\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l, n - 1)\n                for (j <- 0 until subResult.length) {\n                    result = result :+ l(i) + subResult(j)\n                }\n            }\n            result\n        }",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 1) l\n        else {\n            val l2 = combinationsColors(l, n - 1)\n            l2 ::: (for (i <- l) yield l2.map(x => x + i)).flatten\n        }",
    "        if (n == 0) List(\"\")\n        else if (l.isEmpty) List()\n        else {\n            val x = combinationsColors(l.tail, n)\n            val y = combinationsColors(l.tail, n - 1).map(l.head + _)\n            x ::: y\n        }",
    "        def combinationsColors(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield x + y\n                combinationsColors(l, n - 1, newAcc)\n            }\n        }\n        combinationsColors(l, n, l)",
    "        if (n == 1) l\n        else {\n            val result = new ListBuffer[String]\n            for (i <- 0 until l.length) {\n                val subResult = combinationsColors(l.drop(i), n - 1)\n                for (j <- 0 until subResult.length) result += (l(i) + subResult(j))\n            }\n            result.toList\n        }",
    "        val result = new ListBuffer[String]\n        for (i <- 0 to l.length - 1) {\n            for (j <- 0 to l.length - 1) {\n                for (k <- 0 to l.length - 1) {\n                    result += l(i) + l(j) + l(k)\n                }\n            }\n        }\n        result.toList",
    "        def combinationsColorsHelper(l : List[String], n : Long) : List[String] = {\n            if (n == 0) List(\"\")\n            else if (l.isEmpty) Nil\n            else combinationsColorsHelper(l, n - 1).map(l.head + _) ::: combinationsColorsHelper(l.tail, n)\n        }\n        combinationsColorsHelper(l, n).map(x => x.sorted).distinct",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l) yield {\n                    for (j <- acc) yield {\n                        i + j\n                    }\n                }\n                combinationsColorsHelper(l, n - 1, newAcc.flatten.toList)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        var result = List[String]()\n        for (i <- 0 until l.length) {\n            for (j <- 0 until l.length) {\n                for (k <- 0 until l.length) {\n                    result = result :+ (l(i) + l(j) + l(k))\n                }\n            }\n        }\n        return result",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (i <- l; j <- acc) yield i + j\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)",
    "        if (n == 0) return List(\"\")\n        if (l.length == 0) return List(\"\")\n        val x = combinationsColors(l.tail, n - 1)\n        val y = combinationsColors(l.tail, n)\n        x.map(x => l.head + x) ::: y",
    "        def combinationsColorsHelper(l : List[String], n : Long, acc : List[String]) : List[String] = {\n            if (n == 0) acc\n            else {\n                val newAcc = for (x <- l; y <- acc) yield (x + y)\n                combinationsColorsHelper(l, n - 1, newAcc)\n            }\n        }\n        combinationsColorsHelper(l, n, l)"
  ]
}