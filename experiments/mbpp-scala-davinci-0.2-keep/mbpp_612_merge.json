{
  "name": "mbpp_612_merge",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n    def merge(lst : Any) : Any = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(merge((Any(List[String](\"x\", \"y\"), List[String](\"a\", \"b\"), List[String](\"m\", \"n\")))).equals((Any(List[String](\"x\", \"a\", \"m\"), List[String](\"y\", \"b\", \"n\")))));\n    assert(merge((Any(List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong)))).equals((Any(List[Long](1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong), List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong)))));\n    assert(merge((Any(List[String](\"x\", \"y\", \"z\"), List[String](\"a\", \"b\", \"c\"), List[String](\"m\", \"n\", \"o\")))).equals((Any(List[String](\"x\", \"a\", \"m\"), List[String](\"y\", \"b\", \"n\"), List[String](\"z\", \"c\", \"o\")))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val lst2 = lst.asInstanceOf[List[List[Int]]]\n        val lst3 = ListBuffer[Int]()\n        val lst4 = ListBuffer[Int]()\n        for (i <- 0 until lst2.length) {\n            lst3 += lst2(i)(0)\n            lst4 += lst2(i)(1)\n        }\n        return List(lst3.toList, lst4.toList)",
    "        lst match {\n            case lst : List[List[Any]] => {\n                val first = new ListBuffer[Any]\n                val second = new ListBuffer[Any]\n                for (i <- 0 until lst.length) {\n                    first += lst(i)(0)\n                    second += lst(i)(1)\n                }\n                List(first.toList, second.toList)\n            }\n            case _ => lst\n        }",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x.head)\n        val lst3 = lst1.map(x => x.tail.head)\n        List(lst2, lst3)",
    "        var lst1 = List[Any]()\n        var lst2 = List[Any]()\n        for (i <- lst.asInstanceOf[List[List[Any]]]) {\n            lst1 = lst1 :+ i(0)\n            lst2 = lst2 :+ i(1)\n        }\n        return List(lst1, lst2)",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => {\n                val (a, b) = x\n                (a :: merge(xs).asInstanceOf[List[Any]]).asInstanceOf[Any] -> (b :: merge(xs).asInstanceOf[List[Any]]).asInstanceOf[Any]\n            }\n        }",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = ListBuffer[Int]()\n        val lst3 = ListBuffer[Int]()\n        for (i <- 0 until lst1.length) {\n            lst2 += lst1(i)(0)\n            lst3 += lst1(i)(1)\n        }\n        List(lst2.toList, lst3.toList)",
    "        lst match {\n            case lst : List[List[Any]] => {\n                val lst1 = new ListBuffer[Any]()\n                val lst2 = new ListBuffer[Any]()\n                for (i <- lst) {\n                    lst1 += i(0)\n                    lst2 += i(1)\n                }\n                List(lst1.toList, lst2.toList)\n            }\n            case _ => lst\n        }",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        var lst1 = List[Any]()\n        var lst2 = List[Any]()\n        for (i <- lst.asInstanceOf[List[List[Any]]]) {\n            lst1 = lst1 :+ i(0)\n            lst2 = lst2 :+ i(1)\n        }\n        List(lst1, lst2)",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => {\n                val (a, b) = x\n                merge(xs) match {\n                    case (c :: cs, d :: ds) => ((a :: c) :: (b :: d) :: Nil)\n                    case _ => (a :: Nil) :: (b :: Nil) :: Nil\n                }\n            }\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x : List[Any]) :: xs => {\n                val (x1, x2) = (x.head, x.tail.head)\n                val (l1, l2) = merge(xs) match {\n                    case (l1 : List[Any], l2 : List[Any]) => (l1, l2)\n                }\n                (x1 :: l1, x2 :: l2)\n            }\n        }",
    "        var lst1 = ListBuffer[Any]()\n        var lst2 = ListBuffer[Any]()\n        for (i <- lst.asInstanceOf[List[List[Any]]]) {\n            lst1 += i(0)\n            lst2 += i(1)\n        }\n        List(lst1.toList, lst2.toList)",
    "        val lst2 = lst.asInstanceOf[List[List[Any]]]\n        val lst3 = lst2.map(x => x(0))\n        val lst4 = lst2.map(x => x(1))\n        List(lst3, lst4)",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x.head)\n        val lst3 = lst1.map(x => x.tail.head)\n        List(lst2, lst3)"
  ]
}