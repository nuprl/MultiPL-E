{
  "name": "mbpp_603_get_ludic",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to get all lucid numbers smaller than or equal to a given integer.\n    def getLudic(n : Long) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getLudic((10l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(getLudic((25l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong))));\n    assert(getLudic((45l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong, 29l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var digits = List[Int]()\n            var num = i\n            while (num > 0) {\n                digits = (num % 10) :: digits\n                num /= 10\n            }\n            var sum = 0\n            for (digit <- digits) {\n                sum += pow(digit, digits.length).toInt\n            }\n            if (sum == i) result = i :: result\n        }\n        return result",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var str = i.toString\n            var isLudic = true\n            for (j <- 0 to str.length - 1) {\n                if (str(j) == '0') {\n                    isLudic = false\n                    break\n                }\n            }\n            if (isLudic) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val m = s.map(x => pow(x.asDigit, l).toLong).sum\n            m == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        def isLudic(x : Long) : Boolean = {\n            var y = x\n            while (y > 0) {\n                if (y % 10 == 0) return false\n                y /= 10\n            }\n            true\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val d = s.map(x => x.asDigit).toList\n            val ds = d.map(x => x * x)\n            val dss = ds.map(x => x.toString)\n            val dsss = dss.map(x => x.length)\n            val dssss = dsss.map(x => x * x)\n            val dsssss = dssss.map(x => x.toString)\n            val dssssss = dsssss.map(x => x.length)\n            val dsssssss = dssssss.map(x => x * x)\n            val dssssssss = dsssssss.map(x => x.toString)\n            val dsssssssss = dssssssss.map(x => x.length)\n            val dssssssssss = dsssssssss.map(x => x * x)\n            val dsssssssssss = dssssssssss.map(x => x.toString)\n            val dssssssssssss = dsssssssssss.map(x => x.length)\n            val dsssssssssssss = dssssssssssss.map(x => x * x)\n            val dssssssssssssss = dsssssssssssss.map(x => x.toString)\n            val dsssssssssssssss = dssssssssssssss.map(x => x.length)\n            val dssssssssssssssss = dsssssssssssssss.map(x => x * x)\n            val dsssssssssssssssss = dssssssssssssssss.map(x => x.toString)\n            val dssssssssssssssssss = dsssssssssssssssss.map(x => x.length)\n            val dsssssssssssssssssss",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digit = n % 10\n                if (digit % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudicRec(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digits = n.toString.map(_.asDigit).toList\n                val sum = digits.map(x => pow(x, digits.length).toLong).sum\n                if (sum == n) getLudicRec(n - 1, n :: acc)\n                else getLudicRec(n - 1, acc)\n            }\n        }\n        getLudicRec(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1L to n) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.contains(\"0\")) {\n                val s1 = s.replaceAll(\"0\", \"\")\n                if (s1.toInt % i == 0) ludic += i\n            }\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result"
  ]
}