{
  "name": "mbpp_603_get_ludic",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to get all lucid numbers smaller than or equal to a given integer.\n    def getLudic(n : Long) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getLudic((10l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(getLudic((25l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong))));\n    assert(getLudic((45l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong, 29l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var digits = List[Int]()\n            var num = i\n            while (num > 0) {\n                digits = (num % 10) :: digits\n                num /= 10\n            }\n            var sum = 0\n            for (digit <- digits) {\n                sum += pow(digit, digits.length).toInt\n            }\n            if (sum == i) result = i :: result\n        }\n        return result",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var str = i.toString\n            var isLudic = true\n            for (j <- 0 to str.length - 1) {\n                if (str(j) == '0') {\n                    isLudic = false\n                    break\n                }\n            }\n            if (isLudic) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val m = s.map(x => pow(x.asDigit, l).toLong).sum\n            m == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        def isLudic(x : Long) : Boolean = {\n            var y = x\n            while (y > 0) {\n                if (y % 10 == 0) return false\n                y /= 10\n            }\n            true\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val d = s.map(x => x.asDigit).toList\n            val ds = d.map(x => x * x)\n            val dss = ds.map(x => x.toString)\n            val dsss = dss.map(x => x.length)\n            val dssss = dsss.map(x => x * x)\n            val dsssss = dssss.map(x => x.toString)\n            val dssssss = dsssss.map(x => x.length)\n            val dsssssss = dssssss.map(x => x * x)\n            val dssssssss = dsssssss.map(x => x.toString)\n            val dsssssssss = dssssssss.map(x => x.length)\n            val dssssssssss = dsssssssss.map(x => x * x)\n            val dsssssssssss = dssssssssss.map(x => x.toString)\n            val dssssssssssss = dsssssssssss.map(x => x.length)\n            val dsssssssssssss = dssssssssssss.map(x => x * x)\n            val dssssssssssssss = dsssssssssssss.map(x => x.toString)\n            val dsssssssssssssss = dssssssssssssss.map(x => x.length)\n            val dssssssssssssssss = dsssssssssssssss.map(x => x * x)\n            val dsssssssssssssssss = dssssssssssssssss.map(x => x.toString)\n            val dssssssssssssssssss = dsssssssssssssssss.map(x => x.length)\n            val dsssssssssssssssssss",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digit = n % 10\n                if (digit % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudicRec(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digits = n.toString.map(_.asDigit).toList\n                val sum = digits.map(x => pow(x, digits.length).toLong).sum\n                if (sum == n) getLudicRec(n - 1, n :: acc)\n                else getLudicRec(n - 1, acc)\n            }\n        }\n        getLudicRec(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1L to n) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.contains(\"0\")) {\n                val s1 = s.replaceAll(\"0\", \"\")\n                if (s1.toInt % i == 0) ludic += i\n            }\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(x => pow(x.asDigit, s.length)).sum\n            if (sum == i) ludic += sum\n        }\n        ludic.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digits = n.toString.map(_.asDigit).toList\n                val sum = digits.map(x => pow(x, 2).toLong).sum\n                if (sum == 1) getLudic(n - 1, n :: acc)\n                else if (acc.contains(sum)) getLudic(n - 1, acc)\n                else getLudic(n - 1, getLudic(sum, acc))\n            }\n        }\n        getLudic(n, List())",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, List())",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(n : Long) : Boolean = {\n            val digits = n.toString.map(_.asDigit)\n            val sum = digits.map(x => pow(x, digits.length).toLong).sum\n            sum == n\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            var sum = 0L\n            var m = n\n            while (m > 0) {\n                sum += pow(m % 10, 2).toLong\n                m /= 10\n            }\n            if (sum == 1) true\n            else if (sum == 4) false\n            else isLudic(sum)\n        }\n        var l = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) l = i :: l\n        }\n        l",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 2) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 3) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 4) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 5) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 6) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 7) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 8) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 9) getLudic(n / 10, n :: acc)\n            else getLudic(n / 10, acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digit = n % 10\n                if (digit % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudicRec(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudicRec(n / 10, acc)\n                else getLudicRec(n / 10, n :: acc)\n            }\n        }\n        getLudicRec(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var res = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) res = i :: res\n        }\n        res",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLucid(n)) getLudicHelper(n - 1, n :: acc)\n            else getLudicHelper(n - 1, acc)\n        }\n        getLudicHelper(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val m = s.length\n            val a = s.map(x => pow(x.asDigit, m).toLong).sum\n            a == n\n        }\n        (1L to n).filter(isLudic).toList",
    "        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result += i\n        }\n        result.toList",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var j = i\n            while (j > 0) {\n                sum += pow(j % 10, 2).toInt\n                j /= 10\n            }\n            if (sum == 1) ludic += i\n        }\n        ludic.toList",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            var s = i.toString\n            var sum = 0\n            for (c <- s) {\n                sum += pow(c.toString.toInt, s.length).toInt\n            }\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result += i\n        }\n        result.toList",
    "        def isLucid(x : Long) : Boolean = {\n            def isLucid(x : Long, y : Long) : Boolean = {\n                if (x == 0) true\n                else if (x % y == 0) false\n                else isLucid(x, y + 1)\n            }\n            isLucid(x, 2)\n        }\n        (1 to n.toInt).filter(x => isLucid(x)).map(x => x.toLong).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var x = i\n            var y = 0\n            while (x > 0) {\n                y += pow(x % 10, 2).toInt\n                x /= 10\n            }\n            if (y == 1) result ::= i\n            else {\n                var z = y\n                while (z != 1 && z != 89) {\n                    var x = z\n                    var y = 0\n                    while (x > 0) {\n                        y += pow(x % 10, 2).toInt\n                        x /= 10\n                    }\n                    z = y\n                }\n                if (z == 1) result ::= i\n            }\n        }\n        result",
    "        var result = List[Long]()\n        var i = 1L\n        while (i <= n) {\n            if (isLudic(i)) result = i :: result\n            i += 1\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val d = s.map(c => c.asDigit).toList\n            if (d.map(x => pow(x, s.length)).sum == i) ludic += i\n        }\n        ludic.toList",
    "        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result += i\n        }\n        result.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudicRec(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudicRec(n / 10, l)\n                else getLudicRec(n / 10, n :: l)\n            }\n        }\n        getLudicRec(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, List())",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val a = s.map(x => pow(x.asDigit, l).toLong).sum\n            a == n\n        }\n        (1L to n).filter(x => isLudic(x)).toList",
    "        var result = List[Long]()\n        for (i <- 2 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            var sum = 0\n            for (j <- 0 until s.length) {\n                sum += pow(s(j).asDigit, 2).toInt\n            }\n            if (sum == i) result = i :: result\n        }\n        result",
    "        var l = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) l = i :: l\n        }\n        l",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            for (j <- i.toString) sum += pow(j.asDigit, 2).toInt\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic.reverse",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val next = acc.head * 10\n                if (next > n) acc\n                else getLudicHelper(n, next :: acc)\n            }\n        }\n        getLudicHelper(n, List(1))",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val x = (n - 1) % 9 + 1\n                getLudic((n - x) / 9, x :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var digits = i.toString.map(_.asDigit).toList\n            var sum = 0\n            for (digit <- digits) {\n                sum += pow(digit, digits.length).toInt\n            }\n            if (sum == i) result = i :: result\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val m = s.map(x => pow(x.asDigit, l).toLong).sum\n            m == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLucid(n)) getLudic(n - 1, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        var i = 1L\n        while (i <= n) {\n            if (isLucid(i)) result = result :+ i\n            i += 1\n        }\n        result",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val d = s.map(c => c.toString.toInt).toList\n            val ds = d.map(x => x * x).sum\n            val dss = ds.toString\n            val dsss = dss.map(c => c.toString.toInt).toList\n            val dssss = dsss.map(x => x * x).sum\n            val dsssss = dssss.toString\n            val dssssss = dsssss.map(c => c.toString.toInt).toList\n            val dsssssss = dssssss.map(x => x * x).sum\n            val dssssssss = dsssssss.toString\n            val dsssssssss = dssssssss.map(c => c.toString.toInt).toList\n            val dssssssssss = dsssssssss.map(x => x * x).sum\n            val dsssssssssss = dssssssssss.toString\n            val dssssssssssss = dsssssssssss.map(c => c.toString.toInt).toList\n            val dsssssssssssss = dssssssssssss.map(x => x * x).sum\n            val dssssssssssssss = dsssssssssssss.toString\n            val dsssssssssssssss = dssssssssssssss.map(c => c.toString.toInt).toList\n            val dssssssssssssssss = dsssssssssssssss.map(x => x * x).sum\n            val dsssssssssssssssss = dssssssssssssssss.toString\n            val dssssssssssssssssss = dsssssssssssssssss.map(c => c.toString.toInt).toList\n            val dssssssssssssssss",
    "        val result = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result += i\n        }\n        result.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1L to n) {\n            var sum = 0L\n            var x = i\n            while (x > 0) {\n                sum += pow(x % 10, 2).toLong\n                x /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Long]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var newSum = 0L\n                    var x = sum\n                    while (x > 0) {\n                        newSum += pow(x % 10, 2).toLong\n                        x /= 10\n                    }\n                    sum = newSum\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val m = s.map(c => pow(c.asDigit, l).toLong).sum\n            m == x\n        }\n        (1L to n).filter(isLudic).toList",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val a = s.map(x => x.toString.toLong).toList\n            val b = a.map(x => x * x)\n            val c = b.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val d = c.flatten\n            val e = d.map(x => x * x)\n            val f = e.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val g = f.flatten\n            val h = g.map(x => x * x)\n            val i = h.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val j = i.flatten\n            val k = j.map(x => x * x)\n            val l = k.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val m = l.flatten\n            val o = m.map(x => x * x)\n            val p = o.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val q = p.flatten\n            val r = q.map(x => x * x)\n            val t = r.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val u = t.flatten\n            val v = u.map(x => x * x)\n            val w = v.map(x => x.toString).map(x => x.map(x => x.toString.toLong).toList).toList\n            val y = w.flatten\n            val z = y.map(x => x * x)\n            val aa = z.map(x",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudicR(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val l = getLudicR(n / 10, acc)\n                if (n % 10 == 0) l\n                else n :: l\n            }\n        }\n        getLudicR(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, List())",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n - 1, n :: acc)\n            else getLudic(n - 2, n :: acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n < 10) acc\n            else {\n                val digits = n.toString.map(_.asDigit).toList\n                val sum = digits.map(x => pow(x, digits.length).toLong).sum\n                if (sum == n) getLudic(n - 1, n :: acc)\n                else getLudic(n - 1, acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def isLudic(n : Long) : Boolean = {\n            val digits = n.toString.map(_.toString.toInt).toList\n            digits.map(pow(_, digits.length)).sum == n\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n - 1, n :: acc)\n            else getLudic(n - 2, n :: acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1L to n) {\n            var digits = List[Long]()\n            var x = i\n            while (x > 0) {\n                digits = (x % 10) :: digits\n                x /= 10\n            }\n            if (digits.map(x => pow(x, digits.length).toLong).sum == i) ludic = i :: ludic\n        }\n        ludic.reverse",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def isLudic(n : Long) : Boolean = {\n            var sum = 0L\n            var m = n\n            while (m > 0) {\n                sum += pow(m % 10, 2).toLong\n                m /= 10\n            }\n            sum == 1\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        val s = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) s += i\n        }\n        s.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val d = s.map(c => c.toString.toInt).toList\n            val l = d.length\n            val m = d.map(x => pow(x, l).toLong).sum\n            if (m == n) true else false\n        }\n        val l = (1 to n.toInt).filter(x => isLudic(x)).map(x => x.toLong).toList\n        l",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val digits = n.toString.map(_.asDigit).toList\n            val sum = digits.map(x => pow(x, digits.length).toLong).sum\n            sum == n\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var j = i\n            while (j > 0) {\n                sum += pow(j % 10, 2).toInt\n                j /= 10\n            }\n            if (sum == 1) ludic = i :: ludic\n            else {\n                var k = sum\n                while (k != 1 && k != 89) {\n                    var sum2 = 0\n                    var l = k\n                    while (l > 0) {\n                        sum2 += pow(l % 10, 2).toInt\n                        l /= 10\n                    }\n                    k = sum2\n                }\n                if (k == 1) ludic = i :: ludic\n            }\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else if (n % m == 0) getLudic(n / 10, n :: acc)\n                else getLudic(n / 10, acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def isLudic(n : Long) : Boolean = {\n            val digits = n.toString.map(_.asDigit).toList\n            val sum = digits.foldLeft(0)((a, b) => a + pow(b, digits.length).toInt)\n            sum == n\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val d = s.map(c => c.toString.toInt).toList\n            val l = d.length\n            val l2 = l / 2\n            val d1 = d.take(l2)\n            val d2 = d.drop(l2)\n            val s1 = d1.map(c => c.toString).reduceLeft(_ + _)\n            val s2 = d2.map(c => c.toString).reduceLeft(_ + _)\n            val n1 = s1.toLong\n            val n2 = s2.toLong\n            val sqrt = sqrt(n).toLong\n            if (sqrt * sqrt == n) {\n                if (n1 + n2 == sqrt) true else false\n            } else false\n        }\n        (1L to n).filter(isLudic).toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.contains(\"0\") && s.contains(\"1\") && s.contains(\"2\") && s.contains(\"3\") && s.contains(\"4\") && s.contains(\"5\") && s.contains(\"6\") && s.contains(\"7\") && s.contains(\"8\") && s.contains(\"9\")) ludic += i\n        }\n        ludic.toList",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(c => pow(c.asDigit, s.length).toLong).sum\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result += i\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var temp = i\n            while (temp > 0) {\n                sum += pow(temp % 10, 2).toInt\n                temp /= 10\n            }\n            if (sum == 1) result ::= i\n            else {\n                var isLudic = true\n                var set = Set[Int]()\n                while (sum != 1 && isLudic) {\n                    if (set.contains(sum)) isLudic = false\n                    else {\n                        set += sum\n                        var temp = sum\n                        sum = 0\n                        while (temp > 0) {\n                            sum += pow(temp % 10, 2).toInt\n                            temp /= 10\n                        }\n                    }\n                }\n                if (isLudic) result ::= i\n            }\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(x => pow(x.toString.toInt, s.length).toInt).sum\n            if (sum == i) ludic += sum\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else if (n % m == 0) getLudic(n / 10, n :: acc)\n                else getLudic(n / 10, acc)\n            }\n        }\n        getLudic(n, List())",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 2 == 0) getLudic(n - 1, acc)\n            else {\n                val m = n.toString.map(_.asDigit).sum\n                if (m % 2 == 0) getLudic(n - 1, acc)\n                else getLudic(n - m, n :: acc)\n            }\n        }\n        getLudic(n, List()).reverse",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, List()).reverse",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val d = s.map(x => x.toString.toInt).toList\n            val ds = d.map(x => pow(x, l).toLong).sum\n            ds == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).map(x => x.toLong).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var x = i\n            while (x > 0) {\n                sum += pow(x % 10, 2).toInt\n                x /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var x = sum\n                    sum = 0\n                    while (x > 0) {\n                        sum += pow(x % 10, 2).toInt\n                        x /= 10\n                    }\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            for (j <- 1 to i) {\n                if (i % j == 0) sum += j\n            }\n            if (sum == 2 * i) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val s2 = s.map(x => pow(x.asDigit, 2).toInt).sum\n            if (s2 == i) ludic += i\n        }\n        ludic.toList",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLudic(n)) getLudicHelper(n - 1, n :: acc)\n            else getLudicHelper(n - 1, acc)\n        }\n        getLudicHelper(n, List())",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var x = i\n            while (x > 0) {\n                sum += pow(x % 10, 2).toInt\n                x /= 10\n            }\n            if (sum == 1) ludic += i\n        }\n        ludic.toList",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digit = n % 10\n                if (digit == 0) getLudicHelper(n / 10, acc)\n                else {\n                    val newAcc = if (n % digit == 0) acc :+ n else acc\n                    getLudicHelper(n / 10, newAcc)\n                }\n            }\n        }\n        getLudicHelper(n, List())",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var list = List[Long]()\n        for (i <- 1 to n.toInt) {\n            val x = i.toString.toList\n            val y = x.map(c => pow(c.toString.toInt, x.length).toInt).sum\n            if (y == i) list = list :+ i\n        }\n        list",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n / 10, acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(x => pow(x.asDigit, s.length).toLong).sum\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val s2 = s.map(x => (x - '0') * (x - '0')).mkString\n            if (s2.endsWith(s)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def isLudic(x : Long) : Boolean = {\n            def getDigits(x : Long) : List[Long] = {\n                if (x == 0) List()\n                else (x % 10) :: getDigits(x / 10)\n            }\n            def getSum(x : Long) : Long = {\n                if (x == 0) 0\n                else (x % 10) + getSum(x / 10)\n            }\n            val digits = getDigits(x)\n            val sum = getSum(x)\n            digits.map(x => pow(x, sum).toLong).sum == x\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var s = i.toString\n            var sum = 0\n            for (j <- 0 until s.length) {\n                sum += pow(s(j).toInt - '0', 2).toInt\n            }\n            if (sum == 1) {\n                result = i :: result\n            }\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    s = sum.toString\n                    sum = 0\n                    for (j <- 0 until s.length) {\n                        sum += pow(s(j).toInt - '0', 2).toInt\n                    }\n                }\n                if (sum == 1) {\n                    result = i :: result\n                }\n            }\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(x : Long) : Boolean = {\n            def getDigits(x : Long) : List[Long] = {\n                if (x == 0) Nil\n                else x % 10 :: getDigits(x / 10)\n            }\n            def getSum(x : Long) : Long = {\n                if (x == 0) 0\n                else x % 10 + getSum(x / 10)\n            }\n            val digits = getDigits(x)\n            val sum = getSum(x)\n            digits.forall(d => d == 0 || x % d == 0) && digits.forall(d => d == 0 || sum % d == 0)\n        }\n        def getLudicRec(x : Long, l : List[Long]) : List[Long] = {\n            if (x == 0) l\n            else if (isLudic(x)) getLudicRec(x - 1, x :: l)\n            else getLudicRec(x - 1, l)\n        }\n        getLudicRec(n, Nil)",
    "        def isLudic(x : Long) : Boolean = {\n            def isLudic(x : Long, y : Long) : Boolean = {\n                if (x == 0) true\n                else if (x % y == 0) false\n                else isLudic(x, y + 1)\n            }\n            isLudic(x, 2)\n        }\n        def getLudic(x : Long, acc : List[Long]) : List[Long] = {\n            if (x == 0) acc\n            else if (isLudic(x)) getLudic(x - 1, x :: acc)\n            else getLudic(x - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 2) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 3) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 4) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 5) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 6) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 7) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 8) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 9) getLudic(n / 10, n :: acc)\n            else getLudic(n / 10, acc)\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i.toString.contains(\"0\")) {\n                ludic += i\n            } else {\n                var sum = 0\n                for (c <- i.toString) {\n                    sum += pow(c.asDigit, 2).toInt\n                }\n                if (sum.toString.contains(\"0\")) ludic += i\n            }\n        }\n        ludic.toList",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val d = s.map(c => (c - '0').toLong).toList\n            val ds = d.map(x => x * x)\n            val sum = ds.sum\n            if (sum == 1) true\n            else if (sum == n) false\n            else isLudic(sum)\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).map(x => x.toLong).toList",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            for (i <- 0 until l) {\n                val a = s.substring(0, i)\n                val b = s.substring(i, l)\n                if (a.length > 0 && b.length > 0) {\n                    val x = a.toLong\n                    val y = b.toLong\n                    if (x + y == x * y) return true\n                }\n            }\n            return false\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        return result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val m = s.length\n            var i = 0\n            while (i < m) {\n                val d = s(i).asDigit\n                if (d != 0 && n % d != 0) return false\n                i += 1\n            }\n            true\n        }\n        var result = List[Long]()\n        var i = 1L\n        while (i <= n) {\n            if (isLudic(i)) result = i :: result\n            i += 1\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i.toString.contains(\"0\") || i.toString.contains(\"2\") || i.toString.contains(\"4\") || i.toString.contains(\"6\") || i.toString.contains(\"8\")) {\n                ludic = ludic :+ i.toLong\n            }\n        }\n        return ludic",
    "        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(x => pow(x.asDigit, s.length).toInt).sum\n            if (sum == i) result += i\n        }\n        result.toList",
    "        val digits = n.toString.map(_.asDigit).toList\n        val ludic = new ListBuffer[Long]\n        def getLudic(digits : List[Int], n : Long) : Unit = {\n            if (n <= n) {\n                if (digits.forall(d => d % 2 == 0)) ludic += n\n                for (i <- 0 to 9) {\n                    if (i != 0 || digits.length != 0) {\n                        getLudic(i :: digits, n * 10 + i)\n                    }\n                }\n            }\n        }\n        getLudic(digits, 0)\n        ludic.toList",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, List())",
    "        var ludic = new ListBuffer[Long]\n        var i = 1\n        while (i <= n) {\n            if (isLudic(i)) ludic += i\n            i += 1\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            for (i <- 0 until l) {\n                val x = s.substring(0, i) + s.substring(i + 1)\n                val y = s(i) - '0'\n                if (x.toLong % y != 0) return false\n            }\n            return true\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        return result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        return ludic",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val ludic = new ArrayBuffer[Long]\n        def isLudic(n : Long) : Boolean = {\n            var sum = 0L\n            var m = n\n            while (m > 0) {\n                val d = m % 10\n                sum += pow(d, 2).toLong\n                m /= 10\n            }\n            if (sum == 1) true\n            else if (ludic.contains(sum)) false\n            else isLudic(sum)\n        }\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(c => pow(c.asDigit, s.length).toLong).sum\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.length == 1) ludic += i\n            else {\n                val sum = s.map(c => pow(c.asDigit, s.length).toInt).sum\n                if (sum == i) ludic += i\n            }\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else if (n % 10 == 0) getLudic(n / 10, l)\n            else getLudic(n / 10, (n % 10) :: l)\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList"
  ]
}