{
  "name": "mbpp_239_get_total_number_of_sequences",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    def getTotalNumberOfSequences(m : Long, n : Long) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getTotalNumberOfSequences((10l), (4l)) == (4l));\n    assert(getTotalNumberOfSequences((5l), (2l)) == (6l));\n    assert(getTotalNumberOfSequences((16l), (3l)) == (84l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- j / 2 to j - 1) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.fill(n.toInt + 1, m.toInt + 1)(0L)\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (i == 1) {\n                    dp(i)(j) = 1\n                } else {\n                    for (k <- 2 * j to j) {\n                        dp(i)(j) += dp(i - 1)(k)\n                    }\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val mod = 1000000007L\n        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) {\n                    dp(i) = (dp(i) + dp(i - 1)) % mod\n                }\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                if (i - j >= 0) dp(i) += dp(i - j)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to n.toInt) dp(i)(0) = 0\n        for (i <- 0 to m.toInt) dp(0)(i) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                dp(i)(j) = dp(i)(j - 1) + dp(i - 1)(j / 2)\n            }\n        }\n        dp(n.toInt)(m.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 1 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                dp(i)(j) = dp(i)(j - 1) + dp(i - 1)(j / 2)\n            }\n        }\n        dp(n.toInt)(m.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 2 * j to j) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                if (i - j >= 0) dp(i) += dp(i - j)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        // We can use dynamic programming to solve this problem.\n        // Let dp(i, j) be the number of sequences of length i, such that the last element is j.\n        // Then, dp(i, j) = sum(dp(i - 1, k)) for all k such that 2k <= j <= m.\n        // We can use a 2D array to store the values of dp.\n        // The answer is sum(dp(n, j)) for all j such that 2 <= j <= m.\n        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        // Base case: dp(1, j) = 1 for all j such that 2 <= j <= m.\n        for (j <- 2 to m.toInt) dp(1)(j) = 1\n        // Iterative case: dp(i, j) = sum(dp(i - 1, k)) for all k such that 2k <= j <= m.\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 2 * j to m.toInt) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        // The answer is sum(dp(n, j)) for all j such that 2 <= j <= m.\n        var sum = 0L\n        for (j <- 2 to m.toInt) sum += dp(n.toInt)(j)\n        sum",
    "        var dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        // The number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, is equal to the number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m.\n        // The number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m, is equal to the number of sequences of length n - 1, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m / 2.\n        // The number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m, is equal to the sum of the number of sequences of length n - 1, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m / 2, for all m / 2 >= 1.\n        // The number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m, is equal to the sum of the number of sequences of length n - 1, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m / 2, for all m / 2 >= 1, plus 1.\n        // The number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m, is equal to the sum of the number of sequences of length n - 1, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m, where the last element is m / 2, for all m / 2 >= 1, plus 1, plus the number of sequences of length n - 1, such that each",
    "        var dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                dp(i)(j) = dp(i)(j - 1)\n                if (j % 2 == 0) dp(i)(j) += dp(i - 1)(j / 2)\n            }\n        }\n        dp(n.toInt)(m.toInt)",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 1 to m.toInt) {\n            dp(1)(i) = 1\n        }\n        for (i <- 2 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                for (k <- 1 to j / 2) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.fill(n.toInt + 1, m.toInt + 1)(0L)\n        for (i <- 1 to m.toInt) {\n            dp(1)(i) = 1\n        }\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 1 to j / 2) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.fill(n.toInt + 1, m.toInt + 1)(0L)\n        for (i <- 1 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 1 to j / 2) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum"
  ]
}