{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue(List(nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            result += heap.dequeue\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        for (i <- 0 until k.toInt if heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val x = index / nums2.length\n            val y = index % nums2.length\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, (i, j)) = pq.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until n) {\n            heap.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < m) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            pq.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (sum, index) = pq.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) pq.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val pair = List(nums1(i), nums2(j))\n                if (pq.size < k) pq.enqueue(pair)\n                else if (pq.head.sum > pair.sum) {\n                    pq.dequeue\n                    pq.enqueue(pair)\n                }\n            }\n        }\n        pq.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i1, i2, _) = heap.dequeue\n            result += List(nums1(i1.toInt), nums2(i2.toInt))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, n)) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, n * m)) {\n            val (sum, x, y) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y < m - 1) heap.enqueue((nums1(x.toInt) + nums2(y.toInt + 1), x, y + 1))\n        }\n        result.toList"
  ]
}