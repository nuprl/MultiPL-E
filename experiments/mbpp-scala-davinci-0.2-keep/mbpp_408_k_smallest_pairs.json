{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue(List(nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            result += heap.dequeue\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        for (i <- 0 until k.toInt if heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val x = index / nums2.length\n            val y = index % nums2.length\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, (i, j)) = pq.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until n) {\n            heap.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < m) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            pq.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (sum, index) = pq.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) pq.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val pair = List(nums1(i), nums2(j))\n                if (pq.size < k) pq.enqueue(pair)\n                else if (pq.head.sum > pair.sum) {\n                    pq.dequeue\n                    pq.enqueue(pair)\n                }\n            }\n        }\n        pq.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i1, i2, _) = heap.dequeue\n            result += List(nums1(i1.toInt), nums2(i2.toInt))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, n)) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, n * m)) {\n            val (sum, x, y) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y < m - 1) heap.enqueue((nums1(x.toInt) + nums2(y.toInt + 1), x, y + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (pq.size < k) pq.enqueue((nums1(i) + nums2(j), (i, j)))\n                else {\n                    if (nums1(i) + nums2(j) < pq.head._1) {\n                        pq.dequeue\n                        pq.enqueue((nums1(i) + nums2(j), (i, j)))\n                    }\n                }\n            }\n        }\n        pq.map(x => List(nums1(x._2._1), nums2(x._2._2))).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, num1, num2) = heap.dequeue\n            result = List(num1, num2) :: result\n        }\n        result",
    "        val q = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                q.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (q.isEmpty) return result.toList\n            val (sum, x, y) = q.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, i, j) = heap.dequeue\n            result = List(i, j) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i, j + 1)))\n        }\n        result.toList",
    "        val q = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                q.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (q.isEmpty) return result\n            val (sum, i, j) = q.dequeue\n            result = List(i, j) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap += ((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result.append(List(pair._1, pair._2))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap.enqueue((nums1(i), nums2(0), nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k.toInt && heap.nonEmpty) {\n            val (x, y, _) = heap.dequeue\n            result += List(x, y)\n            if (y != nums2.last) {\n                val index = nums2.indexOf(y)\n                heap.enqueue((x, nums2(index + 1), x + nums2(index + 1)))\n            }\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, product) = heap.dequeue\n            result = List(List(sum, product)) ::: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length.toInt), nums2(index % nums2.length.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap += ((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield (i, j)\n        pairs.sortBy(x => x._1 + x._2).take(k.toInt).map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result.append(List(i, j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0L until min(k, heap.size)) {\n            val (a, b, _) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result.append(List(i, j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result.append(List(pair._1, pair._2))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, first, second) = heap.dequeue\n            result += List(first, second)\n        }\n        result.toList",
    "        val n = nums1.size\n        val m = nums2.size\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(n, k.toInt)) {\n            pq.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.size < k && !pq.isEmpty) {\n            val (sum, i, j) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j < m - 1) pq.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result.append(List(i, j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0L until min(k, heap.size)) {\n            val (sum, x, y) = heap.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                pq.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i * nums2.length) + j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, a, b) = heap.dequeue\n            result = List(a, b) :: result\n        }\n        result",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue(List(nums1(i), nums2(j)))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.size)) {\n            val (sum, index) = pq.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt if !heap.isEmpty) {\n            val (sum, x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < k) pq.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                pq.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.length).toInt) {\n            val (a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val queue = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                queue.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (queue.isEmpty) return result.toList\n            val (sum, x, y) = queue.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ArrayBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue()\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i * nums2.length) + (j + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            val (i, j) = (index / nums2.length, index % nums2.length)\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            pq += ((i, 0, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until min(k, nums1.length * nums2.length).toInt) {\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) {\n                pq += ((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        while (!heap.isEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result.append(List(i, j))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue(List(nums1(i), nums2(j)))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList",
    "        var result = List[List[Long]]()\n        var pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        for (i <- 0 until k) {\n            if (pq.isEmpty) return result\n            val (x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < k) pq.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val sorted = (for (i <- nums1; j <- nums2) yield (i + j, List(i, j))).sortBy(_._1).take(k.toInt)\n        sorted.map(_._2)",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val pairs = nums1.flatMap(x => nums2.map(y => List(x, y))).sortWith((x, y) => x(0) + x(1) < y(0) + y(1))\n        pairs.take(k.toInt)",
    "        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i), nums2(0)))\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (x, y) = heap.dequeue\n            result = List(x, y) :: result\n            if (y != nums2.last) heap.enqueue((x, nums2(nums2.indexOf(y) + 1)))\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) {\n                heap += ((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (nums1(i), nums2(j))))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (x, y)) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            heap.enqueue((i.toLong, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (i1, i2, sum) = heap.dequeue\n            result += List(nums1(i1.toInt), nums2(i2.toInt))\n            if (i2 + 1 < nums2.length) heap.enqueue((i1, i2 + 1, nums1(i1.toInt) + nums2(i2.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue(List(i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y < nums2.length - 1) {\n                heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        var result = List[List[Long]]()\n        if (nums1.length == 0 || nums2.length == 0) return result\n        var heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        for (i <- 0 until min(k, nums1.length * nums2.length).toInt) {\n            val (sum, i, j) = heap.dequeue\n            result = List(nums1(i.toInt), nums2(j.toInt)) :: result\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (heap.size < k) heap.enqueue((nums1(i), nums2(j)))\n                else {\n                    val (a, b) = heap.head\n                    if (nums1(i) + nums2(j) < a + b) {\n                        heap.dequeue\n                        heap.enqueue((nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result += List(pair._1, pair._2)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var res = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return res\n            val (sum, x, y) = pq.dequeue\n            res = List(x, y) :: res\n        }\n        res",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._1, x._2)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < k.toInt) pq.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        var result = List[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result = List(nums1(i), nums2(0)) :: result\n            if (nums2.length > 1) heap += ((nums1(i) + nums2(1), i))\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = pq.dequeue\n            result += List(nums1(index), nums2(i / nums1.length))\n            if (i / nums1.length + 1 < nums2.length) {\n                pq.enqueue((nums1(index) + nums2(i / nums1.length + 1), index))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        var result = List[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result = List(nums1(i), nums2(0)) :: result\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i + j, i, j))\n                else {\n                    val (sum, i1, j1) = heap.head\n                    if (i + j < sum) {\n                        heap.dequeue\n                        heap.enqueue((i + j, i, j))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (a, b, c) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0L until min(k, pq.size)) {\n            val (a, b, c) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by((_ : (Long, Long, Long))._3).reverse)\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- 0 until nums1.length) {\n            pq.enqueue((i.toLong, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (i, j, _) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) {\n                pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n            }\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var queue = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                queue.enqueue((i, j))\n            }\n        }\n        for (i <- 1 to k.toInt) {\n            if (queue.isEmpty) return result\n            val (a, b) = queue.dequeue\n            result = List(a, b) :: result\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                pq.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (pq.nonEmpty && result.length < k) {\n            val (sum, index) = pq.dequeue\n            val i = index / nums2.length.toInt\n            val j = index % nums2.length.toInt\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield (i, j)\n        pairs.sortWith((a, b) => a._1 + a._2 < b._1 + b._2).take(k.toInt).map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, _) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ArrayBuffer[List[Long]]()\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(index) + nums2(1), index))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.length)) {\n            val (sum, x, y) = pq.dequeue\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (i, j, _) = pq.dequeue\n            result.append(List(nums1(i.toInt), nums2(j.toInt)))\n            if (j + 1 < nums2.length) pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result.prepend(List(nums1(i), nums2(j)))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt if !heap.isEmpty) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i, j, _) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (x <- nums1) {\n            for (y <- nums2) {\n                heap.enqueue((x + y, x, y))\n            }\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i), nums2(j)))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i, j + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(nums1(x._2 / nums2.length), nums2(x._2 % nums2.length))).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i, j))\n                else {\n                    val (a, b) = heap.head\n                    if (i + j < a + b) {\n                        heap.dequeue\n                        heap.enqueue((i, j))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k.toInt) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue()\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        while (heap.nonEmpty) {\n            val (sum, x, y) = heap.dequeue()\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i + j, i * j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._1))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(nums1(x._2), nums2(x._3))).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i + j, i * j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._1)).toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            val (i, j) = (index / nums2.length, index % nums2.length)\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), i * nums2.length + j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) for (j <- nums2) heap.enqueue((i + j, i, j))\n        var result = List[List[Long]]()\n        for (i <- 0 until min(k, heap.size)) {\n            val (sum, i, j) = heap.dequeue\n            result = List(i, j) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result\n            val (i1, i2, sum) = heap.dequeue\n            result = List(nums1(i1.toInt), nums2(i2.toInt)) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(nums1(x._2), nums2(x._3))).toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, _) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            val (sum, x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => -x._3))\n        for (i <- 0 until nums1.length) {\n            pq.enqueue((i.toLong, 0.toLong, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until k) {\n            if (pq.isEmpty) return result.toList\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, x, y) = heap.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val queue = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                queue.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0L until k) {\n            if (queue.isEmpty) return result.toList\n            val (x, y) = queue.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield List(i, j)\n        pairs.sortBy(x => x(0) + x(1)).take(k.toInt)",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (heap.size < k) heap.enqueue(List(nums1(i), nums2(j)))\n                else {\n                    val sum = nums1(i) + nums2(j)\n                    if (sum < heap.head(0) + heap.head(1)) {\n                        heap.dequeue\n                        heap.enqueue(List(nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i), nums2(0)))\n        }\n        while (k > 0 && !heap.isEmpty) {\n            val (x, y) = heap.dequeue\n            result = result :+ List(x, y)\n            k -= 1\n            if (y != nums2.last) {\n                heap.enqueue((x, nums2(nums2.indexOf(y) + 1)))\n            }\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap += ((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        while (heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val result = new ListBuffer[List[Long]]\n        var i = 0\n        var j = 0\n        while (i < nums1.length && j < nums2.length && result.length < k) {\n            val sum = nums1(i) + nums2(j)\n            if (i + 1 < nums1.length && nums1(i + 1) + nums2(j) < sum) i += 1\n            else if (j + 1 < nums2.length && nums1(i) + nums2(j + 1) < sum) j += 1\n            else {\n                result += List(nums1(i), nums2(j))\n                if (i + 1 < nums1.length && j + 1 < nums2.length) {\n                    if (nums1(i + 1) + nums2(j) < nums1(i) + nums2(j + 1)) i += 1\n                    else j += 1\n                }\n                else if (i + 1 < nums1.length) i += 1\n                else j += 1\n            }\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- 0 until nums1.length) {\n            pq += ((0, i, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k) {\n            if (pq.isEmpty) return result.toList\n            val (j, i, sum) = pq.dequeue\n            result += List(nums1(i), nums2(j.toInt))\n            if (j < nums2.length - 1) pq += ((j + 1, i, nums1(i) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            for (j <- 0 until min(nums2.length, k.toInt)) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(heap.size, k.toInt)) {\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val n1 = nums1.length\n        val n2 = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, n1)) {\n            heap.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < n2) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, num1, num2) = heap.dequeue\n            result += List(num1, num2)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, _) = heap.dequeue\n            result.append(List(a, b))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (pq.size < k) pq.enqueue(List(nums1(i), nums2(j)))\n                else {\n                    val sum = nums1(i) + nums2(j)\n                    if (sum < pq.head(0) + pq.head(1)) {\n                        pq.dequeue\n                        pq.enqueue(List(nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        pq.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, a, b) = heap.dequeue\n            result = List(a, b) :: result\n        }\n        result",
    "        val heap = new BinaryHeap[(Long, Long, Long)](k.toInt)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.add((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            val (sum, x, y) = heap.remove\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq += ((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.size)) {\n            val (x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList"
  ]
}