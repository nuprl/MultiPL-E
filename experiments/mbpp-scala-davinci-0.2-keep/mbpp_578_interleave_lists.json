{
  "name": "mbpp_578_interleave_lists",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to interleave 3 lists of the same length into a single flat list.\n    def interleaveLists(list1 : List[Long], list2 : List[Long], list3 : List[Long]) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(interleaveLists((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)), (List[Long](10l.toLong, 20l.toLong, 30l.toLong, 40l.toLong, 50l.toLong, 60l.toLong, 70l.toLong)), (List[Long](100l.toLong, 200l.toLong, 300l.toLong, 400l.toLong, 500l.toLong, 600l.toLong, 700l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 100l.toLong, 2l.toLong, 20l.toLong, 200l.toLong, 3l.toLong, 30l.toLong, 300l.toLong, 4l.toLong, 40l.toLong, 400l.toLong, 5l.toLong, 50l.toLong, 500l.toLong, 6l.toLong, 60l.toLong, 600l.toLong, 7l.toLong, 70l.toLong, 700l.toLong))));\n    assert(interleaveLists((List[Long](10l.toLong, 20l.toLong)), (List[Long](15l.toLong, 2l.toLong)), (List[Long](5l.toLong, 10l.toLong))).equals((List[Long](10l.toLong, 15l.toLong, 5l.toLong, 20l.toLong, 2l.toLong, 10l.toLong))));\n    assert(interleaveLists((List[Long](11l.toLong, 44l.toLong)), (List[Long](10l.toLong, 15l.toLong)), (List[Long](20l.toLong, 5l.toLong))).equals((List[Long](11l.toLong, 10l.toLong, 20l.toLong, 44l.toLong, 15l.toLong, 5l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val list = ListBuffer[Long]()\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length == 0) return List()\n        else return List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = ListBuffer[Long]()\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.length != list2.length || list1.length != list3.length) throw new IllegalArgumentException(\"Lists must be of equal length\")\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        list1.zip(list2).zip(list3).map(x => List(x._1._1, x._1._2, x._2)).flatten",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result : List[Long] = List()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        return result",
    "        // Assume all lists are the same length\n        val length = list1.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        def interleaveListsHelper(list1 : List[Long], list2 : List[Long], list3 : List[Long], result : List[Long]) : List[Long] = {\n            if (list1.length == 0) result\n            else interleaveListsHelper(list1.tail, list2.tail, list3.tail, result :+ list1.head :+ list2.head :+ list3.head)\n        }\n        interleaveListsHelper(list1, list2, list3, List())",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be the same length\")\n        else {\n            var result = List[Long]()\n            for (i <- 0 until list1.length) {\n                result = result :+ list1(i)\n                result = result :+ list2(i)\n                result = result :+ list3(i)\n            }\n            result\n        }",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val n = list1.length\n        val list = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) List()\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result ::: List(list1(i), list2(i), list3(i))\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        def interleaveListsHelper(list1 : List[Long], list2 : List[Long], list3 : List[Long], result : List[Long]) : List[Long] = {\n            if (list1.isEmpty) result\n            else interleaveListsHelper(list1.tail, list2.tail, list3.tail, result :+ list1.head :+ list2.head :+ list3.head)\n        }\n        interleaveListsHelper(list1, list2, list3, List())",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be of equal length\")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.length != list2.length || list1.length != list3.length) throw new IllegalArgumentException(\"Lists must be of equal length\")\n        else (list1, list2, list3).zipped.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length.\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        def interleaveListsHelper(list1 : List[Long], list2 : List[Long], list3 : List[Long], result : List[Long]) : List[Long] = {\n            if (list1.isEmpty) result\n            else interleaveListsHelper(list1.tail, list2.tail, list3.tail, result :+ list1.head :+ list2.head :+ list3.head)\n        }\n        interleaveListsHelper(list1, list2, list3, List())",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists are not of the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) return List[Long]()\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be of equal length\")\n        else if (list1.length == 0) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        list1.zip(list2).zip(list3).map(x => List(x._1._1, x._1._2, x._2)).flatten",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        val list = ListBuffer[Long]()\n        for (i <- 0 to list1.length - 1) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length\")\n        }\n        def interleaveListsHelper(list1 : List[Long], list2 : List[Long], list3 : List[Long], result : List[Long]) : List[Long] = {\n            if (list1.length == 0) {\n                result\n            } else {\n                interleaveListsHelper(list1.tail, list2.tail, list3.tail, result ::: List(list1.head, list2.head, list3.head))\n            }\n        }\n        interleaveListsHelper(list1, list2, list3, List())",
    "        if (list1.length != list2.length || list1.length != list3.length) throw new IllegalArgumentException(\"Lists must be of the same length\")\n        if (list1.length == 0) return Nil\n        return List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new Exception(\"Lists must be of equal length\")\n        else {\n            var result = List[Long]()\n            for (i <- 0 until list1.length) {\n                result = result :+ list1(i)\n                result = result :+ list2(i)\n                result = result :+ list3(i)\n            }\n            result\n        }",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new Exception(\"Lists must be of the same length\")\n        }\n        else {\n            val result = new ListBuffer[Long]()\n            for (i <- 0 until list1.length) {\n                result += list1(i)\n                result += list2(i)\n                result += list3(i)\n            }\n            result.toList\n        }",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new Exception(\"Lists are not the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        (list1, list2, list3) match {\n            case (Nil, Nil, Nil) => Nil\n            case (x :: xs, y :: ys, z :: zs) => x :: y :: z :: interleaveLists(xs, ys, zs)\n        }",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be the same length.\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        list1.zip(list2).zip(list3).map(x => List(x._1._1, x._1._2, x._2)).flatten",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be the same length\")\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result ::: List(list1(i), list2(i), list3(i))\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        (list1, list2, list3) match {\n            case (Nil, Nil, Nil) => Nil\n            case (x :: xs, y :: ys, z :: zs) => x :: y :: z :: interleaveLists(xs, ys, zs)\n            case _ => throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new Exception(\"Lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result ::: List(list1(i), list2(i), list3(i))\n        }\n        result",
    "        if (list1.isEmpty)\n            Nil\n        else\n            List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list2.length != list3.length)\n            throw new IllegalArgumentException(\"Lists must be of the same length\")\n        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        list1.zip(list2).zip(list3).map(x => List(x._1._1, x._1._2, x._2)).flatten",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        (list1, list2, list3) match {\n            case (Nil, Nil, Nil) => Nil\n            case (l1 :: tail1, l2 :: tail2, l3 :: tail3) => l1 :: l2 :: l3 :: interleaveLists(tail1, tail2, tail3)\n            case _ => throw new IllegalArgumentException(\"Lists must be the same length\")\n        }",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 to list1.length - 1) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length.\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        (list1, list2, list3) match {\n            case (Nil, Nil, Nil) => Nil\n            case (x :: xs, y :: ys, z :: zs) => List(x, y, z) ::: interleaveLists(xs, ys, zs)\n        }",
    "        (list1, list2, list3) match {\n            case (Nil, Nil, Nil) => Nil\n            case (x :: xs, y :: ys, z :: zs) => x :: y :: z :: interleaveLists(xs, ys, zs)\n        }",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty)\n            List()\n        else\n            List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list1.length != list3.length) throw new IllegalArgumentException(\"Lists must be of the same length\")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result ::: List(list1(i), list2(i), list3(i))\n        }\n        result",
    "        if (list1.isEmpty) return List()\n        else return List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be of the same length\")\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val zipped = list1.zip(list2).zip(list3).map(x => List(x._1._1, x._1._2, x._2))\n        zipped.flatten",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            println(\"Error: lists are not of the same length\")\n            return List()\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        return result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) List()\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list1.length != list3.length) throw new IllegalArgumentException(\"Lists must be of the same length\")\n        def interleaveListsHelper(list1 : List[Long], list2 : List[Long], list3 : List[Long], acc : List[Long]) : List[Long] = {\n            if (list1.isEmpty) acc\n            else interleaveListsHelper(list1.tail, list2.tail, list3.tail, acc :+ list1.head :+ list2.head :+ list3.head)\n        }\n        interleaveListsHelper(list1, list2, list3, List())",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result ::: List(list1(i), list2(i), list3(i))\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length == 0) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) List()\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) List()\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        list1.zip(list2).zip(list3).map(x => List(x._1._1, x._1._2, x._2)).flatten",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be the same length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list1.length != list3.length) {\n            throw new Exception(\"Lists are not of the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of the same length.\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        (list1, list2, list3) match {\n            case (Nil, Nil, Nil) => Nil\n            case (x :: xs, y :: ys, z :: zs) => x :: y :: z :: interleaveLists(xs, ys, zs)\n        }",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists are not the same length.\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result ::: List(list1(i), list2(i), list3(i))\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList"
  ]
}