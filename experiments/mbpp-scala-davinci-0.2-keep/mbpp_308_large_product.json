{
  "name": "mbpp_308_large_product",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedMapRev = nums1SortedMap.map(_.swap)\n        val nums2SortedMapRev = nums2SortedMap.map(_.swap)\n        val nums1SortedMapRevSet = nums1SortedMapRev.keySet\n        val nums2SortedMapRevSet = nums2SortedMapRev.keySet\n        val nums1SortedMapRevList = nums1SortedMapRev.toList\n        val nums2SortedMapRevList = nums2SortedMapRev.toList\n        val nums1SortedMapRevListSorted = nums1SortedMapRevList.sortWith(_._1 > _._1)\n        val nums2SortedMapRevListSorted = nums2SortedMapRevList.sortWith(_._1 > _._1)\n        val nums1SortedMapRevListSortedMap = nums1SortedMapRevListSorted.toMap\n        val nums2SortedMapRevListSortedMap = nums2SortedMapRevListSorted.toMap\n        val nums1SortedMapRevListSortedMapSet = nums1SortedMapRevListSortedMap.keySet\n        val nums2SortedMapRevListSortedMapSet = nums2SortedMapRevListSortedMap.keySet\n        val nums1SortedMapRevListSortedMapSetList = nums1SortedMapRevListSortedMapSet.toList\n        val nums2SortedMapRevListSortedMapSetList = nums2SortedMapRevListSortedMapSet.toList\n        val nums1SortedMapRevListS",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) {\n                    pq.enqueue((sorted1(i), sorted2(j), product))\n                } else if (pq.head._3 < product) {\n                    pq.dequeue\n                    pq.enqueue((sorted1(i), sorted2(j), product))\n                }\n            }\n        }\n        pq.map(_._3).toList",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySorted = nums1SortedReversedSetArray.sorted\n        val nums2SortedReversedSetArraySorted = nums2SortedReversedSetArray.sorted\n        val nums1SortedReversedSetArraySortedSize = nums1SortedReversedSetArraySorted.size\n        val nums2SortedReversedSetArraySortedSize = nums2SortedReversedSetArraySorted.size\n        val nums1SortedReversedSetArraySortedReversed = nums1SortedReversedSetArraySorted.reverse\n        val nums2SortedReversedSetArraySortedReversed = nums2SortedReversedSetArraySorted.reverse\n        val nums1SortedReversedSetArraySortedReversedSize = nums1SortedReversedSetArraySortedReversed.size\n        val nums2SortedReversedSetArraySortedRevers",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val products = new ArrayBuffer[Long]()\n        for (i <- 0 until nums1Sorted.length; j <- 0 until nums2Sorted.length) {\n            products += nums1Sorted(i) * nums2Sorted(j)\n        }\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySorted = nums1SortedReversedSetArray.sorted\n        val nums2SortedReversedSetArraySorted = nums2SortedReversedSetArray.sorted\n        val nums1SortedReversedSetArraySortedReversed = nums1SortedReversedSetArraySorted.reverse\n        val nums2SortedReversedSetArraySortedReversed = nums2SortedReversedSetArraySorted.reverse\n        val nums1SortedReversedSetArraySortedReversedSize = nums1SortedReversedSetArraySortedReversed.size\n        val nums2SortedReversedSetArraySortedReversedSize = nums2SortedReversedSetArraySortedReversed.size\n        val nums1SortedReversedSetArraySortedReversedMap = nums1SortedReversedSetArraySortedReversed.zipWithIndex.toMap",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val max1 = sorted1(0)\n        val max2 = sorted2(0)\n        val max = max1 * max2\n        val min1 = sorted1(sorted1.length - 1)\n        val min2 = sorted2(sorted2.length - 1)\n        val min = min1 * min2\n        val result = new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        var count = 0\n        while (count < N) {\n            val product = sorted1(i) * sorted2(j)\n            if (product == max) {\n                result += product\n                count += 1\n                i += 1\n                j += 1\n            } else if (product > max) {\n                result += product\n                count += 1\n                i += 1\n                j += 1\n            } else if (product < max) {\n                if (sorted1(i) > sorted2(j)) {\n                    i += 1\n                } else {\n                    j += 1\n                }\n            }\n        }\n        result.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val products = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse\n        products.take(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(product)\n                else if (product > pq.head) {\n                    pq.dequeue\n                    pq.enqueue(product)\n                }\n            }\n        }\n        pq.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 to nums1.length - 1; j <- 0 to nums2.length - 1) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1Set = nums1Sorted.toSet\n        val nums2Set = nums2Sorted.toSet\n        val nums1Map = nums1Sorted.zipWithIndex.toMap\n        val nums2Map = nums2Sorted.zipWithIndex.toMap\n        val nums1Index = nums1Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums2Index = nums2Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums1IndexReverse = nums1Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums2IndexReverse = nums2Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums1IndexReverseMap = nums1Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums2IndexReverseMap = nums2Sorted.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val nums1IndexMap = nums1Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums2IndexMap = nums2Sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val nums1IndexReverseSet = nums1Sorted.zipWithIndex.map(x => (x._2, x._1)).toSet\n        val nums2IndexReverseSet = nums2Sorted.zipWithIndex.map(x => (x._2, x._1)).toSet\n        val nums1IndexSet = nums1Sorted.zipWithIndex.map(x => (x._1, x._2)).toSet\n        val nums2IndexSet = nums2Sorted",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue((product, sorted1(i)))\n                else if (product > pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((product, sorted1(i)))\n                }\n            }\n        }\n        pq.toList.map(_._1)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        val set = new HashSet[(Int, Int)]()\n        pq.enqueue((sorted1.last * sorted2.last, sorted1.length - 1, sorted2.length - 1))\n        set.add((sorted1.length - 1, sorted2.length - 1))\n        var result = List[Long]()\n        while (result.length < N) {\n            val (product, i, j) = pq.dequeue\n            result = result :+ product\n            if (i - 1 >= 0 && !set.contains((i - 1, j))) {\n                pq.enqueue((sorted1(i - 1) * sorted2(j), i - 1, j))\n                set.add((i - 1, j))\n            }\n            if (j - 1 >= 0 && !set.contains((i, j - 1))) {\n                pq.enqueue((sorted1(i) * sorted2(j - 1), i, j - 1))\n                set.add((i, j - 1))\n            }\n        }\n        result",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq += ((product, i, j))\n                else if (product > pq.head._1) {\n                    pq.dequeue\n                    pq += ((product, i, j))\n                }\n            }\n        }\n        pq.map(_._1).toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val nums = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse.take(N.toInt)\n        nums",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val pq = new PriorityQueue[Long]()\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val p = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(p)\n                else if (pq.head < p) {\n                    pq.dequeue\n                    pq.enqueue(p)\n                }\n            }\n        }\n        pq.toList.sortWith(_ > _)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                val p = i * j\n                if (pq.size < N) pq.enqueue(p)\n                else if (pq.head < p) {\n                    pq.dequeue\n                    pq.enqueue(p)\n                }\n            }\n        }\n        pq.toList",
    "        var products = new ArrayBuffer[Long]\n        for (num1 <- nums1; num2 <- nums2) products += num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) {\n            val product = sorted1(i) * sorted2(j)\n            if (heap.size < N) heap += product\n            else if (heap.head < product) {\n                heap.dequeue\n                heap += product\n            }\n        }\n        heap.toList",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1Max = nums1Sorted.last\n        val nums2Max = nums2Sorted.last\n        val nums1Min = nums1Sorted.head\n        val nums2Min = nums2Sorted.head\n        val nums1MaxIndex = nums1.indexOf(nums1Max)\n        val nums2MaxIndex = nums2.indexOf(nums2Max)\n        val nums1MinIndex = nums1.indexOf(nums1Min)\n        val nums2MinIndex = nums2.indexOf(nums2Min)\n        val nums1MaxIndex2 = nums1.lastIndexOf(nums1Max)\n        val nums2MaxIndex2 = nums2.lastIndexOf(nums2Max)\n        val nums1MinIndex2 = nums1.lastIndexOf(nums1Min)\n        val nums2MinIndex2 = nums2.lastIndexOf(nums2Min)\n        val nums1MaxIndex3 = nums1.indexWhere(_ == nums1Max)\n        val nums2MaxIndex3 = nums2.indexWhere(_ == nums2Max)\n        val nums1MinIndex3 = nums1.indexWhere(_ == nums1Min)\n        val nums2MinIndex3 = nums2.indexWhere(_ == nums2Min)\n        val nums1MaxIndex4 = nums1.lastIndexWhere(_ == nums1Max)\n        val nums2MaxIndex4 = nums2.lastIndexWhere(_ == nums2Max)\n        val nums1MinIndex4 = nums1.lastIndexWhere(_ == nums1Min)\n        val nums2MinIndex4 = nums2.lastIndexWhere(_ == nums2Min)\n        val nums1MaxIndex5 = nums1.indexOf(nums1Max, nums1MaxIndex + 1)\n        val nums2MaxIndex5 = nums2.indexOf(nums2Max, nums2MaxIndex +",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val nums = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse.take(N.toInt)\n        nums",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedRev = nums1Sorted.reverse\n        val nums2SortedRev = nums2Sorted.reverse\n        val nums1SortedRevIndex = nums1SortedRev.zipWithIndex.toMap\n        val nums2SortedRevIndex = nums2SortedRev.zipWithIndex.toMap\n        val nums1SortedRevIndexed = nums1SortedRev.zipWithIndex\n        val nums2SortedRevIndexed = nums2SortedRev.zipWithIndex\n        val nums1SortedRevIndexedSorted = nums1SortedRevIndexed.sortBy(_._1)\n        val nums2SortedRevIndexedSorted = nums2SortedRevIndexed.sortBy(_._1)\n        val nums1SortedRevIndexedSortedRev = nums1SortedRevIndexedSorted.reverse\n        val nums2SortedRevIndexedSortedRev = nums2SortedRevIndexedSorted.reverse\n        val nums1SortedRevIndexedSortedRevIndex = nums1SortedRevIndexedSortedRev.zipWithIndex.toMap\n        val nums2SortedRevIndexedSortedRevIndex = nums2SortedRevIndexedSortedRev.zipWithIndex.toMap\n        val nums1SortedRevIndexedSortedRevIndexed = nums1SortedRevIndexedSortedRev.zipWithIndex\n        val nums2SortedRevIndexedSortedRevIndexed = nums2SortedRevIndexedSortedRev.zipWithIndex\n        val nums1SortedRevIndexedSortedRevIndexedSorted = nums1SortedRevIndexedSortedRevIndexed.sortBy(_._1._1)\n        val nums2SortedRevIndexedSortedRevIndexedSorted = nums2SortedRevIndexedSortedRevIndexed.sortBy(_._1._1)\n        val nums1SortedRevIndexedSortedRevIndexedSortedRev = nums1SortedRevIndexedSorted",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedMapReverse = nums1SortedMap.map(_.swap)\n        val nums2SortedMapReverse = nums2SortedMap.map(_.swap)\n        val nums1SortedMapReverseSet = nums1SortedMapReverse.keySet\n        val nums2SortedMapReverseSet = nums2SortedMapReverse.keySet\n        val nums1SortedMapReverseList = nums1SortedMapReverse.toList\n        val nums2SortedMapReverseList = nums2SortedMapReverse.toList\n        val nums1SortedMapReverseListSorted = nums1SortedMapReverseList.sortWith(_._1 > _._1)\n        val nums2SortedMapReverseListSorted = nums2SortedMapReverseList.sortWith(_._1 > _._1)\n        val nums1SortedMapReverseListSortedMap = nums1SortedMapReverseListSorted.toMap\n        val nums2SortedMapReverseListSortedMap = nums2SortedMapReverseListSorted.toMap\n        val nums1SortedMapReverseListSortedMapReverse = nums1SortedMapReverseListSortedMap.map(_.swap)\n        val nums2SortedMapReverseListSortedMapReverse = nums2SortedMapReverseListSortedMap.map(_.swap)\n        val nums1SortedMapReverseListSortedMapReverseSet",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for(x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = new Array[Long](nums1.length * nums2.length)\n        for (i <- 0 until nums1.length; j <- 0 until nums2.length) {\n            products(i * nums2.length + j) = nums1(i) * nums2(j)\n        }\n        products.sorted.reverse.take(N.toInt).toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt).toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val heap = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        heap.enqueue((sorted1(0) * sorted2(0), 0, 0))\n        val result = new ListBuffer[Long]()\n        for (i <- 1 to N.toInt) {\n            val (product, index1, index2) = heap.dequeue\n            result += product\n            if (index1 + 1 < sorted1.length) heap.enqueue((sorted1(index1 + 1) * sorted2(index2), index1 + 1, index2))\n            if (index2 + 1 < sorted2.length) heap.enqueue((sorted1(index1) * sorted2(index2 + 1), index1, index2 + 1))\n        }\n        result.toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for {\n            i <- nums1\n            j <- nums2\n        } yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue((product, sorted1(i)))\n                else if (product > pq.head._1) {\n                    pq.dequeue\n                    pq.enqueue((product, sorted1(i)))\n                }\n            }\n        }\n        pq.map(_._1).toList",
    "        val products = for {\n            num1 <- nums1\n            num2 <- nums2\n        } yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums = nums1.map(x => nums2.map(y => x * y)).flatten.sorted.reverse.take(N.toInt)\n        nums",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.takeRight(N.toInt).toList",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until nums1.length; j <- 0 until nums2.length) {\n            pq += nums1(i) * nums2(j)\n            if (pq.size > N) pq.dequeue\n        }\n        pq.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (a <- nums1; b <- nums2) yield a * b\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt).reverse",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1Set = nums1Sorted.toSet\n        val nums2Set = nums2Sorted.toSet\n        val nums1Map = nums1Sorted.zipWithIndex.toMap\n        val nums2Map = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedWithIndex = nums1Sorted.zipWithIndex\n        val nums2SortedWithIndex = nums2Sorted.zipWithIndex\n        val result = new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        while (result.length < N) {\n            val num1 = nums1Sorted(i)\n            val num2 = nums2Sorted(j)\n            val product = num1 * num2\n            if (result.length == 0 || result.last != product) {\n                result += product\n                if (result.length == N) return result.toList\n            }\n            if (num1 > num2) {\n                if (i < nums1.length - 1) i += 1\n                else j += 1\n            } else if (num1 < num2) {\n                if (j < nums2.length - 1) j += 1\n                else i += 1\n            } else {\n                val i1 = nums1Map(num1)\n                val i2 = nums2Map(num2)\n                if (i1 < nums1.length - 1 && i2 < nums2.length - 1) {\n                    if (nums1Sorted(i1 + 1) > nums2Sorted(i2 + 1)) i += 1\n                    else j += 1\n                } else if (i1 < nums1.length - 1) i += 1\n                else if (i2 < nums2.length - 1) j += 1\n                else {\n                    i += 1\n                    j += 1\n                }\n            }\n        }\n        result.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedIndex = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedIndex = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedIndexReverse = nums1SortedIndex.map(_.swap)\n        val nums2SortedIndexReverse = nums2SortedIndex.map(_.swap)\n        val nums1SortedIndexReverseSet = nums1SortedIndexReverse.toSet\n        val nums2SortedIndexReverseSet = nums2SortedIndexReverse.toSet\n        val nums1SortedIndexReverseMap = nums1SortedIndexReverse.toMap\n        val nums2SortedIndexReverseMap = nums2SortedIndexReverse.toMap\n        val nums1SortedIndexReverseMapReverse = nums1SortedIndexReverseMap.map(_.swap)\n        val nums2SortedIndexReverseMapReverse = nums2SortedIndexReverseMap.map(_.swap)\n        val nums1SortedIndexReverseMapReverseSet = nums1SortedIndexReverseMapReverse.toSet\n        val nums2SortedIndexReverseMapReverseSet = nums2SortedIndexReverseMapReverse.toSet\n        val nums1SortedIndexReverseMapReverseMap = nums1SortedIndexReverseMapReverse.toMap\n        val nums2SortedIndexReverseMapReverseMap = nums2SortedIndex",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for(num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReverse = nums1Sorted.reverse\n        val nums2SortedReverse = nums2Sorted.reverse\n        val nums1SortedReverseSet = nums1SortedReverse.toSet\n        val nums2SortedReverseSet = nums2SortedReverse.toSet\n        val nums1SortedReverseSetSize = nums1SortedReverseSet.size\n        val nums2SortedReverseSetSize = nums2SortedReverseSet.size\n        val nums1SortedReverseSetSizeMinusOne = nums1SortedReverseSetSize - 1\n        val nums2SortedReverseSetSizeMinusOne = nums2SortedReverseSetSize - 1\n        val nums1SortedReverseSetSizeMinusOneDouble = nums1SortedReverseSetSizeMinusOne.toDouble\n        val nums2SortedReverseSetSizeMinusOneDouble = nums2SortedReverseSetSizeMinusOne.toDouble\n        val nums1SortedReverseSetSizeMinusOneDoubleSqrt = sqrt(nums1SortedReverseSetSizeMinusOneDouble)\n        val nums2SortedReverseSetSizeMinusOneDoubleSqrt = sqrt(nums2SortedReverseSetSizeMinusOneDouble)\n        val nums1SortedReverseSetSizeMinusOneDoubleSqrtCeil = ceil(nums1SortedReverseSetSizeMinusOneDoubleSqrt)\n        val nums2SortedReverseSetSizeMinusOneDoubleSqrtCeil = ceil(nums2SortedReverseSetSizeMinusOneDoubleSqrt)\n        val nums1SortedReverseSetSizeMinusOneDoubleSqrtCeilInt = nums1SortedReverseSetSizeMinusOneDoubleSqrtCeil.toInt\n        val num",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val result = new ListBuffer[Long]\n        var i = sorted1.length - 1\n        var j = sorted2.length - 1\n        while (result.length < N) {\n            if (sorted1(i) * sorted2(j) > sorted1(i - 1) * sorted2(j - 1)) {\n                result += sorted1(i) * sorted2(j)\n                i -= 1\n            } else {\n                result += sorted1(i - 1) * sorted2(j - 1)\n                i -= 1\n                j -= 1\n            }\n        }\n        result.toList",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)"
  ]
}