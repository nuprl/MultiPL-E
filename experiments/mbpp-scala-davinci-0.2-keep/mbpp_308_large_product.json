{
  "name": "mbpp_308_large_product",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedMapRev = nums1SortedMap.map(_.swap)\n        val nums2SortedMapRev = nums2SortedMap.map(_.swap)\n        val nums1SortedMapRevSet = nums1SortedMapRev.keySet\n        val nums2SortedMapRevSet = nums2SortedMapRev.keySet\n        val nums1SortedMapRevList = nums1SortedMapRev.toList\n        val nums2SortedMapRevList = nums2SortedMapRev.toList\n        val nums1SortedMapRevListSorted = nums1SortedMapRevList.sortWith(_._1 > _._1)\n        val nums2SortedMapRevListSorted = nums2SortedMapRevList.sortWith(_._1 > _._1)\n        val nums1SortedMapRevListSortedMap = nums1SortedMapRevListSorted.toMap\n        val nums2SortedMapRevListSortedMap = nums2SortedMapRevListSorted.toMap\n        val nums1SortedMapRevListSortedMapSet = nums1SortedMapRevListSortedMap.keySet\n        val nums2SortedMapRevListSortedMapSet = nums2SortedMapRevListSortedMap.keySet\n        val nums1SortedMapRevListSortedMapSetList = nums1SortedMapRevListSortedMapSet.toList\n        val nums2SortedMapRevListSortedMapSetList = nums2SortedMapRevListSortedMapSet.toList\n        val nums1SortedMapRevListS",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) {\n                    pq.enqueue((sorted1(i), sorted2(j), product))\n                } else if (pq.head._3 < product) {\n                    pq.dequeue\n                    pq.enqueue((sorted1(i), sorted2(j), product))\n                }\n            }\n        }\n        pq.map(_._3).toList",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySorted = nums1SortedReversedSetArray.sorted\n        val nums2SortedReversedSetArraySorted = nums2SortedReversedSetArray.sorted\n        val nums1SortedReversedSetArraySortedSize = nums1SortedReversedSetArraySorted.size\n        val nums2SortedReversedSetArraySortedSize = nums2SortedReversedSetArraySorted.size\n        val nums1SortedReversedSetArraySortedReversed = nums1SortedReversedSetArraySorted.reverse\n        val nums2SortedReversedSetArraySortedReversed = nums2SortedReversedSetArraySorted.reverse\n        val nums1SortedReversedSetArraySortedReversedSize = nums1SortedReversedSetArraySortedReversed.size\n        val nums2SortedReversedSetArraySortedRevers",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val products = new ArrayBuffer[Long]()\n        for (i <- 0 until nums1Sorted.length; j <- 0 until nums2Sorted.length) {\n            products += nums1Sorted(i) * nums2Sorted(j)\n        }\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySorted = nums1SortedReversedSetArray.sorted\n        val nums2SortedReversedSetArraySorted = nums2SortedReversedSetArray.sorted\n        val nums1SortedReversedSetArraySortedReversed = nums1SortedReversedSetArraySorted.reverse\n        val nums2SortedReversedSetArraySortedReversed = nums2SortedReversedSetArraySorted.reverse\n        val nums1SortedReversedSetArraySortedReversedSize = nums1SortedReversedSetArraySortedReversed.size\n        val nums2SortedReversedSetArraySortedReversedSize = nums2SortedReversedSetArraySortedReversed.size\n        val nums1SortedReversedSetArraySortedReversedMap = nums1SortedReversedSetArraySortedReversed.zipWithIndex.toMap",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)"
  ]
}