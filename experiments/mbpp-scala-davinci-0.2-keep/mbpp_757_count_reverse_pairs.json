{
  "name": "mbpp_757_count_reverse_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n    def countReversePairs(test_list : List[String]) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countReversePairs((List[String](\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"))) == (2l));\n    assert(countReversePairs((List[String](\"geeks\", \"best\", \"for\", \"skeeg\"))) == (1l));\n    assert(countReversePairs((List[String](\"makes\", \"best\", \"sekam\", \"for\", \"rof\"))) == (2l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(i)) result += count(i)\n            if (i == reverse) result -= 1\n        }\n        result / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                count += map(i) * map(rev)\n            }\n        }\n        count / 2",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val pairs = test_list.map(x => reverse_set.contains(x))\n        pairs.count(x => x)",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var result = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                result += map(i)\n                map(i) = 0\n            }\n        }\n        result",
    "        val map = Map[String, Int]()\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) count += map(str)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count",
    "        val count = new HashMap[String, Long]\n        for (i <- 0 until test_list.length) {\n            val reversed = test_list(i).reverse\n            if (count.contains(reversed)) count(reversed) += 1\n            else count(reversed) = 1\n        }\n        var result = 0L\n        for (i <- 0 until test_list.length) {\n            val reversed = test_list(i).reverse\n            if (count.contains(reversed)) {\n                result += count(reversed)\n                count(reversed) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map(rev) = 0\n            }\n        }\n        count",
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (count.contains(rev)) count(rev) += 1\n            else count += (rev -> 1)\n        }\n        var result = 0\n        for (i <- test_list) {\n            if (count.contains(i)) result += count(i)\n        }\n        result",
    "        val map = new HashMap[String, Long]()\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n            }\n            if (map.contains(s)) {\n                map(s) += 1\n            } else {\n                map(s) = 1\n            }\n        }\n        count",
    "        val map = Map[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) map(r) += 1\n            else map(r) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            if (map.contains(s)) count += map(s)\n        }\n        count",
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0L\n        for (i <- count.keys) {\n            if (count.contains(i)) {\n                val n = count(i)\n                result += n * (n - 1) / 2\n                count -= i\n            }\n        }\n        result",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map -= i\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_map = HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(reverse_i)) reverse_map(reverse_i) += 1\n            else reverse_map(reverse_i) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(reverse_i) -= 1\n            }\n        }\n        count",
    "        val count = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0L\n        for (i <- count) {\n            val n = i._2\n            result += n * (n - 1) / 2\n        }\n        result",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) count += map(i)\n            map(rev) -= 1\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n                map(reverse) -= 1\n                if (map(reverse) == 0) map.remove(reverse)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map += reverse -> 1\n        }\n        map.values.map(x => x * (x - 1) / 2).sum",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                if (i == i.reverse) count += map(i) * (map(i) - 1)\n                else count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) map(r) += 1\n            else map(r) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(s)) count += map(s)\n            if (s == r) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(reverse) && map(reverse) > 1) count += map(reverse) - 1\n            if (map.contains(i) && map.contains(reverse)) count -= 1\n        }\n        count / 2",
    "        val count = new HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(i)) result += count(i)\n            if (i == reverse) result -= 1\n        }\n        result / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length - 1) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map -= i\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            if (map.contains(str)) map(str) += 1\n            else map(str) = 1\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) count += map(s)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var result = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                result += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        result",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (reverse_map.contains(reverse)) {\n                count += reverse_map(reverse)\n                reverse_map(reverse) = 0\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map += reverse -> 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (reverse_map.contains(reverse)) {\n                count += reverse_map(reverse)\n                reverse_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev_i = i.reverse\n            if (test_map.contains(rev_i)) {\n                test_map(rev_i) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev_i = i.reverse\n            if (test_map.contains(rev_i)) {\n                count += test_map(rev_i)\n                test_map(rev_i) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(rev) && map(rev) > 1) count += map(rev) - 1\n            if (map.contains(i) && map.contains(rev)) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str) && map(str) > 1) count += map(str) - 1\n            else if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(reverse) && map(reverse) > 1) count += map(reverse) - 1\n            if (map.contains(i) && map.contains(reverse)) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var result = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                result += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val t = s.reverse\n            if (map.contains(t)) map(t) += 1\n            else map(t) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- map) {\n            if (i._2 > 1) {\n                count += (i._2 * (i._2 - 1)) / 2\n            }\n        }\n        count",
    "        val test_set = test_list.toSet\n        var count = 0\n        for (i <- test_set) {\n            val reverse = i.reverse\n            if (test_set.contains(reverse)) count += 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(reverse_str)) reverse_map(reverse_str) += 1\n            else reverse_map(reverse_str) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(str)) {\n                count += reverse_map(str)\n                reverse_map(str) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                result += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        result",
    "        val reverse_map = Map[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (s <- test_list) {\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (i == reverse) count -= 1\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            else if (map.contains(rev)) count += map(rev)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(rev) -= 1\n                if (map(rev) == 0) map.remove(rev)\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map.remove(i)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(reverse) -= 1\n                if (map(reverse) == 0) map.remove(reverse)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map.contains(reverse) && i != reverse) {\n                count += map(i) * map(reverse)\n                map(i) = 0\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val reverse_map = HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map += (reverse -> 1)\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(rev) && map(rev) > 1) count += map(rev) - 1\n            if (map.contains(i) && map.contains(rev)) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                result += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (map.contains(test_list(i))) {\n                count += map(test_list(i))\n                map(test_list(i)) = 0\n            }\n        }\n        count",
    "        val map = Map[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        // Write your code here\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        return count",
    "        val map = HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map += (i -> 1)\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(i) * map(reverse)\n        }\n        count / 2",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map.remove(i)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                val value = map(i)\n                if (value > 1) count += value * (value - 1) / 2\n            }\n        }\n        count",
    "        val n = test_list.length\n        var count = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        count",
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (count.contains(rev)) count(rev) += 1\n            else count(rev) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (count.contains(i) && count(i) > 0) {\n                result += count(i)\n                count(i) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(reverse) && map(reverse) > 1) count += map(reverse) - 1\n            if (map.contains(i) && map.contains(reverse)) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (i <- 0 until test_list.length) {\n            val key = test_list(i).reverse\n            if (map.contains(key)) map(key) += 1\n            else map(key) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val key = test_list(i)\n            if (map.contains(key)) {\n                count += map(key)\n                map(key) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(test_list(i))) {\n                count += map(test_list(i))\n                map(reverse) -= 1\n                if (map(reverse) == 0) map.remove(reverse)\n            }\n        }\n        count",
    "        val pairs = for {\n            i <- 0 until test_list.length\n            j <- i + 1 until test_list.length\n            if (test_list(i) == test_list(j).reverse)\n        } yield (i, j)\n        pairs.length",
    "        val map = new HashMap[String, Long]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(str) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(reverse_str)) reverse_map(reverse_str) += 1\n            else reverse_map(reverse_str) = 1\n        }\n        var result = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(str)) {\n                result += reverse_map(str)\n                reverse_map(str) = 0\n            }\n        }\n        result",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 0 && map.contains(reverse) && map(reverse) > 0) {\n                count += 1\n                map(i) -= 1\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val n = test_list.length\n        var count = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) map(r) += 1\n            else map(r) = 1\n        }\n        var result = 0L\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(s)) result += map(s)\n        }\n        result",
    "        val map = new HashMap[String, Int]()\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Long]\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(str)) count += map(str)\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i).reverse == test_list(j)) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) {\n                map(r) += 1\n            } else {\n                map += (r -> 1)\n            }\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            if (map.contains(s)) {\n                count += map(s)\n            }\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) {\n                test_map(i) += 1\n            }\n            else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map -= i\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        return count",
    "        val count = new HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(i)) result += count(i)\n            if (i == reverse) result -= 1\n        }\n        result / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map += (i -> 1)\n        }\n        var result = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                result += map(i) * map(i.reverse)\n                map(i.reverse) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(rev) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(reverse) && map(reverse) > 1) count += map(reverse) - 1\n            if (map.contains(i) && map.contains(reverse)) count -= 1\n        }\n        count / 2",
    "        val reverse_list = test_list.map(_.reverse)\n        val reverse_map = reverse_list.groupBy(identity).mapValues(_.size)\n        var count = 0L\n        for (x <- test_list) {\n            if (reverse_map.contains(x)) {\n                count += reverse_map(x)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) count += map(s)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val n = test_list.length\n        val map = new HashMap[String, Long]\n        for (i <- 0 until n) {\n            val s = test_list(i)\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- 0 until n) {\n            val s = test_list(i)\n            val reverse = s.reverse\n            if (map.contains(s)) count += map(s)\n            if (s == reverse) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) map(r) += 1\n            else map(r) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            if (map.contains(s)) count += map(s)\n        }\n        count",
    "        val map = Map[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val count = new HashMap[String, Long]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (count.contains(reverse)) {\n                result += count(reverse)\n                count(reverse) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(i) * map(reverse)\n        }\n        count",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val count_map = HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            if (reverse_set.contains(test_list(i))) {\n                if (count_map.contains(test_list(i))) count_map(test_list(i)) += 1\n                else count_map(test_list(i)) = 1\n            }\n        }\n        var count = 0\n        for (i <- count_map.keys) {\n            val n = count_map(i)\n            count += n * (n - 1) / 2\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(reverse) && map(reverse) > 1) count += map(reverse) - 1\n            if (map.contains(i) && map.contains(reverse)) count -= 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(rev)) count += map(rev)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            if (map.contains(reverse) && map(reverse) > 1) count += map(reverse) - 1\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0\n        for (str <- test_list) {\n            if (map.contains(str)) {\n                count += map(str)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(i)) {\n                result += count(i)\n                count(i) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                if (i == i.reverse) count += map(i) * (map(i) - 1)\n                else count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map += (reverse -> 1)\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i) && map(i) > 1) count += map(i) - 1\n            else if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val map = Map[String, Int]()\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) count += map(reverse)\n            if (map.contains(test_list(i))) map(test_list(i)) += 1\n            else map(test_list(i)) = 1\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map += (i -> 1)\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map(rev) = 0\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                if (i == reverse) count += map(i) * (map(i) - 1)\n                else count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse) * map(i)\n        }\n        count / 2",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                map(i) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map += (i -> 1)\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map.remove(i)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            if (map.contains(str)) map(str) += 1\n            else map(str) = 1\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (reverse_set.contains(test_list(i))) count += 1\n        }\n        count / 2",
    "        val reverse_dict = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_dict.contains(reverse_str)) reverse_dict(reverse_str) += 1\n            else reverse_dict(reverse_str) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_dict.contains(str)) {\n                count += reverse_dict(str)\n                reverse_dict(str) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) count += map(str)\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) count += map(s)\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse)\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1 else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(i) * map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var result = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                result += map(i) * map(i.reverse)\n            }\n        }\n        result / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                if (i == reverse) count += map(reverse) - 1\n                else count += map(reverse)\n            }\n        }\n        count / 2",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Int]()\n        for (s <- test_list) {\n            if (map.contains(s)) map(s) += 1\n            else map(s) = 1\n        }\n        var count = 0\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse) && map(reverse) > 0) {\n                count += 1\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(str) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var result = 0L\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) {\n                result += map(i)\n                map(i) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Long]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse) && map(reverse) > 0) {\n                count += 1\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- map.values) {\n            count += i * (i - 1) / 2\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i.reverse)) map(i.reverse) += 1\n            else map += (i.reverse -> 1)\n        }\n        var count = 0\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i.reverse) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- 0 until test_list.length) {\n            val str = test_list(i)\n            val rev = str.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val str = test_list(i)\n            if (map.contains(str)) count += map(str)\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) count += map(str)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                map(i) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) count += map(s)\n            map(reverse) -= 1\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                if (i == reverse) count += map(i) * (map(i) - 1)\n                else count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val reversed_list = test_list.map(x => x.reverse)\n        val map = new HashMap[String, Int]\n        for (x <- reversed_list) {\n            if (map.contains(x)) map(x) += 1\n            else map(x) = 1\n        }\n        var count = 0\n        for (x <- test_list) {\n            if (map.contains(x)) {\n                count += map(x)\n                map(x) = 0\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map.remove(i)\n            }\n        }\n        count",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length - 1) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        return count"
  ]
}