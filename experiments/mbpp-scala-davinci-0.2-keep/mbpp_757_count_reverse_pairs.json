{
  "name": "mbpp_757_count_reverse_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n    def countReversePairs(test_list : List[String]) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countReversePairs((List[String](\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"))) == (2l));\n    assert(countReversePairs((List[String](\"geeks\", \"best\", \"for\", \"skeeg\"))) == (1l));\n    assert(countReversePairs((List[String](\"makes\", \"best\", \"sekam\", \"for\", \"rof\"))) == (2l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(i)) result += count(i)\n            if (i == reverse) result -= 1\n        }\n        result / 2",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) count += map(i)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                count += map(i) * map(rev)\n            }\n        }\n        count / 2",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val pairs = test_list.map(x => reverse_set.contains(x))\n        pairs.count(x => x)",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var result = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                result += map(i)\n                map(i) = 0\n            }\n        }\n        result",
    "        val map = Map[String, Int]()\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) count += map(str)\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count",
    "        val count = new HashMap[String, Long]\n        for (i <- 0 until test_list.length) {\n            val reversed = test_list(i).reverse\n            if (count.contains(reversed)) count(reversed) += 1\n            else count(reversed) = 1\n        }\n        var result = 0L\n        for (i <- 0 until test_list.length) {\n            val reversed = test_list(i).reverse\n            if (count.contains(reversed)) {\n                result += count(reversed)\n                count(reversed) = 0\n            }\n        }\n        result",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map(rev) = 0\n            }\n        }\n        count",
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (count.contains(rev)) count(rev) += 1\n            else count += (rev -> 1)\n        }\n        var result = 0\n        for (i <- test_list) {\n            if (count.contains(i)) result += count(i)\n        }\n        result",
    "        val map = new HashMap[String, Long]()\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n            }\n            if (map.contains(s)) {\n                map(s) += 1\n            } else {\n                map(s) = 1\n            }\n        }\n        count",
    "        val map = Map[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) map(r) += 1\n            else map(r) = 1\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            if (map.contains(s)) count += map(s)\n        }\n        count",
    "        val count = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0L\n        for (i <- count.keys) {\n            if (count.contains(i)) {\n                val n = count(i)\n                result += n * (n - 1) / 2\n                count -= i\n            }\n        }\n        result",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * (map(i) - 1) / 2\n                map -= i\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_map = HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(reverse_i)) reverse_map(reverse_i) += 1\n            else reverse_map(reverse_i) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(reverse_i) -= 1\n            }\n        }\n        count",
    "        val count = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (count.contains(reverse)) count(reverse) += 1\n            else count(reverse) = 1\n        }\n        var result = 0L\n        for (i <- count) {\n            val n = i._2\n            result += n * (n - 1) / 2\n        }\n        result",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(reverse) = 0\n            }\n        }\n        count"
  ]
}